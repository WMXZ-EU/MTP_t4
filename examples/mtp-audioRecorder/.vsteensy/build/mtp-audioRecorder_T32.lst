
.vsteensy/build/mtp-audioRecorder_T32.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00014bd4 l    d  .fini	00000000 .fini
00014bd8 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff8000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff8200 l    d  .dmabuffers	00000000 .dmabuffers
1fff83bc l    d  .usbbuffers	00000000 .usbbuffers
1fff8960 l    d  .data	00000000 .data
1fff9710 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
0000d0bc l     F .text	0000000c startup_default_early_hook
0000d0c8 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff9710 l       .bss	00000000 completed.8603
00000434 l     F .text	00000000 frame_dummy
1fff9714 l       .bss	00000000 object.8608
00014b88 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 mtp-audioRecorder.ino
000005c8 l     F .text	00000002 __tcf_0
00000878 l     F .text	00000074 logg(unsigned long, char const*) [clone .part.55]
00001b60 l     F .text	00000120 _GLOBAL__sub_I_audioShield
1fffb940 l     O .bss	00000400 acq_rx_buffer
1fffbe44 l     O .bss	00000002 front_
1fffbe48 l     O .bss	00000800 tdm_rx_buffer
000142cc l     O .text	00000008 SGTL_ADDR
1fff8a48 l     O .data	00000014 mfile
20002b06 l     O .bss	00000002 rear_
20002b1c l     O .bss	00000004 check_filing(short)::to
20002b20 l     O .bss	00000004 logg(unsigned long, char const*)::to
00000000 l    df *ABS*	00000000 Storage.cpp
00002088 l     F .text	000000a0 File::invalidate() [clone .isra.1]
0000261c l     F .text	00000084 MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]
00003aa4 l     F .text	00000036 MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]
00003adc l     F .text	00000030 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]
00004308 l     F .text	000000b2 MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]
00004eb8 l     F .text	00000a4c mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]
00000000 l    df *ABS*	00000000 MTP.cpp
00005b58 l     F .text	00000064 MTPD::write(char const*, int) [clone .part.2]
00005c64 l     F .text	000000bc MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]
00006e64 l     F .text	0000002c MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]
0001450c l     O .text	00000028 supported_op
00014534 l     O .text	00000010 propertyList
00014590 l     O .text	00000008 supported_events
00000000 l    df *ABS*	00000000 SPI.cpp
00007750 l     F .text	000001f8 SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]
00000000 l    df *ABS*	00000000 Time.cpp
00007e58 l     F .text	00000018 refreshCache(long) [clone .part.0]
20002b2c l     O .bss	00000004 cacheTime
20002b30 l     O .bss	00000007 tm
20002b38 l     O .bss	00000004 sysTime
20002b3c l     O .bss	00000001 Status
20002b44 l     O .bss	00000004 prevMillis
1fff8a98 l     O .data	00000004 syncInterval
0001469c l     O .text	0000000c monthDays
20002b48 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 output_pwm.cpp
00007ff0 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE
00000000 l    df *ABS*	00000000 input_i2s.cpp
00008008 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
00000000 l    df *ABS*	00000000 output_pt8211.cpp
00008020 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_adat.cpp
00008038 l     F .text	00000018 _GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_adc.cpp
00008050 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE
00000000 l    df *ABS*	00000000 control_sgtl5000.cpp
00000000 l    df *ABS*	00000000 output_dac.cpp
000084b0 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE
00000000 l    df *ABS*	00000000 input_adcs.cpp
000084c8 l     F .text	00000030 _GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
000084f8 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
00008510 l     F .text	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
00008528 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm.cpp
00008540 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_tdm.cpp
00008558 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
00008570 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 input_pdm.cpp
00008588 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE
00000000 l    df *ABS*	00000000 output_i2s.cpp
000085a0 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
000085b8 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 WireKinetis.cpp
00008926 l       .text	00000000 L_1480_delayMicroseconds
00008934 l       .text	00000000 L_1494_delayMicroseconds
0000897a l       .text	00000000 L_1545_delayMicroseconds
00008cae l       .text	00000000 L_3073_delayMicroseconds
20002bd4 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 FsCache.cpp
00008ce4 l     F .text	00000060 FsCache::sync() [clone .part.0]
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00009764 l     F .text	00000034 ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]
00009798 l     F .text	0000002a ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]
00000000 l    df *ABS*	00000000 upcase.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
0000a61c l     F .text	00000032 FatFile::openRoot(FatVolume*) [clone .part.37]
0000a748 l     F .text	00000094 FatFile::sync() [clone .part.41]
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
0000b728 l     F .text	00000028 lfnGetChar(DirLfn_t*, unsigned char)
00000000 l    df *ABS*	00000000 FatFileSFN.cpp
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
0000c334 l     F .text	00000016 SdSpiCard::spiStart() [clone .part.7]
0000c34c l     F .text	00000020 SdSpiCard::spiStop() [clone .part.8]
00000000 l    df *ABS*	00000000 SdSpiTeensy3.cpp
00000000 l    df *ABS*	00000000 SdSpiChipSelect.cpp
00000000 l    df *ABS*	00000000 SD.cpp
0000cac8 l     F .text	00000048 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
20003091 l     O .bss	00000001 tx_noautoflush
20003094 l     O .bss	00000004 tx_packet
20003098 l     O .bss	00000001 transmit_previous_timeout
2000309c l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 analog.c
200030a1 l     O .bss	00000001 calibrating
1fff8b74 l     O .data	00000001 analog_config_bits
200030a2 l     O .bss	00000001 analog_reference_internal
1fff8b75 l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 usb_desc.c
1fff8b7c l     O .data	00000012 device_descriptor
1fff8ba8 l     O .data	00000069 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 pins_teensy.c
0000d53c l     F .text	00000002 dummy_isr
1fff8960 l     F .data	0000002c port_E_isr
1fff898c l     F .data	0000002c port_D_isr
1fff89b8 l     F .data	0000002c port_C_isr
1fff89e4 l     F .data	0000002c port_B_isr
1fff8a10 l     F .data	0000002c port_A_isr
0000d540 l     F .text	00000044 digitalWrite.part.1
0000d584 l     F .text	00000078 pinMode.part.2
00000000 l    df *ABS*	00000000 usb_mem.c
1fff8d48 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
200030a8 l     O .bss	00000004 ep0_tx_ptr
200030ac l     O .bss	00000018 rx_last
200030c4 l     O .bss	00000002 ep0_tx_len
200030c8 l     O .bss	00000040 ep0_rx0_buf
20003108 l     O .bss	00000018 rx_first
20003120 l     O .bss	00000001 ep0_tx_data_toggle
20003124 l     O .bss	00000040 ep0_rx1_buf
20003164 l     O .bss	00000018 tx_first
1fff8000 l     O .usbdescriptortable	000000e0 table
2000317c l     O .bss	00000018 tx_last
20003194 l     O .bss	00000008 setup
2000319c l     O .bss	00000001 ep0_tx_bdt_bank
200031a0 l     O .bss	00000008 reply_buffer
200031ac l     O .bss	00000006 tx_state
00000000 l    df *ABS*	00000000 yield.cpp
200031b2 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 wf_fmod.c
00000000 l    df *ABS*	00000000 ef_fmod.c
000148e4 l     O .text	00000008 Zero
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _arm_addsubsf3.o
00000000 l    df *ABS*	00000000 _arm_muldivsf3.o
00000000 l    df *ABS*	00000000 _arm_cmpsf2.o
00000000 l    df *ABS*	00000000 _arm_unordsf2.o
00000000 l    df *ABS*	00000000 _arm_fixsfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunssfsi.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 efgcvt.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlcat.c
00000000 l    df *ABS*	00000000 strlcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
00014900 l     O .text	00000010 zeroes.7256
00014950 l     O .text	00000010 blanks.7255
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
000126bc l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
000126dc l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 ecvtbuf.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mprec.c
00014b40 l     O .text	0000000c p05.6085
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 impure.c
1fff8d68 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/crtn.o
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff9710 l       .bss	00000000 __bss_start__
20003234 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
0000d0b4  w    F .text	00000006 adc0_isr
000024c0 g     F .text	0000015c MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)
000011d0 g     F .text	00000060 pushData(unsigned long*)
0000f3d8 g     F .text	0000002c .hidden __aeabi_dcmpun
0000cd30 g     F .text	0000001c usb_serial_available
0000f39c g     F .text	00000012 .hidden __aeabi_dcmple
00010bd0 g     F .text	000000ba strcpy
0000f2d8 g     F .text	0000007a .hidden __cmpdf2
0000e964 g     F .text	000000bc fmodf
0000e4a8  w    F .text	000000ec yield
20002b18 g     O .bss	00000004 acq_miss
0000b1a8 g     F .text	0000021c FatFile::write(void const*, unsigned int)
0000f2d8 g     F .text	0000007a .hidden __eqdf2
0000e808 g     F .text	000000ba Print::printNumber64(unsigned long long, unsigned char, unsigned char)
00009238 g     F .text	000003dc ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)
1fffbd40 g     O .bss	00000104 storage
1fff8b90 g     O .data	00000018 usb_string_manufacturer_name_default
20002b28 g     O .bss	00000004 tx_event_packet
0000b130 g     F .text	00000076 FatFile::truncate()
1fff8b08 g     O .data	0000006c Wire1
00001230 g     F .text	00000074 acq_isr()
0000814c g     F .text	0000006c AudioControlSGTL5000::micGain(unsigned int)
00002910 g     F .text	0000003c MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)
0000ee48 g     F .text	0000005a .hidden __floatdidf
1fff9730 g     O .bss	00000008 dma
0000d06c  w    F .text	00000048 hard_fault_isr
0000d0b4  w    F .text	00000006 dma_ch6_isr
00001710 g     F .text	000000b4 do_logger(unsigned short, short)
20002bd8 g     O .bss	00000004 FsDateTime::callback
0000e7bc g     F .text	00000020 Print::println()
00008710 g     F .text	0000012c TwoWire::isr()
0000d0b4  w    F .text	00000006 uart0_lon_isr
00009138 g     F .text	000000fe ExFatFile::seekSet(unsigned long long)
00013660 g     F .text	000000ec fcvtbuf
0000da78 g     F .text	00000084 usb_rx_memory
000004a8  w    F .text	0000000c File::flush()
00008070 g     F .text	00000084 AudioControlSGTL5000::read(unsigned int)
0000c240 g     F .text	000000c8 FsVolume::begin(SdSpiCard*)
000076b4 g     F .text	00000018 usb_init_events
0000d0b4  w    F .text	00000006 dma_ch8_isr
0001077c g     F .text	00000002 __malloc_unlock
1fff8c68 g     O .data	00000038 isr_table_portA
00000624  w    F .text	000000c0 SDFile::openNextFile(unsigned char)
20002be4 g     O .bss	00000004 FsVolume::m_cwv
0000aa0c g     F .text	000000be FatFile::open(FatFile*, char const*, int)
0000cf8c g     F .text	000000e0 analog_init
0000dafc g     F .text	00000084 usb_tx
0000f878 g     F .text	00000136 .hidden __divsf3
0000d0b4  w    F .text	00000006 portcd_isr
0001256c g     F .text	0000004a _vdprintf_r
00007c10 g     F .text	00000090 SPIClass::setSCK(unsigned char)
00014244  w    O .text	00000060 vtable for SDFile
00010614 g     F .text	000000c6 memmove
00003b0c g     F .text	00000046 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)
000139fc g     F .text	0000004c _Balloc
0000d0b4  w    F .text	00000006 can1_rx_warn_isr
00007704 g     F .text	0000002c MTPD::send_Event(unsigned short)
00001e48  w    F .text	00000004 MTPStorage_SD::get_FSCount()
00014be0 g       .ARM.exidx	00000000 __exidx_end
0000fac8 g     F .text	0000004c .hidden __fixsfsi
0000d0b4  w    F .text	00000006 dma_error_isr
0000b520 g     F .text	0000003c FatPartition::freeChain(unsigned long)
200031c8 g     O .bss	00000001 EventResponder::runningFromYield
0000ca10 g     F .text	0000001a SdSpiArduinoDriver::receive()
0000c514 g     F .text	00000086 SdSpiCard::cardCommand(unsigned char, unsigned long)
20002b04 g     O .bss	00000002 maxCount
00008ccc g     F .text	0000000c i2c0_isr
0000e790 g     F .text	0000002c Print::write(unsigned char const*, unsigned int)
0000f2c8 g     F .text	0000008a .hidden __gtdf2
0000b750 g     F .text	00000022 FatFile::lfnChecksum(unsigned char*)
0000fef8 g     F .text	0000000c __errno
00000c88  w    F .text	00000026 SDFile::isDirectory()
0000d0b4  w    F .text	00000006 portd_isr
0000d0b4  w    F .text	00000006 enet_error_isr
0000148c g     F .text	00000088 makeFilename(char*)
00000e98  w    F .text	00000028 File::~File()
200031b8 g     O .bss	00000004 EventResponder::firstInterrupt
00006000 g     F .text	0000006e MTPD::GetObjectHandles(unsigned long, unsigned long)
000088a4 g     F .text	0000000c sda_rising_isr1()
0000b60c g     F .text	0000011a FatPartition::init(SdSpiCard*, unsigned char)
0000c0c0 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000d0b4  w    F .text	00000006 tpm1_isr
00009bf0 g     F .text	00000018 ExFatPartition::rootLength()
0000e780  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
000147a0 g     O .text	00000110 digital_pin_to_info_PGM
20003230 g     O .bss	00000004 errno
0000ca2c g     F .text	00000020 SdSpiArduinoDriver::receive(unsigned char*, unsigned int)
0000bcb8 g     F .text	00000390 FatFile::open(FatFile*, fname_t*, int)
000099e8 g     F .text	00000012 ExFatPartition::fatGet(unsigned long, unsigned long*)
00014be0 g       .ARM.exidx	00000000 _etext
00007948 g     F .text	00000134 _spi_dma_rxISR0()
1fff9710 g       .bss	00000000 _sbss
0000cab8 g     F .text	00000006 sdCsInit(unsigned char)
0000f364 g     F .text	00000010 .hidden __aeabi_cdcmple
00009b10 g     F .text	000000e0 ExFatPartition::init(SdSpiCard*, unsigned char)
00001e5c g     F .text	0000000c MTPStorage_SD::totalSize(unsigned long)
00004c78 g     F .text	000000fe MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)
0000f500 g     F .text	00000160 .hidden __aeabi_fadd
0000f4fc g     F .text	00000164 .hidden __subsf3
0000d0b4  w    F .text	00000006 porte_isr
00001ab8 g     F .text	000000a8 loop
0000d0b4  w    F .text	00000006 portb_isr
0000d0b4  w    F .text	00000006 spi1_isr
000064ec g     F .text	00000144 MTPD::GetStorageInfo(unsigned long)
0000d0b4  w    F .text	00000006 uart3_status_isr
00008e9c g     F .text	000000c4 ExFatFile::parsePathName(char const*, ExName_t*, char const**)
0000d0b4  w    F .text	00000006 mcm_isr
00008068  w    F .text	00000004 AudioControlSGTL5000::disable()
0000c36c g     F .text	00000088 SdSpiCard::readData(unsigned char*, unsigned int)
0000899c g     F .text	00000114 TwoWire::endTransmission(unsigned char)
200031bc g     O .bss	00000004 EventResponder::lastInterrupt
0000d0b4  w    F .text	00000006 uart1_status_isr
0000c138 g     F .text	00000028 FsBaseFile::close()
0000cb10 g     F .text	000001a6 memcpy
0000d0b4  w    F .text	00000006 randnum_isr
0000f354 g     F .text	00000020 .hidden __aeabi_cdrcmple
0000048c  w    F .text	0000000c File::available()
00003b54 g     F .text	000007b4 MTPStorage_SD::removeFile(unsigned long, char*)
0000328c g     F .text	00000816 MTPStorage_SD::ScanDir(unsigned long, unsigned long)
0000144c g     F .text	00000040 file_writeHeader()
00009a1c g     F .text	00000080 ExFatPartition::freeChain(unsigned long)
00002c14 g     F .text	0000046c MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)
0000ac80 g     F .text	0000002a FatFile::peek()
0000fa88 g     F .text	00000012 .hidden __aeabi_fcmpgt
00010ebc g     F .text	000016b0 _svfprintf_r
0000edd8 g     F .text	00000022 .hidden __floatsidf
000005f4  w    F .text	00000014 SDFile::whoami()
1fff972c  w    O .bss	00000001 SDFile::name()::zeroterm
1fff8cf0 g     O .data	00000030 isr_table_portC
200030a4 g     O .bss	00000004 systick_millis_count
0000f2d0 g     F .text	00000082 .hidden __ltdf2
0000a21c g     F .text	000000aa ExFatFile::rename(ExFatFile*, char const*)
0000d06c  w    F .text	00000048 bus_fault_isr
0000099c  w    F .text	00000044 SDFile::truncate(unsigned long long)
000088b0 g     F .text	000000ec TwoWire::wait_idle()
0000703c g     F .text	00000678 MTPD::loop()
0000d0b4  w    F .text	00000006 watchdog_isr
0000fb54 g     F .text	00000000 .hidden __aeabi_uldivmod
00008cd8 g     F .text	0000000c i2c1_isr
200031a8 g     O .bss	00000001 usb_configuration
0000d0b4  w    F .text	00000006 dma_ch11_isr
00000000  w      *UND*	00000000 __fini_array_end
00001418 g     F .text	00000034 makeHeader(char*)
200031c9 g     O .bss	00000001 SPCRemulation::pinout
00000dbc  w    F .text	00000058 StreamFile<FsBaseFile, unsigned long long>::available()
0000acac g     F .text	00000040 FatFile::readDirCache(bool)
0000d0b4  w    F .text	00000006 i2c2_isr
20002b74 g     O .bss	00000008 AudioOutputAnalog::dma
20002b08 g     O .bss	00000004 loop_count
1fff8b90  w    O .data	00000018 usb_string_manufacturer_name
20003224 g     O .bss	0000000c usb_rx_byte_count_data
0000d0b4  w    F .text	00000006 pit1_isr
1fff8c14 g     O .data	00000008 usb_string_mtp
0000ff54 g     F .text	00000010 malloc
0000d0b4  w    F .text	00000006 dma_ch4_isr
000146e4 g     O .text	00000020 TwoWire::i2c1_hardware
0000e8d4 g     F .text	00000084 software_isr
000012fc g     F .text	00000078 do_menu(short)
000141c0  w    O .text	00000024 vtable for FsFile
0000d0b4  w    F .text	00000006 dma_ch7_isr
000085dc  w    F .text	0000001e TwoWire::read()
00007738  w    F .text	00000018 EventResponder::triggerEvent(int, void*)
0000f668 g     F .text	0000001c .hidden __aeabi_i2f
00014a78 g     O .text	000000c8 __mprec_tens
0000e3f4 g     F .text	000000b4 usb_init
20002b24 g     O .bss	00000004 sessionID_
0000f9b8 g     F .text	00000066 .hidden __lesf2
0000d0b4  w    F .text	00000006 lptmr_isr
00000e14  w    F .text	00000084 SDFile::seek(unsigned long long, int)
200031ec g     O .bss	00000004 __malloc_top_pad
0000d788 g     F .text	00000024 rtc_set
0000c8cc g     F .text	0000006c SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
0000a2c8 g     F .text	000000e2 ExFatFile::truncate()
1fff8a3c g     O .data	00000000 .hidden __dso_handle
0000edb8 g     F .text	0000001e .hidden __aeabi_ui2d
000139e0 g     F .text	0000001c _localeconv_r
1fff8a44 g     O .data	00000004 sd_str
0000c9d8 g     F .text	00000038 SdSpiArduinoDriver::deactivate()
00013b78 g     F .text	00000012 __i2b
1fff8960 g       .data	00000000 _sdata
000146c4 g     O .text	00000020 TwoWire::i2c0_hardware
1fff8a40 g     O .data	00000004 t_on
00000500  w    F .text	0000000c File::operator bool()
0000fb84 g     F .text	000002e2 .hidden __udivmoddi4
00006330 g     F .text	000001bc MTPD::getObjectPropValue(unsigned long, unsigned long)
0000eb34 g     F .text	00000000 .hidden __aeabi_drsub
0000a650 g     F .text	00000034 FatFile::addCluster()
00010b60 g     F .text	00000024 _sbrk_r
00000480  w    F .text	0000000c File::write(void const*, unsigned int)
000001bc g     F .text	000001d8 ResetHandler
0000ccb8 g     F .text	00000048 usb_serial_getchar
0000d0b4  w    F .text	00000006 can1_bus_off_isr
0000d0b4  w    F .text	00000006 ftm2_isr
00000950  w    F .text	0000004c SDFile::name()
20003218 g     O .bss	00000008 usb_cdc_line_coding
0000d7ac g     F .text	0000000a digitalWrite
200031c0 g     O .bss	00000004 EventResponder::lastYield
0000d0b4  w    F .text	00000006 uart5_status_isr
0000d0b4  w    F .text	00000006 lpuart0_status_isr
00008e74 g     F .text	00000028 ExFatFile::openRoot(ExFatVolume*)
00014730 g     O .text	00000006 usb_endpoint_config_table
0000d0b4  w    F .text	00000006 dma_ch9_isr
000007f8  w    F .text	00000038 StreamFile<FsBaseFile, unsigned long long>::read()
0000d0b4  w    F .text	00000006 pit2_isr
0000f388 g     F .text	00000012 .hidden __aeabi_dcmplt
000145c8 g     O .text	0000005c SPISettings::ctar_clock_table
200031e8 g     O .bss	00000004 __malloc_max_sbrked_mem
00000bec  w    F .text	0000001a SDFile::position()
0000d7b8 g     F .text	0000000a pinMode
0000c4b4 g     F .text	00000042 SdSpiCard::writeStop()
00003080 g     F .text	00000160 MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)
0000d9c4 g     F .text	0000004c usb_free
0000d0b4  w    F .text	00000006 i2c3_isr
0000edfc g     F .text	0000003a .hidden __extendsfdf2
0000f0f8 g     F .text	000001d0 .hidden __aeabi_ddiv
0000eb40 g     F .text	00000276 .hidden __adddf3
0000f9c0 g     F .text	0000005e .hidden __nesf2
000062c4 g     F .text	0000006c MTPD::getObjectPropsSupported(unsigned long)
00005bbc g     F .text	000000a8 MTPD::writestring(char const*)
0000c480 g     F .text	00000032 SdSpiCard::writeData(unsigned char const*)
00000498  w    F .text	00000010 File::peek()
0000b55c g     F .text	000000b0 FatPartition::freeClusterCount()
00000cb0  w    F .text	000000d0 SDClass::open(char const*, unsigned char)
00014bd8 g       .ARM.exidx	00000000 __exidx_start
0000eea4 g     F .text	00000254 .hidden __aeabi_dmul
0000077c  w    F .text	0000000c DMAChannel::~DMAChannel()
0000c838 g     F .text	0000002e SdSpiCard::writeStart(unsigned long)
0000d0b4  w    F .text	00000006 pit0_isr
1fff8d61 g     O .data	00000001 __fdlib_version
200031c4 g     O .bss	00000004 EventResponder::firstYield
000148ec g     O .text	00000004 _global_impure_ptr
00001e74 g     F .text	00000080 MTPStorage_SD::write(char const*, unsigned long)
0000d0b4  w    F .text	00000006 can1_error_isr
00000844  w    F .text	00000034 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00010780 g     F .text	000003de _realloc_r
00000c24  w    F .text	00000018 SDFile::read(void*, unsigned int)
0000ff04 g     F .text	00000050 __libc_init_array
20003234 g       .bss	00000000 __bss_end
0000d1cc g     F .text	0000036e dtostrf
00000a7c  w    F .text	00000044 SDFile::rewindDirectory()
000085d0  w    F .text	0000000c TwoWire::available()
0000d0b4  w    F .text	00000006 can0_wakeup_isr
00009714 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
00009ff0 g     F .text	000000f6 ExFatFile::addDirCluster()
0000d0b4  w    F .text	00000006 flash_cmd_isr
00004e84 g     F .text	00000034 mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)
0000c430 g     F .text	0000004e SdSpiCard::writeData(unsigned char, unsigned char const*)
00014b50 g     O .text	00000028 __mprec_bigtens
00008ab0 g     F .text	0000021c TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000e768  w    F .text	00000004 usb_serial_class::clear()
0000edb8 g     F .text	0000001e .hidden __floatunsidf
0000d0b4  w    F .text	00000006 uart2_status_isr
0000d0cc g     F .text	0000002c _sbrk
00013e0c g     F .text	0000003e __mcmp
000043d0 g     F .text	000008a8 mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)
0000d5fc g     F .text	000000f8 attachInterrupt
000142a4  w    O .text	00000028 vtable for SDClass
20002ba4 g     O .bss	00000008 AudioOutputTDM::dma
000005b4  w    F .text	00000012 SDFile::operator bool()
1fff8b78 g     O .data	00000004 __brkval
200030a0 g     O .bss	00000001 usb_cdc_line_rtsdtr
00001868 g     F .text	00000214 acq_init(long)
0000cf44 g     F .text	00000048 usb_serial_flush_callback
00014b78 g     F .text	00000000 _init
0000a728 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
1fffbe46 g     O .bss	00000002 state
0000d0b4  w    F .text	00000006 svcall_isr
000008ec  w    F .text	00000062 SDClass::remove(char const*)
00000608  w    F .text	0000001c SDFile::close()
0000d0b4  w    F .text	00000006 dma_ch15_isr
00000fcc  w    F .text	0000005c SDFile::~SDFile()
0000f454 g     F .text	0000009e .hidden __aeabi_d2f
00007f70 g     F .text	00000020 day()
0000f4fc g     F .text	00000164 .hidden __aeabi_fsub
00014704 g     O .text	00000024 vtable for TwoWire
0000d0b4  w    F .text	00000006 uart1_error_isr
0001374c g     F .text	00000028 __libc_fini_array
0000d0b4  w    F .text	00000006 usbhs_phy_isr
0000c9b0 g     F .text	00000028 SdSpiArduinoDriver::begin(SdSpiConfig)
20002b7c g     O .bss	00000008 AudioInputAnalogStereo::dma0
20003234 g       .bss	00000000 _ebss
00005d20 g     F .text	00000278 MTPD::WriteDescriptor()
1fff8a5c g     O .data	00000004 propertyListNum
20002b64 g     O .bss	00000008 AudioOutputADAT::dma
00000830  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
0000fa9c g     F .text	0000002c .hidden __aeabi_fcmpun
00013adc g     F .text	00000040 __hi0bits
0000fa74 g     F .text	00000012 .hidden __aeabi_fcmpge
0000f404 g     F .text	0000004e .hidden __fixdfsi
00001c80 g     F .text	0000005c chipWrite(int, unsigned int, unsigned int)
0000a0e8 g     F .text	0000005a ExFatFile::mkdir(ExFatFile*, ExName_t*)
0000d0b4 g     F .text	00000006 unused_isr
00005f98 g     F .text	00000068 MTPD::WriteStorageIDs()
0000d0b4  w    F .text	00000006 spi0_isr
0000f694 g     F .text	0000007c .hidden __floatdisf
0000d0b4  w    F .text	00000006 dma_ch3_isr
0000cac4  w    F .text	00000002 SDClass::~SDClass()
00005904 g     F .text	00000214 MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)
0000077c  w    F .text	0000000c DMAChannel::~DMAChannel()
1fff993c g     O .bss	00002000 diskBuffer
1fffc648 g     O .bss	000004a8 sdx
00000e98  w    F .text	00000028 File::~File()
00001028 g     F .text	000001a8 storage_configure()
0000f9b0 g     F .text	0000006e .hidden __gtsf2
00007fb0 g     F .text	00000024 year()
0000e960 g     F .text	00000004 operator delete(void*, unsigned int)
0000d0b4  w    F .text	00000006 flash_error_isr
0000eb40 g     F .text	00000276 .hidden __aeabi_dadd
0000f2d0 g     F .text	00000082 .hidden __ledf2
0000fa60 g     F .text	00000012 .hidden __aeabi_fcmple
0000d0b4  w    F .text	00000006 uart5_error_isr
0000d0b4  w    F .text	00000006 rtc_seconds_isr
00014624 g     O .text	00000078 SPIClass::spi0_hardware
0000d0b4  w    F .text	00000006 pdb_isr
00013cbc g     F .text	000000a0 __pow5mult
0000aec0 g     F .text	0000005c FatFile::rmdir()
0000ee38 g     F .text	0000006a .hidden __aeabi_ul2d
0000d06c  w    F .text	00000048 usage_fault_isr
0000d0b4  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001bc _VectorsFlash
0000b49c g     F .text	00000082 FatPartition::allocateCluster(unsigned long, unsigned long*)
0000d0b4  w    F .text	00000006 dma_ch14_isr
00000a30  w    F .text	0000004c SDClass::exists(char const*)
0000d6f4 g     F .text	00000088 detachInterrupt
00000000  w      *UND*	00000000 __deregister_frame_info
20003220 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
0000e758 g     F .text	00000010 systick_isr
0000d0b4  w    F .text	00000006 rtc_alarm_isr
00000520  w    F .text	0000000c File::isDirectory()
0000c048 g     F .text	00000076 FatFile::getSFN(char*)
0000c868 g     F .text	00000064 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
200031cc g     O .bss	00000004 AudioStream::first_update
0000d0b4  w    F .text	00000006 dma_ch2_isr
1fff8d50 g     O .data	00000010 Serial
0000d0b4  w    F .text	00000006 ftm1_isr
000004c0  w    F .text	00000012 File::seek(unsigned long long, int)
000146a8 g     O .text	0000001c vtable for AudioControlSGTL5000
0000e788  w    F .text	00000006 usb_serial_class::write(unsigned char)
0000c1e0 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
0000d0bc  w    F .text	0000000c startup_early_hook
0000c7f0 g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
0000d0b4  w    F .text	00000006 dma_ch13_isr
00009c98 g     F .text	0000008c ExFatFile::addCluster()
0000806c  w    F .text	00000004 AudioControlSGTL5000::inputLevel(float)
000141e4  w    O .text	00000060 vtable for File
0000d0b4  w    F .text	00000006 uart2_error_isr
00000b98  w    F .text	00000052 SDClass::usedSize()
0000cd00 g     F .text	00000030 usb_serial_peekchar
0000f3c4 g     F .text	00000012 .hidden __aeabi_dcmpgt
00002128 g     F .text	00000002 mtp_yield()
00010510 g     F .text	00000000 memchr
0000b434 g     F .text	00000066 FatPartition::fatPut(unsigned long, unsigned long)
1fff8c50 g     O .data	00000016 usb_string_serial_number_default
0000d06c g     F .text	00000048 fault_isr
00013810 g     F .text	000001d0 _free_r
00008d44 g     F .text	0000005c FsCache::get(unsigned long, unsigned char)
0000f3b0 g     F .text	00000012 .hidden __aeabi_dcmpge
0000d0b4  w    F .text	00000006 usb_charge_isr
00004d78 g     F .text	0000010a MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)
0000e778  w    F .text	00000004 usb_serial_class::flush()
0000d0b4  w    F .text	00000006 cmt_isr
0000eb3c g     F .text	0000027a .hidden __aeabi_dsub
0000d0b4  w    F .text	00000006 usbhs_isr
0000a7fc g     F .text	0000014c FatFile::mkdir(FatFile*, fname_t*)
1fff970c g     O .data	00000004 __malloc_sbrk_base
0000e770  w    F .text	00000004 usb_serial_class::read()
0000d0b4  w    F .text	00000006 ftm3_isr
00000564  w    F .text	0000000c File::rewindDirectory()
0000d0b4  w    F .text	00000006 tsi0_isr
0000badc g     F .text	00000124 FatFile::remove()
0000ee38 g     F .text	0000006a .hidden __floatundidf
0000d0f8  w    F .text	00000002 __cxa_pure_virtual
00013d5c g     F .text	000000ae __lshift
0000a948 g     F .text	000000c2 FatFile::mkdir(FatFile*, char const*, bool)
0000d0b4  w    F .text	00000006 spi2_isr
00009c08 g     F .text	00000058 exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)
20002b84 g     O .bss	00000008 AudioInputAnalogStereo::dma1
0000f668 g     F .text	0000001c .hidden __floatsisf
00014018 g     F .text	00000100 __ssprint_r
00014118 g     F .text	0000005e _vasnprintf_r
0000e958  w    F .text	00000002 serialEvent()
000083c0  w    F .text	0000005c AudioControlSGTL5000::inputSelect(int)
20003121 g     O .bss	00000001 usb_reboot_timer
20002b4c g     O .bss	00000008 AudioOutputPWM::dma
00012618 g     F .text	000000a4 __register_exitproc
00009614 g     F .text	000000fe ExFatFile::open(ExFatFile*, char const*, int)
00010ce0 g     F .text	0000002a strlcpy
00007fd4 g     F .text	0000001c setSyncProvider(long (*)())
00010e1c g     F .text	000000a0 strncmp
00001514 g     F .text	00000104 checkPath(unsigned short, char*)
0000a144 g     F .text	000000d6 ExFatFile::mkdir(ExFatFile*, char const*, bool)
0000cd4c g     F .text	00000038 usb_serial_flush_input
00009a9c g     F .text	00000072 ExFatPartition::freeClusterCount()
00002b00 g     F .text	00000064 MTPStorage_SD::ConstructFilename(int, char*, int)
00013b8c g     F .text	00000130 __multiply
1fff8d40 g     O .data	00000008 isr_table_portE
1fffb93c g     O .bss	00000004 acq_count
0000ce8c g     F .text	00000018 usb_serial_putchar
00000021 g       *ABS*	00000000 _teensy_model_identifier
0000fac8 g     F .text	0000004c .hidden __aeabi_f2iz
200031f0 g     O .bss	00000028 __malloc_current_mallinfo
00008484  w    F .text	0000002c AudioControlSGTL5000::volume(float)
0000f9c0 g     F .text	0000005e .hidden __eqsf2
00013f60 g     F .text	000000b6 __d2b
200031d4 g     O .bss	0000000c HardwareSerial::s_serials_with_serial_events
0000d0b4  w    F .text	00000006 can0_bus_off_isr
00001e4c  w    F .text	00000008 MTPStorage_SD::get_FSName(unsigned long)
00008dc4 g     F .text	000000ae ExFatFile::getName(char*, unsigned int)
000013d4 g     F .text	00000044 printTimestamp(unsigned long)
2000319d g     O .bss	00000001 usb_rx_memory_needed
0000db80 g     F .text	00000874 usb_isr
0000fecc g     F .text	0000000c __cxa_atexit
00008f60 g     F .text	000001a6 ExFatFile::read(void*, unsigned int)
0000f878 g     F .text	00000136 .hidden __aeabi_fdiv
0000edd8 g     F .text	00000022 .hidden __aeabi_i2d
00000c3c  w    F .text	00000018 SDFile::peek()
00008da0 g     F .text	0000000e FsCache::sync()
1fff8a60 g     O .data	00000038 SPI
000105b0 g     F .text	00000062 memcmp
000148b0  w    O .text	00000028 vtable for usb_serial_class
0000ca4c g     F .text	00000016 SdSpiArduinoDriver::send(unsigned char)
0000d0b4  w    F .text	00000006 uart3_error_isr
00006d34 g     F .text	0000007c MTPD::GetObject(unsigned long)
0000f684 g     F .text	0000008c .hidden __floatundisf
0000cac0 g     F .text	00000004 sdCsWrite(unsigned char, bool)
0000fe68  w    F .text	00000002 .hidden __aeabi_ldiv0
00009df8 g     F .text	0000005a ExFatFile::rmdir()
20002bb4 g     O .bss	00000008 AudioInputI2SHex::dma
0000d0b4  w    F .text	00000006 porta_isr
00006630 g     F .text	000006e6 MTPD::getObjectPropDesc(unsigned long, unsigned long)
0000f0f8 g     F .text	000001d0 .hidden __divdf3
1fff83bc g     O .usbbuffers	000005a0 usb_buffer_memory
0000d0b4  w    F .text	00000006 low_voltage_isr
00001e58 g     F .text	00000004 MTPStorage_SD::has_directories(unsigned long)
1fff9300 g     O .data	00000408 __malloc_av_
0000f660 g     F .text	00000024 .hidden __aeabi_ui2f
0000d0b4  w    F .text	00000006 can0_error_isr
0000d8a4 g     F .text	000000e0 _init_Teensyduino_internal_
00000d80  w    F .text	00000014 SDFile::flush()
0000eea4 g     F .text	00000254 .hidden __muldf3
0000883c g     F .text	0000005c TwoWire::sda_rising_isr()
0000ceec g     F .text	00000058 usb_serial_flush_output
0000d0b4  w    F .text	00000006 dma_ch12_isr
20002b54 g     O .bss	00000008 AudioInputI2S::dma
00010778 g     F .text	00000002 __malloc_lock
0000ea20 g     F .text	00000104 __ieee754_fmodf
00000000  w      *UND*	00000000 __fini_array_start
0000b890 g     F .text	0000024c FatFile::parsePathName(char const*, fname_t*, char const**)
0000d0b4  w    F .text	00000006 can1_wakeup_isr
000076cc g     F .text	00000038 usb_mtp_sendEvent
1fff8200 g     O .dmabuffers	000001bc _VectorsRam
0000ca64 g     F .text	00000052 SdSpiArduinoDriver::send(unsigned char const*, unsigned int)
0000fe6c g     F .text	0000005e _calloc_r
0000d0b4  w    F .text	00000006 pit3_isr
00007a7c g     F .text	0000007c SPIClass::begin()
00006db0 g     F .text	0000006e MTPD::read(char*, unsigned long)
20002b40 g     O .bss	00000004 getTimePtr
00001374 g     F .text	00000038 file_writeData(void*, unsigned long)
0000f9c0 g     F .text	0000005e .hidden __cmpsf2
1fff8d4c g     O .data	00000001 yield_active_check_flags
0000d0b4  w    F .text	00000006 enet_rx_isr
00009f94 g     F .text	0000005c ExFatFile::sync()
0000acec g     F .text	000001d2 FatFile::rename(FatFile*, char const*)
0000d0b4  w    F .text	00000006 portc_isr
0000c7b8 g     F .text	00000038 SdSpiCard::readStop()
20002b8c g     O .bss	00000008 AudioInputI2SQuad::dma
000106dc g     F .text	0000009a memset
0000841c g     F .text	00000066 AudioControlSGTL5000::volumeInteger(unsigned int)
0000e8c4 g     F .text	00000010 main
20002bc4 g     O .bss	00000008 AudioOutputI2S::dma
200031e4 g     O .bss	00000004 __malloc_max_total_mem
000097c4 g     F .text	000000b4 ExFatPartition::bitmapFind(unsigned long, unsigned long)
0000f694 g     F .text	0000007c .hidden __aeabi_l2f
00007e70 g     F .text	000000a0 now()
0000a3ac g     F .text	00000270 ExFatFile::write(void const*, unsigned int)
0000f9b8 g     F .text	00000066 .hidden __ltsf2
0001444c g     O .text	00000060 vtable for MTPStorage_SD
00006e90 g     F .text	00000132 MTPD::SendObjectInfo(unsigned long, unsigned long)
00010c8c g     F .text	00000052 strlcat
0000d06c  w    F .text	00000048 memmanage_fault_isr
00000788  w    F .text	00000058 SDFile::available()
000004f4  w    F .text	0000000c File::close()
000080f4 g     F .text	00000058 AudioControlSGTL5000::write(unsigned int, unsigned int)
0000eb24 g     F .text	00000004 matherr
0000d0fc g     F .text	00000084 usb_init_serialnumber
00001a7c g     F .text	0000003c acq_check(short)
0000f454 g     F .text	0000009e .hidden __truncdfsf2
00014bd4 g       .text	00000000 __init_array_end
00012808 g     F .text	00000e56 _dtoa_r
0000ff74 g     F .text	00000570 _malloc_r
200031e0 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
0000d0b4  w    F .text	00000006 debugmonitor_isr
000125d0 g     F .text	0000001a __ascii_wctomb
0000c0c0 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000ee48 g     F .text	0000005a .hidden __aeabi_l2d
20002be0 g     O .bss	00000004 FatVolume::m_cwv
20002b9c g     O .bss	00000008 AudioInputI2SOct::dma
1fff8d20 g     O .data	00000020 isr_table_portD
0000e690 g     F .text	00000080 EventResponder::triggerEventNotImmediate()
00007ca0 g     F .text	00000008 SPIClass::transfer(void const*, void*, unsigned int)
60f29bcc g       *ABS*	00000000 __rtc_localtime
000083b4 g     F .text	0000000c AudioControlSGTL5000::enable()
0000d7c4 g     F .text	00000044 micros
00000000  w      *UND*	00000000 __libc_fini
0000052c  w    F .text	00000038 File::openNextFile(unsigned char)
00008898 g     F .text	0000000c sda_rising_isr0()
0000f684 g     F .text	0000008c .hidden __aeabi_ul2f
0000d0b4  w    F .text	00000006 cmp1_isr
0000d0b4  w    F .text	00000006 ftm0_isr
00009e54 g     F .text	00000140 ExFatFile::syncDir()
0000fa28 g     F .text	00000010 .hidden __aeabi_cfcmple
00013774 g     F .text	0000009c _malloc_trim_r
1fff8c4c g     O .data	00000004 string0
0000cd84 g     F .text	00000108 usb_serial_write
0000f710 g     F .text	00000168 .hidden __mulsf3
00001e30  w    F .text	00000018 MTPStorage_SD::addFilesystem(FS&, char const*)
0000d0c8  w    F .text	00000002 startup_late_hook
0000e774  w    F .text	00000004 usb_serial_class::available()
1fff8d60 g     O .data	00000001 _serialEvent_default
00006e20 g     F .text	00000044 MTPD::readstring(char*)
0000b124 g     F .text	0000000c FatFile::sync()
000009e0  w    F .text	00000050 SDClass::mkdir(char const*)
1fff8c1c  w    O .data	0000002e usb_string_product_name
00005b18 g     F .text	00000028 MTPD::GetNumObjects(unsigned long, unsigned long)
0000d808 g     F .text	0000009c delay
0000f2d8 g     F .text	0000007a .hidden __nedf2
0000d0b4  w    F .text	00000006 tpm0_isr
200031b4 g     O .bss	00000002 dma_channel_allocated_mask
00001f70 g     F .text	00000118 MTPStorage_SD::CloseIndex()
00014bd4 g     F .fini	00000000 _fini
00005b40 g     F .text	00000018 MTPD::get_buffer()
0000050c  w    F .text	00000014 File::name()
00008654 g     F .text	00000026 TwoWire::write(unsigned char)
20002b5c g     O .bss	00000008 AudioOutputPT8211::dma
00007f90 g     F .text	00000020 month()
00014598 g     O .text	0000002e SPISettings::ctar_div_table
0000c788 g     F .text	0000002e SdSpiCard::readStart(unsigned long)
00009724 g     F .text	00000040 ExFatFile::openNext(ExFatFile*, int)
00010b84 g     F .text	0000004c sprintf
0000e7ec g     F .text	0000001c Print::printf(char const*, ...)
0000d0b4  w    F .text	00000006 i2s0_rx_isr
0000d0b4  w    F .text	00000006 uart4_error_isr
0000a7dc g     F .text	0000001e FatFile::close()
000004d4  w    F .text	00000010 File::position()
00000ec0  w    F .text	00000064 SDFile::~SDFile()
000126d0 g     F .text	0000000c atexit
0000f9b0 g     F .text	0000006e .hidden __gesf2
000007e0  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
0000059c  w    F .text	00000018 File::write(unsigned char)
000125ec g     F .text	0000002c _write_r
000017c4 g     F .text	000000a4 Adjust_MCLK(long, long*, long*)
20002be8 g     O .bss	000004a8 SD
0000f4f4 g     F .text	0000016c .hidden __aeabi_frsub
0000d0b4  w    F .text	00000006 can0_message_isr
00007af8 g     F .text	00000090 SPIClass::setMOSI(unsigned char)
1fff9190 g     O .data	00000004 _impure_ptr
00014178  w    O .text	00000024 vtable for Stream
0000d0b4  w    F .text	00000006 can1_message_isr
0000fa38 g     F .text	00000012 .hidden __aeabi_fcmpeq
00009108 g     F .text	0000002e ExFatFile::peek()
0001419c  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
20002bcc g     O .bss	00000008 AudioOutputSPDIF::dma
0000d0b4  w    F .text	00000006 nmi_isr
1fff8a9c g     O .data	0000006c Wire
0000bc00 g     F .text	000000b6 FatFile::lfnUniqueSfn(fname_t*)
00000da8  w    F .text	00000014 SDFile::write(void const*, unsigned int)
0000f710 g     F .text	00000168 .hidden __aeabi_fmul
0000c308 g     F .text	00000028 FsVolume::open(char const*, int)
20002b0c g     O .bss	0000000c audioShield
0000aacc g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000d94  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
00014b84 g       .text	00000000 __preinit_array_end
000006e4 g     F .text	00000098 dateTime(unsigned short*, unsigned short*, unsigned char*)
20002bac g     O .bss	00000008 AudioInputTDM::dma
0000fa20 g     F .text	00000018 .hidden __aeabi_cfrcmple
0000d0b4  w    F .text	00000006 sdhc_isr
00007f30 g     F .text	00000020 minute()
0000995c g     F .text	00000034 ExFatPartition::dirCache(DirPos_t*, unsigned char)
000043bc g     F .text	00000012 MTPStorage_SD::DeleteObject(unsigned long)
000104e4 g     F .text	0000002a __ascii_mbtowc
1fff973c g     O .bss	00000200 header
000085fc  w    F .text	00000016 TwoWire::peek()
00008614  w    F .text	00000002 TwoWire::flush()
00001cdc g     F .text	00000154 setup
00014738 g     O .text	00000060 usb_descriptor_list
0000da10 g     F .text	0000003c usb_rx
00001ef4 g     F .text	0000007c MTPStorage_SD::ResetIndex()
0000d0b4  w    F .text	00000006 dma_ch10_isr
00000470  w    F .text	00000002 Print::flush()
0000d0b4  w    F .text	00000006 uart0_error_isr
000004e4  w    F .text	00000010 File::size()
00000b34  w    F .text	00000062 SDClass::rmdir(char const*)
00001618 g     F .text	000000f8 file_open(unsigned short)
0000d984 g     F .text	00000040 usb_malloc
0000aae8 g     F .text	00000198 FatFile::read(void*, unsigned int)
0000fa4c g     F .text	00000012 .hidden __aeabi_fcmplt
0000d0b4  w    F .text	00000006 i2s0_isr
0000aadc g     F .text	0000000c FatFile::openRoot(FatVolume*)
20002bdc g     O .bss	00000004 ExFatVolume::m_cwv
20008000 g       .bss	00000000 _estack
0000c330 g     F .text	00000004 operator new(unsigned int, unsigned long*)
0000e65c g     F .text	00000034 DMAChannel::release()
00000570  w    F .text	0000002c File::read()
0000cea4 g     F .text	00000048 usb_serial_write_buffer_free
0000c3f4 g     F .text	0000003c SdSpiCard::waitNotBusy(unsigned short)
0000d0b4  w    F .text	00000006 enet_timer_isr
0000f374 g     F .text	00000012 .hidden __aeabi_dcmpeq
20002bbc g     O .bss	00000008 AudioInputPDM::dma
00008618 g     F .text	0000003a TwoWire::write(unsigned char const*, unsigned int)
00000f24  w    F .text	00000030 File::~File()
0000e7dc  w    F .text	0000000e _write
1fff9738 g     O .bss	00000004 maxDel
1fff9710 g       .data	00000000 _edata
000099fc g     F .text	00000020 ExFatPartition::fatPut(unsigned long, unsigned long)
00006070 g     F .text	00000254 MTPD::GetObjectInfo(unsigned long)
0000d0b4  w    F .text	00000006 i2s0_tx_isr
0000d0b4  w    F .text	00000006 adc1_isr
0000fa9c g     F .text	0000002c .hidden __unordsf2
0000c4f8 g     F .text	0000001a SdSpiCard::syncDevice()
0000a684 g     F .text	000000a4 FatFile::addDirCluster()
00000474  w    F .text	0000000c File::read(void*, unsigned int)
0000e77c  w    F .text	00000004 usb_serial_class::availableForWrite()
0000d0b4  w    F .text	00000006 cmp0_isr
000004b4  w    F .text	0000000c File::truncate(unsigned long long)
0000d180 g     F .text	0000004c ultoa
0000fb14 g     F .text	0000003e .hidden __aeabi_f2uiz
0000cac4  w    F .text	00000002 SDClass::~SDClass()
0000c59c g     F .text	000001ec SdSpiCard::begin(SdSpiConfig)
00007f50 g     F .text	00000020 second()
0000867c g     F .text	00000094 TwoWire::begin()
0000c160 g     F .text	00000080 FsBaseFile::open(FsVolume*, char const*, int)
000026a0 g     F .text	00000210 MTPStorage_SD::ReadIndexRecord(unsigned long)
0000e95c g     F .text	00000004 operator new(unsigned int)
0000e710 g     F .text	00000044 EventResponder::runFromInterrupt()
1fff9708 g     O .data	00000004 __malloc_trim_threshold
0000e76c  w    F .text	00000004 usb_serial_class::peek()
0000fed8 g     F .text	00000020 fcvtf
000028b0 g     F .text	0000005e MTPStorage_SD::GetNextObjectHandle(unsigned long)
000081b8 g     F .text	000001fc AudioControlSGTL5000::enable(unsigned int, unsigned long)
00000f54  w    F .text	00000078 MTPStorage_SD::~MTPStorage_SD()
0000f660 g     F .text	00000024 .hidden __floatunsisf
20002af0 g     O .bss	00000014 mtpd
00013e4c g     F .text	00000114 __mdiff
0000f404 g     F .text	0000004e .hidden __aeabi_d2iz
000031e0 g     F .text	000000aa MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)
00009990 g     F .text	00000058 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
20003090 g     O .bss	00000001 usb_cdc_transmit_flush_timer
0000fa28 g     F .text	00000010 .hidden __aeabi_cfcmpeq
200031d2 g     O .bss	00000002 AudioStream::cpu_cycles_total
0000d0b4  w    F .text	00000006 pit_isr
00007f10 g     F .text	00000020 hour()
00008db0 g     F .text	00000014 ExFatFile::close()
00014960 g     O .text	00000101 _ctype_
0000d0b4  w    F .text	00000006 dac0_isr
00014b84 g       .text	00000000 __init_array_start
0000fe68  w    F .text	00000002 .hidden __aeabi_idiv0
0000d0b4  w    F .text	00000006 can1_tx_warn_isr
0000212c g     F .text	00000394 MTPStorage_SD::OpenIndex()
0000f3d8 g     F .text	0000002c .hidden __unorddf2
0000fb14 g     F .text	0000003e .hidden __fixunssfsi
00000ac0  w    F .text	00000074 SDClass::rename(char const*, char const*)
0000d0b4  w    F .text	00000006 uart0_status_isr
0000d0b4  w    F .text	00000006 mcg_isr
00000400 g     O .text	00000010 flashconfigbytes
0000e594 g     F .text	000000c8 DMAChannel::begin(bool)
00010d40 g     F .text	000000dc strlen
0000b774 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000f364 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000f2c8 g     F .text	0000008a .hidden __gedf2
0000af1c g     F .text	000000b0 FatFile::seekSet(unsigned long)
1fff8c1c g     O .data	0000002e usb_string_product_name_default
20002b94 g     O .bss	00000008 AudioOutputI2SQuad::dma
000125b8 g     F .text	00000018 vdprintf
0000d0b4  w    F .text	00000006 dma_ch1_isr
00007730 g     F .text	00000008 MTPD::send_DeviceResetEvent()
0000da4c g     F .text	0000002c usb_tx_packet_count
0000b0a4 g     F .text	00000080 FatFile::openNext(FatFile*, int)
0000edfc g     F .text	0000003a .hidden __aeabi_f2d
0000d0b4  w    F .text	00000006 dma_ch5_isr
00002964 g     F .text	0000019c MTPStorage_SD::close()
0000b7a4 g     F .text	000000ec FatFile::getName(char*, unsigned int)
0000d0b4  w    F .text	00000006 can0_rx_warn_isr
00000f54  w    F .text	00000078 MTPStorage_SD::~MTPStorage_SD()
00002b64 g     F .text	000000b0 MTPStorage_SD::rename(unsigned long, char const*)
0000d0b4  w    F .text	00000006 can0_tx_warn_isr
0000d0b4  w    F .text	00000006 uart4_status_isr
00000000  w      *UND*	00000000 _Jv_RegisterClasses
20002b6c g     O .bss	00000008 AudioInputAnalog::dma
200031d0 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
0000c938 g     F .text	00000078 SdSpiArduinoDriver::activate()
00001e54 g     F .text	00000004 MTPStorage_SD::readonly(unsigned long)
0000eb3c g     F .text	0000027a .hidden __subdf3
000012a4 g     F .text	00000058 pullData(unsigned long*, unsigned long)
00014b84 g       .text	00000000 __preinit_array_start
00009878 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
0000294c g     F .text	00000016 MTPStorage_SD::GetSize(unsigned long)
000005cc  w    F .text	00000028 File::whoami()
1fffcaf0 g     O .bss	00006000 data_buffer
00013b1c g     F .text	0000005a __lo0bits
00009920 g     F .text	0000003a ExFatPartition::chainSize(unsigned long)
0000afcc g     F .text	000000d6 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000eb28 g     F .text	0000000a __aeabi_atexit
00006d18 g     F .text	0000001a MTPD::receive_buffer()
00000000  w      *UND*	00000000 __register_frame_info
0000d77c g     F .text	0000000c rtc_get
00009d24 g     F .text	000000d4 ExFatFile::remove()
0000d0b4  w    F .text	00000006 cmp2_isr
0000f500 g     F .text	00000160 .hidden __addsf3
0000e754 g     F .text	00000004 pendablesrvreq_isr
00000c54  w    F .text	00000034 SDClass::totalSize()
00006fc4 g     F .text	00000076 MTPD::SendObject()
00001e68 g     F .text	0000000c MTPStorage_SD::usedSize(unsigned long)
0000046c  w    F .text	00000004 Print::availableForWrite()
1fff9194 g     O .data	0000016c __global_locale
1fff8ca0 g     O .data	00000050 isr_table_portB
0000d0b4  w    F .text	00000006 wakeup_isr
00007b88 g     F .text	00000088 SPIClass::setMISO(unsigned char)
000013ac g     F .text	00000028 file_close()
0000d0b4  w    F .text	00000006 cmp3_isr
00007ca8 g     F .text	000001b0 breakTime(long, tmElements_t&)
0000b3c4 g     F .text	0000006e FatPartition::fatGet(unsigned long, unsigned long*)
0000ff64 g     F .text	00000010 free
0000d0b4  w    F .text	00000006 tpm2_isr
00013a5c g     F .text	00000080 __multadd
00013a48 g     F .text	00000012 _Bfree
00000c08  w    F .text	0000001a SDFile::size()
0000d0b4  w    F .text	00000006 dma_ch0_isr
00000fcc  w    F .text	0000005c SDFile::~SDFile()
1fff8c50  w    O .data	00000016 usb_string_serial_number
0000d0b4  w    F .text	00000006 enet_tx_isr
00009c60 g     F .text	00000038 exFatHashName(char const*, unsigned int, unsigned short)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  str = fsFmtField(str, 2*(time & 31) + (sec100 < 100 ? 0 : 1), 0);
  *--str = ':';
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
       0:	... ........m...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      10:	m...m...m...m...
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
      20:	m...m...m.......
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      30:	....m...U...Y...
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
      40:	................
  }
  str = fmtBase10(str, n);
  if (n < 10) {
    *--str = '0';
      50:	................
      tz = -tz;
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      60:	................
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      *--str = sign;
    }
    *--str = 'C';
    *--str = 'T';
      70:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      80:	................
      90:	................
      a0:	................
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	................
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	............

000001bc <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1bc:	ldr	r3, [pc, #344]	; (318 <ResetHandler+0x15c>)
     1be:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1c2:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1c4:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1c6:	movw	r2, #55592	; 0xd928
     1ca:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1cc:	nop
	__asm__ volatile ("nop");
     1ce:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1d0:	bl	d0bc <startup_early_hook>
	// enable clocks to always-used peripherals
#if defined(__MK20DX128__)
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
     1d4:	ldr	r3, [pc, #324]	; (31c <ResetHandler+0x160>)
     1d6:	mov.w	r2, #150994944	; 0x9000000
     1da:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1dc:	ldr	r2, [pc, #320]	; (320 <ResetHandler+0x164>)
     1de:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1e0:	ldr	r2, [pc, #320]	; (324 <ResetHandler+0x168>)
     1e2:	str	r2, [r3, #12]
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1e4:	ldr	r2, [pc, #320]	; (328 <ResetHandler+0x16c>)
     1e6:	ldr	r3, [r2, #0]
     1e8:	ands.w	r3, r3, #256	; 0x100
     1ec:	bne.n	1f8 <ResetHandler+0x3c>
		RTC_SR = 0;
     1ee:	ldr	r1, [pc, #316]	; (32c <ResetHandler+0x170>)
     1f0:	str	r3, [r1, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1f2:	mov.w	r3, #5376	; 0x1500
     1f6:	str	r3, [r2, #0]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1f8:	ldr	r3, [pc, #308]	; (330 <ResetHandler+0x174>)
     1fa:	ldrb	r2, [r3, #0]
     1fc:	lsls	r1, r2, #28
     1fe:	bpl.n	208 <ResetHandler+0x4c>
     200:	ldrb	r2, [r3, #0]
     202:	orr.w	r2, r2, #8
     206:	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     208:	ldr	r3, [pc, #296]	; (334 <ResetHandler+0x178>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     20a:	ldr	r1, [pc, #300]	; (338 <ResetHandler+0x17c>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     20c:	movs	r2, #42	; 0x2a
     20e:	strb	r2, [r3, #0]
     210:	ldr	r2, [pc, #296]	; (33c <ResetHandler+0x180>)
     212:	ldr	r3, [pc, #300]	; (340 <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     214:	cmp	r3, r1
     216:	bcs.n	222 <ResetHandler+0x66>
     218:	ldr.w	r0, [r2, #4]!
     21c:	str.w	r0, [r3], #4
     220:	b.n	214 <ResetHandler+0x58>
     222:	ldr	r3, [pc, #288]	; (344 <ResetHandler+0x188>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     224:	ldr	r1, [pc, #288]	; (348 <ResetHandler+0x18c>)
     226:	movs	r2, #0
     228:	cmp	r3, r1
     22a:	bcs.n	232 <ResetHandler+0x76>
     22c:	str.w	r2, [r3], #4
     230:	b.n	228 <ResetHandler+0x6c>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     232:	ldr	r1, [pc, #280]	; (34c <ResetHandler+0x190>)
     234:	ldr	r2, [pc, #280]	; (350 <ResetHandler+0x194>)
     236:	movs	r3, #0
     238:	ldr.w	r0, [r2, r3, lsl #2]
     23c:	str.w	r0, [r1, r3, lsl #2]
     240:	adds	r3, #1
     242:	cmp	r3, #111	; 0x6f
     244:	bne.n	238 <ResetHandler+0x7c>
     246:	ldr	r3, [pc, #268]	; (354 <ResetHandler+0x198>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     248:	ldr	r2, [pc, #268]	; (358 <ResetHandler+0x19c>)
     24a:	movs	r1, #128	; 0x80
     24c:	strb.w	r1, [r3], #1
     250:	cmp	r3, r2
     252:	bne.n	24c <ResetHandler+0x90>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     254:	ldr	r3, [pc, #260]	; (35c <ResetHandler+0x1a0>)
     256:	ldr	r2, [pc, #244]	; (34c <ResetHandler+0x190>)
     258:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     25a:	ldr	r3, [pc, #260]	; (360 <ResetHandler+0x1a4>)
     25c:	movs	r2, #138	; 0x8a
     25e:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     260:	sub.w	r3, r3, #4096	; 0x1000
     264:	movs	r2, #36	; 0x24
     266:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     268:	movs	r2, #160	; 0xa0
     26a:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     26c:	ldrb	r2, [r3, #6]
     26e:	lsls	r2, r2, #30
     270:	bpl.n	26c <ResetHandler+0xb0>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     272:	ldrb	r2, [r3, #6]
     274:	lsls	r4, r2, #27
     276:	bmi.n	272 <ResetHandler+0xb6>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     278:	ldr	r2, [pc, #232]	; (364 <ResetHandler+0x1a8>)
     27a:	ldrb	r3, [r2, #6]
     27c:	and.w	r3, r3, #12
     280:	cmp	r3, #8
     282:	ldr	r3, [pc, #224]	; (364 <ResetHandler+0x1a8>)
     284:	bne.n	27a <ResetHandler+0xbe>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     286:	movs	r2, #3
     288:	strb	r2, [r3, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
     28a:	movs	r2, #64	; 0x40
     28c:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     28e:	ldrb	r2, [r3, #6]
     290:	lsls	r0, r2, #26
     292:	bpl.n	28e <ResetHandler+0xd2>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     294:	ldr	r2, [pc, #204]	; (364 <ResetHandler+0x1a8>)
     296:	ldrb	r1, [r2, #6]
     298:	ldr	r3, [pc, #200]	; (364 <ResetHandler+0x1a8>)
     29a:	lsls	r1, r1, #25
     29c:	bpl.n	296 <ResetHandler+0xda>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     29e:	ldr	r2, [pc, #200]	; (368 <ResetHandler+0x1ac>)
     2a0:	ldr	r1, [pc, #200]	; (36c <ResetHandler+0x1b0>)
     2a2:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2a4:	movs	r1, #2
     2a6:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2a8:	movs	r2, #32
     2aa:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ac:	ldrb	r2, [r3, #6]
     2ae:	and.w	r2, r2, #12
     2b2:	cmp	r2, #12
     2b4:	bne.n	2ac <ResetHandler+0xf0>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2b6:	ldr	r3, [pc, #184]	; (370 <ResetHandler+0x1b4>)
     2b8:	ldr	r2, [pc, #184]	; (374 <ResetHandler+0x1b8>)
     2ba:	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2bc:	ldr	r3, [pc, #184]	; (378 <ResetHandler+0x1bc>)
     2be:	ldr	r2, [pc, #188]	; (37c <ResetHandler+0x1c0>)
     2c0:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2c2:	movs	r2, #0
     2c4:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2c6:	movs	r2, #7
     2c8:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2cc:	ldr	r2, [pc, #176]	; (380 <ResetHandler+0x1c4>)
     2ce:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2d2:	cpsie	i

	_init_Teensyduino_internal_();
     2d4:	bl	d8a4 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2d8:	ldr	r3, [pc, #80]	; (32c <ResetHandler+0x170>)
     2da:	ldr	r3, [r3, #0]
     2dc:	lsls	r2, r3, #31
     2de:	bpl.n	2ec <ResetHandler+0x130>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2e0:	ldr	r0, [pc, #160]	; (384 <ResetHandler+0x1c8>)
     2e2:	bl	d788 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2e6:	ldr	r3, [pc, #160]	; (388 <ResetHandler+0x1cc>)
     2e8:	ldr	r2, [pc, #160]	; (38c <ResetHandler+0x1d0>)
     2ea:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2ec:	ldr	r3, [pc, #160]	; (390 <ResetHandler+0x1d4>)
     2ee:	ldrb	r3, [r3, #0]
     2f0:	lsls	r3, r3, #25
     2f2:	bpl.n	308 <ResetHandler+0x14c>
     2f4:	ldr	r4, [pc, #144]	; (388 <ResetHandler+0x1cc>)
     2f6:	ldr	r3, [pc, #148]	; (38c <ResetHandler+0x1d0>)
     2f8:	ldr	r2, [r4, #0]
     2fa:	cmp	r2, r3
     2fc:	bne.n	308 <ResetHandler+0x14c>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2fe:	ldr	r0, [pc, #132]	; (384 <ResetHandler+0x1c8>)
     300:	bl	d788 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     304:	movs	r3, #0
     306:	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     308:	bl	ff04 <__libc_init_array>

	startup_late_hook();
     30c:	bl	d0c8 <startup_late_hook>
	main();
     310:	bl	e8c4 <main>
     314:	b.n	314 <ResetHandler+0x158>
     316:	nop
     318:	.word	0x4005200e
     31c:	.word	0x40048030
     320:	.word	0x00043f82
     324:	.word	0x2b000001
     328:	.word	0x4003d010
     32c:	.word	0x4003d014
     330:	.word	0x4007d002
     334:	.word	0x4007e000
     338:	.word	0x1fff9710
     33c:	.word	0x00014bdc
     340:	.word	0x1fff8960
     344:	.word	0x1fff9710
     348:	.word	0x20003234
     34c:	.word	0x1fff8200
     350:	.word	0x00000000
     354:	.word	0xe000e400
     358:	.word	0xe000e45f
     35c:	.word	0xe000ed08
     360:	.word	0x40065000
     364:	.word	0x40064000
     368:	.word	0x40048044
     36c:	.word	0x01030000
     370:	.word	0x40048004
     374:	.word	0x000510c0
     378:	.word	0xe000e014
     37c:	.word	0x000176ff
     380:	.word	0x20200000
     384:	.word	0x60f29bcc
     388:	.word	0x4003e01c
     38c:	.word	0x5a94c3a5
     390:	.word	0x4007f000
     394:	.word	0xffffffff
     398:	.word	0xffffffff
     39c:	.word	0xffffffff
     3a0:	.word	0xffffffff
     3a4:	.word	0xffffffff
     3a8:	.word	0xffffffff
     3ac:	.word	0xffffffff
     3b0:	.word	0xffffffff
     3b4:	.word	0xffffffff
     3b8:	.word	0xffffffff
     3bc:	.word	0xffffffff
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff9710
     42c:	.word	0x00000000
     430:	.word	0x00014bd8

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff9714
     460:	.word	0x00014bd8
     464:	.word	0x1fff9710
     468:	.word	0x00000000

0000046c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     46c:	movs	r0, #0
     46e:	bx	lr

00000470 <Print::flush()>:
	virtual void flush()				{ }
     470:	bx	lr
     472:	nop

00000474 <File::read(void*, unsigned int)>:
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
     474:	ldr	r0, [r0, #16]
     476:	cbz	r0, 47e <File::read(void*, unsigned int)+0xa>
     478:	ldr	r3, [r0, #0]
     47a:	ldr	r3, [r3, #40]	; 0x28
     47c:	bx	r3
	}
     47e:	bx	lr

00000480 <File::write(void const*, unsigned int)>:
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
     480:	ldr	r0, [r0, #16]
     482:	cbz	r0, 48a <File::write(void const*, unsigned int)+0xa>
     484:	ldr	r3, [r0, #0]
     486:	ldr	r3, [r3, #44]	; 0x2c
     488:	bx	r3
	}
     48a:	bx	lr

0000048c <File::available()>:
	virtual int available() {
		return (f) ? f->available() : 0;
     48c:	ldr	r0, [r0, #16]
     48e:	cbz	r0, 496 <File::available()+0xa>
     490:	ldr	r3, [r0, #0]
     492:	ldr	r3, [r3, #16]
     494:	bx	r3
	}
     496:	bx	lr

00000498 <File::peek()>:
	virtual int peek() {
		return (f) ? f->peek() : -1;
     498:	ldr	r0, [r0, #16]
     49a:	cbz	r0, 4a2 <File::peek()+0xa>
     49c:	ldr	r3, [r0, #0]
     49e:	ldr	r3, [r3, #24]
     4a0:	bx	r3
	}
     4a2:	mov.w	r0, #4294967295
     4a6:	bx	lr

000004a8 <File::flush()>:
	virtual void flush() {
		if (f) f->flush();
     4a8:	ldr	r0, [r0, #16]
     4aa:	cbz	r0, 4b2 <File::flush()+0xa>
     4ac:	ldr	r3, [r0, #0]
     4ae:	ldr	r3, [r3, #12]
     4b0:	bx	r3
     4b2:	bx	lr

000004b4 <File::truncate(unsigned long long)>:
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
     4b4:	ldr	r0, [r0, #16]
     4b6:	cbz	r0, 4be <File::truncate(unsigned long long)+0xa>
     4b8:	ldr	r1, [r0, #0]
     4ba:	ldr	r1, [r1, #48]	; 0x30
     4bc:	bx	r1
	}
     4be:	bx	lr

000004c0 <File::seek(unsigned long long, int)>:
	virtual bool seek(uint64_t pos, int mode) {
     4c0:	push	{r4}
		return (f) ? f->seek(pos, mode) : false;
     4c2:	ldr	r0, [r0, #16]
     4c4:	cbz	r0, 4ce <File::seek(unsigned long long, int)+0xe>
     4c6:	ldr	r4, [r0, #0]
     4c8:	ldr	r1, [r4, #52]	; 0x34
	}
     4ca:	pop	{r4}
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
     4cc:	bx	r1
	}
     4ce:	pop	{r4}
     4d0:	bx	lr
     4d2:	nop

000004d4 <File::position()>:
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
     4d4:	ldr	r0, [r0, #16]
     4d6:	cbz	r0, 4de <File::position()+0xa>
     4d8:	ldr	r3, [r0, #0]
     4da:	ldr	r3, [r3, #56]	; 0x38
     4dc:	bx	r3
	}
     4de:	movs	r0, #0
     4e0:	movs	r1, #0
     4e2:	bx	lr

000004e4 <File::size()>:
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
     4e4:	ldr	r0, [r0, #16]
     4e6:	cbz	r0, 4ee <File::size()+0xa>
     4e8:	ldr	r3, [r0, #0]
     4ea:	ldr	r3, [r3, #60]	; 0x3c
     4ec:	bx	r3
	}
     4ee:	movs	r0, #0
     4f0:	movs	r1, #0
     4f2:	bx	lr

000004f4 <File::close()>:
	virtual void close() {
		if (f) f->close();
     4f4:	ldr	r0, [r0, #16]
     4f6:	cbz	r0, 4fe <File::close()+0xa>
     4f8:	ldr	r3, [r0, #0]
     4fa:	ldr	r3, [r3, #64]	; 0x40
     4fc:	bx	r3
     4fe:	bx	lr

00000500 <File::operator bool()>:
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
     500:	ldr	r0, [r0, #16]
     502:	cbz	r0, 50a <File::operator bool()+0xa>
     504:	ldr	r3, [r0, #0]
     506:	ldr	r3, [r3, #68]	; 0x44
     508:	bx	r3
	}
     50a:	bx	lr

0000050c <File::name()>:
	virtual const char* name() {
		return (f) ? f->name() : "";
     50c:	ldr	r0, [r0, #16]
     50e:	cbz	r0, 516 <File::name()+0xa>
     510:	ldr	r3, [r0, #0]
     512:	ldr	r3, [r3, #72]	; 0x48
     514:	bx	r3
	}
     516:	ldr	r0, [pc, #4]	; (51c <File::name()+0x10>)
     518:	bx	lr
     51a:	nop
     51c:	.word	0x000143a8

00000520 <File::isDirectory()>:
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
     520:	ldr	r0, [r0, #16]
     522:	cbz	r0, 52a <File::isDirectory()+0xa>
     524:	ldr	r3, [r0, #0]
     526:	ldr	r3, [r3, #76]	; 0x4c
     528:	bx	r3
	}
     52a:	bx	lr

0000052c <File::openNextFile(unsigned char)>:
	virtual File openNextFile(uint8_t mode=0) {
     52c:	push	{r3, r4, r5, lr}
		return (f) ? f->openNextFile(mode) : *this;
     52e:	ldr	r3, [r1, #16]
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
     530:	mov	r4, r0
		return (f) ? f->openNextFile(mode) : *this;
     532:	cbz	r3, 540 <File::openNextFile(unsigned char)+0x14>
     534:	ldr	r5, [r3, #0]
     536:	mov	r1, r3
     538:	ldr	r3, [r5, #80]	; 0x50
     53a:	blx	r3
	}
     53c:	mov	r0, r4
     53e:	pop	{r3, r4, r5, pc}
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     540:	mov.w	r0, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
     544:	ldr	r2, [pc, #24]	; (560 <File::openNextFile(unsigned char)+0x34>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     546:	strb	r3, [r4, #4]
     548:	strb	r3, [r4, #12]
     54a:	str	r0, [r4, #8]
     54c:	str	r2, [r4, #0]
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
     54e:	ldr	r3, [r1, #16]
     550:	str	r3, [r4, #16]
		if (f) f->refcount++;
     552:	cmp	r3, #0
     554:	beq.n	53c <File::openNextFile(unsigned char)+0x10>
     556:	ldr	r2, [r3, #16]
     558:	adds	r2, #1
     55a:	str	r2, [r3, #16]
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
	}
     55c:	mov	r0, r4
     55e:	pop	{r3, r4, r5, pc}
     560:	.word	0x000141ec

00000564 <File::rewindDirectory()>:
	virtual void rewindDirectory(void) {
		if (f) f->rewindDirectory();
     564:	ldr	r0, [r0, #16]
     566:	cbz	r0, 56e <File::rewindDirectory()+0xa>
     568:	ldr	r3, [r0, #0]
     56a:	ldr	r3, [r3, #84]	; 0x54
     56c:	bx	r3
     56e:	bx	lr

00000570 <File::read()>:
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     570:	ldr	r0, [r0, #16]
     572:	cbz	r0, 596 <File::read()+0x26>
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     574:	push	{lr}
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     576:	ldr	r3, [r0, #0]
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     578:	sub	sp, #12
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     57a:	ldr	r3, [r3, #40]	; 0x28
     57c:	movs	r2, #1
     57e:	add.w	r1, sp, #7
     582:	blx	r3
     584:	cbz	r0, 590 <File::read()+0x20>
		return b;
     586:	ldrb.w	r0, [sp, #7]
	}
     58a:	add	sp, #12
     58c:	ldr.w	pc, [sp], #4
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     590:	mov.w	r0, #4294967295
     594:	b.n	58a <File::read()+0x1a>
     596:	mov.w	r0, #4294967295
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
     59a:	bx	lr

0000059c <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     59c:	push	{r4, lr}
     59e:	sub	sp, #8
     5a0:	add	r3, sp, #8
		return write(&b, 1);
     5a2:	ldr	r2, [r0, #0]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     5a4:	strb.w	r1, [r3, #-1]!
		return write(&b, 1);
     5a8:	ldr	r4, [r2, #44]	; 0x2c
     5aa:	mov	r1, r3
     5ac:	movs	r2, #1
     5ae:	blx	r4
	}
     5b0:	add	sp, #8
     5b2:	pop	{r4, pc}

000005b4 <SDFile::operator bool()>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     5b4:	ldr	r3, [r0, #92]	; 0x5c
     5b6:	cbz	r3, 5bc <SDFile::operator bool()+0x8>
     5b8:	movs	r0, #1
		}
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
     5ba:	bx	lr
     5bc:	ldr	r0, [r0, #96]	; 0x60
     5be:	adds	r0, #0
     5c0:	it	ne
     5c2:	movne	r0, #1
     5c4:	bx	lr
     5c6:	nop

000005c8 <__tcf_0>:
  return state;
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
     5c8:	bx	lr
     5ca:	nop

000005cc <File::whoami()>:
	}
	virtual ~File() {
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
     5cc:	push	{r4, lr}
     5ce:	mov	r4, r0
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
     5d0:	mov	r2, r0
     5d2:	ldr	r3, [r0, #16]
     5d4:	ldr	r1, [pc, #20]	; (5ec <File::whoami()+0x20>)
     5d6:	ldr	r0, [pc, #24]	; (5f0 <File::whoami()+0x24>)
     5d8:	bl	e7ec <Print::printf(char const*, ...)>
		if (f) f->whoami();
     5dc:	ldr	r0, [r4, #16]
     5de:	cbz	r0, 5ea <File::whoami()+0x1e>
     5e0:	ldr	r3, [r0, #0]
	}
     5e2:	ldmia.w	sp!, {r4, lr}
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
		if (f) f->whoami();
     5e6:	ldr	r3, [r3, #36]	; 0x24
     5e8:	bx	r3
     5ea:	pop	{r4, pc}
     5ec:	.word	0x000142d4
     5f0:	.word	0x1fff8d50

000005f4 <SDFile::whoami()>:
		if (filename) free(filename);
	}
#ifdef FILE_WHOAMI
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
     5f4:	mov	r2, r0
     5f6:	ldr	r3, [r0, #16]
     5f8:	ldr	r1, [pc, #4]	; (600 <SDFile::whoami()+0xc>)
     5fa:	ldr	r0, [pc, #8]	; (604 <SDFile::whoami()+0x10>)
     5fc:	b.w	e7ec <Print::printf(char const*, ...)>
     600:	.word	0x000142f0
     604:	.word	0x1fff8d50

00000608 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     608:	push	{r4, lr}
     60a:	mov	r4, r0
		if (filename) {
     60c:	ldr	r0, [r0, #100]	; 0x64
     60e:	cbz	r0, 618 <SDFile::close()+0x10>
			free(filename);
     610:	bl	ff64 <free>
			filename = nullptr;
     614:	movs	r3, #0
     616:	str	r3, [r4, #100]	; 0x64
		}
		sdfatfile.close();
     618:	add.w	r0, r4, #36	; 0x24
	}
     61c:	ldmia.w	sp!, {r4, lr}
	virtual void close() {
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		sdfatfile.close();
     620:	b.w	c138 <FsBaseFile::close()>

00000624 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     624:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     628:	movs	r3, #0
     62a:	sub	sp, #80	; 0x50
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     62c:	mov	r2, r3
     62e:	mov	r5, r0
     630:	adds	r1, #36	; 0x24
     632:	add	r0, sp, #16
     634:	mov.w	r4, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     638:	ldr	r7, [pc, #148]	; (6d0 <SDFile::openNextFile(unsigned char)+0xac>)
     63a:	strb.w	r3, [sp, #4]
     63e:	strb.w	r3, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     642:	str	r3, [sp, #72]	; 0x48
     644:	str	r3, [sp, #76]	; 0x4c
     646:	str	r4, [sp, #8]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     648:	str	r7, [sp, #0]
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     64a:	bl	c1e0 <FsBaseFile::openNext(FsBaseFile*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     64e:	ldr	r3, [sp, #72]	; 0x48
     650:	cmp	r3, #0
     652:	beq.n	6ba <SDFile::openNextFile(unsigned char)+0x96>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     654:	movs	r0, #104	; 0x68
     656:	bl	e95c <operator new(unsigned int)>
     65a:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     65c:	ldrb.w	r6, [sp, #4]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     660:	ldr	r2, [sp, #8]
     662:	ldrb.w	r3, [sp, #12]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     666:	ldr	r0, [pc, #108]	; (6d4 <SDFile::openNextFile(unsigned char)+0xb0>)
     668:	ldr	r1, [pc, #108]	; (6d8 <SDFile::openNextFile(unsigned char)+0xb4>)
     66a:	strb	r6, [r4, #24]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     66c:	mov.w	r8, #1000	; 0x3e8
{
  public:
	constexpr Print() : write_error(0) {}
     670:	movs	r6, #0
     672:	str	r0, [r4, #0]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     674:	str	r1, [r4, #20]
     676:	str	r2, [r4, #28]
     678:	strb.w	r3, [r4, #32]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     67c:	add.w	r0, r4, #36	; 0x24
     680:	add	r1, sp, #16
     682:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     684:	strb	r6, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     686:	str	r6, [r4, #16]
     688:	str.w	r8, [r4, #8]
     68c:	bl	c0c0 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     690:	ldr	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     692:	ldr	r2, [pc, #72]	; (6dc <SDFile::openNextFile(unsigned char)+0xb8>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     694:	str	r7, [r4, #20]
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     696:	adds	r3, #1
     698:	str	r6, [r4, #100]	; 0x64
     69a:	strb	r6, [r5, #4]
     69c:	str.w	r8, [r5, #8]
     6a0:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     6a2:	str	r4, [r5, #16]
		if (f) f->refcount++;
     6a4:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     6a6:	str	r2, [r5, #0]
     6a8:	ldr	r3, [pc, #52]	; (6e0 <SDFile::openNextFile(unsigned char)+0xbc>)
     6aa:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     6ac:	add	r0, sp, #16
     6ae:	bl	c138 <FsBaseFile::close()>
	}
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
     6b2:	mov	r0, r5
     6b4:	add	sp, #80	; 0x50
     6b6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     6ba:	ldr	r3, [sp, #76]	; 0x4c
     6bc:	cmp	r3, #0
     6be:	bne.n	654 <SDFile::openNextFile(unsigned char)+0x30>

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     6c0:	ldr	r2, [pc, #24]	; (6dc <SDFile::openNextFile(unsigned char)+0xb8>)
     6c2:	strb	r3, [r5, #4]
     6c4:	str	r4, [r5, #8]
     6c6:	strb	r3, [r5, #12]
     6c8:	str	r3, [r5, #16]
     6ca:	str	r2, [r5, #0]
     6cc:	b.n	6a8 <SDFile::openNextFile(unsigned char)+0x84>
     6ce:	nop
     6d0:	.word	0x000141c8
     6d4:	.word	0x0001424c
     6d8:	.word	0x00014180
     6dc:	.word	0x000141ec
     6e0:	.word	0x000141a4

000006e4 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:

/****************** File Utilities *****************************/
  #if USE_SD==1
    // Call back for file timestamps.  Only called for file create and sync()
    void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
    { *date = FS_DATE(year(), month(), day());
     6e4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     6e8:	mov	r7, r1
     6ea:	mov	r6, r2
     6ec:	mov	r8, r0
     6ee:	bl	7fb0 <year()>
     6f2:	mov	r4, r0
     6f4:	bl	7f90 <month()>
     6f8:	mov	r5, r0
     6fa:	bl	7f70 <day()>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
     6fe:	subw	r3, r4, #1980	; 0x7bc
     702:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
     704:	cmp	r3, #127	; 0x7f
     706:	bhi.n	70e <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     708:	uxtb	r2, r5
     70a:	cmp	r2, #12
     70c:	bls.n	766 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x82>
         year << 9 | month << 5 | day;
     70e:	movs	r3, #0
     710:	strh.w	r3, [r8]
      *time = FS_TIME(hour(), minute(), second());
     714:	bl	7f10 <hour()>
     718:	mov	r4, r0
     71a:	bl	7f30 <minute()>
     71e:	mov	r5, r0
     720:	bl	7f50 <second()>
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
     724:	uxtb	r3, r4
     726:	cmp	r3, #23
     728:	bhi.n	730 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     72a:	uxtb	r3, r5
     72c:	cmp	r3, #59	; 0x3b
     72e:	bls.n	748 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
     730:	movs	r3, #0
     732:	strh	r3, [r7, #0]
      *ms10 = second() & 1 ? 100 : 0;
     734:	bl	7f50 <second()>
     738:	tst.w	r0, #1
     73c:	ite	ne
     73e:	movne	r3, #100	; 0x64
     740:	moveq	r3, #0
     742:	strb	r3, [r6, #0]
     744:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     748:	uxtb	r3, r0
     74a:	cmp	r3, #59	; 0x3b
     74c:	bhi.n	730 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
         hour << 11 | minute << 5 | second >> 1;
     74e:	lsls	r4, r4, #11
     750:	lsls	r3, r5, #5
     752:	and.w	r4, r4, #522240	; 0x7f800
     756:	and.w	r3, r3, #8160	; 0x1fe0
     75a:	orrs	r3, r4
     75c:	ubfx	r0, r0, #1, #7
     760:	orrs	r3, r0
     762:	uxth	r3, r3
     764:	b.n	732 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4e>

/****************** File Utilities *****************************/
  #if USE_SD==1
    // Call back for file timestamps.  Only called for file create and sync()
    void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
    { *date = FS_DATE(year(), month(), day());
     766:	uxtb	r0, r0
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     768:	cmp	r0, #31
     76a:	bhi.n	70e <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
         year << 9 | month << 5 | day;
     76c:	lsls	r5, r5, #5
     76e:	and.w	r5, r5, #8160	; 0x1fe0
     772:	orrs	r0, r5
     774:	orr.w	r3, r0, r3, lsl #9
     778:	uxth	r3, r3
     77a:	b.n	710 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2c>

0000077c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     77c:	push	{r4, lr}
     77e:	mov	r4, r0
		release();
     780:	bl	e65c <DMAChannel::release()>
	}
     784:	mov	r0, r4
     786:	pop	{r4, pc}

00000788 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     788:	ldr	r2, [r0, #92]	; 0x5c
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     78a:	cbz	r2, 7a6 <SDFile::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     78c:	ldrb	r3, [r2, #0]
     78e:	and.w	r3, r3, #8
     792:	and.w	r0, r3, #255	; 0xff
     796:	cbz	r3, 7da <SDFile::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     798:	ldr	r3, [r2, #28]
     79a:	ldr	r0, [r2, #20]
     79c:	subs	r0, r3, r0
     79e:	it	mi
     7a0:	mvnmi.w	r0, #2147483648	; 0x80000000
     7a4:	bx	lr
     7a6:	ldr	r1, [r0, #96]	; 0x60
     7a8:	cbz	r1, 7dc <SDFile::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     7aa:	ldrb.w	r3, [r1, #49]	; 0x31
     7ae:	and.w	r3, r3, #8
     7b2:	and.w	r0, r3, #255	; 0xff
     7b6:	cbz	r3, 7da <SDFile::available()+0x52>
     7b8:	ldrd	r2, r3, [r1, #16]
     7bc:	ldrd	r0, r1, [r1]
     7c0:	subs	r0, r2, r0
     7c2:	push	{r4, r5}
     7c4:	sbc.w	r1, r3, r1
     7c8:	movs	r5, #0
     7ca:	mvn.w	r4, #2147483648	; 0x80000000
     7ce:	cmp	r5, r1
     7d0:	it	eq
     7d2:	cmpeq	r4, r0
     7d4:	bcs.n	7d8 <SDFile::available()+0x50>
     7d6:	mov	r0, r4
		return sdfatfile.available();
	}
     7d8:	pop	{r4, r5}
     7da:	bx	lr
     7dc:	mov	r0, r1
     7de:	bx	lr

000007e0 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     7e0:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     7e2:	cbz	r3, 7ea <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     7e4:	mov	r0, r3
     7e6:	b.w	ac80 <FatFile::peek()>
     7ea:	ldr	r0, [r0, #76]	; 0x4c
     7ec:	cbz	r0, 7f2 <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     7ee:	b.w	9108 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     7f2:	mov.w	r0, #4294967295
     7f6:	bx	lr

000007f8 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     7f8:	push	{lr}
     7fa:	ldr	r3, [r0, #72]	; 0x48
     7fc:	sub	sp, #12
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     7fe:	cbz	r3, 81a <StreamFile<FsBaseFile, unsigned long long>::read()+0x22>
     800:	mov	r0, r3
     802:	movs	r2, #1
     804:	add.w	r1, sp, #7
     808:	bl	aae8 <FatFile::read(void*, unsigned int)>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     80c:	cmp	r0, #1
     80e:	bne.n	82a <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     810:	ldrb.w	r0, [sp, #7]
    return BaseFile::read();
  }
     814:	add	sp, #12
     816:	ldr.w	pc, [sp], #4
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     81a:	ldr	r0, [r0, #76]	; 0x4c
     81c:	cbz	r0, 82a <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     81e:	movs	r2, #1
     820:	add.w	r1, sp, #7
     824:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
     828:	b.n	80c <StreamFile<FsBaseFile, unsigned long long>::read()+0x14>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     82a:	mov.w	r0, #4294967295
     82e:	b.n	814 <StreamFile<FsBaseFile, unsigned long long>::read()+0x1c>

00000830 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     830:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     832:	cbz	r3, 83a <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     834:	mov	r0, r3
     836:	b.w	b124 <FatFile::sync()>
     83a:	ldr	r0, [r0, #76]	; 0x4c
     83c:	cbz	r0, 842 <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     83e:	b.w	9f94 <ExFatFile::sync()>
     842:	bx	lr

00000844 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     844:	push	{lr}
     846:	ldr	r3, [r0, #72]	; 0x48
     848:	sub	sp, #12
     84a:	strb.w	r1, [sp, #7]
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     84e:	cbz	r3, 862 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x1e>
     850:	mov	r0, r3
     852:	movs	r2, #1
     854:	add.w	r1, sp, #7
     858:	bl	b1a8 <FatFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     85c:	add	sp, #12
     85e:	ldr.w	pc, [sp], #4
     862:	ldr	r0, [r0, #76]	; 0x4c
     864:	cmp	r0, #0
     866:	beq.n	85c <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x18>
     868:	movs	r2, #1
     86a:	add.w	r1, sp, #7
     86e:	bl	a3ac <ExFatFile::write(void const*, unsigned int)>
     872:	add	sp, #12
     874:	ldr.w	pc, [sp], #4

00000878 <logg(unsigned long, char const*) [clone .part.55]>:
}

/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
     878:	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d; %4d %4d; %4d\n",
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel); 
     87c:	ldr	r4, [pc, #72]	; (8c8 <logg(unsigned long, char const*) [clone .part.55]+0x50>)
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d; %4d %4d; %4d\n",
     87e:	ldr	r5, [pc, #76]	; (8cc <logg(unsigned long, char const*) [clone .part.55]+0x54>)
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel); 
     880:	ldr	r1, [r4, #0]
     882:	ldr	r6, [pc, #76]	; (8d0 <logg(unsigned long, char const*) [clone .part.55]+0x58>)
     884:	ldr	r7, [pc, #76]	; (8d4 <logg(unsigned long, char const*) [clone .part.55]+0x5c>)
     886:	ldrh	r2, [r5, #0]
     888:	ldr.w	r9, [pc, #92]	; 8e8 <logg(unsigned long, char const*) [clone .part.55]+0x70>
}

/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
     88c:	sub	sp, #24
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d; %4d %4d; %4d\n",
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel); 
     88e:	ldr.w	r3, [r9]
     892:	str	r1, [sp, #12]
     894:	ldr	r1, [r7, #0]
     896:	str	r2, [sp, #8]
     898:	mov	r2, r0
     89a:	ldr	r0, [r6, #0]
     89c:	str	r0, [sp, #4]
     89e:	str	r1, [sp, #0]
     8a0:	ldr	r0, [pc, #52]	; (8d8 <logg(unsigned long, char const*) [clone .part.55]+0x60>)
     8a2:	ldr	r1, [pc, #56]	; (8dc <logg(unsigned long, char const*) [clone .part.55]+0x64>)
     8a4:	bl	e7ec <Print::printf(char const*, ...)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8a8:	ldr	r3, [pc, #52]	; (8e0 <logg(unsigned long, char const*) [clone .part.55]+0x68>)
    loop_count=0;
    acq_count=0;
    acq_miss=0;
    maxCount=0;
    maxDel=0;
    to=millis();
     8aa:	ldr	r2, [pc, #56]	; (8e4 <logg(unsigned long, char const*) [clone .part.55]+0x6c>)
     8ac:	ldr	r3, [r3, #0]
     8ae:	str	r3, [sp, #20]
	return ret;
     8b0:	ldr	r1, [sp, #20]
     8b2:	str	r1, [r2, #0]
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d; %4d %4d; %4d\n",
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel); 
    loop_count=0;
     8b4:	movs	r3, #0
     8b6:	str.w	r3, [r9]
    acq_count=0;
     8ba:	str	r3, [r7, #0]
    acq_miss=0;
     8bc:	str	r3, [r6, #0]
    maxCount=0;
     8be:	strh	r3, [r5, #0]
    maxDel=0;
     8c0:	str	r3, [r4, #0]
    to=millis();
  }
}
     8c2:	add	sp, #24
     8c4:	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
     8c8:	.word	0x1fff9738
     8cc:	.word	0x20002b04
     8d0:	.word	0x20002b18
     8d4:	.word	0x1fffb93c
     8d8:	.word	0x1fff8d50
     8dc:	.word	0x00014310
     8e0:	.word	0x200030a4
     8e4:	.word	0x20002b20
     8e8:	.word	0x20002b08

000008ec <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
     8ec:	push	{r4, lr}
     8ee:	ldr.w	r4, [r0, #1156]	; 0x484
     8f2:	sub	sp, #56	; 0x38
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
     8f4:	cbz	r4, 920 <SDClass::remove(char const*)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     8f6:	mov	r2, r1
     8f8:	mov	r0, sp
     8fa:	mov	r1, r4
     8fc:	movs	r3, #1
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     8fe:	movs	r4, #0
     900:	strb.w	r4, [sp]
     904:	strb.w	r4, [sp, #1]
     908:	strb.w	r4, [sp, #2]
     90c:	bl	aacc <FatFile::open(FatVolume*, char const*, int)>
     910:	cbnz	r0, 916 <SDClass::remove(char const*)+0x2a>
		return sdfs.remove(filepath);
	}
     912:	add	sp, #56	; 0x38
     914:	pop	{r4, pc}
     916:	mov	r0, sp
     918:	bl	badc <FatFile::remove()>
     91c:	add	sp, #56	; 0x38
     91e:	pop	{r4, pc}
     920:	ldr.w	r0, [r0, #1160]	; 0x488
     924:	cmp	r0, #0
     926:	beq.n	912 <SDClass::remove(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     928:	mov	r2, r1
     92a:	movs	r3, #1
     92c:	mov	r1, r0
     92e:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     930:	strb.w	r4, [sp, #49]	; 0x31
     934:	strb.w	r4, [sp, #50]	; 0x32
     938:	strb.w	r4, [sp, #51]	; 0x33
     93c:	bl	9714 <ExFatFile::open(ExFatVolume*, char const*, int)>
     940:	cmp	r0, #0
     942:	beq.n	912 <SDClass::remove(char const*)+0x26>
     944:	mov	r0, sp
     946:	bl	9d24 <ExFatFile::remove()>
     94a:	add	sp, #56	; 0x38
     94c:	pop	{r4, pc}
     94e:	nop

00000950 <SDFile::name()>:
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     950:	push	{r3, r4, r5, lr}
		if (!filename) {
     952:	ldr	r4, [r0, #100]	; 0x64
     954:	cbz	r4, 95a <SDFile::name()+0xa>
				static char zeroterm = 0;
				filename = &zeroterm;
			}
		}
		return filename;
	}
     956:	mov	r0, r4
     958:	pop	{r3, r4, r5, pc}
     95a:	mov	r5, r0
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
		if (!filename) {
			filename = (char *)malloc(MAX_FILENAME_LEN);
     95c:	mov.w	r0, #256	; 0x100
     960:	bl	ff54 <malloc>
     964:	mov	r1, r0
     966:	str	r0, [r5, #100]	; 0x64
			if (filename) {
     968:	cbz	r0, 98c <SDFile::name()+0x3c>
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
     96a:	ldr	r0, [r5, #92]	; 0x5c
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     96c:	strb	r4, [r1, #0]
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
     96e:	cbz	r0, 97c <SDFile::name()+0x2c>
     970:	mov.w	r2, #256	; 0x100
     974:	bl	b7a4 <FatFile::getName(char*, unsigned int)>
     978:	ldr	r4, [r5, #100]	; 0x64
     97a:	b.n	956 <SDFile::name()+0x6>
     97c:	ldr	r0, [r5, #96]	; 0x60
     97e:	cbz	r0, 992 <SDFile::name()+0x42>
     980:	mov.w	r2, #256	; 0x100
     984:	bl	8dc4 <ExFatFile::getName(char*, unsigned int)>
     988:	ldr	r4, [r5, #100]	; 0x64
     98a:	b.n	956 <SDFile::name()+0x6>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     98c:	ldr	r4, [pc, #8]	; (998 <SDFile::name()+0x48>)
     98e:	str	r4, [r5, #100]	; 0x64
     990:	b.n	956 <SDFile::name()+0x6>
     992:	mov	r4, r1
     994:	b.n	956 <SDFile::name()+0x6>
     996:	nop
     998:	.word	0x1fff972c

0000099c <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     99c:	push	{r4, r6, r7, lr}
     99e:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
           m_xFile ? m_xFile->truncate(length) : false;
     9a0:	cbz	r4, 9c6 <SDFile::truncate(unsigned long long)+0x2a>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     9a2:	cmp	r3, #1
     9a4:	it	eq
     9a6:	cmpeq	r2, #0
     9a8:	bcc.n	9ae <SDFile::truncate(unsigned long long)+0x12>
     9aa:	movs	r0, #0
		return sdfatfile.truncate(size);
	}
     9ac:	pop	{r4, r6, r7, pc}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     9ae:	mov	r1, r2
     9b0:	mov	r0, r4
     9b2:	bl	af1c <FatFile::seekSet(unsigned long)>
     9b6:	cmp	r0, #0
     9b8:	beq.n	9aa <SDFile::truncate(unsigned long long)+0xe>
     9ba:	mov	r0, r4
     9bc:	bl	b130 <FatFile::truncate()>
     9c0:	cmp	r0, #0
     9c2:	beq.n	9aa <SDFile::truncate(unsigned long long)+0xe>
     9c4:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     9c6:	ldr	r4, [r0, #96]	; 0x60
     9c8:	cmp	r4, #0
     9ca:	beq.n	9aa <SDFile::truncate(unsigned long long)+0xe>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     9cc:	mov	r0, r4
     9ce:	bl	9138 <ExFatFile::seekSet(unsigned long long)>
     9d2:	cmp	r0, #0
     9d4:	beq.n	9aa <SDFile::truncate(unsigned long long)+0xe>
     9d6:	mov	r0, r4
     9d8:	ldmia.w	sp!, {r4, r6, r7, lr}
     9dc:	b.w	a2c8 <ExFatFile::truncate()>

000009e0 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
     9e0:	push	{r4, lr}
     9e2:	ldr.w	r4, [r0, #1156]	; 0x484
     9e6:	sub	sp, #56	; 0x38
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
     9e8:	cbz	r4, a0a <SDClass::mkdir(char const*)+0x2a>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     9ea:	mov	r2, r1
     9ec:	movs	r3, #1
     9ee:	addw	r1, r4, #1092	; 0x444
     9f2:	mov	r0, sp
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     9f4:	movs	r4, #0
     9f6:	strb.w	r4, [sp]
     9fa:	strb.w	r4, [sp, #1]
     9fe:	strb.w	r4, [sp, #2]
     a02:	bl	a948 <FatFile::mkdir(FatFile*, char const*, bool)>
		return sdfs.mkdir(filepath);
	}
     a06:	add	sp, #56	; 0x38
     a08:	pop	{r4, pc}
     a0a:	ldr.w	r0, [r0, #1160]	; 0x488
     a0e:	cmp	r0, #0
     a10:	beq.n	a06 <SDClass::mkdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     a12:	mov	r2, r1
     a14:	movs	r3, #1
     a16:	add.w	r1, r0, #1096	; 0x448
     a1a:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     a1c:	strb.w	r4, [sp, #49]	; 0x31
     a20:	strb.w	r4, [sp, #50]	; 0x32
     a24:	strb.w	r4, [sp, #51]	; 0x33
     a28:	bl	a144 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
     a2c:	add	sp, #56	; 0x38
     a2e:	pop	{r4, pc}

00000a30 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
     a30:	push	{r4, r5, lr}
     a32:	ldr.w	r4, [r0, #1156]	; 0x484
     a36:	sub	sp, #60	; 0x3c
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
     a38:	cbz	r4, a58 <SDClass::exists(char const*)+0x28>
     a3a:	movs	r5, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     a3c:	mov	r2, r1
     a3e:	mov	r3, r5
     a40:	mov	r1, r4
     a42:	mov	r0, sp
     a44:	strb.w	r5, [sp]
     a48:	strb.w	r5, [sp, #1]
     a4c:	strb.w	r5, [sp, #2]
     a50:	bl	aacc <FatFile::open(FatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
     a54:	add	sp, #60	; 0x3c
     a56:	pop	{r4, r5, pc}
     a58:	ldr.w	r0, [r0, #1160]	; 0x488
     a5c:	cmp	r0, #0
     a5e:	beq.n	a54 <SDClass::exists(char const*)+0x24>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     a60:	mov	r2, r1
     a62:	mov	r3, r4
     a64:	mov	r1, r0
     a66:	mov	r0, sp
     a68:	strb.w	r4, [sp, #49]	; 0x31
     a6c:	strb.w	r4, [sp, #50]	; 0x32
     a70:	strb.w	r4, [sp, #51]	; 0x33
     a74:	bl	9714 <ExFatFile::open(ExFatVolume*, char const*, int)>
     a78:	add	sp, #60	; 0x3c
     a7a:	pop	{r4, r5, pc}

00000a7c <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     a7c:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     a7e:	cbz	r3, aa8 <SDFile::rewindDirectory()+0x2c>
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     a80:	ldrb	r2, [r3, #0]
     a82:	tst.w	r2, #112	; 0x70
     a86:	bne.n	a8a <SDFile::rewindDirectory()+0xe>
     a88:	bx	lr
     a8a:	push	{r4, lr}
     a8c:	mov	r4, r0
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     a8e:	movs	r1, #0
     a90:	mov	r0, r3
     a92:	bl	af1c <FatFile::seekSet(unsigned long)>
     a96:	ldr	r0, [r4, #96]	; 0x60
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
    if (m_xFile) m_xFile->rewind();
     a98:	cbz	r0, aa6 <SDFile::rewindDirectory()+0x2a>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     a9a:	movs	r2, #0
     a9c:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     a9e:	ldmia.w	sp!, {r4, lr}
     aa2:	b.w	9138 <ExFatFile::seekSet(unsigned long long)>
     aa6:	pop	{r4, pc}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     aa8:	ldr	r0, [r0, #96]	; 0x60
     aaa:	cmp	r0, #0
     aac:	beq.n	a88 <SDFile::rewindDirectory()+0xc>
     aae:	ldrb.w	r3, [r0, #49]	; 0x31
     ab2:	tst.w	r3, #80	; 0x50
     ab6:	beq.n	a88 <SDFile::rewindDirectory()+0xc>
     ab8:	movs	r2, #0
     aba:	movs	r3, #0
     abc:	b.w	9138 <ExFatFile::seekSet(unsigned long long)>

00000ac0 <SDClass::rename(char const*, char const*)>:
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
     ac0:	push	{r4, r5, r6, lr}
     ac2:	ldr.w	r4, [r0, #1156]	; 0x484
     ac6:	sub	sp, #56	; 0x38
     ac8:	mov	r6, r2
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
     aca:	cbz	r4, afe <SDClass::rename(char const*, char const*)+0x3e>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     acc:	movs	r5, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
     ace:	addw	r4, r4, #1092	; 0x444
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     ad2:	mov	r2, r1
     ad4:	mov	r3, r5
     ad6:	mov	r1, r4
     ad8:	mov	r0, sp
     ada:	strb.w	r5, [sp]
     ade:	strb.w	r5, [sp, #1]
     ae2:	strb.w	r5, [sp, #2]
     ae6:	bl	aa0c <FatFile::open(FatFile*, char const*, int)>
     aea:	cbnz	r0, af0 <SDClass::rename(char const*, char const*)+0x30>
		return sdfs.rename(oldfilepath, newfilepath);
	}
     aec:	add	sp, #56	; 0x38
     aee:	pop	{r4, r5, r6, pc}
     af0:	mov	r2, r6
     af2:	mov	r1, r4
     af4:	mov	r0, sp
     af6:	bl	acec <FatFile::rename(FatFile*, char const*)>
     afa:	add	sp, #56	; 0x38
     afc:	pop	{r4, r5, r6, pc}
     afe:	ldr.w	r0, [r0, #1160]	; 0x488
     b02:	cmp	r0, #0
     b04:	beq.n	aec <SDClass::rename(char const*, char const*)+0x2c>
#endif  //  USE_EXFAT_UNICODE_NAMES

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
     b06:	add.w	r5, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     b0a:	mov	r2, r1
     b0c:	mov	r3, r4
     b0e:	mov	r1, r5
     b10:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     b12:	strb.w	r4, [sp, #49]	; 0x31
     b16:	strb.w	r4, [sp, #50]	; 0x32
     b1a:	strb.w	r4, [sp, #51]	; 0x33
     b1e:	bl	9614 <ExFatFile::open(ExFatFile*, char const*, int)>
     b22:	cmp	r0, #0
     b24:	beq.n	aec <SDClass::rename(char const*, char const*)+0x2c>
     b26:	mov	r2, r6
     b28:	mov	r1, r5
     b2a:	mov	r0, sp
     b2c:	bl	a21c <ExFatFile::rename(ExFatFile*, char const*)>
     b30:	add	sp, #56	; 0x38
     b32:	pop	{r4, r5, r6, pc}

00000b34 <SDClass::rmdir(char const*)>:
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
     b34:	push	{r4, r5, lr}
     b36:	ldr.w	r4, [r0, #1156]	; 0x484
     b3a:	sub	sp, #60	; 0x3c
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
           m_xVol ? m_xVol->rmdir(path) : false;
     b3c:	cbz	r4, b68 <SDClass::rmdir(char const*)+0x34>
     b3e:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     b40:	mov	r2, r1
     b42:	mov	r3, r5
     b44:	mov	r1, r4
     b46:	mov	r0, sp
     b48:	strb.w	r5, [sp]
     b4c:	strb.w	r5, [sp, #1]
     b50:	strb.w	r5, [sp, #2]
     b54:	bl	aacc <FatFile::open(FatVolume*, char const*, int)>
     b58:	cbnz	r0, b5e <SDClass::rmdir(char const*)+0x2a>
		return sdfs.rmdir(filepath);
	}
     b5a:	add	sp, #60	; 0x3c
     b5c:	pop	{r4, r5, pc}
     b5e:	mov	r0, sp
     b60:	bl	aec0 <FatFile::rmdir()>
     b64:	add	sp, #60	; 0x3c
     b66:	pop	{r4, r5, pc}
     b68:	ldr.w	r0, [r0, #1160]	; 0x488
     b6c:	cmp	r0, #0
     b6e:	beq.n	b5a <SDClass::rmdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     b70:	mov	r2, r1
     b72:	mov	r3, r4
     b74:	mov	r1, r0
     b76:	mov	r0, sp
     b78:	strb.w	r4, [sp, #49]	; 0x31
     b7c:	strb.w	r4, [sp, #50]	; 0x32
     b80:	strb.w	r4, [sp, #51]	; 0x33
     b84:	bl	9714 <ExFatFile::open(ExFatVolume*, char const*, int)>
     b88:	cmp	r0, #0
     b8a:	beq.n	b5a <SDClass::rmdir(char const*)+0x26>
     b8c:	mov	r0, sp
     b8e:	bl	9df8 <ExFatFile::rmdir()>
     b92:	add	sp, #60	; 0x3c
     b94:	pop	{r4, r5, pc}
     b96:	nop

00000b98 <SDClass::usedSize()>:
	uint64_t usedSize() {
     b98:	push	{r3, r4, r5, lr}
     b9a:	mov	r5, r0
     b9c:	ldr.w	r0, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     ba0:	cbz	r0, bd4 <SDClass::usedSize()+0x3c>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
     ba2:	ldr	r4, [r0, #28]
     ba4:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
     ba6:	bl	b55c <FatPartition::freeClusterCount()>
     baa:	ldr.w	r3, [r5, #1156]	; 0x484
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
     bae:	subs	r4, r4, r0
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     bb0:	cbz	r3, bc4 <SDClass::usedSize()+0x2c>
     bb2:	ldrb	r0, [r3, #6]
     bb4:	mov.w	r3, #512	; 0x200
     bb8:	lsl.w	r0, r3, r0
     bbc:	uxth	r0, r0
     bbe:	umull	r0, r1, r0, r4
     bc2:	pop	{r3, r4, r5, pc}
     bc4:	ldr.w	r3, [r5, #1160]	; 0x488
     bc8:	cbz	r3, be4 <SDClass::usedSize()+0x4c>
     bca:	ldr.w	r0, [r3, #1084]	; 0x43c
     bce:	umull	r0, r1, r0, r4
     bd2:	pop	{r3, r4, r5, pc}
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     bd4:	ldr.w	r0, [r5, #1160]	; 0x488
     bd8:	cbz	r0, be4 <SDClass::usedSize()+0x4c>
     bda:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
     bde:	bl	9a9c <ExFatPartition::freeClusterCount()>
     be2:	b.n	baa <SDClass::usedSize()+0x12>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     be4:	movs	r0, #0
     be6:	movs	r1, #0
		  * (uint64_t)sdfs.bytesPerCluster();
	}
     be8:	pop	{r3, r4, r5, pc}
     bea:	nop

00000bec <SDFile::position()>:
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
		return false;
	}
	virtual uint64_t position() {
     bec:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     bee:	cbz	r3, bf6 <SDFile::position()+0xa>
     bf0:	ldr	r0, [r3, #20]
     bf2:	movs	r1, #0
     bf4:	bx	lr
     bf6:	ldr	r3, [r0, #96]	; 0x60
     bf8:	cbz	r3, c00 <SDFile::position()+0x14>
     bfa:	ldmia.w	r3, {r0, r1}
     bfe:	bx	lr
     c00:	mov	r0, r3
     c02:	mov	r1, r3
		return sdfatfile.curPosition();
	}
     c04:	bx	lr
     c06:	nop

00000c08 <SDFile::size()>:
	virtual uint64_t size() {
     c08:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     c0a:	cbz	r3, c12 <SDFile::size()+0xa>
     c0c:	ldr	r0, [r3, #28]
     c0e:	movs	r1, #0
     c10:	bx	lr
     c12:	ldr	r3, [r0, #96]	; 0x60
     c14:	cbz	r3, c1c <SDFile::size()+0x14>
     c16:	ldr	r0, [r3, #16]
     c18:	ldr	r1, [r3, #20]
     c1a:	bx	lr
     c1c:	mov	r0, r3
     c1e:	mov	r1, r3
		return sdfatfile.size();
	}
     c20:	bx	lr
     c22:	nop

00000c24 <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     c24:	ldr	r3, [r0, #92]	; 0x5c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     c26:	cbz	r3, c2e <SDFile::read(void*, unsigned int)+0xa>
     c28:	mov	r0, r3
     c2a:	b.w	aae8 <FatFile::read(void*, unsigned int)>
     c2e:	ldr	r0, [r0, #96]	; 0x60
     c30:	cbz	r0, c36 <SDFile::read(void*, unsigned int)+0x12>
     c32:	b.w	8f60 <ExFatFile::read(void*, unsigned int)>
		return sdfatfile.read(buf, nbyte);
	}
     c36:	mov.w	r0, #4294967295
     c3a:	bx	lr

00000c3c <SDFile::peek()>:
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     c3c:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     c3e:	cbz	r3, c46 <SDFile::peek()+0xa>
     c40:	mov	r0, r3
     c42:	b.w	ac80 <FatFile::peek()>
     c46:	ldr	r0, [r0, #96]	; 0x60
     c48:	cbz	r0, c4e <SDFile::peek()+0x12>
     c4a:	b.w	9108 <ExFatFile::peek()>
		return sdfatfile.peek();
	}
     c4e:	mov.w	r0, #4294967295
     c52:	bx	lr

00000c54 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
     c54:	ldr.w	r2, [r0, #1156]	; 0x484
     c58:	cbz	r2, c6e <SDClass::totalSize()+0x1a>
     c5a:	ldrb	r1, [r2, #6]
     c5c:	ldr	r0, [r2, #28]
     c5e:	mov.w	r3, #512	; 0x200
     c62:	lsls	r3, r1
     c64:	uxth	r3, r3
     c66:	subs	r0, #1
     c68:	umull	r0, r1, r3, r0
     c6c:	bx	lr
     c6e:	ldr.w	r2, [r0, #1160]	; 0x488
     c72:	cbz	r2, c82 <SDClass::totalSize()+0x2e>
     c74:	ldr.w	r3, [r2, #1072]	; 0x430
     c78:	ldr.w	r0, [r2, #1084]	; 0x43c
     c7c:	umull	r0, r1, r3, r0
     c80:	bx	lr
     c82:	movs	r0, #0
     c84:	movs	r1, #0
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
	}
     c86:	bx	lr

00000c88 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     c88:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     c8a:	cbz	r3, c9a <SDFile::isDirectory()+0x12>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     c8c:	ldrb	r3, [r3, #0]
     c8e:	tst.w	r3, #112	; 0x70
     c92:	ite	ne
     c94:	movne	r0, #1
     c96:	moveq	r0, #0
     c98:	bx	lr
     c9a:	ldr	r0, [r0, #96]	; 0x60
     c9c:	cbz	r0, cac <SDFile::isDirectory()+0x24>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     c9e:	ldrb.w	r3, [r0, #49]	; 0x31
     ca2:	tst.w	r3, #80	; 0x50
     ca6:	ite	ne
     ca8:	movne	r0, #1
     caa:	moveq	r0, #0
		return sdfatfile.isDirectory();
	}
     cac:	bx	lr
     cae:	nop

00000cb0 <SDClass::open(char const*, unsigned char)>:
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     cb0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     cb4:	cmp	r3, #1
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     cb6:	sub	sp, #80	; 0x50
     cb8:	mov	r5, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     cba:	beq.n	d40 <SDClass::open(char const*, unsigned char)+0x90>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     cbc:	cmp	r3, #2
		SDFAT_FILE file = sdfs.open(filepath, flags);
     cbe:	add.w	r1, r1, #4
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     cc2:	movw	r3, #514	; 0x202
		SDFAT_FILE file = sdfs.open(filepath, flags);
     cc6:	mov	r0, sp
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     cc8:	it	ne
     cca:	movne	r3, #0
		SDFAT_FILE file = sdfs.open(filepath, flags);
     ccc:	bl	c308 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     cd0:	ldr	r3, [sp, #72]	; 0x48
     cd2:	cmp	r3, #0
     cd4:	beq.n	d52 <SDClass::open(char const*, unsigned char)+0xa2>
		if (file) return File(new SDFile(file));
     cd6:	movs	r0, #104	; 0x68
     cd8:	bl	e95c <operator new(unsigned int)>
     cdc:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     cde:	ldrb.w	r6, [sp, #4]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     ce2:	ldr	r0, [pc, #136]	; (d6c <SDClass::open(char const*, unsigned char)+0xbc>)
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     ce4:	ldr	r1, [pc, #136]	; (d70 <SDClass::open(char const*, unsigned char)+0xc0>)
     ce6:	ldr	r2, [sp, #8]
     ce8:	ldrb.w	r3, [sp, #12]
     cec:	str	r0, [r4, #0]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     cee:	add	r7, sp, #16
     cf0:	strb	r6, [r4, #24]
     cf2:	str	r1, [r4, #20]
{
  public:
	constexpr Print() : write_error(0) {}
     cf4:	movs	r6, #0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     cf6:	mov.w	r8, #1000	; 0x3e8
     cfa:	mov	r1, r7
     cfc:	add.w	r0, r4, #36	; 0x24
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     d00:	str	r2, [r4, #28]
     d02:	strb.w	r3, [r4, #32]
     d06:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     d08:	strb	r6, [r4, #12]
     d0a:	str	r6, [r4, #16]
     d0c:	str.w	r8, [r4, #8]
     d10:	bl	c0c0 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     d14:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     d16:	ldr	r1, [pc, #92]	; (d74 <SDClass::open(char const*, unsigned char)+0xc4>)
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     d18:	ldr	r2, [pc, #92]	; (d78 <SDClass::open(char const*, unsigned char)+0xc8>)
     d1a:	str	r6, [r4, #100]	; 0x64
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     d1c:	adds	r3, #1
     d1e:	strb	r6, [r5, #4]
     d20:	str.w	r8, [r5, #8]
     d24:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     d26:	str	r4, [r5, #16]
     d28:	str	r1, [r4, #20]
		if (f) f->refcount++;
     d2a:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     d2c:	str	r2, [r5, #0]
     d2e:	ldr	r3, [pc, #76]	; (d7c <SDClass::open(char const*, unsigned char)+0xcc>)
     d30:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     d32:	mov	r0, r7
     d34:	bl	c138 <FsBaseFile::close()>
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
     d38:	mov	r0, r5
     d3a:	add	sp, #80	; 0x50
     d3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     d40:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     d44:	adds	r1, #4
     d46:	mov	r0, sp
     d48:	bl	c308 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     d4c:	ldr	r3, [sp, #72]	; 0x48
     d4e:	cmp	r3, #0
     d50:	bne.n	cd6 <SDClass::open(char const*, unsigned char)+0x26>
     d52:	ldr	r3, [sp, #76]	; 0x4c
     d54:	cmp	r3, #0
     d56:	bne.n	cd6 <SDClass::open(char const*, unsigned char)+0x26>
     d58:	mov.w	r1, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     d5c:	ldr	r2, [pc, #24]	; (d78 <SDClass::open(char const*, unsigned char)+0xc8>)
     d5e:	strb	r3, [r5, #4]
     d60:	strb	r3, [r5, #12]
     d62:	str	r3, [r5, #16]
     d64:	str	r1, [r5, #8]
     d66:	str	r2, [r5, #0]
     d68:	add	r7, sp, #16
     d6a:	b.n	d2e <SDClass::open(char const*, unsigned char)+0x7e>
     d6c:	.word	0x0001424c
     d70:	.word	0x00014180
     d74:	.word	0x000141c8
     d78:	.word	0x000141ec
     d7c:	.word	0x000141a4

00000d80 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     d80:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     d82:	cbz	r3, d8a <SDFile::flush()+0xa>
     d84:	mov	r0, r3
     d86:	b.w	b124 <FatFile::sync()>
     d8a:	ldr	r0, [r0, #96]	; 0x60
     d8c:	cbz	r0, d92 <SDFile::flush()+0x12>
     d8e:	b.w	9f94 <ExFatFile::sync()>
     d92:	bx	lr

00000d94 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     d94:	ldr	r3, [r0, #72]	; 0x48
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     d96:	cbz	r3, d9e <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0xa>
     d98:	mov	r0, r3
     d9a:	b.w	b1a8 <FatFile::write(void const*, unsigned int)>
     d9e:	ldr	r0, [r0, #76]	; 0x4c
     da0:	cbz	r0, da6 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0x12>
     da2:	b.w	a3ac <ExFatFile::write(void const*, unsigned int)>
    return BaseFile::write(buffer, size);
  }
     da6:	bx	lr

00000da8 <SDFile::write(void const*, unsigned int)>:
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
     da8:	ldr	r3, [r0, #92]	; 0x5c
     daa:	cbz	r3, db2 <SDFile::write(void const*, unsigned int)+0xa>
     dac:	mov	r0, r3
     dae:	b.w	b1a8 <FatFile::write(void const*, unsigned int)>
     db2:	ldr	r0, [r0, #96]	; 0x60
     db4:	cbz	r0, dba <SDFile::write(void const*, unsigned int)+0x12>
     db6:	b.w	a3ac <ExFatFile::write(void const*, unsigned int)>
		return sdfatfile.write(buf, size);
	}
     dba:	bx	lr

00000dbc <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     dbc:	ldr	r2, [r0, #72]	; 0x48
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     dbe:	cbz	r2, dda <StreamFile<FsBaseFile, unsigned long long>::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     dc0:	ldrb	r3, [r2, #0]
     dc2:	and.w	r3, r3, #8
     dc6:	and.w	r0, r3, #255	; 0xff
     dca:	cbz	r3, e0e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     dcc:	ldr	r3, [r2, #28]
     dce:	ldr	r0, [r2, #20]
     dd0:	subs	r0, r3, r0
     dd2:	it	mi
     dd4:	mvnmi.w	r0, #2147483648	; 0x80000000
     dd8:	bx	lr
     dda:	ldr	r1, [r0, #76]	; 0x4c
     ddc:	cbz	r1, e10 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     dde:	ldrb.w	r3, [r1, #49]	; 0x31
     de2:	and.w	r3, r3, #8
     de6:	and.w	r0, r3, #255	; 0xff
     dea:	cbz	r3, e0e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     dec:	ldrd	r2, r3, [r1, #16]
     df0:	ldrd	r0, r1, [r1]
     df4:	subs	r0, r2, r0
     df6:	push	{r4, r5}
     df8:	sbc.w	r1, r3, r1
     dfc:	movs	r5, #0
     dfe:	mvn.w	r4, #2147483648	; 0x80000000
     e02:	cmp	r5, r1
     e04:	it	eq
     e06:	cmpeq	r4, r0
     e08:	bcs.n	e0c <StreamFile<FsBaseFile, unsigned long long>::available()+0x50>
     e0a:	mov	r0, r4
    return BaseFile::available();
  }
     e0c:	pop	{r4, r5}
     e0e:	bx	lr
     e10:	mov	r0, r1
     e12:	bx	lr

00000e14 <SDFile::seek(unsigned long long, int)>:
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     e14:	push	{r4, r6, r7}
     e16:	ldr	r4, [sp, #12]
     e18:	mov	r6, r2
     e1a:	mov	r7, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     e1c:	cbz	r4, e2c <SDFile::seek(unsigned long long, int)+0x18>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     e1e:	cmp	r4, #1
     e20:	beq.n	e60 <SDFile::seek(unsigned long long, int)+0x4c>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     e22:	cmp	r4, #2
     e24:	beq.n	e42 <SDFile::seek(unsigned long long, int)+0x2e>
		return false;
	}
     e26:	movs	r0, #0
     e28:	pop	{r4, r6, r7}
     e2a:	bx	lr
     e2c:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e2e:	cbz	r4, e68 <SDFile::seek(unsigned long long, int)+0x54>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     e30:	cmp	r3, #1
     e32:	it	eq
     e34:	cmpeq	r2, #0
     e36:	bcs.n	e26 <SDFile::seek(unsigned long long, int)+0x12>
     e38:	mov	r0, r4
     e3a:	mov	r1, r2
     e3c:	pop	{r4, r6, r7}
     e3e:	b.w	af1c <FatFile::seekSet(unsigned long)>
     e42:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     e44:	cbz	r3, e74 <SDFile::seek(unsigned long long, int)+0x60>
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     e46:	ldr	r2, [r3, #28]
     e48:	adds	r6, r6, r2
     e4a:	adc.w	r7, r7, #0
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     e4e:	cmp	r7, #1
     e50:	it	eq
     e52:	cmpeq	r6, #0
     e54:	bcs.n	e26 <SDFile::seek(unsigned long long, int)+0x12>
     e56:	mov	r1, r6
     e58:	mov	r0, r3
     e5a:	pop	{r4, r6, r7}
     e5c:	b.w	af1c <FatFile::seekSet(unsigned long)>
     e60:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     e62:	cbz	r3, e88 <SDFile::seek(unsigned long long, int)+0x74>
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int64_t offset) {
    return seekSet(curPosition() + offset);
     e64:	ldr	r2, [r3, #20]
     e66:	b.n	e48 <SDFile::seek(unsigned long long, int)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e68:	ldr	r0, [r0, #96]	; 0x60
     e6a:	cmp	r0, #0
     e6c:	beq.n	e26 <SDFile::seek(unsigned long long, int)+0x12>
     e6e:	pop	{r4, r6, r7}
     e70:	b.w	9138 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     e74:	ldr	r0, [r0, #96]	; 0x60
     e76:	cmp	r0, #0
     e78:	beq.n	e26 <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e7a:	ldrd	r2, r3, [r0, #16]
     e7e:	adds	r2, r2, r6
     e80:	adcs	r3, r7
     e82:	pop	{r4, r6, r7}
     e84:	b.w	9138 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     e88:	ldr	r0, [r0, #96]	; 0x60
     e8a:	cmp	r0, #0
     e8c:	beq.n	e26 <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e8e:	ldrd	r2, r3, [r0]
     e92:	adds	r2, r2, r6
     e94:	adcs	r3, r7
     e96:	b.n	e6e <SDFile::seek(unsigned long long, int)+0x5a>

00000e98 <File::~File()>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     e98:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     e9a:	ldr	r3, [pc, #32]	; (ebc <File::~File()+0x24>)
     e9c:	push	{r4, lr}
     e9e:	mov	r4, r0
     ea0:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ea2:	cbz	r2, eb6 <File::~File()+0x1e>
     ea4:	ldr	r3, [r2, #16]
     ea6:	subs	r3, #1
     ea8:	str	r3, [r2, #16]
     eaa:	cbnz	r3, eb6 <File::~File()+0x1e>
     eac:	ldr	r0, [r0, #16]
     eae:	cbz	r0, eb6 <File::~File()+0x1e>
     eb0:	ldr	r3, [r0, #0]
     eb2:	ldr	r3, [r3, #32]
     eb4:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     eb6:	mov	r0, r4
     eb8:	pop	{r4, pc}
     eba:	nop
     ebc:	.word	0x000141ec

00000ec0 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     ec0:	push	{r3, r4, r5, lr}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     ec2:	ldr	r3, [r0, #92]	; 0x5c
     ec4:	ldr	r2, [pc, #80]	; (f18 <SDFile::~SDFile()+0x58>)
     ec6:	str	r2, [r0, #0]
     ec8:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
     eca:	add.w	r5, r0, #36	; 0x24
     ece:	cbz	r3, f0e <SDFile::~SDFile()+0x4e>
     ed0:	mov	r0, r5
     ed2:	bl	c138 <FsBaseFile::close()>
		if (filename) free(filename);
     ed6:	ldr	r0, [r4, #100]	; 0x64
     ed8:	cbz	r0, ede <SDFile::~SDFile()+0x1e>
     eda:	bl	ff64 <free>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     ede:	ldr	r3, [pc, #60]	; (f1c <SDFile::~SDFile()+0x5c>)
     ee0:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     ee2:	mov	r0, r5
     ee4:	bl	c138 <FsBaseFile::close()>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ee8:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     eea:	ldr	r3, [pc, #52]	; (f20 <SDFile::~SDFile()+0x60>)
     eec:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     eee:	cbz	r2, f02 <SDFile::~SDFile()+0x42>
     ef0:	ldr	r3, [r2, #16]
     ef2:	subs	r3, #1
     ef4:	str	r3, [r2, #16]
     ef6:	cbnz	r3, f02 <SDFile::~SDFile()+0x42>
     ef8:	ldr	r0, [r4, #16]
     efa:	cbz	r0, f02 <SDFile::~SDFile()+0x42>
     efc:	ldr	r3, [r0, #0]
     efe:	ldr	r3, [r3, #32]
     f00:	blx	r3
	}
     f02:	mov	r0, r4
     f04:	movs	r1, #104	; 0x68
     f06:	bl	e960 <operator delete(void*, unsigned int)>
     f0a:	mov	r0, r4
     f0c:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     f0e:	ldr	r3, [r0, #96]	; 0x60
     f10:	cmp	r3, #0
     f12:	bne.n	ed0 <SDFile::~SDFile()+0x10>
     f14:	b.n	ed6 <SDFile::~SDFile()+0x16>
     f16:	nop
     f18:	.word	0x0001424c
     f1c:	.word	0x000141a4
     f20:	.word	0x000141ec

00000f24 <File::~File()>:
     f24:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f26:	ldr	r3, [pc, #40]	; (f50 <File::~File()+0x2c>)
     f28:	push	{r4, lr}
     f2a:	mov	r4, r0
     f2c:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f2e:	cbz	r2, f42 <File::~File()+0x1e>
     f30:	ldr	r3, [r2, #16]
     f32:	subs	r3, #1
     f34:	str	r3, [r2, #16]
     f36:	cbnz	r3, f42 <File::~File()+0x1e>
     f38:	ldr	r0, [r0, #16]
     f3a:	cbz	r0, f42 <File::~File()+0x1e>
     f3c:	ldr	r3, [r0, #0]
     f3e:	ldr	r3, [r3, #32]
     f40:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     f42:	mov	r0, r4
     f44:	movs	r1, #20
     f46:	bl	e960 <operator delete(void*, unsigned int)>
     f4a:	mov	r0, r4
     f4c:	pop	{r4, pc}
     f4e:	nop
     f50:	.word	0x000141ec

00000f54 <MTPStorage_SD::~MTPStorage_SD()>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f54:	ldr.w	r2, [r0, #224]	; 0xe0

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
     f58:	push	{r3, r4, r5, lr}
     f5a:	ldr	r3, [pc, #104]	; (fc4 <MTPStorage_SD::~MTPStorage_SD()+0x70>)
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f5c:	ldr	r5, [pc, #104]	; (fc8 <MTPStorage_SD::~MTPStorage_SD()+0x74>)
     f5e:	str	r3, [r0, #0]
     f60:	mov	r4, r0
     f62:	str.w	r5, [r0, #208]	; 0xd0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f66:	cbz	r2, f70 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     f68:	ldr	r3, [r2, #16]
     f6a:	subs	r3, #1
     f6c:	str	r3, [r2, #16]
     f6e:	cbz	r3, fa4 <MTPStorage_SD::~MTPStorage_SD()+0x50>
     f70:	ldr.w	r2, [r4, #204]	; 0xcc
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f74:	str.w	r5, [r4, #188]	; 0xbc
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f78:	cbz	r2, f82 <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     f7a:	ldr	r3, [r2, #16]
     f7c:	subs	r3, #1
     f7e:	str	r3, [r2, #16]
     f80:	cbz	r3, fb4 <MTPStorage_SD::~MTPStorage_SD()+0x60>
     f82:	ldr.w	r2, [r4, #184]	; 0xb8
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f86:	str.w	r5, [r4, #168]	; 0xa8
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f8a:	cbz	r2, fa0 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     f8c:	ldr	r3, [r2, #16]
     f8e:	subs	r3, #1
     f90:	str	r3, [r2, #16]
     f92:	cbnz	r3, fa0 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     f94:	ldr.w	r0, [r4, #184]	; 0xb8
     f98:	cbz	r0, fa0 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     f9a:	ldr	r3, [r0, #0]
     f9c:	ldr	r3, [r3, #32]
     f9e:	blx	r3
     fa0:	mov	r0, r4
     fa2:	pop	{r3, r4, r5, pc}
     fa4:	ldr.w	r0, [r0, #224]	; 0xe0
     fa8:	cmp	r0, #0
     faa:	beq.n	f70 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     fac:	ldr	r3, [r0, #0]
     fae:	ldr	r3, [r3, #32]
     fb0:	blx	r3
     fb2:	b.n	f70 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     fb4:	ldr.w	r0, [r4, #204]	; 0xcc
     fb8:	cmp	r0, #0
     fba:	beq.n	f82 <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     fbc:	ldr	r3, [r0, #0]
     fbe:	ldr	r3, [r3, #32]
     fc0:	blx	r3
     fc2:	b.n	f82 <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     fc4:	.word	0x00014454
     fc8:	.word	0x000141ec

00000fcc <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     fcc:	push	{r3, r4, r5, lr}
     fce:	ldr	r3, [r0, #92]	; 0x5c
     fd0:	ldr	r2, [pc, #72]	; (101c <SDFile::~SDFile()+0x50>)
     fd2:	str	r2, [r0, #0]
     fd4:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
     fd6:	add.w	r5, r0, #36	; 0x24
     fda:	cbz	r3, 1012 <SDFile::~SDFile()+0x46>
     fdc:	mov	r0, r5
     fde:	bl	c138 <FsBaseFile::close()>
		if (filename) free(filename);
     fe2:	ldr	r0, [r4, #100]	; 0x64
     fe4:	cbz	r0, fea <SDFile::~SDFile()+0x1e>
     fe6:	bl	ff64 <free>
     fea:	ldr	r3, [pc, #52]	; (1020 <SDFile::~SDFile()+0x54>)
     fec:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     fee:	mov	r0, r5
     ff0:	bl	c138 <FsBaseFile::close()>
     ff4:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     ff6:	ldr	r3, [pc, #44]	; (1024 <SDFile::~SDFile()+0x58>)
     ff8:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ffa:	cbz	r2, 100e <SDFile::~SDFile()+0x42>
     ffc:	ldr	r3, [r2, #16]
     ffe:	subs	r3, #1
    1000:	str	r3, [r2, #16]
    1002:	cbnz	r3, 100e <SDFile::~SDFile()+0x42>
    1004:	ldr	r0, [r4, #16]
    1006:	cbz	r0, 100e <SDFile::~SDFile()+0x42>
    1008:	ldr	r3, [r0, #0]
    100a:	ldr	r3, [r3, #32]
    100c:	blx	r3
	}
    100e:	mov	r0, r4
    1010:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    1012:	ldr	r3, [r0, #96]	; 0x60
    1014:	cmp	r3, #0
    1016:	bne.n	fdc <SDFile::~SDFile()+0x10>
    1018:	b.n	fe2 <SDFile::~SDFile()+0x16>
    101a:	nop
    101c:	.word	0x0001424c
    1020:	.word	0x000141a4
    1024:	.word	0x000141ec

00001028 <storage_configure()>:
MTPStorage_SD storage;
MTPD       mtpd(&storage);


void storage_configure()
{
    1028:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    102c:	movs	r1, #7
MTPStorage_SD storage;
MTPD       mtpd(&storage);


void storage_configure()
{
    102e:	sub	sp, #52	; 0x34
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1030:	ldr	r0, [pc, #372]	; (11a8 <storage_configure()+0x180>)
    1032:	ldr	r6, [pc, #376]	; (11ac <storage_configure()+0x184>)
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1034:	ldr	r5, [pc, #376]	; (11b0 <storage_configure()+0x188>)
    1036:	bl	7af8 <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    103a:	movs	r1, #12
    103c:	ldr	r0, [pc, #360]	; (11a8 <storage_configure()+0x180>)
    103e:	bl	7b88 <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
    1042:	movs	r1, #14
    1044:	ldr	r0, [pc, #352]	; (11a8 <storage_configure()+0x180>)
    1046:	bl	7c10 <SPIClass::setSCK(unsigned char)>
          }
        }
        else if(cs[ii]<BUILTIN_SDCARD)
      #endif
      {
        pinMode(cs[ii],OUTPUT); digitalWriteFast(cs[ii],HIGH);
    104a:	movs	r1, #1
    104c:	movs	r0, #10
    104e:	bl	d7b8 <pinMode>
			} else if (pin == 8) {
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
			} else if (pin == 9) {
				CORE_PIN9_PORTSET = CORE_PIN9_BITMASK;
			} else if (pin == 10) {
				CORE_PIN10_PORTSET = CORE_PIN10_BITMASK;
    1052:	ldr	r3, [pc, #352]	; (11b4 <storage_configure()+0x18c>)
    1054:	movs	r4, #0
    1056:	movs	r2, #16
    1058:	movs	r7, #10
    105a:	str	r2, [r3, #0]
    105c:	strb.w	r4, [sp, #13]
    1060:	str	r4, [sp, #20]
    1062:	add	r3, sp, #12
    1064:	strb.w	r7, [sp, #12]
    1068:	str	r6, [sp, #16]
    106a:	ldmia.w	r3, {r0, r1, r2}
    106e:	add	r3, sp, #24
    1070:	stmia.w	r3, {r0, r1, r2}
    1074:	strb.w	r4, [sp, #25]
    1078:	str	r4, [sp, #32]
    107a:	strb.w	r7, [sp, #24]
    107e:	str	r6, [sp, #28]
    1080:	ldmia.w	r3, {r0, r1, r2}
    1084:	add	r3, sp, #36	; 0x24
    1086:	stmia.w	r3, {r0, r1, r2}
    108a:	addw	r4, r5, #1172	; 0x494
    108e:	ldmia	r3, {r1, r2, r3}
    1090:	mov	r0, r4
    1092:	bl	c59c <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    1096:	ldrb.w	r3, [r5, #1187]	; 0x4a3
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    109a:	str.w	r4, [r5, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    109e:	cbz	r3, 10be <storage_configure()+0x96>
        if(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED))) 
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
    10a0:	ldr	r3, [pc, #276]	; (11b8 <storage_configure()+0x190>)
    10a2:	ldr	r1, [pc, #280]	; (11bc <storage_configure()+0x194>)
    10a4:	ldr	r3, [r3, #0]
    10a6:	str	r3, [sp, #0]
    10a8:	movs	r2, #0
    10aa:	movs	r3, #10
    10ac:	ldr	r0, [pc, #272]	; (11c0 <storage_configure()+0x198>)
    10ae:	bl	e7ec <Print::printf(char const*, ...)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    10b2:	ldr	r0, [pc, #268]	; (11c0 <storage_configure()+0x198>)
      uint64_t totalSize = ramfs[ii].totalSize();
      uint64_t usedSize  = ramfs[ii].usedSize();
      Serial.printf("Storage %d %s ",ii,lfs_str[ii]); Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    }
    #endif
}
    10b4:	add	sp, #52	; 0x34
    10b6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    10ba:	b.w	e7bc <Print::println()>
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    return cardBegin(spiConfig) && Vol::begin(m_card);
    10be:	mov	r1, r4
    10c0:	adds	r0, r5, #4
    10c2:	bl	c240 <FsVolume::begin(SdSpiCard*)>
    10c6:	cmp	r0, #0
    10c8:	beq.n	10a0 <storage_configure()+0x78>
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    10ca:	ldr	r1, [pc, #248]	; (11c4 <storage_configure()+0x19c>)
        if(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED))) 
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
        }
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
    10cc:	ldr.w	r8, [pc, #232]	; 11b8 <storage_configure()+0x190>
    10d0:	ldr	r3, [r1, #4]
    10d2:	ldr.w	r2, [r8]
    10d6:	cmp	r3, #19
    10d8:	bgt.n	10e6 <storage_configure()+0xbe>
        sd_name[fsCount] = name;
    10da:	add.w	r4, r1, r3, lsl #2
        sdx[fsCount++] = &fs;
    10de:	adds	r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
    10e0:	str	r2, [r4, #8]
        sdx[fsCount++] = &fs;
    10e2:	str	r5, [r4, #88]	; 0x58
    10e4:	str	r3, [r1, #4]
    10e6:	ldr.w	r0, [r5, #1156]	; 0x484
    10ea:	ldr	r3, [pc, #196]	; (11b0 <storage_configure()+0x188>)
    10ec:	cmp	r0, #0
    10ee:	beq.n	117e <storage_configure()+0x156>
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    10f0:	ldrb	r6, [r0, #6]
    10f2:	ldr	r4, [r0, #28]
    10f4:	mov.w	r3, #512	; 0x200
    10f8:	lsl.w	r6, r3, r6
    10fc:	uxth	r6, r6
    10fe:	subs	r4, #1
    1100:	umull	r6, r7, r6, r4
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    1104:	bl	b55c <FatPartition::freeClusterCount()>
    1108:	ldr.w	r3, [r5, #1156]	; 0x484
    110c:	ldr	r2, [pc, #160]	; (11b0 <storage_configure()+0x188>)
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    110e:	subs	r4, r4, r0
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1110:	cbz	r3, 116a <storage_configure()+0x142>
    1112:	ldrb	r0, [r3, #6]
    1114:	ldr.w	r2, [r8]
    1118:	mov.w	r3, #512	; 0x200
    111c:	lsl.w	r0, r3, r0
    1120:	uxth	r0, r0
    1122:	umull	r4, r5, r0, r4
          uint64_t totalSize = sdx[ii].totalSize();
          uint64_t usedSize  = sdx[ii].usedSize();
          Serial.printf("SD Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1126:	str	r2, [sp, #0]
    1128:	movs	r2, #0
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    112a:	mov	r9, r2
    112c:	ldr	r1, [pc, #152]	; (11c8 <storage_configure()+0x1a0>)
    112e:	ldr	r0, [pc, #144]	; (11c0 <storage_configure()+0x198>)
    1130:	mov.w	r8, #10
    1134:	movs	r3, #10
    1136:	bl	e7ec <Print::printf(char const*, ...)>
    113a:	mov	r2, r6
    113c:	mov	r3, r7
    113e:	stmia.w	sp, {r8, r9}
    1142:	ldr	r0, [pc, #124]	; (11c0 <storage_configure()+0x198>)
    1144:	bl	e808 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1148:	movs	r1, #1
    114a:	ldr	r0, [pc, #128]	; (11cc <storage_configure()+0x1a4>)
    114c:	bl	cd84 <usb_serial_write>
    1150:	stmia.w	sp, {r8, r9}
    1154:	mov	r2, r4
    1156:	mov	r3, r5
    1158:	ldr	r0, [pc, #100]	; (11c0 <storage_configure()+0x198>)
    115a:	bl	e808 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    115e:	ldr	r0, [pc, #96]	; (11c0 <storage_configure()+0x198>)
      uint64_t totalSize = ramfs[ii].totalSize();
      uint64_t usedSize  = ramfs[ii].usedSize();
      Serial.printf("Storage %d %s ",ii,lfs_str[ii]); Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    }
    #endif
}
    1160:	add	sp, #52	; 0x34
    1162:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1166:	b.w	e7bc <Print::println()>
    116a:	ldr.w	r3, [r2, #1160]	; 0x488
    116e:	ldr.w	r2, [r8]
    1172:	cbz	r3, 11a0 <storage_configure()+0x178>
    1174:	ldr.w	r0, [r3, #1084]	; 0x43c
    1178:	umull	r4, r5, r4, r0
    117c:	b.n	1126 <storage_configure()+0xfe>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    117e:	ldr.w	r0, [r3, #1160]	; 0x488
    1182:	cbz	r0, 1196 <storage_configure()+0x16e>
    1184:	ldr.w	r4, [r0, #1072]	; 0x430
    1188:	ldr.w	r6, [r0, #1084]	; 0x43c
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    118c:	umull	r6, r7, r4, r6
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1190:	bl	9a9c <ExFatPartition::freeClusterCount()>
    1194:	b.n	1108 <storage_configure()+0xe0>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    1196:	movs	r4, #0
    1198:	movs	r5, #0
    119a:	mov	r6, r4
    119c:	mov	r7, r5
    119e:	b.n	1126 <storage_configure()+0xfe>
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    11a0:	movs	r4, #0
    11a2:	movs	r5, #0
    11a4:	b.n	1126 <storage_configure()+0xfe>
    11a6:	nop
    11a8:	.word	0x1fff8a60
    11ac:	.word	0x01f78a40
    11b0:	.word	0x1fffc648
    11b4:	.word	0x400ff084
    11b8:	.word	0x1fff8a44
    11bc:	.word	0x0001432c
    11c0:	.word	0x1fff8d50
    11c4:	.word	0x1fffbd40
    11c8:	.word	0x00014354
    11cc:	.word	0x00014580

000011d0 <pushData(unsigned long*)>:
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    11d0:	push	{r4, r5, r6, lr}
    11d2:	ldr	r6, [pc, #76]	; (1220 <pushData(unsigned long*)+0x50>)
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    11d4:	ldr	r3, [pc, #76]	; (1224 <pushData(unsigned long*)+0x54>)
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    11d6:	ldrh	r4, [r6, #0]
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    11d8:	ldrh	r5, [r3, #0]
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    11da:	adds	r4, #1
    11dc:	uxth	r4, r4
  if(f >= MAXBUF) f=0;
    11de:	cmp	r4, #24
    11e0:	it	cs
    11e2:	movcs	r4, #0
  if(f == rear_) return 0;
    11e4:	cmp	r4, r5
    11e6:	beq.n	121a <pushData(unsigned long*)+0x4a>
    11e8:	mov	r1, r0

  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
    11ea:	ldr	r0, [pc, #60]	; (1228 <pushData(unsigned long*)+0x58>)
    11ec:	mov.w	r2, #1024	; 0x400
    11f0:	add.w	r0, r0, r4, lsl #10
    11f4:	bl	cb10 <memcpy>
  front_ = f;
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    11f8:	cmp	r4, r5
  if(count>maxCount) maxCount=count;
    11fa:	ldr	r3, [pc, #48]	; (122c <pushData(unsigned long*)+0x5c>)
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;

  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
  front_ = f;
    11fc:	strh	r4, [r6, #0]
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    11fe:	itet	cc
    1200:	rsbcc	r5, r5, #24
    1204:	subcs	r4, r4, r5
    1206:	addcc	r4, r4, r5
  if(count>maxCount) maxCount=count;
    1208:	ldrh	r2, [r3, #0]
  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
  front_ = f;
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    120a:	uxth	r4, r4
  if(count>maxCount) maxCount=count;
    120c:	cmp	r2, r4
    120e:	bcs.n	1216 <pushData(unsigned long*)+0x46>
    1210:	strh	r4, [r3, #0]
  //
  return 1;
    1212:	movs	r0, #1
    1214:	pop	{r4, r5, r6, pc}
    1216:	movs	r0, #1
}
    1218:	pop	{r4, r5, r6, pc}
void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    121a:	movs	r0, #0
    121c:	pop	{r4, r5, r6, pc}
    121e:	nop
    1220:	.word	0x1fffbe44
    1224:	.word	0x20002b06
    1228:	.word	0x1fffcaf0
    122c:	.word	0x20002b04

00001230 <acq_isr()>:

  uint32_t acq_count=0;
  uint32_t acq_miss=0;

    void acq_isr(void)
    {
    1230:	push	{r3, r4, r5, r6, r7, lr}
        uint32_t daddr;
        uint32_t *src;
        acq_count++;

        daddr = (uint32_t)(dma.TCD->DADDR);
    1232:	ldr	r0, [pc, #88]	; (128c <acq_isr()+0x5c>)

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    1234:	ldr	r4, [pc, #88]	; (1290 <acq_isr()+0x60>)

        daddr = (uint32_t)(dma.TCD->DADDR);
    1236:	ldr	r2, [r0, #0]

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    1238:	ldr	r1, [r4, #0]

        daddr = (uint32_t)(dma.TCD->DADDR);
        dma.clearInterrupt();

        if (daddr < (uint32_t)tdm_rx_buffer + sizeof(tdm_rx_buffer) / 2) {
    123a:	ldr	r3, [pc, #88]	; (1294 <acq_isr()+0x64>)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;

        daddr = (uint32_t)(dma.TCD->DADDR);
    123c:	ldr	r7, [r2, #16]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    123e:	ldr	r5, [pc, #88]	; (1298 <acq_isr()+0x68>)
    1240:	ldrb	r6, [r0, #4]
    1242:	ldr	r0, [pc, #88]	; (129c <acq_isr()+0x6c>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
    1244:	sub.w	r2, r3, #1024	; 0x400

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    1248:	adds	r1, #1
    124a:	str	r1, [r4, #0]
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
    124c:	cmp	r7, r3
    124e:	it	cc
    1250:	movcc	r2, r3
    1252:	strb	r6, [r5, #0]
    1254:	movs	r3, #0

        for(int jj=0;jj<NCH_ACQ;jj++)
        {
          for(int ii=0; ii<NDAT;ii++)
          {
            acq_rx_buffer[ichan[jj]+ii*NCH_ACQ]=src[ichan[jj]+ii*NCH_I2S];
    1256:	ldr.w	r1, [r2, r3, lsl #3]
    125a:	str.w	r1, [r0, r3, lsl #3]
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        for(int jj=0;jj<NCH_ACQ;jj++)
        {
          for(int ii=0; ii<NDAT;ii++)
    125e:	adds	r3, #1
    1260:	cmp	r3, #128	; 0x80
    1262:	bne.n	1256 <acq_isr()+0x26>
    1264:	ldr	r1, [pc, #52]	; (129c <acq_isr()+0x6c>)
    1266:	mov	r3, r2
    1268:	add.w	r0, r1, #1024	; 0x400
          {
            acq_rx_buffer[ichan[jj]+ii*NCH_ACQ]=src[ichan[jj]+ii*NCH_I2S];
    126c:	ldr	r2, [r3, #4]
    126e:	str	r2, [r1, #4]
    1270:	adds	r1, #8
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        for(int jj=0;jj<NCH_ACQ;jj++)
        {
          for(int ii=0; ii<NDAT;ii++)
    1272:	cmp	r0, r1
    1274:	add.w	r3, r3, #8
    1278:	bne.n	126c <acq_isr()+0x3c>
          {
            acq_rx_buffer[ichan[jj]+ii*NCH_ACQ]=src[ichan[jj]+ii*NCH_I2S];
          }
        }

        if(!pushData(acq_rx_buffer)) acq_miss++;
    127a:	ldr	r0, [pc, #32]	; (129c <acq_isr()+0x6c>)
    127c:	bl	11d0 <pushData(unsigned long*)>
    1280:	cbnz	r0, 128a <acq_isr()+0x5a>
    1282:	ldr	r2, [pc, #28]	; (12a0 <acq_isr()+0x70>)
    1284:	ldr	r3, [r2, #0]
    1286:	adds	r3, #1
    1288:	str	r3, [r2, #0]
    128a:	pop	{r3, r4, r5, r6, r7, pc}
    128c:	.word	0x1fff9730
    1290:	.word	0x1fffb93c
    1294:	.word	0x1fffc248
    1298:	.word	0x4000801f
    129c:	.word	0x1fffb940
    12a0:	.word	0x20002b18

000012a4 <pullData(unsigned long*, unsigned long)>:
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    12a4:	push	{r3, r4, r5, lr}
    12a6:	ldr	r4, [pc, #72]	; (12f0 <pullData(unsigned long*, unsigned long)+0x4c>)
  if(r == (front_/ndbl)) return 0;
    12a8:	ldr	r3, [pc, #72]	; (12f4 <pullData(unsigned long*, unsigned long)+0x50>)
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    12aa:	ldrh	r2, [r4, #0]
  if(r == (front_/ndbl)) return 0;
    12ac:	ldrh	r3, [r3, #0]
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    12ae:	udiv	r2, r2, r1
  if(r == (front_/ndbl)) return 0;
    12b2:	udiv	r5, r3, r1
    12b6:	cmp	r2, r5
    12b8:	beq.n	12ec <pullData(unsigned long*, unsigned long)+0x48>
    12ba:	uxth	r3, r2
  if(++r >= (MAXBUF/ndbl)) r=0;
    12bc:	adds	r3, #1
    12be:	uxth	r3, r3
    12c0:	movs	r2, #24
    12c2:	udiv	r2, r2, r1
    12c6:	cmp	r3, r2
    12c8:	bcs.n	12e4 <pullData(unsigned long*, unsigned long)+0x40>
    12ca:	ldr	r5, [pc, #44]	; (12f8 <pullData(unsigned long*, unsigned long)+0x54>)
    12cc:	lsls	r2, r1, #10
    12ce:	smulbb	r1, r1, r3
    12d2:	mla	r3, r2, r3, r5
    12d6:	uxth	r5, r1
  uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
  memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    12d8:	mov	r1, r3
    12da:	bl	cb10 <memcpy>
  rear_ = r*ndbl;
    12de:	strh	r5, [r4, #0]
  return 1;
    12e0:	movs	r0, #1
    12e2:	pop	{r3, r4, r5, pc}
    12e4:	ldr	r3, [pc, #16]	; (12f8 <pullData(unsigned long*, unsigned long)+0x54>)
    12e6:	lsls	r2, r1, #10
    12e8:	movs	r5, #0
    12ea:	b.n	12d8 <pullData(unsigned long*, unsigned long)+0x34>
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
  if(r == (front_/ndbl)) return 0;
    12ec:	movs	r0, #0
  if(++r >= (MAXBUF/ndbl)) r=0;
  uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
  memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
  rear_ = r*ndbl;
  return 1;
}
    12ee:	pop	{r3, r4, r5, pc}
    12f0:	.word	0x20002b06
    12f4:	.word	0x1fffbe44
    12f8:	.word	0x1fffcaf0

000012fc <do_menu(short)>:
void do_menu1(void);
void do_menu2(void);
void do_menu3(void);

int16_t do_menu(int16_t state)
{ // check Serial input
    12fc:	push	{r4, lr}
    12fe:	mov	r4, r0
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1300:	bl	cd30 <usb_serial_available>
  if(!Serial.available()) return state;
    1304:	cbnz	r0, 130a <do_menu(short)+0xe>
      break;
    default:
      break;
  }
  return state;
}
    1306:	mov	r0, r4
    1308:	pop	{r4, pc}
        virtual int read() { return usb_serial_getchar(); }
    130a:	bl	ccb8 <usb_serial_getchar>

int16_t do_menu(int16_t state)
{ // check Serial input
  if(!Serial.available()) return state;
  char cc = Serial.read();
  switch(cc)
    130e:	uxtb	r0, r0
    1310:	cmp	r0, #114	; 0x72
    1312:	beq.n	1348 <do_menu(short)+0x4c>
    1314:	cmp	r0, #115	; 0x73
    1316:	beq.n	1332 <do_menu(short)+0x36>
    1318:	cmp	r0, #113	; 0x71
    131a:	bne.n	1306 <do_menu(short)+0xa>
      if(state>=0) return state;
      state=0;
      Serial.println("\nStart");
      break;
    case 'q': // stop acquisition
      if(state<0) return state;
    131c:	cmp	r4, #0
    131e:	blt.n	1306 <do_menu(short)+0xa>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1320:	movs	r1, #5
    1322:	ldr	r0, [pc, #60]	; (1360 <do_menu(short)+0x64>)
    1324:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1328:	ldr	r0, [pc, #56]	; (1364 <do_menu(short)+0x68>)
    132a:	bl	e7bc <Print::println()>
      state=4;
    132e:	movs	r4, #4
    1330:	b.n	1306 <do_menu(short)+0xa>
  if(!Serial.available()) return state;
  char cc = Serial.read();
  switch(cc)
  {
    case 's': // start acquisition
      if(state>=0) return state;
    1332:	cmp	r4, #0
    1334:	bge.n	1306 <do_menu(short)+0xa>
    1336:	movs	r1, #6
    1338:	ldr	r0, [pc, #44]	; (1368 <do_menu(short)+0x6c>)
    133a:	bl	cd84 <usb_serial_write>
    133e:	ldr	r0, [pc, #36]	; (1364 <do_menu(short)+0x68>)
    1340:	bl	e7bc <Print::println()>
    1344:	movs	r4, #0
    1346:	b.n	1306 <do_menu(short)+0xa>
    1348:	movs	r1, #5
    134a:	ldr	r0, [pc, #32]	; (136c <do_menu(short)+0x70>)
    134c:	bl	cd84 <usb_serial_write>
    1350:	ldr	r0, [pc, #16]	; (1364 <do_menu(short)+0x68>)
    1352:	bl	e7bc <Print::println()>
      Serial.println("\nStop");
      break;
#if USE_EVENTS==1
    case 'r': 
      Serial.println("Reset");
      mtpd.send_DeviceResetEvent();
    1356:	ldr	r0, [pc, #24]	; (1370 <do_menu(short)+0x74>)
    1358:	bl	7730 <MTPD::send_DeviceResetEvent()>
      break;
    135c:	b.n	1306 <do_menu(short)+0xa>
    135e:	nop
    1360:	.word	0x00014374
    1364:	.word	0x1fff8d50
    1368:	.word	0x0001436c
    136c:	.word	0x0001437c
    1370:	.word	0x20002af0

00001374 <file_writeData(void*, unsigned long)>:
  size_t nb = mfile.write(header,512);
  return (nb==512);
}

int16_t file_writeData(void *diskBuffer, uint32_t nd)
{ if(!mfile) return 0;
    1374:	push	{r4, r5, r6, lr}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1376:	ldr	r6, [pc, #48]	; (13a8 <file_writeData(void*, unsigned long)+0x34>)
    1378:	ldr	r3, [r6, #16]
    137a:	cbz	r3, 13a4 <file_writeData(void*, unsigned long)+0x30>
    137c:	ldr	r2, [r3, #0]
    137e:	mov	r5, r0
    1380:	mov	r0, r3
    1382:	ldr	r3, [r2, #68]	; 0x44
    1384:	mov	r4, r1
    1386:	blx	r3
    1388:	cbz	r0, 13a4 <file_writeData(void*, unsigned long)+0x30>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    138a:	ldr	r0, [r6, #16]
    138c:	cbz	r0, 1398 <file_writeData(void*, unsigned long)+0x24>
    138e:	ldr	r3, [r0, #0]
    1390:	mov	r1, r5
    1392:	ldr	r3, [r3, #44]	; 0x2c
    1394:	mov	r2, r4
    1396:	blx	r3
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
    1398:	subs	r0, r4, r0
    139a:	clz	r0, r0
    139e:	lsrs	r0, r0, #5
    13a0:	sxth	r0, r0
}
    13a2:	pop	{r4, r5, r6, pc}
  size_t nb = mfile.write(header,512);
  return (nb==512);
}

int16_t file_writeData(void *diskBuffer, uint32_t nd)
{ if(!mfile) return 0;
    13a4:	movs	r0, #0
    13a6:	pop	{r4, r5, r6, pc}
    13a8:	.word	0x1fff8a48

000013ac <file_close()>:
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
}

int16_t file_close(void)
{ mfile.close();
    13ac:	push	{r4, lr}
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    13ae:	ldr	r4, [pc, #32]	; (13d0 <file_close()+0x24>)
    13b0:	ldr	r0, [r4, #16]
    13b2:	cbz	r0, 13cc <file_close()+0x20>
    13b4:	ldr	r3, [r0, #0]
    13b6:	ldr	r3, [r3, #64]	; 0x40
    13b8:	blx	r3
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    13ba:	ldr	r0, [r4, #16]
    13bc:	cbz	r0, 13cc <file_close()+0x20>
    13be:	ldr	r3, [r0, #0]
    13c0:	ldr	r3, [r3, #68]	; 0x44
    13c2:	blx	r3
    13c4:	eor.w	r0, r0, #1
    13c8:	uxtb	r0, r0
  return (!mfile);
}
    13ca:	pop	{r4, pc}
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
}

int16_t file_close(void)
{ mfile.close();
    13cc:	movs	r0, #1
    13ce:	pop	{r4, pc}
    13d0:	.word	0x1fff8a48

000013d4 <printTimestamp(unsigned long)>:
 */

/****************** Time Utilities *****************************/
#include "TimeLib.h"
void printTimestamp(uint32_t tt)
{
    13d4:	push	{r4, r5, lr}
    13d6:	sub	sp, #28
  tmElements_t tm;
  breakTime(tt, tm);
    13d8:	add	r1, sp, #16
    13da:	bl	7ca8 <breakTime(long, tmElements_t&)>
  Serial.printf("Now: %04d-%02d-%02d_%02d:%02d:%02d\r\n", 
                      tmYearToCalendar(tm.Year), tm.Month, tm.Day, tm.Hour, tm.Minute, tm.Second);
    13de:	ldrb.w	r2, [sp, #22]
    13e2:	ldrb.w	r0, [sp, #18]
    13e6:	ldrb.w	r1, [sp, #20]
    13ea:	ldrb.w	r5, [sp, #16]
    13ee:	ldrb.w	r4, [sp, #17]
    13f2:	str	r0, [sp, #4]
    13f4:	str	r1, [sp, #0]
    13f6:	ldrb.w	r3, [sp, #21]
    13fa:	str	r5, [sp, #12]
    13fc:	addw	r2, r2, #1970	; 0x7b2
    1400:	str	r4, [sp, #8]
    1402:	ldr	r1, [pc, #12]	; (1410 <printTimestamp(unsigned long)+0x3c>)
    1404:	ldr	r0, [pc, #12]	; (1414 <printTimestamp(unsigned long)+0x40>)
    1406:	bl	e7ec <Print::printf(char const*, ...)>
}
    140a:	add	sp, #28
    140c:	pop	{r4, r5, pc}
    140e:	nop
    1410:	.word	0x00014384
    1414:	.word	0x1fff8d50

00001418 <makeHeader(char*)>:
    }
  #endif


void makeHeader(char *header)
{
    1418:	push	{r4, lr}
  memset(header,0,512);
    141a:	movs	r1, #0
    141c:	mov.w	r2, #512	; 0x200
    }
  #endif


void makeHeader(char *header)
{
    1420:	mov	r4, r0
  memset(header,0,512);
    1422:	bl	106dc <memset>
  sprintf(header,"WMXZ");
    1426:	ldr	r3, [pc, #32]	; (1448 <makeHeader(char*)+0x30>)
  int32_t *ihdr=(int32_t *)&header[strlen(header)+1];
  uint32_t *uhdr=(uint32_t *)&header[strlen(header)+1];
  ihdr[0]=1; // version number
    1428:	movs	r2, #1


void makeHeader(char *header)
{
  memset(header,0,512);
  sprintf(header,"WMXZ");
    142a:	ldr	r0, [r3, #0]
    142c:	ldrb	r3, [r3, #4]
    142e:	strb	r3, [r4, #4]
  int32_t *ihdr=(int32_t *)&header[strlen(header)+1];
  uint32_t *uhdr=(uint32_t *)&header[strlen(header)+1];
  ihdr[0]=1; // version number
    1430:	str.w	r2, [r4, #5]


void makeHeader(char *header)
{
  memset(header,0,512);
  sprintf(header,"WMXZ");
    1434:	str	r0, [r4, #0]
  int32_t *ihdr=(int32_t *)&header[strlen(header)+1];
  uint32_t *uhdr=(uint32_t *)&header[strlen(header)+1];
  ihdr[0]=1; // version number
  uhdr[1]=rtc_get();
    1436:	bl	d77c <rtc_get>
    143a:	str.w	r0, [r4, #9]
  uhdr[2]=micros();
    143e:	bl	d7c4 <micros>
    1442:	str.w	r0, [r4, #13]
    1446:	pop	{r4, pc}
    1448:	.word	0x000143ac

0000144c <file_writeHeader()>:
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}

int16_t file_writeHeader(void)
{ if(!mfile) return 0;
    144c:	push	{r4, lr}
    144e:	ldr	r4, [pc, #52]	; (1484 <file_writeHeader()+0x38>)
    1450:	ldr	r0, [r4, #16]
    1452:	cbz	r0, 1480 <file_writeHeader()+0x34>
    1454:	ldr	r3, [r0, #0]
    1456:	ldr	r3, [r3, #68]	; 0x44
    1458:	blx	r3
    145a:	cbz	r0, 1480 <file_writeHeader()+0x34>
  makeHeader(header);
    145c:	ldr	r0, [pc, #40]	; (1488 <file_writeHeader()+0x3c>)
    145e:	bl	1418 <makeHeader(char*)>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1462:	ldr	r0, [r4, #16]
    1464:	cbz	r0, 147e <file_writeHeader()+0x32>
    1466:	ldr	r3, [r0, #0]
    1468:	ldr	r1, [pc, #28]	; (1488 <file_writeHeader()+0x3c>)
    146a:	ldr	r3, [r3, #44]	; 0x2c
    146c:	mov.w	r2, #512	; 0x200
    1470:	blx	r3
    1472:	sub.w	r0, r0, #512	; 0x200
    1476:	clz	r0, r0
    147a:	lsrs	r0, r0, #5
    147c:	sxth	r0, r0
  size_t nb = mfile.write(header,512);
  return (nb==512);
}
    147e:	pop	{r4, pc}
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}

int16_t file_writeHeader(void)
{ if(!mfile) return 0;
    1480:	movs	r0, #0
    1482:	pop	{r4, pc}
    1484:	.word	0x1fff8a48
    1488:	.word	0x1fff973c

0000148c <makeFilename(char*)>:
  uhdr[1]=rtc_get();
  uhdr[2]=micros();
}

int16_t makeFilename(char *filename)
{
    148c:	push	{r4, r5, r6, r7, lr}
    148e:	sub	sp, #12
    1490:	mov	r7, r0
  uint32_t tt = rtc_get();
    1492:	bl	d77c <rtc_get>
  int dd;
  ss= tt % 60; tt /= 60;
  mm= tt % 60; tt /= 60;
  hh= tt % 24; tt /= 24;
  dd= tt;
  sprintf(filename,"/%d/%02d_%02d_%02d.raw",dd,hh,mm,ss);
    1496:	ldr	r4, [pc, #100]	; (14fc <makeFilename(char*)+0x70>)
    1498:	ldr	r3, [pc, #100]	; (1500 <makeFilename(char*)+0x74>)
    149a:	ldr	r6, [pc, #104]	; (1504 <makeFilename(char*)+0x78>)
    149c:	ldr	r2, [pc, #104]	; (1508 <makeFilename(char*)+0x7c>)
    149e:	ldr	r1, [pc, #108]	; (150c <makeFilename(char*)+0x80>)
    14a0:	umull	lr, r5, r4, r0
    14a4:	lsrs	r5, r5, #5
    14a6:	umull	lr, r3, r3, r0
    14aa:	umull	lr, r4, r4, r5
    14ae:	lsrs	r3, r3, #11
    14b0:	lsrs	r4, r4, #5
    14b2:	umull	lr, r6, r6, r3
    14b6:	rsb	r4, r4, r4, lsl #4
    14ba:	sub.w	r4, r5, r4, lsl #2
    14be:	lsrs	r6, r6, #4
    14c0:	rsb	r5, r5, r5, lsl #4
    14c4:	sub.w	r5, r0, r5, lsl #2
    14c8:	add.w	r6, r6, r6, lsl #1
    14cc:	umull	r0, r2, r2, r0
    14d0:	lsrs	r2, r2, #16
    14d2:	sub.w	r3, r3, r6, lsl #3
    14d6:	stmia.w	sp, {r4, r5}
    14da:	mov	r0, r7
    14dc:	bl	10b84 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    14e0:	mov	r0, r7
    14e2:	bl	10d40 <strlen>
    14e6:	mov	r1, r0
    14e8:	mov	r0, r7
    14ea:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    14ee:	ldr	r0, [pc, #32]	; (1510 <makeFilename(char*)+0x84>)
    14f0:	bl	e7bc <Print::println()>
  Serial.println(filename);
  return 1;
}
    14f4:	movs	r0, #1
    14f6:	add	sp, #12
    14f8:	pop	{r4, r5, r6, r7, pc}
    14fa:	nop
    14fc:	.word	0x88888889
    1500:	.word	0x91a2b3c5
    1504:	.word	0xaaaaaaab
    1508:	.word	0xc22e4507
    150c:	.word	0x000143b4
    1510:	.word	0x1fff8d50

00001514 <checkPath(unsigned short, char*)>:

int16_t checkPath(uint16_t store, char *filename)
{
    1514:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1518:	mov	r8, r0
    151a:	sub	sp, #56	; 0x38
  int ln=strlen(filename);
    151c:	mov	r0, r1
  Serial.println(filename);
  return 1;
}

int16_t checkPath(uint16_t store, char *filename)
{
    151e:	mov	r5, r1
  int ln=strlen(filename);
    1520:	bl	10d40 <strlen>
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
    1524:	cmp	r0, #0
    1526:	ble.n	15e2 <checkPath(unsigned short, char*)+0xce>
    1528:	subs	r1, r5, #1
    152a:	movs	r3, #0
    152c:	mov.w	r2, #4294967295
    1530:	ldrb.w	r4, [r1, #1]!
    1534:	cmp	r4, #47	; 0x2f
    1536:	it	eq
    1538:	moveq	r2, r3
    153a:	adds	r3, #1
    153c:	cmp	r0, r3
    153e:	bne.n	1530 <checkPath(unsigned short, char*)+0x1c>
  if(i1<0) return 1; // no path
    1540:	cmp	r2, #0
    1542:	blt.n	15e2 <checkPath(unsigned short, char*)+0xce>
  filename[i1]=0;
  if(!sdx[store].exists(filename))
    1544:	ldr	r3, [pc, #200]	; (1610 <checkPath(unsigned short, char*)+0xfc>)
    1546:	mov.w	r6, #1192	; 0x4a8
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
    154a:	movs	r7, #0
  if(!sdx[store].exists(filename))
    154c:	mla	r6, r6, r8, r3
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
    1550:	strb	r7, [r5, r2]
    1552:	ldr.w	lr, [r6, #1156]	; 0x484
    1556:	adds	r4, r5, r2
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
    1558:	cmp.w	lr, #0
    155c:	beq.n	1584 <checkPath(unsigned short, char*)+0x70>
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    155e:	mov	r1, lr
    1560:	mov	r3, r7
    1562:	mov	r2, r5
    1564:	mov	r0, sp
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    1566:	strb.w	r7, [sp]
    156a:	strb.w	r7, [sp, #1]
    156e:	strb.w	r7, [sp, #2]
    1572:	bl	aacc <FatFile::open(FatVolume*, char const*, int)>
  if(!sdx[store].exists(filename))
    1576:	cbz	r0, 15a4 <checkPath(unsigned short, char*)+0x90>
  { Serial.println(filename); 
    if(!sdx[store].mkdir(filename)) return 0;
  }

  filename[i1]='/';
    1578:	movs	r3, #47	; 0x2f
    157a:	strb	r3, [r4, #0]
  return 1;
    157c:	movs	r0, #1
}
    157e:	add	sp, #56	; 0x38
    1580:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1584:	ldr.w	r1, [r6, #1160]	; 0x488
    1588:	cbz	r1, 15a4 <checkPath(unsigned short, char*)+0x90>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    158a:	mov	r3, lr
    158c:	mov	r2, r5
    158e:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    1590:	strb.w	lr, [sp, #49]	; 0x31
    1594:	strb.w	lr, [sp, #50]	; 0x32
    1598:	strb.w	lr, [sp, #51]	; 0x33
    159c:	bl	9714 <ExFatFile::open(ExFatVolume*, char const*, int)>
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
  if(!sdx[store].exists(filename))
    15a0:	cmp	r0, #0
    15a2:	bne.n	1578 <checkPath(unsigned short, char*)+0x64>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    15a4:	mov	r0, r5
    15a6:	bl	10d40 <strlen>
    15aa:	mov	r1, r0
    15ac:	mov	r0, r5
    15ae:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    15b2:	ldr	r0, [pc, #96]	; (1614 <checkPath(unsigned short, char*)+0x100>)
    15b4:	bl	e7bc <Print::println()>
    15b8:	ldr.w	r7, [r6, #1156]	; 0x484
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    15bc:	cbz	r7, 15ea <checkPath(unsigned short, char*)+0xd6>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    15be:	mov	r2, r5
    15c0:	addw	r1, r7, #1092	; 0x444
    15c4:	movs	r5, #0
    15c6:	movs	r3, #1
    15c8:	mov	r0, sp
    15ca:	strb.w	r5, [sp]
    15ce:	strb.w	r5, [sp, #1]
    15d2:	strb.w	r5, [sp, #2]
    15d6:	bl	a948 <FatFile::mkdir(FatFile*, char const*, bool)>
  { Serial.println(filename); 
    if(!sdx[store].mkdir(filename)) return 0;
    15da:	cmp	r0, #0
    15dc:	bne.n	1578 <checkPath(unsigned short, char*)+0x64>
    15de:	movs	r0, #0
    15e0:	b.n	157e <checkPath(unsigned short, char*)+0x6a>
int16_t checkPath(uint16_t store, char *filename)
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
    15e2:	movs	r0, #1
    if(!sdx[store].mkdir(filename)) return 0;
  }

  filename[i1]='/';
  return 1;
}
    15e4:	add	sp, #56	; 0x38
    15e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    15ea:	ldr.w	r1, [r6, #1160]	; 0x488
    15ee:	cmp	r1, #0
    15f0:	beq.n	15de <checkPath(unsigned short, char*)+0xca>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    15f2:	mov	r2, r5
    15f4:	add.w	r1, r1, #1096	; 0x448
    15f8:	movs	r3, #1
    15fa:	mov	r0, sp
    15fc:	strb.w	r7, [sp, #49]	; 0x31
    1600:	strb.w	r7, [sp, #50]	; 0x32
    1604:	strb.w	r7, [sp, #51]	; 0x33
    1608:	bl	a144 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    160c:	b.n	15da <checkPath(unsigned short, char*)+0xc6>
    160e:	nop
    1610:	.word	0x1fffc648
    1614:	.word	0x1fff8d50

00001618 <file_open(unsigned short)>:
void makeHeader(char *header);
int16_t makeFilename(char *filename);
int16_t checkPath(uint16_t store, char *filename);

int16_t file_open(uint16_t store)
{ char filename[80];
    1618:	push	{r4, r5, r6, r7, lr}
    161a:	sub	sp, #164	; 0xa4
    161c:	mov	r4, r0
  if(!makeFilename(filename)) return 0;
    161e:	mov	r0, sp
    1620:	bl	148c <makeFilename(char*)>
    1624:	cbnz	r0, 162c <file_open(unsigned short)+0x14>
    1626:	movs	r0, #0
  if(!checkPath(store, filename)) return 0;
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}
    1628:	add	sp, #164	; 0xa4
    162a:	pop	{r4, r5, r6, r7, pc}
int16_t checkPath(uint16_t store, char *filename);

int16_t file_open(uint16_t store)
{ char filename[80];
  if(!makeFilename(filename)) return 0;
  if(!checkPath(store, filename)) return 0;
    162c:	mov	r1, sp
    162e:	mov	r0, r4
    1630:	bl	1514 <checkPath(unsigned short, char*)>
    1634:	cmp	r0, #0
    1636:	beq.n	1626 <file_open(unsigned short)+0xe>
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    1638:	ldr	r3, [pc, #188]	; (16f8 <file_open(unsigned short)+0xe0>)
    163a:	mov.w	r1, #1192	; 0x4a8
    163e:	mla	r1, r1, r4, r3
    1642:	mov	r2, sp
    1644:	movw	r3, #16898	; 0x4202
    1648:	adds	r1, #4
    164a:	add	r0, sp, #80	; 0x50
    164c:	bl	c308 <FsVolume::open(char const*, int)>
    1650:	ldr	r3, [sp, #152]	; 0x98
    1652:	cmp	r3, #0
    1654:	beq.n	16e6 <file_open(unsigned short)+0xce>
		if (file) return File(new SDFile(file));
    1656:	movs	r0, #104	; 0x68
    1658:	bl	e95c <operator new(unsigned int)>
    165c:	mov	r4, r0
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    165e:	ldr	r5, [pc, #156]	; (16fc <file_open(unsigned short)+0xe4>)
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    1660:	ldrb.w	r1, [sp, #84]	; 0x54
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    1664:	ldr	r2, [sp, #88]	; 0x58
    1666:	ldrb.w	r3, [sp, #92]	; 0x5c
    166a:	str	r5, [r4, #0]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    166c:	mov.w	r0, #1000	; 0x3e8
{
  public:
	constexpr Print() : write_error(0) {}
    1670:	movs	r5, #0
    1672:	add	r6, sp, #96	; 0x60
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    1674:	ldr	r7, [pc, #136]	; (1700 <file_open(unsigned short)+0xe8>)
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    1676:	str	r0, [r4, #8]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    1678:	strb	r1, [r4, #24]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    167a:	str	r2, [r4, #28]
    167c:	strb.w	r3, [r4, #32]
    1680:	add.w	r0, r4, #36	; 0x24
    1684:	mov	r1, r6
    1686:	str	r7, [r4, #20]
{
  public:
	constexpr Print() : write_error(0) {}
    1688:	strb	r5, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    168a:	strb	r5, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    168c:	str	r5, [r4, #16]
    168e:	bl	c0c0 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    1692:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1694:	ldr	r2, [pc, #108]	; (1704 <file_open(unsigned short)+0xec>)
    1696:	str	r5, [r4, #100]	; 0x64
    1698:	adds	r3, #1
    169a:	str	r2, [r4, #20]
    169c:	str	r3, [r4, #16]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    169e:	ldr	r5, [pc, #104]	; (1708 <file_open(unsigned short)+0xf0>)
    16a0:	ldr	r3, [pc, #104]	; (170c <file_open(unsigned short)+0xf4>)
    16a2:	str	r3, [sp, #80]	; 0x50
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    16a4:	mov	r0, r6
    16a6:	bl	c138 <FsBaseFile::close()>
    16aa:	ldr	r2, [r5, #16]
    16ac:	cbz	r2, 16c0 <file_open(unsigned short)+0xa8>
    16ae:	ldr	r3, [r2, #16]
    16b0:	subs	r3, #1
    16b2:	str	r3, [r2, #16]
    16b4:	cbnz	r3, 16c0 <file_open(unsigned short)+0xa8>
    16b6:	ldr	r0, [r5, #16]
    16b8:	cbz	r0, 16c0 <file_open(unsigned short)+0xa8>
    16ba:	ldr	r3, [r0, #0]
    16bc:	ldr	r3, [r3, #32]
    16be:	blx	r3
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    16c0:	str	r4, [r5, #16]
    16c2:	ldr	r5, [pc, #68]	; (1708 <file_open(unsigned short)+0xf0>)
		if (f) f->refcount++;
    16c4:	cbz	r4, 16f2 <file_open(unsigned short)+0xda>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    16c6:	ldr	r3, [r4, #16]
    16c8:	cbnz	r3, 16d8 <file_open(unsigned short)+0xc0>
    16ca:	ldr	r3, [r4, #0]
    16cc:	mov	r0, r4
    16ce:	ldr	r3, [r3, #32]
    16d0:	blx	r3
    16d2:	ldr	r4, [r5, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    16d4:	cmp	r4, #0
    16d6:	beq.n	1626 <file_open(unsigned short)+0xe>
    16d8:	ldr	r3, [r4, #0]
    16da:	mov	r0, r4
    16dc:	ldr	r3, [r3, #68]	; 0x44
    16de:	blx	r3
    16e0:	sxth	r0, r0
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}
    16e2:	add	sp, #164	; 0xa4
    16e4:	pop	{r4, r5, r6, r7, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    16e6:	ldr	r0, [sp, #156]	; 0x9c
    16e8:	cmp	r0, #0
    16ea:	bne.n	1656 <file_open(unsigned short)+0x3e>

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    16ec:	mov	r4, r0
    16ee:	add	r6, sp, #96	; 0x60
    16f0:	b.n	169e <file_open(unsigned short)+0x86>
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    16f2:	mov	r0, r4
    16f4:	b.n	1628 <file_open(unsigned short)+0x10>
    16f6:	nop
    16f8:	.word	0x1fffc648
    16fc:	.word	0x0001424c
    1700:	.word	0x00014180
    1704:	.word	0x000141c8
    1708:	.word	0x1fff8a48
    170c:	.word	0x000141a4

00001710 <do_logger(unsigned short, short)>:
#define NBUF_DISK (NDBL*NBUF_ACQ)
uint32_t diskBuffer[NBUF_DISK];
uint32_t maxDel=0;

int16_t do_logger(uint16_t store, int16_t state)
{ uint32_t to=millis();
    1710:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1712:	ldr	r5, [pc, #164]	; (17b8 <do_logger(unsigned short, short)+0xa8>)
    1714:	sub	sp, #12
    1716:	ldr	r3, [r5, #0]
    1718:	str	r3, [sp, #0]
    171a:	mov	r7, r0
    171c:	mov	r4, r1
  if(pullData(diskBuffer,NDBL))
    171e:	ldr	r0, [pc, #156]	; (17bc <do_logger(unsigned short, short)+0xac>)
	return ret;
    1720:	ldr	r6, [sp, #0]
    1722:	movs	r1, #8
    1724:	bl	12a4 <pullData(unsigned long*, unsigned long)>
    1728:	cbz	r0, 173e <do_logger(unsigned short, short)+0x2e>
  {
    if(state==0)
    172a:	cbz	r4, 1764 <do_logger(unsigned short, short)+0x54>
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
      state=1;
    }
    if(state==1)
    172c:	cmp	r4, #1
    172e:	beq.n	176c <do_logger(unsigned short, short)+0x5c>
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
      state=2;
      
    }
    if(state>=2)
    1730:	ble.n	1742 <do_logger(unsigned short, short)+0x32>
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    1732:	mov.w	r1, #8192	; 0x2000
    1736:	ldr	r0, [pc, #132]	; (17bc <do_logger(unsigned short, short)+0xac>)
    1738:	bl	1374 <file_writeData(void*, unsigned long)>
    173c:	cbz	r0, 1798 <do_logger(unsigned short, short)+0x88>
    }
  }

  if(state==3)
    173e:	cmp	r4, #3
    1740:	beq.n	1782 <do_logger(unsigned short, short)+0x72>
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    state=0;
  }

  if(state==4)
    1742:	cmp	r4, #4
    1744:	beq.n	178c <do_logger(unsigned short, short)+0x7c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1746:	ldr	r3, [r5, #0]
    1748:	str	r3, [sp, #4]
    if(!file_close()) return -6;
    state=-1;
  }

  uint32_t dt=millis()-to;
  if(dt>maxDel) maxDel=dt;
    174a:	ldr	r2, [pc, #116]	; (17c0 <do_logger(unsigned short, short)+0xb0>)
	return ret;
    174c:	ldr	r3, [sp, #4]
    174e:	ldr	r1, [r2, #0]
  { // close file and stop acquisition
    if(!file_close()) return -6;
    state=-1;
  }

  uint32_t dt=millis()-to;
    1750:	subs	r3, r3, r6
  if(dt>maxDel) maxDel=dt;
    1752:	cmp	r3, r1
    1754:	bls.n	175e <do_logger(unsigned short, short)+0x4e>
    1756:	str	r3, [r2, #0]

  return state;
    1758:	mov	r0, r4
}
    175a:	add	sp, #12
    175c:	pop	{r4, r5, r6, r7, pc}
  }

  uint32_t dt=millis()-to;
  if(dt>maxDel) maxDel=dt;

  return state;
    175e:	mov	r0, r4
}
    1760:	add	sp, #12
    1762:	pop	{r4, r5, r6, r7, pc}
{ uint32_t to=millis();
  if(pullData(diskBuffer,NDBL))
  {
    if(state==0)
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
    1764:	mov	r0, r7
    1766:	bl	1618 <file_open(unsigned short)>
    176a:	cbz	r0, 179e <do_logger(unsigned short, short)+0x8e>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
    176c:	bl	144c <file_writeHeader()>
    1770:	cbz	r0, 17a4 <do_logger(unsigned short, short)+0x94>
      state=2;
      
    }
    if(state>=2)
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    1772:	mov.w	r1, #8192	; 0x2000
    1776:	ldr	r0, [pc, #68]	; (17bc <do_logger(unsigned short, short)+0xac>)
    1778:	bl	1374 <file_writeData(void*, unsigned long)>
    177c:	cbz	r0, 1798 <do_logger(unsigned short, short)+0x88>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
      state=2;
    177e:	movs	r4, #2
    1780:	b.n	1746 <do_logger(unsigned short, short)+0x36>
    }
  }

  if(state==3)
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    1782:	bl	13ac <file_close()>
    1786:	cbz	r0, 17b0 <do_logger(unsigned short, short)+0xa0>
    state=0;
    1788:	movs	r4, #0
    178a:	b.n	1746 <do_logger(unsigned short, short)+0x36>
  }

  if(state==4)
  { // close file and stop acquisition
    if(!file_close()) return -6;
    178c:	bl	13ac <file_close()>
    1790:	cbz	r0, 17aa <do_logger(unsigned short, short)+0x9a>
    state=-1;
    1792:	mov.w	r4, #4294967295
    1796:	b.n	1746 <do_logger(unsigned short, short)+0x36>
      state=2;
      
    }
    if(state>=2)
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    1798:	mvn.w	r0, #3
    179c:	b.n	175a <do_logger(unsigned short, short)+0x4a>
{ uint32_t to=millis();
  if(pullData(diskBuffer,NDBL))
  {
    if(state==0)
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
    179e:	mvn.w	r0, #1
    17a2:	b.n	175a <do_logger(unsigned short, short)+0x4a>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
    17a4:	mvn.w	r0, #2
    17a8:	b.n	175a <do_logger(unsigned short, short)+0x4a>
    state=0;
  }

  if(state==4)
  { // close file and stop acquisition
    if(!file_close()) return -6;
    17aa:	mvn.w	r0, #5
    17ae:	b.n	175a <do_logger(unsigned short, short)+0x4a>
    }
  }

  if(state==3)
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    17b0:	mvn.w	r0, #4
    17b4:	b.n	175a <do_logger(unsigned short, short)+0x4a>
    17b6:	nop
    17b8:	.word	0x200030a4
    17bc:	.word	0x1fff993c
    17c0:	.word	0x1fff9738

000017c4 <Adjust_MCLK(long, long*, long*)>:
  //Teensy 3.2, 3.6 or 3.5
      #define MCLK_SRC  3

    // estimate MCLK to generate precise sampling frequency (typically equal or greater desired frequency)
    void Adjust_MCLK(int32_t fsamp, int32_t *mult, int32_t *div)
    {
    17c4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    17c8:	sub.w	sp, sp, #1024	; 0x400
    17cc:	mov	r9, r1
    17ce:	mov	r8, r2
    17d0:	bl	f668 <__aeabi_i2f>
    17d4:	mov	r1, r0
    17d6:	ldr	r0, [pc, #140]	; (1864 <Adjust_MCLK(long, long*, long*)+0xa0>)
    17d8:	bl	f878 <__aeabi_fdiv>
    17dc:	mov	r6, sp
    17de:	mov	r7, r0
    17e0:	mov	r5, sp
      float A = (float)F_PLL / (BIT_DIV*ovr);
      float X[255];
      for(int ii=0; ii<255;ii++) X[ii]=A/((float) fsamp)*(ii+1);
    17e2:	movs	r4, #0
    17e4:	adds	r4, #1
    17e6:	mov	r0, r4
    17e8:	bl	f668 <__aeabi_i2f>
    17ec:	mov	r1, r7
    17ee:	bl	f710 <__aeabi_fmul>
    17f2:	cmp	r4, #255	; 0xff
    17f4:	str.w	r0, [r5, #4]!
    17f8:	bne.n	17e4 <Adjust_MCLK(long, long*, long*)+0x20>
    17fa:	movs	r4, #0
    17fc:	mov.w	r7, #1065353216	; 0x3f800000
    1800:	mov	sl, r4
    1802:	b.n	180a <Adjust_MCLK(long, long*, long*)+0x46>
      int32_t iimin=0;
      float xmin=1.0f;
      for(int ii=0; ii<255;ii++) if((X[ii]<4096.0f) && (fmodf(X[ii],1.0f)<xmin)) {iimin=ii; xmin=fmodf(X[ii],1.0f);}
    1804:	adds	r4, #1
    1806:	cmp	r4, #255	; 0xff
    1808:	beq.n	1844 <Adjust_MCLK(long, long*, long*)+0x80>
    180a:	ldr.w	r5, [r6, #4]!
    180e:	mov.w	r1, #1166016512	; 0x45800000
    1812:	mov	r0, r5
    1814:	bl	fa4c <__aeabi_fcmplt>
    1818:	cmp	r0, #0
    181a:	beq.n	1804 <Adjust_MCLK(long, long*, long*)+0x40>
    181c:	mov.w	r1, #1065353216	; 0x3f800000
    1820:	mov	r0, r5
    1822:	bl	e964 <fmodf>
    1826:	mov	r1, r7
    1828:	bl	fa4c <__aeabi_fcmplt>
    182c:	mov.w	r1, #1065353216	; 0x3f800000
    1830:	cmp	r0, #0
    1832:	beq.n	1804 <Adjust_MCLK(long, long*, long*)+0x40>
    1834:	mov	r0, r5
    1836:	bl	e964 <fmodf>
    183a:	mov	sl, r4
    183c:	adds	r4, #1
    183e:	cmp	r4, #255	; 0xff
    1840:	mov	r7, r0
    1842:	bne.n	180a <Adjust_MCLK(long, long*, long*)+0x46>
      *mult=iimin+1;
      *div=(int) X[iimin];
    1844:	add	r2, sp, #4
      float X[255];
      for(int ii=0; ii<255;ii++) X[ii]=A/((float) fsamp)*(ii+1);
      int32_t iimin=0;
      float xmin=1.0f;
      for(int ii=0; ii<255;ii++) if((X[ii]<4096.0f) && (fmodf(X[ii],1.0f)<xmin)) {iimin=ii; xmin=fmodf(X[ii],1.0f);}
      *mult=iimin+1;
    1846:	add.w	r3, sl, #1
      *div=(int) X[iimin];
    184a:	ldr.w	r0, [r2, sl, lsl #2]
      float X[255];
      for(int ii=0; ii<255;ii++) X[ii]=A/((float) fsamp)*(ii+1);
      int32_t iimin=0;
      float xmin=1.0f;
      for(int ii=0; ii<255;ii++) if((X[ii]<4096.0f) && (fmodf(X[ii],1.0f)<xmin)) {iimin=ii; xmin=fmodf(X[ii],1.0f);}
      *mult=iimin+1;
    184e:	str.w	r3, [r9]
      *div=(int) X[iimin];
    1852:	bl	fac8 <__aeabi_f2iz>
    1856:	str.w	r0, [r8]
    }
    185a:	add.w	sp, sp, #1024	; 0x400
    185e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1862:	nop
    1864:	.word	0x48b71b00

00001868 <acq_init(long)>:
        SIM_SCGC7 |= SIM_SCGC7_DMA;
        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    }

    void acq_init(int32_t fsamp)
    {
    1868:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    186c:	sub	sp, #32
      int32_t MCLK_MULT, MCLK_DIV;

#define EST_MCKL 0 // 0 precise frequency, 1 minimal jitter
#if EST_MCKL==0
      Adjust_MCLK(fsamp,&MCLK_MULT,&MCLK_DIV);
    186e:	add	r2, sp, #28
    1870:	add	r1, sp, #24
        SIM_SCGC7 |= SIM_SCGC7_DMA;
        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    }

    void acq_init(int32_t fsamp)
    {
    1872:	mov	r6, r0
      int32_t MCLK_MULT, MCLK_DIV;

#define EST_MCKL 0 // 0 precise frequency, 1 minimal jitter
#if EST_MCKL==0
      Adjust_MCLK(fsamp,&MCLK_MULT,&MCLK_DIV);
    1874:	bl	17c4 <Adjust_MCLK(long, long*, long*)>
#elif EST_MCKL==1
      Approx_MCLK(fsamp,&MCLK_MULT,&MCLK_DIV);
#endif
      float fract = (float)MCLK_MULT/((float) MCLK_DIV);
    1878:	ldr	r4, [sp, #24]
    187a:	ldr	r5, [sp, #28]
      int32_t mclk0=((F_PLL)*fract);
    187c:	mov	r0, r4
    187e:	bl	f668 <__aeabi_i2f>
    1882:	mov	r7, r0
    1884:	mov	r0, r5
    1886:	bl	f668 <__aeabi_i2f>
    188a:	mov	r1, r0
    188c:	mov	r0, r7
    188e:	bl	f878 <__aeabi_fdiv>
    1892:	ldr	r1, [pc, #352]	; (19f4 <acq_init(long)+0x18c>)
P36 PTC9                    I2S0_RX_BCLK (4)
P37 PTC10                   I2S0_RX_FS (4)
P38 PTC11                   I2S0_RXD1 (4)
P39 PTA17  I2S0_MCLK (6)
*/
        CORE_PIN11_CONFIG = PORT_PCR_MUX(6);   // PTC6,  I2S0_MCLK
    1894:	ldr	r7, [pc, #352]	; (19f8 <acq_init(long)+0x190>)
      Adjust_MCLK(fsamp,&MCLK_MULT,&MCLK_DIV);
#elif EST_MCKL==1
      Approx_MCLK(fsamp,&MCLK_MULT,&MCLK_DIV);
#endif
      float fract = (float)MCLK_MULT/((float) MCLK_DIV);
      int32_t mclk0=((F_PLL)*fract);
    1896:	bl	f710 <__aeabi_fmul>
    189a:	bl	fac8 <__aeabi_f2iz>
      int32_t fsamp0=(mclk0/(BIT_DIV*ovr));

      Serial.printf("%d %d %d %d %d %d %d\n",F_CPU, MCLK_MULT, MCLK_DIV, BIT_DIV, mclk0,fsamp,fsamp0); Serial.flush();
    189e:	movs	r2, #2
    18a0:	lsrs	r3, r0, #8
    18a2:	ldr	r1, [pc, #344]	; (19fc <acq_init(long)+0x194>)
    18a4:	str	r6, [sp, #12]
    18a6:	str	r0, [sp, #8]
    18a8:	str	r3, [sp, #16]
    18aa:	str	r5, [sp, #0]
    18ac:	mov	r3, r4
    18ae:	str	r2, [sp, #4]
    18b0:	ldr	r0, [pc, #332]	; (1a00 <acq_init(long)+0x198>)
    18b2:	ldr	r2, [pc, #336]	; (1a04 <acq_init(long)+0x19c>)
P37 PTC10                   I2S0_RX_FS (4)
P38 PTC11                   I2S0_RXD1 (4)
P39 PTA17  I2S0_MCLK (6)
*/
        CORE_PIN11_CONFIG = PORT_PCR_MUX(6);   // PTC6,  I2S0_MCLK
        CORE_PIN9_CONFIG = PORT_PCR_MUX(6);    // PTC3,  I2S0_TX_BCLK
    18b4:	ldr	r6, [pc, #336]	; (1a08 <acq_init(long)+0x1a0>)
        CORE_PIN23_CONFIG = PORT_PCR_MUX(6);   // PTC2,  I2S0_TX_FS 
    18b6:	ldr	r5, [pc, #340]	; (1a0c <acq_init(long)+0x1a4>)
#endif
      float fract = (float)MCLK_MULT/((float) MCLK_DIV);
      int32_t mclk0=((F_PLL)*fract);
      int32_t fsamp0=(mclk0/(BIT_DIV*ovr));

      Serial.printf("%d %d %d %d %d %d %d\n",F_CPU, MCLK_MULT, MCLK_DIV, BIT_DIV, mclk0,fsamp,fsamp0); Serial.flush();
    18b8:	bl	e7ec <Print::printf(char const*, ...)>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    18bc:	bl	ceec <usb_serial_flush_output>
*/
        CORE_PIN11_CONFIG = PORT_PCR_MUX(6);   // PTC6,  I2S0_MCLK
        CORE_PIN9_CONFIG = PORT_PCR_MUX(6);    // PTC3,  I2S0_TX_BCLK
        CORE_PIN23_CONFIG = PORT_PCR_MUX(6);   // PTC2,  I2S0_TX_FS 

        I2S0_RCSR=0;
    18c0:	ldr	r2, [pc, #332]	; (1a10 <acq_init(long)+0x1a8>)

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    18c2:	ldr	r0, [pc, #336]	; (1a14 <acq_init(long)+0x1ac>)
        while(I2S0_MCR & I2S_MCR_DUF);
    18c4:	ldr	r1, [pc, #336]	; (1a18 <acq_init(long)+0x1b0>)
P36 PTC9                    I2S0_RX_BCLK (4)
P37 PTC10                   I2S0_RX_FS (4)
P38 PTC11                   I2S0_RXD1 (4)
P39 PTA17  I2S0_MCLK (6)
*/
        CORE_PIN11_CONFIG = PORT_PCR_MUX(6);   // PTC6,  I2S0_MCLK
    18c6:	mov.w	r3, #1536	; 0x600
        CORE_PIN9_CONFIG = PORT_PCR_MUX(6);    // PTC3,  I2S0_TX_BCLK
        CORE_PIN23_CONFIG = PORT_PCR_MUX(6);   // PTC2,  I2S0_TX_FS 

        I2S0_RCSR=0;
    18ca:	movs	r4, #0
P36 PTC9                    I2S0_RX_BCLK (4)
P37 PTC10                   I2S0_RX_FS (4)
P38 PTC11                   I2S0_RXD1 (4)
P39 PTA17  I2S0_MCLK (6)
*/
        CORE_PIN11_CONFIG = PORT_PCR_MUX(6);   // PTC6,  I2S0_MCLK
    18cc:	str	r3, [r7, #0]
        CORE_PIN9_CONFIG = PORT_PCR_MUX(6);    // PTC3,  I2S0_TX_BCLK
    18ce:	str	r3, [r6, #0]
        CORE_PIN23_CONFIG = PORT_PCR_MUX(6);   // PTC2,  I2S0_TX_FS 
    18d0:	str	r3, [r5, #0]

        I2S0_RCSR=0;
    18d2:	str	r4, [r2, #0]

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    18d4:	ldr	r2, [sp, #24]
    18d6:	ldr	r3, [sp, #28]
    18d8:	subs	r2, #1
    18da:	lsls	r2, r2, #12
    18dc:	subs	r3, #1
    18de:	and.w	r2, r2, #1044480	; 0xff000
    18e2:	ubfx	r3, r3, #0, #12
    18e6:	orrs	r3, r2
    18e8:	str	r3, [r0, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
    18ea:	ldr	r3, [r1, #0]
    18ec:	ldr	r2, [pc, #296]	; (1a18 <acq_init(long)+0x1b0>)
    18ee:	cmp	r3, #0
    18f0:	blt.n	18ea <acq_init(long)+0x82>
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        // configure transmitter
        I2S0_TMR = 0;
    18f2:	ldr	r4, [pc, #296]	; (1a1c <acq_init(long)+0x1b4>)
        I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
        I2S0_TCR2 = I2S_TCR2_SYNC(0) 
                    | I2S_TCR2_BCP 
                    | I2S_TCR2_MSEL(1)
                    | I2S_TCR2_BCD 
                    | I2S_TCR2_DIV((BIT_DIV-1));
    18f4:	ldr.w	ip, [pc, #364]	; 1a64 <acq_init(long)+0x1fc>
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        // configure transmitter
        I2S0_TMR = 0;
        I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    18f8:	ldr.w	r8, [pc, #364]	; 1a68 <acq_init(long)+0x200>
        I2S0_TCR4 = I2S_TCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_TCR4_SYWD(31)
                    | I2S_TCR4_MF
                    | I2S_TCR4_FSE 
                    | I2S_TCR4_FSP 
                    | I2S_TCR4_FSD;
    18fc:	ldr	r3, [pc, #288]	; (1a20 <acq_init(long)+0x1b8>)
        I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    18fe:	ldr	r7, [pc, #292]	; (1a24 <acq_init(long)+0x1bc>)

      	// configure receiver (sync'd to transmitter clocks)
        I2S0_RMR=0;
    1900:	ldr	r5, [pc, #292]	; (1a28 <acq_init(long)+0x1c0>)
        I2S0_RCR1 = I2S_RCR1_RFW(1); 
    1902:	ldr.w	lr, [pc, #360]	; 1a6c <acq_init(long)+0x204>

        I2S0_RCR2 = I2S_RCR2_SYNC(1) 
                    | I2S_RCR2_BCP 
                    | I2S_RCR2_BCD  // Bit clock in master mode
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
    1906:	ldr	r1, [pc, #292]	; (1a2c <acq_init(long)+0x1c4>)
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_SYWD(31)
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSP 
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
    1908:	ldr	r0, [pc, #292]	; (1a30 <acq_init(long)+0x1c8>)
        I2S0_RCSR=0;

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
    190a:	mov.w	r6, #1124073472	; 0x43000000
    190e:	str	r6, [r2, #0]
        
        // configure transmitter
        I2S0_TMR = 0;
    1910:	movs	r6, #0
    1912:	str	r6, [r4, #0]
        I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
        I2S0_TCR2 = I2S_TCR2_SYNC(0) 
                    | I2S_TCR2_BCP 
                    | I2S_TCR2_MSEL(1)
                    | I2S_TCR2_BCD 
                    | I2S_TCR2_DIV((BIT_DIV-1));
    1914:	ldr	r2, [pc, #284]	; (1a34 <acq_init(long)+0x1cc>)
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        // configure transmitter
        I2S0_TMR = 0;
        I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    1916:	movs	r4, #1
    1918:	str.w	r4, [r8]
        I2S0_TCR2 = I2S_TCR2_SYNC(0) 
                    | I2S_TCR2_BCP 
                    | I2S_TCR2_MSEL(1)
                    | I2S_TCR2_BCD 
                    | I2S_TCR2_DIV((BIT_DIV-1));
    191c:	str.w	r2, [ip]
        I2S0_TCR4 = I2S_TCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_TCR4_SYWD(31)
                    | I2S_TCR4_MF
                    | I2S_TCR4_FSE 
                    | I2S_TCR4_FSP 
                    | I2S_TCR4_FSD;
    1920:	ldr	r2, [pc, #276]	; (1a38 <acq_init(long)+0x1d0>)
    1922:	str	r2, [r3, #0]
        I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    1924:	ldr	r3, [pc, #276]	; (1a3c <acq_init(long)+0x1d4>)
    1926:	str	r3, [r7, #0]

      	// configure receiver (sync'd to transmitter clocks)
        I2S0_RMR=0;
    1928:	str	r6, [r5, #0]
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);


  dma.begin(true); // Allocate the DMA channel first
    192a:	ldr	r5, [pc, #276]	; (1a40 <acq_init(long)+0x1d8>)
                    | I2S_TCR4_FSD;
        I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);

      	// configure receiver (sync'd to transmitter clocks)
        I2S0_RMR=0;
        I2S0_RCR1 = I2S_RCR1_RFW(1); 
    192c:	str.w	r4, [lr]

        I2S0_RCR2 = I2S_RCR2_SYNC(1) 
                    | I2S_RCR2_BCP 
                    | I2S_RCR2_BCD  // Bit clock in master mode
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
    1930:	ldr.w	lr, [pc, #316]	; 1a70 <acq_init(long)+0x208>
    1934:	str.w	lr, [r1]
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_SYWD(31)
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSP 
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
    1938:	str	r2, [r0, #0]
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);


  dma.begin(true); // Allocate the DMA channel first
    193a:	mov	r1, r4
    193c:	mov	r0, r5
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSP 
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    193e:	str.w	r3, [r7, #128]	; 0x80


  dma.begin(true); // Allocate the DMA channel first
    1942:	bl	e594 <DMAChannel::begin(bool)>

#if N_ADC==1
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
    1946:	ldr	r3, [pc, #252]	; (1a44 <acq_init(long)+0x1dc>)

          I2S0_TCR3 = I2S_TCR3_TCE;
    1948:	ldr	r0, [pc, #252]	; (1a48 <acq_init(long)+0x1e0>)
          I2S0_RCR3 = I2S_RCR3_RCE;
    194a:	ldr	r1, [pc, #256]	; (1a4c <acq_init(long)+0x1e4>)

          dma.TCD->SADDR = &I2S0_RDR0;
    194c:	ldr	r2, [pc, #256]	; (1a50 <acq_init(long)+0x1e8>)
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
    194e:	ldr.w	lr, [pc, #292]	; 1a74 <acq_init(long)+0x20c>


  dma.begin(true); // Allocate the DMA channel first

#if N_ADC==1
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
    1952:	mov.w	r7, #1024	; 0x400
    1956:	str	r7, [r3, #0]

          I2S0_TCR3 = I2S_TCR3_TCE;
    1958:	mov.w	r3, #65536	; 0x10000
    195c:	str	r3, [r0, #0]
          I2S0_RCR3 = I2S_RCR3_RCE;
    195e:	str	r3, [r1, #0]

          dma.TCD->SADDR = &I2S0_RDR0;
    1960:	ldr	r3, [r5, #0]
    1962:	str	r2, [r3, #0]
          dma.TCD->SOFF = 0;
    1964:	strh	r6, [r3, #4]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    1966:	ldrb	r2, [r5, #4]
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
    1968:	str.w	lr, [r3, #16]
    196c:	add.w	r2, r2, #1073741824	; 0x40000000
    1970:	add.w	r2, r2, #135168	; 0x21000
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
    1974:	sub.w	r7, r7, #3072	; 0xc00
          I2S0_TCR3 = I2S_TCR3_TCE;
          I2S0_RCR3 = I2S_RCR3_RCE;

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
    1978:	movw	r1, #514	; 0x202
    197c:	strh	r1, [r3, #6]
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
    197e:	str	r7, [r3, #24]
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
    1980:	mov.w	r0, #512	; 0x200
          I2S0_RCR3 = I2S_RCR3_RCE;

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
    1984:	movs	r1, #4
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    1986:	mov.w	lr, #6
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    198a:	movs	r7, #142	; 0x8e
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
    198c:	strh	r0, [r3, #30]

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
          dma.TCD->SLAST = 0;
    198e:	str	r6, [r3, #12]
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
    1990:	strh	r0, [r3, #22]
          I2S0_RCR3 = I2S_RCR3_RCE;

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
    1992:	str	r1, [r3, #8]
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = dma.TCD->BITER_ELINKNO = NDAT*FRAME_I2S*2;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    1994:	strh.w	lr, [r3, #28]
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
    1998:	strh	r1, [r3, #20]

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    199a:	strb	r6, [r2, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    199c:	strb	r7, [r2, #0]
    199e:	ldrb	r2, [r5, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    19a0:	ldr	r3, [pc, #176]	; (1a54 <acq_init(long)+0x1ec>)
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
          dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
          dma.enable();

          I2S0_RCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
    19a2:	ldr	r1, [pc, #108]	; (1a10 <acq_init(long)+0x1a8>)
    19a4:	strb	r2, [r3, #0]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    19a6:	asrs	r3, r2, #5
    19a8:	lsls	r3, r3, #2
    19aa:	add.w	r3, r3, #3758096384	; 0xe0000000
          I2S0_TCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
    19ae:	ldr	r0, [pc, #168]	; (1a58 <acq_init(long)+0x1f0>)
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    19b0:	ldr	r7, [pc, #168]	; (1a5c <acq_init(long)+0x1f4>)
    19b2:	ldr.w	lr, [pc, #196]	; 1a78 <acq_init(long)+0x210>
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    19b6:	and.w	r6, r2, #31
    19ba:	add.w	r3, r3, #57600	; 0xe100
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    19be:	adds	r2, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    19c0:	lsls	r4, r6
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
          dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
          dma.enable();

          I2S0_RCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
    19c2:	ldr	r6, [pc, #156]	; (1a60 <acq_init(long)+0x1f8>)
    19c4:	str	r6, [r1, #0]
          I2S0_TCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
    19c6:	str	r6, [r0, #0]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    19c8:	str.w	lr, [r7, r2, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    19cc:	str	r4, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
    19ce:	ldrb	r3, [r5, #4]
    19d0:	add.w	r3, r3, #3758096384	; 0xe0000000
    19d4:	add.w	r3, r3, #58368	; 0xe400
    19d8:	movs	r2, #96	; 0x60
    19da:	strb	r2, [r3, #0]
      *div= iimin+1;
    }

    void acq_start(void)
    {
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
    19dc:	ldr	r3, [r0, #0]
    19de:	orr.w	r3, r3, #2415919104	; 0x90000000
    19e2:	str	r3, [r0, #0]
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    19e4:	ldr	r3, [r1, #0]
    19e6:	orr.w	r3, r3, #2415919104	; 0x90000000
    19ea:	str	r3, [r1, #0]

          I2S0_RCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
          I2S0_TCSR = I2S_RCSR_FRDE | I2S_RCSR_FR;
          dma.attachInterrupt(acq_isr,I2S_DMA_PRIO*16);	
          acq_start();
    }
    19ec:	add	sp, #32
    19ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    19f2:	nop
    19f4:	.word	0x4cb71b00
    19f8:	.word	0x4004b018
    19fc:	.word	0x000143cc
    1a00:	.word	0x1fff8d50
    1a04:	.word	0x05b8d800
    1a08:	.word	0x4004b00c
    1a0c:	.word	0x4004b008
    1a10:	.word	0x4002f080
    1a14:	.word	0x4002f104
    1a18:	.word	0x4002f100
    1a1c:	.word	0x4002f060
    1a20:	.word	0x4002f010
    1a24:	.word	0x4002f014
    1a28:	.word	0x4002f0e0
    1a2c:	.word	0x4002f088
    1a30:	.word	0x4002f090
    1a34:	.word	0x07000001
    1a38:	.word	0x00011f1b
    1a3c:	.word	0x1f1f1f00
    1a40:	.word	0x1fff9730
    1a44:	.word	0x4004b014
    1a48:	.word	0x4002f00c
    1a4c:	.word	0x4002f08c
    1a50:	.word	0x4002f0a0
    1a54:	.word	0x4000801b
    1a58:	.word	0x4002f000
    1a5c:	.word	0x1fff8200
    1a60:	.word	0x02000001
    1a64:	.word	0x4002f008
    1a68:	.word	0x4002f004
    1a6c:	.word	0x4002f084
    1a70:	.word	0x43000001
    1a74:	.word	0x1fffbe48
    1a78:	.word	0x00001231

00001a7c <acq_check(short)>:
        if(!pushData(acq_rx_buffer)) acq_miss++;

    }

  int16_t acq_check(int16_t state)
  { if(!state)
    1a7c:	cbnz	r0, 1a94 <acq_check(short)+0x18>
      *div= iimin+1;
    }

    void acq_start(void)
    {
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
    1a7e:	ldr	r1, [pc, #48]	; (1ab0 <acq_check(short)+0x34>)
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    1a80:	ldr	r2, [pc, #48]	; (1ab4 <acq_check(short)+0x38>)
      *div= iimin+1;
    }

    void acq_start(void)
    {
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
    1a82:	ldr	r3, [r1, #0]
    1a84:	orr.w	r3, r3, #2415919104	; 0x90000000
    1a88:	str	r3, [r1, #0]
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    1a8a:	ldr	r3, [r2, #0]
    1a8c:	orr.w	r3, r3, #2415919104	; 0x90000000
    1a90:	str	r3, [r2, #0]
    1a92:	bx	lr
  int16_t acq_check(int16_t state)
  { if(!state)
    { // start acquisition
      acq_start();
    }
    if(state>3)
    1a94:	cmp	r0, #3
    1a96:	ble.n	1aac <acq_check(short)+0x30>
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    }
    void acq_stop(void)
    { 
          I2S0_TCSR &= ~(I2S_TCSR_TE | I2S_TCSR_BCE);
    1a98:	ldr	r1, [pc, #20]	; (1ab0 <acq_check(short)+0x34>)
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    1a9a:	ldr	r2, [pc, #24]	; (1ab4 <acq_check(short)+0x38>)
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    }
    void acq_stop(void)
    { 
          I2S0_TCSR &= ~(I2S_TCSR_TE | I2S_TCSR_BCE);
    1a9c:	ldr	r3, [r1, #0]
    1a9e:	bic.w	r3, r3, #2415919104	; 0x90000000
    1aa2:	str	r3, [r1, #0]
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    1aa4:	ldr	r3, [r2, #0]
    1aa6:	bic.w	r3, r3, #2415919104	; 0x90000000
    1aaa:	str	r3, [r2, #0]
    if(state>3)
    { // stop acquisition
      acq_stop();
    }
    return state;
  }
    1aac:	bx	lr
    1aae:	nop
    1ab0:	.word	0x4002f000
    1ab4:	.word	0x4002f080

00001ab8 <loop>:
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1ab8:	push	{r4, r5, r6, lr}
    1aba:	ldr	r2, [pc, #132]	; (1b40 <loop+0x88>)
  state = do_menu(state);
    1abc:	ldr	r4, [pc, #132]	; (1b44 <loop+0x8c>)
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1abe:	ldr	r3, [r2, #0]
  state = do_menu(state);
    1ac0:	ldrsh.w	r0, [r4]
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1ac4:	adds	r3, #1
    1ac6:	sub	sp, #16
    1ac8:	str	r3, [r2, #0]
  state = do_menu(state);
    1aca:	bl	12fc <do_menu(short)>
    1ace:	strh	r0, [r4, #0]
  state = acq_check(state);
    1ad0:	bl	1a7c <acq_check(short)>

uint32_t t_on = 60;
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
    1ad4:	cmp	r0, #2

uint32_t loop_count=0;
void loop()
{ loop_count++;
  state = do_menu(state);
  state = acq_check(state);
    1ad6:	mov	r1, r0
    1ad8:	strh	r0, [r4, #0]

uint32_t t_on = 60;
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
    1ada:	beq.n	1b1a <loop+0x62>
{ loop_count++;
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
  //
  if(state<0)
    1adc:	cmp	r0, #0
    1ade:	blt.n	1b0e <loop+0x56>
    mtpd.loop();
  else
    state=do_logger(0,state);
    1ae0:	movs	r0, #0
    1ae2:	bl	1710 <do_logger(unsigned short, short)>
    1ae6:	strh	r0, [r4, #0]

  if(state>=0) logg(1000,"loop");
    1ae8:	cmp	r0, #0
    1aea:	blt.n	1b00 <loop+0x48>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1aec:	ldr	r3, [pc, #88]	; (1b48 <loop+0x90>)
/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
{ static uint32_t to;
  if(millis()-to > del)
    1aee:	ldr	r2, [pc, #92]	; (1b4c <loop+0x94>)
    1af0:	ldr	r3, [r3, #0]
    1af2:	str	r3, [sp, #12]
	return ret;
    1af4:	ldr	r3, [sp, #12]
    1af6:	ldr	r2, [r2, #0]
    1af8:	subs	r3, r3, r2
    1afa:	cmp.w	r3, #1000	; 0x3e8
    1afe:	bhi.n	1b04 <loop+0x4c>
  else
    state=do_logger(0,state);

  if(state>=0) logg(1000,"loop");
  //asm("wfi"); // may wait forever on T4.x
}
    1b00:	add	sp, #16
    1b02:	pop	{r4, r5, r6, pc}
    1b04:	ldr	r0, [pc, #72]	; (1b50 <loop+0x98>)
    1b06:	bl	878 <logg(unsigned long, char const*) [clone .part.55]>
    1b0a:	add	sp, #16
    1b0c:	pop	{r4, r5, r6, pc}
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
  //
  if(state<0)
    mtpd.loop();
    1b0e:	ldr	r0, [pc, #68]	; (1b54 <loop+0x9c>)
    1b10:	bl	703c <MTPD::loop()>
    1b14:	ldrsh.w	r0, [r4]
    1b18:	b.n	1ae8 <loop+0x30>
    1b1a:	str	r0, [sp, #4]
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    1b1c:	bl	d77c <rtc_get>
    uint32_t dt = tt % t_on;
    1b20:	ldr	r3, [pc, #52]	; (1b58 <loop+0xa0>)
    if(dt<to) state = 3;
    1b22:	ldr	r2, [pc, #56]	; (1b5c <loop+0xa4>)
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    1b24:	ldr	r3, [r3, #0]
    if(dt<to) state = 3;
    1b26:	ldr	r5, [r2, #0]
    1b28:	ldr	r1, [sp, #4]
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    1b2a:	udiv	r6, r0, r3
    1b2e:	mls	r0, r6, r3, r0
    if(dt<to) state = 3;
    1b32:	cmp	r0, r5
    1b34:	it	cc
    1b36:	movcc	r1, #3
uint32_t loop_count=0;
void loop()
{ loop_count++;
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
    1b38:	strh	r1, [r4, #0]
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    if(dt<to) state = 3;
    to = dt;
    1b3a:	str	r0, [r2, #0]
    1b3c:	b.n	1ae0 <loop+0x28>
    1b3e:	nop
    1b40:	.word	0x20002b08
    1b44:	.word	0x1fffbe46
    1b48:	.word	0x200030a4
    1b4c:	.word	0x20002b20
    1b50:	.word	0x000143e4
    1b54:	.word	0x20002af0
    1b58:	.word	0x1fff8a40
    1b5c:	.word	0x20002b1c

00001b60 <_GLOBAL__sub_I_audioShield>:

void SGTL5000_disable(void)
{
  chipWrite(0, CHIP_DIG_POWER, 0); 
  chipWrite(0, CHIP_ANA_POWER, 0); 
}
    1b60:	push	{r3, r4, r5, r6, r7, lr}
#define AUDIO_HEADPHONE_LINEIN 1

class AudioControlSGTL5000 : public AudioControl
{
public:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
    1b62:	ldr	r1, [pc, #220]	; (1c40 <_GLOBAL__sub_I_audioShield+0xe0>)


class SDClass : public FS
{
public:
	SDClass() { }
    1b64:	ldr	r3, [pc, #220]	; (1c44 <_GLOBAL__sub_I_audioShield+0xe4>)
  return state;
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
    1b66:	ldr	r6, [pc, #224]	; (1c48 <_GLOBAL__sub_I_audioShield+0xe8>)
    1b68:	ldr	r2, [pc, #224]	; (1c4c <_GLOBAL__sub_I_audioShield+0xec>)
    1b6a:	ldr	r7, [pc, #228]	; (1c50 <_GLOBAL__sub_I_audioShield+0xf0>)
    1b6c:	str	r2, [r1, #0]
    1b6e:	movs	r5, #10
    1b70:	strb	r5, [r1, #8]
    1b72:	str	r7, [r3, #0]
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    1b74:	movs	r5, #0
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    1b76:	ldr	r0, [pc, #220]	; (1c54 <_GLOBAL__sub_I_audioShield+0xf4>)

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    1b78:	ldr	r4, [pc, #220]	; (1c58 <_GLOBAL__sub_I_audioShield+0xf8>)
    1b7a:	str.w	r0, [r3, #1176]	; 0x498
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    1b7e:	movs	r1, #1
    1b80:	movs	r7, #41	; 0x29
    1b82:	mov	r2, r6
    1b84:	strb.w	r1, [r3, #1185]	; 0x4a1
    1b88:	strb.w	r7, [r3, #1187]	; 0x4a3
    1b8c:	str.w	r5, [r3, #1156]	; 0x484
    1b90:	str.w	r5, [r3, #1160]	; 0x488
    1b94:	strb.w	r5, [r3, #1190]	; 0x4a6
    1b98:	mov	r0, r5
    1b9a:	ldr	r1, [pc, #192]	; (1c5c <_GLOBAL__sub_I_audioShield+0xfc>)
    1b9c:	bl	eb28 <__aeabi_atexit>

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    1ba0:	mvn.w	r7, #1
    1ba4:	ldr	r0, [pc, #184]	; (1c60 <_GLOBAL__sub_I_audioShield+0x100>)

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    1ba6:	ldr	r3, [pc, #188]	; (1c64 <_GLOBAL__sub_I_audioShield+0x104>)
    1ba8:	str	r0, [r4, #0]
  const int nfs = sizeof(lfs_size)/sizeof(int);

  LittleFS_RAM ramfs[nfs]; // needs to be declared if LittleFS is used in storage.h
#endif

MTPStorage_SD storage;
    1baa:	mov	r2, r6
    1bac:	str.w	r7, [r4, #240]	; 0xf0
    1bb0:	ldr	r1, [pc, #180]	; (1c68 <_GLOBAL__sub_I_audioShield+0x108>)
    1bb2:	str.w	r3, [r4, #168]	; 0xa8
    1bb6:	mov.w	r7, #1000	; 0x3e8
    1bba:	mov	r0, r4
    1bbc:	str.w	r7, [r4, #176]	; 0xb0
    1bc0:	str.w	r7, [r4, #196]	; 0xc4
    1bc4:	str.w	r7, [r4, #216]	; 0xd8
    1bc8:	str.w	r3, [r4, #188]	; 0xbc
    1bcc:	str.w	r3, [r4, #208]	; 0xd0
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
    1bd0:	ldr	r7, [pc, #152]	; (1c6c <_GLOBAL__sub_I_audioShield+0x10c>)

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    1bd2:	str	r5, [r4, #4]
    1bd4:	strb.w	r5, [r4, #172]	; 0xac
    1bd8:	strb.w	r5, [r4, #180]	; 0xb4
    1bdc:	str.w	r5, [r4, #184]	; 0xb8
    1be0:	strb.w	r5, [r4, #192]	; 0xc0
    1be4:	strb.w	r5, [r4, #200]	; 0xc8
    1be8:	str.w	r5, [r4, #204]	; 0xcc
    1bec:	strb.w	r5, [r4, #212]	; 0xd4
    1bf0:	strb.w	r5, [r4, #220]	; 0xdc
    1bf4:	str.w	r5, [r4, #224]	; 0xe0

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    1bf8:	str.w	r5, [r4, #228]	; 0xe4
    1bfc:	str.w	r5, [r4, #232]	; 0xe8
    1c00:	str.w	r5, [r4, #236]	; 0xec
    1c04:	str.w	r5, [r4, #244]	; 0xf4
    1c08:	strb.w	r5, [r4, #248]	; 0xf8
    1c0c:	strb.w	r5, [r4, #249]	; 0xf9
    1c10:	bl	eb28 <__aeabi_atexit>

// MTP Responder.
class MTPD {
public:

  explicit MTPD(MTPStorageInterface* storage): storage_(storage) {}
    1c14:	ldr	r3, [pc, #88]	; (1c70 <_GLOBAL__sub_I_audioShield+0x110>)
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
static File mfile;
    1c16:	ldr	r1, [pc, #92]	; (1c74 <_GLOBAL__sub_I_audioShield+0x114>)
    1c18:	ldr	r0, [pc, #92]	; (1c78 <_GLOBAL__sub_I_audioShield+0x118>)
    1c1a:	str	r4, [r3, #0]
    1c1c:	mov	r2, r6
    1c1e:	str	r5, [r3, #4]
    1c20:	strb	r5, [r3, #8]
    1c22:	str	r5, [r3, #12]
    1c24:	bl	eb28 <__aeabi_atexit>
    1c28:	mov	r1, r5
    1c2a:	mov	r0, r7
    1c2c:	bl	e594 <DMAChannel::begin(bool)>
  static uint32_t tdm_rx_buffer[2*NBUF_I2S];
  static uint32_t acq_rx_buffer[NBUF_ACQ];
  #define I2S_DMA_PRIO 6

  #include "DMAChannel.h"
  DMAChannel dma;
    1c30:	mov	r2, r6
    1c32:	mov	r0, r7
    1c34:	ldr	r1, [pc, #68]	; (1c7c <_GLOBAL__sub_I_audioShield+0x11c>)

void SGTL5000_disable(void)
{
  chipWrite(0, CHIP_DIG_POWER, 0); 
  chipWrite(0, CHIP_ANA_POWER, 0); 
}
    1c36:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  static uint32_t tdm_rx_buffer[2*NBUF_I2S];
  static uint32_t acq_rx_buffer[NBUF_ACQ];
  #define I2S_DMA_PRIO 6

  #include "DMAChannel.h"
  DMAChannel dma;
    1c3a:	b.w	eb28 <__aeabi_atexit>
    1c3e:	nop
    1c40:	.word	0x20002b0c
    1c44:	.word	0x1fffc648
    1c48:	.word	0x1fff8a3c
    1c4c:	.word	0x000146b0
    1c50:	.word	0x000142ac
    1c54:	.word	0x38011001
    1c58:	.word	0x1fffbd40
    1c5c:	.word	0x000005c9
    1c60:	.word	0x00014454
    1c64:	.word	0x000141ec
    1c68:	.word	0x00000f55
    1c6c:	.word	0x1fff9730
    1c70:	.word	0x20002af0
    1c74:	.word	0x00000e99
    1c78:	.word	0x1fff8a48
    1c7c:	.word	0x0000077d

00001c80 <chipWrite(int, unsigned int, unsigned int)>:
  val |= Wire.read();
  return val;
}

bool chipWrite(int addr, unsigned int reg, unsigned int val)
{
    1c80:	push	{r3, r4, r5, r6, r7, lr}
  Wire.beginTransmission(SGTL_ADDR[addr]);
    1c82:	ldr	r3, [pc, #80]	; (1cd4 <chipWrite(int, unsigned int, unsigned int)+0x54>)
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    1c84:	ldr	r4, [pc, #80]	; (1cd8 <chipWrite(int, unsigned int, unsigned int)+0x58>)
    1c86:	ldr.w	r3, [r3, r0, lsl #2]
		transmitting = 1;
    1c8a:	movs	r5, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    1c8c:	lsls	r3, r3, #1
  val |= Wire.read();
  return val;
}

bool chipWrite(int addr, unsigned int reg, unsigned int val)
{
    1c8e:	mov	r7, r1
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    1c90:	mov	r0, r4
    1c92:	ubfx	r1, r1, #8, #8
    1c96:	mov	r6, r2
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    1c98:	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    1c9c:	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    1ca0:	strb.w	r5, [r4, #93]	; 0x5d
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    1ca4:	bl	8654 <TwoWire::write(unsigned char)>
    1ca8:	uxtb	r1, r7
    1caa:	mov	r0, r4
    1cac:	bl	8654 <TwoWire::write(unsigned char)>
    1cb0:	ubfx	r1, r6, #8, #8
    1cb4:	mov	r0, r4
    1cb6:	bl	8654 <TwoWire::write(unsigned char)>
    1cba:	uxtb	r1, r6
    1cbc:	mov	r0, r4
    1cbe:	bl	8654 <TwoWire::write(unsigned char)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    1cc2:	mov	r1, r5
    1cc4:	mov	r0, r4
    1cc6:	bl	899c <TwoWire::endTransmission(unsigned char)>
  Wire.write(reg);
  Wire.write(val >> 8);
  Wire.write(val);
  if (Wire.endTransmission() == 0) return true;
  return false;
}
    1cca:	clz	r0, r0
    1cce:	lsrs	r0, r0, #5
    1cd0:	pop	{r3, r4, r5, r6, r7, pc}
    1cd2:	nop
    1cd4:	.word	0x000142cc
    1cd8:	.word	0x1fff8a9c

00001cdc <setup>:
void printTimestamp(uint32_t tt);

#include "TimeLib.h" // for setSyncProvider

void setup()
{ while(!Serial && millis()<3000); 
    1cdc:	push	{r4, r5, r6, lr}
    1cde:	ldr	r1, [pc, #264]	; (1de8 <setup+0x10c>)
    1ce0:	ldr	r2, [pc, #264]	; (1dec <setup+0x110>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1ce2:	ldr	r4, [pc, #268]	; (1df0 <setup+0x114>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1ce4:	ldr	r6, [pc, #268]	; (1df4 <setup+0x118>)
    1ce6:	sub	sp, #8
    1ce8:	movw	r0, #2999	; 0xbb7
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1cec:	ldrb	r3, [r1, #0]
    1cee:	cmp	r3, #0
    1cf0:	beq.n	1dbc <setup+0xe0>
    1cf2:	ldrb	r3, [r4, #0]
    1cf4:	lsls	r3, r3, #31
    1cf6:	bpl.n	1dbc <setup+0xe0>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1cf8:	ldr	r3, [r2, #0]
    1cfa:	ldr	r5, [r6, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1cfc:	subs	r3, r3, r5
    1cfe:	cmp	r3, #14
    1d00:	bls.n	1dbc <setup+0xe0>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1d02:	movs	r1, #10
    1d04:	ldr	r0, [pc, #240]	; (1df8 <setup+0x11c>)
    }

    void acq_setup(void)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
        SIM_SCGC7 |= SIM_SCGC7_DMA;
    1d06:	ldr	r6, [pc, #244]	; (1dfc <setup+0x120>)
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    }
    void acq_stop(void)
    { 
          I2S0_TCSR &= ~(I2S_TCSR_TE | I2S_TCSR_BCE);
    1d08:	ldr	r5, [pc, #244]	; (1e00 <setup+0x124>)

  acq_setup();
  acq_stop();
  acq_init(fsamp);

  audioShield.enable();
    1d0a:	ldr	r4, [pc, #248]	; (1e04 <setup+0x128>)
    1d0c:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1d10:	ldr	r0, [pc, #244]	; (1e08 <setup+0x12c>)
    1d12:	bl	e7bc <Print::println()>
#include "TimeLib.h" // for setSyncProvider

void setup()
{ while(!Serial && millis()<3000); 
  Serial.println("MTP logger");
  setSyncProvider((long int (*)()) rtc_get);
    1d16:	ldr	r0, [pc, #244]	; (1e0c <setup+0x130>)
    1d18:	bl	7fd4 <setSyncProvider(long (*)())>

  printTimestamp(rtc_get());
    1d1c:	bl	d77c <rtc_get>
    1d20:	bl	13d4 <printTimestamp(unsigned long)>

  #if USE_EVENTS==1
    usb_init_events();
    1d24:	bl	76b4 <usb_init_events>
  #endif

  #if !__has_include("usb_mtp.h")
    usb_mtp_configure();
  #endif
  storage_configure();
    1d28:	bl	1028 <storage_configure()>
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    }

    void acq_setup(void)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1d2c:	ldr	r3, [pc, #224]	; (1e10 <setup+0x134>)
  #endif
  storage_configure();

  #if USE_SD==1
    // Set Time callback // needed for SDFat
    FsDateTime::callback = dateTime;
    1d2e:	ldr	r2, [pc, #228]	; (1e14 <setup+0x138>)
    1d30:	ldr	r1, [pc, #228]	; (1e18 <setup+0x13c>)
    1d32:	str	r1, [r2, #0]
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    }

    void acq_setup(void)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1d34:	ldr	r2, [r3, #0]
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    }
    void acq_stop(void)
    { 
          I2S0_TCSR &= ~(I2S_TCSR_TE | I2S_TCSR_BCE);
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    1d36:	ldr	r1, [pc, #228]	; (1e1c <setup+0x140>)
    FsDateTime::callback = dateTime;
  #endif

  acq_setup();
  acq_stop();
  acq_init(fsamp);
    1d38:	ldr	r0, [pc, #228]	; (1e20 <setup+0x144>)
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    }

    void acq_setup(void)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1d3a:	orr.w	r2, r2, #32768	; 0x8000
    1d3e:	str	r2, [r3, #0]
        SIM_SCGC7 |= SIM_SCGC7_DMA;
    1d40:	ldr	r2, [r6, #0]
    1d42:	orr.w	r2, r2, #2
    1d46:	str	r2, [r6, #0]
        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    1d48:	ldr	r2, [r3, #0]
    1d4a:	orr.w	r2, r2, #2
    1d4e:	str	r2, [r3, #0]
          I2S0_TCSR |= (I2S_TCSR_TE | I2S_TCSR_BCE);
          I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
    }
    void acq_stop(void)
    { 
          I2S0_TCSR &= ~(I2S_TCSR_TE | I2S_TCSR_BCE);
    1d50:	ldr	r3, [r5, #0]
    1d52:	bic.w	r3, r3, #2415919104	; 0x90000000
    1d56:	str	r3, [r5, #0]
          I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
    1d58:	ldr	r3, [r1, #0]
    1d5a:	bic.w	r3, r3, #2415919104	; 0x90000000
    1d5e:	str	r3, [r1, #0]
    FsDateTime::callback = dateTime;
  #endif

  acq_setup();
  acq_stop();
  acq_init(fsamp);
    1d60:	bl	1868 <acq_init(long)>

  audioShield.enable();
    1d64:	mov	r0, r4
    1d66:	bl	83b4 <AudioControlSGTL5000::enable()>
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
    1d6a:	mov	r0, r4
    1d6c:	movw	r2, #371	; 0x173
    1d70:	movs	r1, #42	; 0x2a
    1d72:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    1d76:	cbnz	r0, 1dc8 <setup+0xec>
  audioShield.inputSelect(AUDIO_SELECT);  //AUDIO_INPUT_LINEIN or AUDIO_INPUT_MIC

  delay(10);
    1d78:	movs	r0, #10
    1d7a:	bl	d808 <delay>

  //(0: 8kHz, 1: 16 kHz 2:32 kHz, 3:44.1 kHz, 4:48 kHz, 5:96 kHz, 6:192 kHz)

//  write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
//	write(CHIP_I2S_CTRL, 0x0130); // SCLK=32*Fs, 16bit, I2S format
  chipWrite(0, CHIP_CLK_CTRL, (sgtl_mode<<2));  // 256*Fs| sgtl_mode = 0:32 kHz; 1:44.1 kHz; 2:48 kHz; 3:96 kHz
    1d7e:	movs	r2, #12
    1d80:	movs	r1, #4
    1d82:	movs	r0, #0
    1d84:	bl	1c80 <chipWrite(int, unsigned int, unsigned int)>
  delay(10);
  SGTL5000_modification(fsamp); // must be called after I2S initialization stabilized 
  
  
  #if AUDIO_SELECT == AUDIO_INPUT_MIC
    audioShield.micGain(MicGain);
    1d88:	movs	r1, #0
    1d8a:	ldr	r0, [pc, #120]	; (1e04 <setup+0x128>)
    1d8c:	bl	814c <AudioControlSGTL5000::micGain(unsigned int)>
  #endif

  state=-1;
    1d90:	ldr	r3, [pc, #144]	; (1e24 <setup+0x148>)
    1d92:	ldr	r0, [pc, #148]	; (1e28 <setup+0x14c>)
    1d94:	movw	r2, #65535	; 0xffff
    1d98:	movs	r1, #10
    1d9a:	strh	r2, [r3, #0]
    1d9c:	bl	cd84 <usb_serial_write>
    1da0:	ldr	r0, [pc, #100]	; (1e08 <setup+0x12c>)
    1da2:	bl	e7bc <Print::println()>
    1da6:	movs	r1, #67	; 0x43
    1da8:	ldr	r0, [pc, #128]	; (1e2c <setup+0x150>)
    1daa:	bl	cd84 <usb_serial_write>
    1dae:	ldr	r0, [pc, #88]	; (1e08 <setup+0x12c>)
    1db0:	bl	e7bc <Print::println()>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1db4:	bl	ceec <usb_serial_flush_output>

  Serial.println("Setup done");
  Serial.println(" Enter 's' to start, 'q' to stop acquisition and 'r' to restart MTP");
  Serial.flush();
}
    1db8:	add	sp, #8
    1dba:	pop	{r4, r5, r6, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1dbc:	ldr	r3, [r2, #0]
    1dbe:	str	r3, [sp, #4]
	return ret;
    1dc0:	ldr	r3, [sp, #4]
void printTimestamp(uint32_t tt);

#include "TimeLib.h" // for setSyncProvider

void setup()
{ while(!Serial && millis()<3000); 
    1dc2:	cmp	r3, r0
    1dc4:	bls.n	1cec <setup+0x10>
    1dc6:	b.n	1d02 <setup+0x26>
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
    1dc8:	movs	r2, #136	; 0x88
    1dca:	movs	r1, #32
    1dcc:	mov	r0, r4
    1dce:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    1dd2:	cmp	r0, #0
    1dd4:	beq.n	1d78 <setup+0x9c>
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    1dd6:	ldrh	r2, [r4, #6]
    1dd8:	mov	r0, r4
    1dda:	bic.w	r2, r2, #4
    1dde:	movs	r1, #36	; 0x24
    1de0:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    1de4:	b.n	1d78 <setup+0x9c>
    1de6:	nop
    1de8:	.word	0x200031a8
    1dec:	.word	0x200030a4
    1df0:	.word	0x200030a0
    1df4:	.word	0x20003220
    1df8:	.word	0x000143ec
    1dfc:	.word	0x40048040
    1e00:	.word	0x4002f000
    1e04:	.word	0x20002b0c
    1e08:	.word	0x1fff8d50
    1e0c:	.word	0x0000d77d
    1e10:	.word	0x4004803c
    1e14:	.word	0x20002bd8
    1e18:	.word	0x000006e5
    1e1c:	.word	0x4002f080
    1e20:	.word	0x00017700
    1e24:	.word	0x1fffbe46
    1e28:	.word	0x000143f8
    1e2c:	.word	0x00014404

00001e30 <MTPStorage_SD::addFilesystem(FS&, char const*)>:
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    1e30:	ldr	r3, [r0, #4]
    1e32:	cmp	r3, #19
    1e34:	bgt.n	1e46 <MTPStorage_SD::addFilesystem(FS&, char const*)+0x16>

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1e36:	push	{r4}
    1e38:	add.w	r4, r0, r3, lsl #2
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
        sdx[fsCount++] = &fs;
    1e3c:	adds	r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
    1e3e:	str	r2, [r4, #8]
        sdx[fsCount++] = &fs;
    1e40:	str	r3, [r0, #4]
    1e42:	str	r1, [r4, #88]	; 0x58

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1e44:	pop	{r4}
    1e46:	bx	lr

00001e48 <MTPStorage_SD::get_FSCount()>:
  Record ReadIndexRecord(uint32_t i) ;
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
    1e48:	ldr	r0, [r0, #4]
    1e4a:	bx	lr

00001e4c <MTPStorage_SD::get_FSName(unsigned long)>:
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    1e4c:	add.w	r1, r0, r1, lsl #2
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
  const char *get_FSName(uint32_t storage) { return sd_getFSName(storage);}
    1e50:	ldr	r0, [r1, #8]
    1e52:	bx	lr

00001e54 <MTPStorage_SD::readonly(unsigned long)>:

// These should probably be weak.
void mtp_yield() {}
void mtp_lock_storage(bool lock) {}

  bool MTPStorage_SD::readonly(uint32_t store) { return false; }
    1e54:	movs	r0, #0
    1e56:	bx	lr

00001e58 <MTPStorage_SD::has_directories(unsigned long)>:
  bool MTPStorage_SD::has_directories(uint32_t store) { return true; }
    1e58:	movs	r0, #1
    1e5a:	bx	lr

00001e5c <MTPStorage_SD::totalSize(unsigned long)>:
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }

    uint64_t sd_totalSize(uint32_t store) { return sdx[store]->totalSize();  }
    1e5c:	add.w	r1, r0, r1, lsl #2
    1e60:	ldr	r0, [r1, #88]	; 0x58
    1e62:	ldr	r3, [r0, #0]
    1e64:	ldr	r3, [r3, #28]
    1e66:	bx	r3

00001e68 <MTPStorage_SD::usedSize(unsigned long)>:
    uint64_t sd_usedSize(uint32_t store)  { return sdx[store]->usedSize();  }
    1e68:	add.w	r1, r0, r1, lsl #2
    1e6c:	ldr	r0, [r1, #88]	; 0x58
    1e6e:	ldr	r3, [r0, #0]
    1e70:	ldr	r3, [r3, #24]
    1e72:	bx	r3

00001e74 <MTPStorage_SD::write(char const*, unsigned long)>:
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1e74:	ldr.w	r0, [r0, #204]	; 0xcc
    1e78:	cmp	r0, #0
    1e7a:	beq.n	1ee2 <MTPStorage_SD::write(char const*, unsigned long)+0x6e>
    #endif
    return ret;
  }

  size_t MTPStorage_SD::write(const char* data, uint32_t bytes)
  {
    1e7c:	push	{r4, r5, r6}
    1e7e:	ldr	r4, [r0, #0]
    1e80:	ldr	r3, [pc, #108]	; (1ef0 <MTPStorage_SD::write(char const*, unsigned long)+0x7c>)
    1e82:	ldr	r4, [r4, #44]	; 0x2c
    1e84:	cmp	r4, r3
    1e86:	bne.n	1edc <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1e88:	ldr	r0, [r0, #16]
    1e8a:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1e8c:	ldr	r4, [r0, #0]
    1e8e:	ldr	r4, [r4, #44]	; 0x2c
    1e90:	cmp	r4, r3
    1e92:	bne.n	1edc <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1e94:	ldr	r0, [r0, #16]
    1e96:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1e98:	ldr	r4, [r0, #0]
    1e9a:	ldr	r4, [r4, #44]	; 0x2c
    1e9c:	cmp	r4, r3
    1e9e:	bne.n	1edc <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1ea0:	ldr	r0, [r0, #16]
    1ea2:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ea4:	ldr	r4, [r0, #0]
    1ea6:	ldr	r4, [r4, #44]	; 0x2c
    1ea8:	cmp	r4, r3
    1eaa:	bne.n	1edc <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1eac:	ldr	r0, [r0, #16]
    1eae:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1eb0:	mov	r6, r2
    1eb2:	ldr	r2, [r0, #0]
    1eb4:	ldr	r4, [r2, #44]	; 0x2c
    1eb6:	cmp	r4, r3
    1eb8:	mov	r5, r1
    1eba:	bne.n	1ee6 <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    1ebc:	ldr	r0, [r0, #16]
    1ebe:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ec0:	ldr	r2, [r0, #0]
    1ec2:	ldr	r4, [r2, #44]	; 0x2c
    1ec4:	cmp	r4, r3
    1ec6:	bne.n	1ee6 <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    1ec8:	ldr	r0, [r0, #16]
    1eca:	cbz	r0, 1ed6 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ecc:	ldr	r3, [r0, #0]
    1ece:	mov	r2, r6
    1ed0:	ldr	r3, [r3, #44]	; 0x2c
      mtp_lock_storage(true);
      size_t ret = file_.write(data,bytes);
      mtp_lock_storage(false);
      return ret;
  }
    1ed2:	pop	{r4, r5, r6}
    1ed4:	bx	r3
    1ed6:	movs	r0, #0
    1ed8:	pop	{r4, r5, r6}
    1eda:	bx	lr
    1edc:	mov	r3, r4
    1ede:	pop	{r4, r5, r6}
    1ee0:	bx	r3
    1ee2:	movs	r0, #0
    1ee4:	bx	lr
    1ee6:	mov	r2, r6
    1ee8:	mov	r1, r5
    1eea:	mov	r3, r4
    1eec:	pop	{r4, r5, r6}
    1eee:	bx	r3
    1ef0:	.word	0x00000481

00001ef4 <MTPStorage_SD::ResetIndex()>:
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1ef4:	ldr.w	r3, [r0, #184]	; 0xb8
    1ef8:	cmp	r3, #0
    1efa:	beq.n	1f64 <MTPStorage_SD::ResetIndex()+0x70>
    1efc:	ldr	r2, [r3, #0]
    1efe:	ldr	r1, [pc, #108]	; (1f6c <MTPStorage_SD::ResetIndex()+0x78>)
    1f00:	ldr	r2, [r2, #68]	; 0x44
    1f02:	cmp	r2, r1
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    mtp_lock_storage(false);
  }

  void MTPStorage_SD::ResetIndex() {
    1f04:	push	{r4, lr}
    1f06:	mov	r4, r0
    1f08:	bne.n	1f5e <MTPStorage_SD::ResetIndex()+0x6a>
    1f0a:	ldr	r0, [r3, #16]
    1f0c:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    1f0e:	ldr	r3, [r0, #0]
    1f10:	ldr	r3, [r3, #68]	; 0x44
    1f12:	cmp	r3, r2
    1f14:	bne.n	1f66 <MTPStorage_SD::ResetIndex()+0x72>
    1f16:	ldr	r0, [r0, #16]
    1f18:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    1f1a:	ldr	r2, [r0, #0]
    1f1c:	ldr	r2, [r2, #68]	; 0x44
    1f1e:	cmp	r2, r3
    1f20:	bne.n	1f60 <MTPStorage_SD::ResetIndex()+0x6c>
    1f22:	ldr	r0, [r0, #16]
    1f24:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    1f26:	ldr	r3, [r0, #0]
    1f28:	ldr	r3, [r3, #68]	; 0x44
    1f2a:	cmp	r3, r2
    1f2c:	bne.n	1f66 <MTPStorage_SD::ResetIndex()+0x72>
    1f2e:	ldr	r0, [r0, #16]
    1f30:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    1f32:	ldr	r2, [r0, #0]
    1f34:	ldr	r2, [r2, #68]	; 0x44
    1f36:	cmp	r2, r3
    1f38:	bne.n	1f60 <MTPStorage_SD::ResetIndex()+0x6c>
    1f3a:	ldr	r0, [r0, #16]
    1f3c:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    1f3e:	ldr	r3, [r0, #0]
    1f40:	ldr	r3, [r3, #68]	; 0x44
    1f42:	blx	r3
    if(!sd_isOpen(index_)) return;
    1f44:	cbz	r0, 1f5c <MTPStorage_SD::ResetIndex()+0x68>
    CloseIndex();
    1f46:	ldr	r3, [r4, #0]
    1f48:	mov	r0, r4
    1f4a:	ldr	r3, [r3, #64]	; 0x40
    1f4c:	blx	r3
//    OpenIndex();

    all_scanned_ = false;
    1f4e:	movs	r2, #0
    open_file_ = 0xFFFFFFFEUL;
    1f50:	mvn.w	r3, #1
  void MTPStorage_SD::ResetIndex() {
    if(!sd_isOpen(index_)) return;
    CloseIndex();
//    OpenIndex();

    all_scanned_ = false;
    1f54:	strb.w	r2, [r4, #249]	; 0xf9
    open_file_ = 0xFFFFFFFEUL;
    1f58:	str.w	r3, [r4, #240]	; 0xf0
    1f5c:	pop	{r4, pc}
    1f5e:	mov	r0, r3
    1f60:	blx	r2
    1f62:	b.n	1f44 <MTPStorage_SD::ResetIndex()+0x50>
    1f64:	bx	lr
    1f66:	blx	r3
    1f68:	b.n	1f44 <MTPStorage_SD::ResetIndex()+0x50>
    1f6a:	nop
    1f6c:	.word	0x00000501

00001f70 <MTPStorage_SD::CloseIndex()>:

  uint64_t MTPStorage_SD::totalSize(uint32_t store) { return sd_totalSize(store); }
  uint64_t MTPStorage_SD::usedSize(uint32_t store) { return sd_usedSize(store); }

  void MTPStorage_SD::CloseIndex()
  {
    1f70:	push	{r4, lr}
    1f72:	mov	r4, r0
    1f74:	ldr.w	r0, [r0, #184]	; 0xb8
    1f78:	cmp	r0, #0
    1f7a:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1f7c:	ldr	r3, [r0, #0]
    1f7e:	ldr	r2, [pc, #256]	; (2080 <MTPStorage_SD::CloseIndex()+0x110>)
    1f80:	ldr	r3, [r3, #68]	; 0x44
    1f82:	cmp	r3, r2
    1f84:	bne.n	2068 <MTPStorage_SD::CloseIndex()+0xf8>
    1f86:	ldr	r0, [r0, #16]
    1f88:	cmp	r0, #0
    1f8a:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1f8c:	ldr	r2, [r0, #0]
    1f8e:	ldr	r2, [r2, #68]	; 0x44
    1f90:	cmp	r2, r3
    1f92:	bne.n	207a <MTPStorage_SD::CloseIndex()+0x10a>
    1f94:	ldr	r0, [r0, #16]
    1f96:	cmp	r0, #0
    1f98:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1f9a:	ldr	r3, [r0, #0]
    1f9c:	ldr	r3, [r3, #68]	; 0x44
    1f9e:	cmp	r3, r2
    1fa0:	bne.n	2068 <MTPStorage_SD::CloseIndex()+0xf8>
    1fa2:	ldr	r0, [r0, #16]
    1fa4:	cmp	r0, #0
    1fa6:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1fa8:	ldr	r2, [r0, #0]
    1faa:	ldr	r2, [r2, #68]	; 0x44
    1fac:	cmp	r2, r3
    1fae:	bne.n	207a <MTPStorage_SD::CloseIndex()+0x10a>
    1fb0:	ldr	r0, [r0, #16]
    1fb2:	cmp	r0, #0
    1fb4:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1fb6:	ldr	r3, [r0, #0]
    1fb8:	ldr	r3, [r3, #68]	; 0x44
    1fba:	cmp	r3, r2
    1fbc:	bne.n	2068 <MTPStorage_SD::CloseIndex()+0xf8>
    1fbe:	ldr	r0, [r0, #16]
    1fc0:	cmp	r0, #0
    1fc2:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1fc4:	ldr	r3, [r0, #0]
    1fc6:	ldr	r3, [r3, #68]	; 0x44
    1fc8:	blx	r3
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    1fca:	cmp	r0, #0
    1fcc:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    1fce:	ldr.w	r0, [r4, #184]	; 0xb8
    1fd2:	cmp	r0, #0
    1fd4:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1fd6:	ldr	r2, [r0, #0]
    1fd8:	ldr	r3, [pc, #168]	; (2084 <MTPStorage_SD::CloseIndex()+0x114>)
    1fda:	ldr	r2, [r2, #64]	; 0x40
    1fdc:	cmp	r2, r3
    1fde:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    1fe0:	ldr	r0, [r0, #16]
    1fe2:	cmp	r0, #0
    1fe4:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1fe6:	ldr	r2, [r0, #0]
    1fe8:	ldr	r2, [r2, #64]	; 0x40
    1fea:	cmp	r2, r3
    1fec:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    1fee:	ldr	r0, [r0, #16]
    1ff0:	cmp	r0, #0
    1ff2:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    1ff4:	ldr	r2, [r0, #0]
    1ff6:	ldr	r2, [r2, #64]	; 0x40
    1ff8:	cmp	r2, r3
    1ffa:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    1ffc:	ldr	r0, [r0, #16]
    1ffe:	cmp	r0, #0
    2000:	beq.n	205c <MTPStorage_SD::CloseIndex()+0xec>
    2002:	ldr	r2, [r0, #0]
    2004:	ldr	r2, [r2, #64]	; 0x40
    2006:	cmp	r2, r3
    2008:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    200a:	ldr	r0, [r0, #16]
    200c:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    200e:	ldr	r2, [r0, #0]
    2010:	ldr	r2, [r2, #64]	; 0x40
    2012:	cmp	r2, r3
    2014:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    2016:	ldr	r0, [r0, #16]
    2018:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    201a:	ldr	r2, [r0, #0]
    201c:	ldr	r2, [r2, #64]	; 0x40
    201e:	cmp	r2, r3
    2020:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    2022:	ldr	r0, [r0, #16]
    2024:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    2026:	ldr	r2, [r0, #0]
    2028:	ldr	r2, [r2, #64]	; 0x40
    202a:	cmp	r2, r3
    202c:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    202e:	ldr	r0, [r0, #16]
    2030:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    2032:	ldr	r2, [r0, #0]
    2034:	ldr	r2, [r2, #64]	; 0x40
    2036:	cmp	r2, r3
    2038:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    203a:	ldr	r0, [r0, #16]
    203c:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    203e:	ldr	r2, [r0, #0]
    2040:	ldr	r2, [r2, #64]	; 0x40
    2042:	cmp	r2, r3
    2044:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    2046:	ldr	r0, [r0, #16]
    2048:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    204a:	ldr	r2, [r0, #0]
    204c:	ldr	r2, [r2, #64]	; 0x40
    204e:	cmp	r2, r3
    2050:	bne.n	206c <MTPStorage_SD::CloseIndex()+0xfc>
    2052:	ldr	r0, [r0, #16]
    2054:	cbz	r0, 205c <MTPStorage_SD::CloseIndex()+0xec>
    2056:	ldr	r3, [r0, #0]
    2058:	ldr	r3, [r3, #64]	; 0x40
    205a:	blx	r3
    mtp_lock_storage(false);
    index_generated = false;
    205c:	movs	r3, #0
    205e:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    2062:	str.w	r3, [r4, #244]	; 0xf4
    2066:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2068:	blx	r3
    206a:	b.n	1fca <MTPStorage_SD::CloseIndex()+0x5a>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    206c:	blx	r2
  void MTPStorage_SD::CloseIndex()
  {
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    mtp_lock_storage(false);
    index_generated = false;
    206e:	movs	r3, #0
    2070:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    2074:	str.w	r3, [r4, #244]	; 0xf4
    2078:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    207a:	blx	r2
    207c:	b.n	1fca <MTPStorage_SD::CloseIndex()+0x5a>
    207e:	nop
    2080:	.word	0x00000501
    2084:	.word	0x000004f5

00002088 <File::invalidate() [clone .isra.1]>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2088:	ldr	r2, [r0, #0]
    208a:	cmp	r2, #0
    208c:	beq.n	2108 <File::invalidate() [clone .isra.1]+0x80>
    208e:	ldr	r3, [r2, #16]
    2090:	subs	r3, #1
    2092:	str	r3, [r2, #16]
    2094:	cmp	r3, #0
    2096:	bne.n	2108 <File::invalidate() [clone .isra.1]+0x80>
	}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
    2098:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (f && --(f->refcount) == 0) delete f;
    209c:	ldr	r4, [r0, #0]
    209e:	cmp	r4, #0
    20a0:	beq.n	210a <File::invalidate() [clone .isra.1]+0x82>
    20a2:	ldr	r3, [r4, #0]
    20a4:	ldr	r1, [pc, #120]	; (2120 <File::invalidate() [clone .isra.1]+0x98>)
    20a6:	ldr	r3, [r3, #32]
    20a8:	cmp	r3, r1
    20aa:	bne.n	210e <File::invalidate() [clone .isra.1]+0x86>
    20ac:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    20ae:	ldr	r6, [pc, #116]	; (2124 <File::invalidate() [clone .isra.1]+0x9c>)
    20b0:	str	r6, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    20b2:	cbz	r2, 20fc <File::invalidate() [clone .isra.1]+0x74>
    20b4:	ldr	r3, [r2, #16]
    20b6:	subs	r3, #1
    20b8:	str	r3, [r2, #16]
    20ba:	cbnz	r3, 20fc <File::invalidate() [clone .isra.1]+0x74>
    20bc:	ldr	r5, [r4, #16]
    20be:	cbz	r5, 20fc <File::invalidate() [clone .isra.1]+0x74>
    20c0:	ldr	r3, [r5, #0]
    20c2:	ldr	r3, [r3, #32]
    20c4:	cmp	r3, r1
    20c6:	bne.n	2116 <File::invalidate() [clone .isra.1]+0x8e>
    20c8:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    20ca:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    20cc:	cbz	r2, 20f4 <File::invalidate() [clone .isra.1]+0x6c>
    20ce:	ldr	r3, [r2, #16]
    20d0:	subs	r3, #1
    20d2:	str	r3, [r2, #16]
    20d4:	cbnz	r3, 20f4 <File::invalidate() [clone .isra.1]+0x6c>
    20d6:	ldr	r7, [r5, #16]
    20d8:	cbz	r7, 20f4 <File::invalidate() [clone .isra.1]+0x6c>
    20da:	ldr	r3, [r7, #0]
    20dc:	ldr	r3, [r3, #32]
    20de:	cmp	r3, r1
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    20e0:	mov	r0, r7
    20e2:	bne.n	211c <File::invalidate() [clone .isra.1]+0x94>
    20e4:	str.w	r6, [r0], #16
		invalidate();
    20e8:	bl	2088 <File::invalidate() [clone .isra.1]>
	}
    20ec:	mov	r0, r7
    20ee:	movs	r1, #20
    20f0:	bl	e960 <operator delete(void*, unsigned int)>
    20f4:	mov	r0, r5
    20f6:	movs	r1, #20
    20f8:	bl	e960 <operator delete(void*, unsigned int)>
    20fc:	mov	r0, r4
    20fe:	movs	r1, #20
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
	}
    2100:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2104:	b.w	e960 <operator delete(void*, unsigned int)>
    2108:	bx	lr
    210a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    210e:	mov	r0, r4
	}
    2110:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2114:	bx	r3
    2116:	mov	r0, r5
    2118:	blx	r3
    211a:	b.n	20fc <File::invalidate() [clone .isra.1]+0x74>
    211c:	blx	r3
    211e:	b.n	20f4 <File::invalidate() [clone .isra.1]+0x6c>
    2120:	.word	0x00000f25
    2124:	.word	0x000141ec

00002128 <mtp_yield()>:
//   support serialflash
//   partial object fetch/receive
//   events (notify usb host when local storage changes) (But, this seems too difficult)

// These should probably be weak.
void mtp_yield() {}
    2128:	bx	lr
    212a:	nop

0000212c <MTPStorage_SD::OpenIndex()>:
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    212c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2130:	mov	r4, r0
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2132:	ldr.w	r0, [r0, #184]	; 0xb8
    2136:	sub	sp, #28
    2138:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    213a:	ldr	r3, [r0, #0]
    213c:	ldr	r2, [pc, #536]	; (2358 <MTPStorage_SD::OpenIndex()+0x22c>)
    213e:	ldr	r3, [r3, #68]	; 0x44
    2140:	cmp	r3, r2
    2142:	bne.w	245c <MTPStorage_SD::OpenIndex()+0x330>
    2146:	ldr	r0, [r0, #16]
    2148:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    214a:	ldr	r2, [r0, #0]
    214c:	ldr	r2, [r2, #68]	; 0x44
    214e:	cmp	r2, r3
    2150:	bne.w	2470 <MTPStorage_SD::OpenIndex()+0x344>
    2154:	ldr	r0, [r0, #16]
    2156:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    2158:	ldr	r3, [r0, #0]
    215a:	ldr	r3, [r3, #68]	; 0x44
    215c:	cmp	r3, r2
    215e:	bne.w	245c <MTPStorage_SD::OpenIndex()+0x330>
    2162:	ldr	r0, [r0, #16]
    2164:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    2166:	ldr	r2, [r0, #0]
    2168:	ldr	r2, [r2, #68]	; 0x44
    216a:	cmp	r2, r3
    216c:	bne.w	2470 <MTPStorage_SD::OpenIndex()+0x344>
    2170:	ldr	r0, [r0, #16]
    2172:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    2174:	ldr	r3, [r0, #0]
    2176:	ldr	r3, [r3, #68]	; 0x44
    2178:	cmp	r3, r2
    217a:	bne.w	245c <MTPStorage_SD::OpenIndex()+0x330>
    217e:	ldr	r0, [r0, #16]
    2180:	cbz	r0, 218c <MTPStorage_SD::OpenIndex()+0x60>
    2182:	ldr	r3, [r0, #0]
    2184:	ldr	r3, [r3, #68]	; 0x44
    2186:	blx	r3
    2188:	cmp	r0, #0
    218a:	bne.n	2260 <MTPStorage_SD::OpenIndex()+0x134>
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    218c:	ldr	r1, [r4, #88]	; 0x58
    218e:	ldr	r2, [pc, #460]	; (235c <MTPStorage_SD::OpenIndex()+0x230>)
    2190:	ldr	r3, [r1, #0]
    2192:	add	r0, sp, #4
    2194:	ldr	r5, [r3, #0]
    2196:	movs	r3, #2
    2198:	blx	r5
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    219a:	ldr.w	r3, [r4, #184]	; 0xb8
    219e:	cbz	r3, 21ac <MTPStorage_SD::OpenIndex()+0x80>
    21a0:	ldr	r2, [r3, #16]
    21a2:	subs	r2, #1
    21a4:	str	r2, [r3, #16]
    21a6:	cmp	r2, #0
    21a8:	beq.w	2370 <MTPStorage_SD::OpenIndex()+0x244>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    21ac:	ldr	r3, [sp, #20]
    21ae:	str.w	r3, [r4, #184]	; 0xb8
		if (f) f->refcount++;
    21b2:	cbz	r3, 21cc <MTPStorage_SD::OpenIndex()+0xa0>
    21b4:	ldr	r2, [r3, #16]
		return *this;
	}
	virtual ~File() {
    21b6:	ldr	r1, [pc, #424]	; (2360 <MTPStorage_SD::OpenIndex()+0x234>)
    21b8:	str	r1, [sp, #4]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    21ba:	adds	r2, #1
    21bc:	str	r2, [r3, #16]
    21be:	ldr	r2, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    21c0:	cbz	r2, 21cc <MTPStorage_SD::OpenIndex()+0xa0>
    21c2:	ldr	r3, [r2, #16]
    21c4:	subs	r3, #1
    21c6:	str	r3, [r2, #16]
    21c8:	cmp	r3, #0
    21ca:	beq.n	2266 <MTPStorage_SD::OpenIndex()+0x13a>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    21cc:	ldr.w	r0, [r4, #184]	; 0xb8
    21d0:	cmp	r0, #0
    21d2:	beq.n	2252 <MTPStorage_SD::OpenIndex()+0x126>
    21d4:	ldr	r2, [r0, #0]
    21d6:	ldr	r3, [pc, #384]	; (2358 <MTPStorage_SD::OpenIndex()+0x22c>)
    21d8:	ldr	r2, [r2, #68]	; 0x44
    21da:	cmp	r2, r3
    21dc:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    21e0:	ldr	r0, [r0, #16]
    21e2:	cmp	r0, #0
    21e4:	beq.n	2252 <MTPStorage_SD::OpenIndex()+0x126>
    21e6:	ldr	r2, [r0, #0]
    21e8:	ldr	r2, [r2, #68]	; 0x44
    21ea:	cmp	r2, r3
    21ec:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    21f0:	ldr	r0, [r0, #16]
    21f2:	cmp	r0, #0
    21f4:	beq.n	2252 <MTPStorage_SD::OpenIndex()+0x126>
    21f6:	ldr	r2, [r0, #0]
    21f8:	ldr	r2, [r2, #68]	; 0x44
    21fa:	cmp	r2, r3
    21fc:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    2200:	ldr	r0, [r0, #16]
    2202:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    2204:	ldr	r2, [r0, #0]
    2206:	ldr	r2, [r2, #68]	; 0x44
    2208:	cmp	r2, r3
    220a:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    220e:	ldr	r0, [r0, #16]
    2210:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    2212:	ldr	r2, [r0, #0]
    2214:	ldr	r2, [r2, #68]	; 0x44
    2216:	cmp	r2, r3
    2218:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    221c:	ldr	r0, [r0, #16]
    221e:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    2220:	ldr	r2, [r0, #0]
    2222:	ldr	r2, [r2, #68]	; 0x44
    2224:	cmp	r2, r3
    2226:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    222a:	ldr	r0, [r0, #16]
    222c:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    222e:	ldr	r2, [r0, #0]
    2230:	ldr	r2, [r2, #68]	; 0x44
    2232:	cmp	r2, r3
    2234:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    2238:	ldr	r0, [r0, #16]
    223a:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    223c:	ldr	r2, [r0, #0]
    223e:	ldr	r2, [r2, #68]	; 0x44
    2240:	cmp	r2, r3
    2242:	bne.w	2466 <MTPStorage_SD::OpenIndex()+0x33a>
    2246:	ldr	r0, [r0, #16]
    2248:	cbz	r0, 2252 <MTPStorage_SD::OpenIndex()+0x126>
    224a:	ldr	r3, [r0, #0]
    224c:	ldr	r3, [r3, #68]	; 0x44
    224e:	blx	r3
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    2250:	cbnz	r0, 2260 <MTPStorage_SD::OpenIndex()+0x134>
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    2252:	movs	r1, #22
    2254:	ldr	r0, [pc, #268]	; (2364 <MTPStorage_SD::OpenIndex()+0x238>)
    2256:	bl	cd84 <usb_serial_write>
    225a:	ldr	r0, [pc, #268]	; (2368 <MTPStorage_SD::OpenIndex()+0x23c>)
    225c:	bl	e7bc <Print::println()>
    mtp_lock_storage(false);
  }
    2260:	add	sp, #28
    2262:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2266:	ldr	r5, [sp, #20]
    2268:	cmp	r5, #0
    226a:	beq.n	21cc <MTPStorage_SD::OpenIndex()+0xa0>
    226c:	ldr	r2, [r5, #0]
    226e:	ldr	r3, [pc, #252]	; (236c <MTPStorage_SD::OpenIndex()+0x240>)
    2270:	ldr	r2, [r2, #32]
    2272:	cmp	r2, r3
    2274:	bne.w	2480 <MTPStorage_SD::OpenIndex()+0x354>
    2278:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    227a:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    227c:	cmp	r0, #0
    227e:	beq.n	234e <MTPStorage_SD::OpenIndex()+0x222>
    2280:	ldr	r2, [r0, #16]
    2282:	subs	r2, #1
    2284:	str	r2, [r0, #16]
    2286:	cmp	r2, #0
    2288:	bne.n	234e <MTPStorage_SD::OpenIndex()+0x222>
    228a:	ldr	r6, [r5, #16]
    228c:	cmp	r6, #0
    228e:	beq.n	234e <MTPStorage_SD::OpenIndex()+0x222>
    2290:	ldr	r2, [r6, #0]
    2292:	ldr	r2, [r2, #32]
    2294:	cmp	r2, r3
    2296:	bne.w	2486 <MTPStorage_SD::OpenIndex()+0x35a>
    229a:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    229c:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    229e:	cmp	r0, #0
    22a0:	beq.n	2346 <MTPStorage_SD::OpenIndex()+0x21a>
    22a2:	ldr	r2, [r0, #16]
    22a4:	subs	r2, #1
    22a6:	str	r2, [r0, #16]
    22a8:	cmp	r2, #0
    22aa:	bne.n	2346 <MTPStorage_SD::OpenIndex()+0x21a>
    22ac:	ldr	r7, [r6, #16]
    22ae:	cmp	r7, #0
    22b0:	beq.n	2346 <MTPStorage_SD::OpenIndex()+0x21a>
    22b2:	ldr	r2, [r7, #0]
    22b4:	ldr	r2, [r2, #32]
    22b6:	cmp	r2, r3
    22b8:	bne.w	2498 <MTPStorage_SD::OpenIndex()+0x36c>
    22bc:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22be:	str	r1, [r7, #0]
    22c0:	ldr.w	lr, [pc, #156]	; 2360 <MTPStorage_SD::OpenIndex()+0x234>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22c4:	cmp	r0, #0
    22c6:	beq.n	233e <MTPStorage_SD::OpenIndex()+0x212>
    22c8:	ldr	r2, [r0, #16]
    22ca:	subs	r2, #1
    22cc:	str	r2, [r0, #16]
    22ce:	cmp	r2, #0
    22d0:	bne.n	233e <MTPStorage_SD::OpenIndex()+0x212>
    22d2:	ldr.w	r8, [r7, #16]
    22d6:	cmp.w	r8, #0
    22da:	beq.n	233e <MTPStorage_SD::OpenIndex()+0x212>
    22dc:	ldr.w	r2, [r8]
    22e0:	ldr	r2, [r2, #32]
    22e2:	cmp	r2, r3
    22e4:	bne.w	24a4 <MTPStorage_SD::OpenIndex()+0x378>
    22e8:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22ec:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22f0:	cbz	r0, 2336 <MTPStorage_SD::OpenIndex()+0x20a>
    22f2:	ldr	r2, [r0, #16]
    22f4:	subs	r2, #1
    22f6:	str	r2, [r0, #16]
    22f8:	cbnz	r2, 2336 <MTPStorage_SD::OpenIndex()+0x20a>
    22fa:	ldr.w	r9, [r8, #16]
    22fe:	cmp.w	r9, #0
    2302:	beq.n	2336 <MTPStorage_SD::OpenIndex()+0x20a>
    2304:	ldr.w	r2, [r9]
    2308:	ldr	r2, [r2, #32]
    230a:	cmp	r2, r3
    230c:	bne.w	24b0 <MTPStorage_SD::OpenIndex()+0x384>
    2310:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2314:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2318:	cbz	r2, 232e <MTPStorage_SD::OpenIndex()+0x202>
    231a:	ldr	r3, [r2, #16]
    231c:	subs	r3, #1
    231e:	str	r3, [r2, #16]
    2320:	cbnz	r3, 232e <MTPStorage_SD::OpenIndex()+0x202>
    2322:	ldr.w	r0, [r9, #16]
    2326:	cbz	r0, 232e <MTPStorage_SD::OpenIndex()+0x202>
    2328:	ldr	r3, [r0, #0]
    232a:	ldr	r3, [r3, #32]
    232c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    232e:	mov	r0, r9
    2330:	movs	r1, #20
    2332:	bl	e960 <operator delete(void*, unsigned int)>
    2336:	mov	r0, r8
    2338:	movs	r1, #20
    233a:	bl	e960 <operator delete(void*, unsigned int)>
    233e:	mov	r0, r7
    2340:	movs	r1, #20
    2342:	bl	e960 <operator delete(void*, unsigned int)>
    2346:	mov	r0, r6
    2348:	movs	r1, #20
    234a:	bl	e960 <operator delete(void*, unsigned int)>
    234e:	mov	r0, r5
    2350:	movs	r1, #20
    2352:	bl	e960 <operator delete(void*, unsigned int)>
    2356:	b.n	21cc <MTPStorage_SD::OpenIndex()+0xa0>
    2358:	.word	0x00000501
    235c:	.word	0x000144ac
    2360:	.word	0x000141ec
    2364:	.word	0x000144bc
    2368:	.word	0x1fff8d50
    236c:	.word	0x00000f25
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2370:	ldr.w	r5, [r4, #184]	; 0xb8
    2374:	cmp	r5, #0
    2376:	beq.w	21ac <MTPStorage_SD::OpenIndex()+0x80>
    237a:	ldr	r2, [r5, #0]
    237c:	ldr	r3, [pc, #312]	; (24b8 <MTPStorage_SD::OpenIndex()+0x38c>)
    237e:	ldr	r2, [r2, #32]
    2380:	cmp	r2, r3
    2382:	bne.n	247a <MTPStorage_SD::OpenIndex()+0x34e>
    2384:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2386:	ldr	r1, [pc, #308]	; (24bc <MTPStorage_SD::OpenIndex()+0x390>)
    2388:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    238a:	cmp	r0, #0
    238c:	beq.n	2452 <MTPStorage_SD::OpenIndex()+0x326>
    238e:	ldr	r2, [r0, #16]
    2390:	subs	r2, #1
    2392:	str	r2, [r0, #16]
    2394:	cmp	r2, #0
    2396:	bne.n	2452 <MTPStorage_SD::OpenIndex()+0x326>
    2398:	ldr	r6, [r5, #16]
    239a:	cmp	r6, #0
    239c:	beq.n	2452 <MTPStorage_SD::OpenIndex()+0x326>
    239e:	ldr	r2, [r6, #0]
    23a0:	ldr	r2, [r2, #32]
    23a2:	cmp	r2, r3
    23a4:	bne.n	248c <MTPStorage_SD::OpenIndex()+0x360>
    23a6:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23a8:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23aa:	cmp	r0, #0
    23ac:	beq.n	244a <MTPStorage_SD::OpenIndex()+0x31e>
    23ae:	ldr	r2, [r0, #16]
    23b0:	subs	r2, #1
    23b2:	str	r2, [r0, #16]
    23b4:	cmp	r2, #0
    23b6:	bne.n	244a <MTPStorage_SD::OpenIndex()+0x31e>
    23b8:	ldr	r7, [r6, #16]
    23ba:	cmp	r7, #0
    23bc:	beq.n	244a <MTPStorage_SD::OpenIndex()+0x31e>
    23be:	ldr	r2, [r7, #0]
    23c0:	ldr	r2, [r2, #32]
    23c2:	cmp	r2, r3
    23c4:	bne.n	2492 <MTPStorage_SD::OpenIndex()+0x366>
    23c6:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23c8:	str	r1, [r7, #0]
    23ca:	ldr.w	lr, [pc, #240]	; 24bc <MTPStorage_SD::OpenIndex()+0x390>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23ce:	cmp	r0, #0
    23d0:	beq.n	2442 <MTPStorage_SD::OpenIndex()+0x316>
    23d2:	ldr	r2, [r0, #16]
    23d4:	subs	r2, #1
    23d6:	str	r2, [r0, #16]
    23d8:	cbnz	r2, 2442 <MTPStorage_SD::OpenIndex()+0x316>
    23da:	ldr.w	r8, [r7, #16]
    23de:	cmp.w	r8, #0
    23e2:	beq.n	2442 <MTPStorage_SD::OpenIndex()+0x316>
    23e4:	ldr.w	r2, [r8]
    23e8:	ldr	r2, [r2, #32]
    23ea:	cmp	r2, r3
    23ec:	bne.n	249e <MTPStorage_SD::OpenIndex()+0x372>
    23ee:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23f2:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23f6:	cbz	r0, 243a <MTPStorage_SD::OpenIndex()+0x30e>
    23f8:	ldr	r2, [r0, #16]
    23fa:	subs	r2, #1
    23fc:	str	r2, [r0, #16]
    23fe:	cbnz	r2, 243a <MTPStorage_SD::OpenIndex()+0x30e>
    2400:	ldr.w	r9, [r8, #16]
    2404:	cmp.w	r9, #0
    2408:	beq.n	243a <MTPStorage_SD::OpenIndex()+0x30e>
    240a:	ldr.w	r2, [r9]
    240e:	ldr	r2, [r2, #32]
    2410:	cmp	r2, r3
    2412:	bne.n	24aa <MTPStorage_SD::OpenIndex()+0x37e>
    2414:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2418:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    241c:	cbz	r2, 2432 <MTPStorage_SD::OpenIndex()+0x306>
    241e:	ldr	r3, [r2, #16]
    2420:	subs	r3, #1
    2422:	str	r3, [r2, #16]
    2424:	cbnz	r3, 2432 <MTPStorage_SD::OpenIndex()+0x306>
    2426:	ldr.w	r0, [r9, #16]
    242a:	cbz	r0, 2432 <MTPStorage_SD::OpenIndex()+0x306>
    242c:	ldr	r3, [r0, #0]
    242e:	ldr	r3, [r3, #32]
    2430:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2432:	mov	r0, r9
    2434:	movs	r1, #20
    2436:	bl	e960 <operator delete(void*, unsigned int)>
    243a:	mov	r0, r8
    243c:	movs	r1, #20
    243e:	bl	e960 <operator delete(void*, unsigned int)>
    2442:	mov	r0, r7
    2444:	movs	r1, #20
    2446:	bl	e960 <operator delete(void*, unsigned int)>
    244a:	mov	r0, r6
    244c:	movs	r1, #20
    244e:	bl	e960 <operator delete(void*, unsigned int)>
    2452:	mov	r0, r5
    2454:	movs	r1, #20
    2456:	bl	e960 <operator delete(void*, unsigned int)>
    245a:	b.n	21ac <MTPStorage_SD::OpenIndex()+0x80>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    245c:	blx	r3
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    245e:	cmp	r0, #0
    2460:	bne.w	2260 <MTPStorage_SD::OpenIndex()+0x134>
    2464:	b.n	218c <MTPStorage_SD::OpenIndex()+0x60>
    2466:	blx	r2
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    2468:	cmp	r0, #0
    246a:	bne.w	2260 <MTPStorage_SD::OpenIndex()+0x134>
    246e:	b.n	2252 <MTPStorage_SD::OpenIndex()+0x126>
    2470:	blx	r2
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    2472:	cmp	r0, #0
    2474:	bne.w	2260 <MTPStorage_SD::OpenIndex()+0x134>
    2478:	b.n	218c <MTPStorage_SD::OpenIndex()+0x60>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    247a:	mov	r0, r5
    247c:	blx	r2
    247e:	b.n	21ac <MTPStorage_SD::OpenIndex()+0x80>
    2480:	mov	r0, r5
    2482:	blx	r2
    2484:	b.n	21cc <MTPStorage_SD::OpenIndex()+0xa0>
    2486:	mov	r0, r6
    2488:	blx	r2
    248a:	b.n	234e <MTPStorage_SD::OpenIndex()+0x222>
    248c:	mov	r0, r6
    248e:	blx	r2
    2490:	b.n	2452 <MTPStorage_SD::OpenIndex()+0x326>
    2492:	mov	r0, r7
    2494:	blx	r2
    2496:	b.n	244a <MTPStorage_SD::OpenIndex()+0x31e>
    2498:	mov	r0, r7
    249a:	blx	r2
    249c:	b.n	2346 <MTPStorage_SD::OpenIndex()+0x21a>
    249e:	mov	r0, r8
    24a0:	blx	r2
    24a2:	b.n	2442 <MTPStorage_SD::OpenIndex()+0x316>
    24a4:	mov	r0, r8
    24a6:	blx	r2
    24a8:	b.n	233e <MTPStorage_SD::OpenIndex()+0x212>
    24aa:	mov	r0, r9
    24ac:	blx	r2
    24ae:	b.n	243a <MTPStorage_SD::OpenIndex()+0x30e>
    24b0:	mov	r0, r9
    24b2:	blx	r2
    24b4:	b.n	2336 <MTPStorage_SD::OpenIndex()+0x20a>
    24b6:	nop
    24b8:	.word	0x00000f25
    24bc:	.word	0x000141ec

000024c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>:
    all_scanned_ = false;
    open_file_ = 0xFFFFFFFEUL;
  }

  void MTPStorage_SD::WriteIndexRecord(uint32_t i, const Record& r) 
  { OpenIndex();
    24c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    24c4:	mov	r6, r0
    24c6:	sub	sp, #12
    24c8:	mov	r4, r1
    24ca:	mov	r7, r2
    24cc:	bl	212c <MTPStorage_SD::OpenIndex()>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    24d0:	ldr.w	r5, [r6, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek((sizeof(r) * i));
    24d4:	add.w	r4, r4, r4, lsl #4
    24d8:	cmp	r5, #0
    24da:	beq.n	25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    24dc:	ldr	r0, [r5, #0]
    24de:	ldr	r1, [pc, #308]	; (2614 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x154>)
    24e0:	lsls	r2, r4, #4
    24e2:	ldr	r4, [r0, #52]	; 0x34
    24e4:	cmp	r4, r1
    24e6:	mov.w	ip, #0
    24ea:	bne.n	25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x11a>
    24ec:	ldr	r1, [r5, #16]
    24ee:	cmp	r1, #0
    24f0:	beq.n	25aa <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xea>
    24f2:	ldr	r3, [r1, #0]
    24f4:	ldr.w	r8, [r3, #52]	; 0x34
    24f8:	cmp	r8, r4
    24fa:	bne.n	25e6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x126>
    24fc:	ldr.w	lr, [r1, #16]
    2500:	cmp.w	lr, #0
    2504:	beq.n	25b8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    2506:	ldr.w	r4, [lr]
    250a:	ldr	r4, [r4, #52]	; 0x34
    250c:	cmp	r4, r8
    250e:	bne.n	25f2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x132>
    2510:	ldr.w	lr, [lr, #16]
    2514:	cmp.w	lr, #0
    2518:	beq.n	25b8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    251a:	ldr.w	r3, [lr]
    251e:	ldr.w	r8, [r3, #52]	; 0x34
    2522:	cmp	r8, r4
    2524:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x13e>
    2526:	ldr.w	r4, [lr, #16]
    252a:	cmp	r4, #0
    252c:	beq.n	25b8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    252e:	ldr	r3, [r4, #0]
    2530:	ldr.w	r9, [r3, #52]	; 0x34
    2534:	cmp	r9, r8
    2536:	bne.n	260a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x14a>
    2538:	ldr	r4, [r4, #16]
    253a:	cmp	r4, #0
    253c:	beq.n	25b8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    253e:	ldr	r1, [r4, #0]
    2540:	str.w	ip, [sp]
    2544:	mov	r3, ip
    2546:	mov	r0, r4
    2548:	ldr	r1, [r1, #52]	; 0x34
    254a:	blx	r1
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    254c:	ldr.w	r5, [r6, #184]	; 0xb8
    2550:	cmp	r5, #0
    2552:	beq.n	25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2554:	ldr	r2, [r5, #0]
    2556:	ldr	r3, [pc, #192]	; (2618 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    2558:	ldr	r4, [r2, #44]	; 0x2c
    255a:	cmp	r4, r3
    255c:	bne.n	25c4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    255e:	ldr	r0, [r5, #16]
    2560:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2562:	ldr	r2, [r0, #0]
    2564:	ldr	r4, [r2, #44]	; 0x2c
    2566:	cmp	r4, r3
    2568:	bne.n	25d6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    256a:	ldr	r0, [r0, #16]
    256c:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    256e:	ldr	r2, [r0, #0]
    2570:	ldr	r4, [r2, #44]	; 0x2c
    2572:	cmp	r4, r3
    2574:	bne.n	25d6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    2576:	ldr	r0, [r0, #16]
    2578:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    257a:	ldr	r2, [r0, #0]
    257c:	ldr	r4, [r2, #44]	; 0x2c
    257e:	cmp	r4, r3
    2580:	bne.n	25d6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    2582:	ldr	r0, [r0, #16]
    2584:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2586:	ldr	r2, [r0, #0]
    2588:	ldr	r4, [r2, #44]	; 0x2c
    258a:	cmp	r4, r3
    258c:	bne.n	25d6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    258e:	ldr	r0, [r0, #16]
    2590:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2592:	ldr	r2, [r0, #0]
    2594:	ldr	r4, [r2, #44]	; 0x2c
    2596:	cmp	r4, r3
    2598:	bne.n	25d6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    259a:	ldr	r0, [r0, #16]
    259c:	cbz	r0, 25b2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    259e:	ldr	r3, [r0, #0]
    25a0:	mov	r1, r7
    25a2:	ldr	r3, [r3, #44]	; 0x2c
    25a4:	mov.w	r2, #272	; 0x110
    25a8:	b.n	25ce <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x10e>
    25aa:	ldr	r4, [r0, #44]	; 0x2c
    25ac:	ldr	r3, [pc, #104]	; (2618 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    25ae:	cmp	r4, r3
    25b0:	bne.n	25c4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }
    25b2:	add	sp, #12
    25b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    25b8:	ldr	r4, [r0, #44]	; 0x2c
    25ba:	ldr	r3, [pc, #92]	; (2618 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    25bc:	cmp	r4, r3
    25be:	bne.n	25c4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    25c0:	mov	r0, r1
    25c2:	b.n	2562 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xa2>
    25c4:	mov	r1, r7
    25c6:	mov	r0, r5
    25c8:	mov.w	r2, #272	; 0x110
    25cc:	mov	r3, r4
    25ce:	add	sp, #12
    25d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    25d4:	bx	r3
    25d6:	mov	r1, r7
    25d8:	b.n	25c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x108>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    25da:	str.w	ip, [sp]
    25de:	mov	r3, ip
    25e0:	mov	r0, r5
    25e2:	blx	r4
    25e4:	b.n	254c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    25e6:	str.w	ip, [sp]
    25ea:	mov	r3, ip
    25ec:	mov	r0, r1
    25ee:	blx	r8
    25f0:	b.n	254c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    25f2:	str.w	ip, [sp]
    25f6:	mov	r3, ip
    25f8:	mov	r0, lr
    25fa:	blx	r4
    25fc:	b.n	254c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    25fe:	str.w	ip, [sp]
    2602:	mov	r3, ip
    2604:	mov	r0, lr
    2606:	blx	r8
    2608:	b.n	254c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    260a:	movs	r3, #0
    260c:	mov	r0, r4
    260e:	str	r3, [sp, #0]
    2610:	blx	r9
    2612:	b.n	254c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    2614:	.word	0x000004c1
    2618:	.word	0x00000481

0000261c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>:
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    261c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  { if (index_generated) return; 
    index_generated = true;
    2620:	movs	r7, #1
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    2622:	mov	r4, r0
    2624:	sub	sp, #272	; 0x110
    2626:	movs	r1, #13
  { if (index_generated) return; 
    index_generated = true;
    2628:	strb.w	r7, [r0, #248]	; 0xf8
    262c:	ldr	r0, [pc, #104]	; (2698 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    262e:	bl	cd84 <usb_serial_write>
    2632:	ldr	r0, [pc, #104]	; (269c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x80>)
    2634:	bl	e7bc <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    2638:	ldr	r0, [r4, #88]	; 0x58
    263a:	ldr	r1, [pc, #92]	; (2698 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    263c:	ldr	r3, [r0, #0]
    263e:	ldr	r3, [r3, #16]
    2640:	blx	r3
    2642:	ldr	r3, [r4, #4]
    // first remove old index file
    mtp_lock_storage(true);
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();
    2644:	str.w	r3, [r4, #228]	; 0xe4

    index_entries_ = 0;
    2648:	movs	r1, #0
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    264a:	cmp	r3, r1
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    264c:	str.w	r1, [r4, #244]	; 0xf4
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    2650:	ble.n	2692 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x76>
    2652:	mov	r5, r1
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
    2654:	mov	r6, r1
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    2656:	mov.w	r8, #4294967295
    265a:	b.n	2660 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x44>
    265c:	ldr.w	r1, [r4, #244]	; 0xf4

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
    2660:	strh.w	r5, [sp, #14]
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    2664:	adds	r3, r1, #1
    2666:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    266a:	mov	r2, sp
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    266c:	movs	r3, #47	; 0x2f
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    266e:	mov	r0, r4
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    2670:	strh.w	r3, [sp, #16]
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    2674:	str.w	r8, [sp]
      r.sibling = 0;
    2678:	str	r6, [sp, #8]
      r.child = 0;
    267a:	str	r6, [sp, #4]
      r.isdir = true;
    267c:	strb.w	r7, [sp, #12]
      r.scanned = false;
    2680:	strb.w	r6, [sp, #13]
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    2684:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    2688:	ldr.w	r3, [r4, #228]	; 0xe4
    268c:	adds	r5, #1
    268e:	cmp	r3, r5
    2690:	bgt.n	265c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x40>
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
      AppendIndexRecord(r);
    }
  }
    2692:	add	sp, #272	; 0x110
    2694:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2698:	.word	0x000144ac
    269c:	.word	0x1fff8d50

000026a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>:
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    26a0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    26a4:	mov	r5, r1
    26a6:	mov	r4, r2
    26a8:	sub	sp, #8
    Record ret;
    memset(&ret, 0, sizeof(ret));
    26aa:	movs	r1, #0
    26ac:	mov.w	r2, #272	; 0x110
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    26b0:	mov	r6, r0
    Record ret;
    memset(&ret, 0, sizeof(ret));
    26b2:	bl	106dc <memset>
    if (i > index_entries_) 
    26b6:	ldr.w	r3, [r5, #244]	; 0xf4
    26ba:	cmp	r3, r4
    26bc:	bcc.w	2836 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x196>
    { memset(&ret, 0, sizeof(ret));
      return ret;
    }
    OpenIndex();
    26c0:	mov	r0, r5
    26c2:	bl	212c <MTPStorage_SD::OpenIndex()>
    26c6:	ldr.w	r0, [r5, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    26ca:	add.w	r4, r4, r4, lsl #4
    26ce:	lsls	r2, r4, #4
    26d0:	mov.w	ip, #0
    26d4:	cmp	r0, #0
    26d6:	beq.w	282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    26da:	ldr	r7, [r0, #0]
    26dc:	ldr	r4, [pc, #456]	; (28a8 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x208>)
    26de:	ldr	r1, [r7, #52]	; 0x34
    26e0:	cmp	r1, r4
    26e2:	bne.w	2862 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1c2>
    26e6:	ldr	r1, [r0, #16]
    26e8:	cmp	r1, #0
    26ea:	beq.w	284a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1aa>
    26ee:	ldr	r3, [r1, #0]
    26f0:	ldr.w	r8, [r3, #52]	; 0x34
    26f4:	cmp	r8, r4
    26f6:	bne.w	2890 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1f0>
    26fa:	ldr.w	lr, [r1, #16]
    26fe:	cmp.w	lr, #0
    2702:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2704:	ldr.w	r3, [lr]
    2708:	ldr.w	r8, [r3, #52]	; 0x34
    270c:	cmp	r8, r4
    270e:	bne.w	2884 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    2712:	ldr.w	lr, [lr, #16]
    2716:	cmp.w	lr, #0
    271a:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    271c:	ldr.w	r3, [lr]
    2720:	ldr.w	r8, [r3, #52]	; 0x34
    2724:	cmp	r8, r4
    2726:	bne.w	2884 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    272a:	ldr.w	lr, [lr, #16]
    272e:	cmp.w	lr, #0
    2732:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2734:	ldr.w	r3, [lr]
    2738:	ldr.w	r8, [r3, #52]	; 0x34
    273c:	cmp	r8, r4
    273e:	bne.w	289c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    2742:	ldr.w	lr, [lr, #16]
    2746:	cmp.w	lr, #0
    274a:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    274c:	ldr.w	r3, [lr]
    2750:	ldr.w	r8, [r3, #52]	; 0x34
    2754:	cmp	r8, r4
    2756:	bne.w	289c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    275a:	ldr.w	lr, [lr, #16]
    275e:	cmp.w	lr, #0
    2762:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2764:	ldr.w	r3, [lr]
    2768:	ldr.w	r8, [r3, #52]	; 0x34
    276c:	cmp	r8, r4
    276e:	bne.w	289c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    2772:	ldr.w	lr, [lr, #16]
    2776:	cmp.w	lr, #0
    277a:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    277c:	ldr.w	r3, [lr]
    2780:	ldr.w	r8, [r3, #52]	; 0x34
    2784:	cmp	r8, r4
    2786:	bne.w	289c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    278a:	ldr.w	lr, [lr, #16]
    278e:	cmp.w	lr, #0
    2792:	beq.n	27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2794:	ldr.w	r3, [lr]
    2798:	ldr.w	r8, [r3, #52]	; 0x34
    279c:	cmp	r8, r4
    279e:	bne.n	289c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    27a0:	ldr.w	r4, [lr, #16]
    27a4:	cbz	r4, 27b6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    27a6:	ldr	r1, [r4, #0]
    27a8:	str.w	ip, [sp]
    27ac:	mov	r3, ip
    27ae:	mov	r0, r4
    27b0:	ldr	r1, [r1, #52]	; 0x34
    27b2:	blx	r1
    27b4:	b.n	286a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    27b6:	ldr	r4, [r7, #40]	; 0x28
    27b8:	ldr	r3, [pc, #240]	; (28ac <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    27ba:	cmp	r4, r3
    27bc:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27be:	mov	r0, r1
    27c0:	ldr	r2, [r0, #0]
    27c2:	ldr	r4, [r2, #40]	; 0x28
    27c4:	cmp	r4, r3
    27c6:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27c8:	ldr	r0, [r0, #16]
    27ca:	cmp	r0, #0
    27cc:	beq.n	282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27ce:	ldr	r2, [r0, #0]
    27d0:	ldr	r4, [r2, #40]	; 0x28
    27d2:	cmp	r4, r3
    27d4:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27d6:	ldr	r0, [r0, #16]
    27d8:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27da:	ldr	r2, [r0, #0]
    27dc:	ldr	r4, [r2, #40]	; 0x28
    27de:	cmp	r4, r3
    27e0:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27e2:	ldr	r0, [r0, #16]
    27e4:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27e6:	ldr	r2, [r0, #0]
    27e8:	ldr	r4, [r2, #40]	; 0x28
    27ea:	cmp	r4, r3
    27ec:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27ee:	ldr	r0, [r0, #16]
    27f0:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27f2:	ldr	r2, [r0, #0]
    27f4:	ldr	r4, [r2, #40]	; 0x28
    27f6:	cmp	r4, r3
    27f8:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27fa:	ldr	r0, [r0, #16]
    27fc:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27fe:	ldr	r2, [r0, #0]
    2800:	ldr	r4, [r2, #40]	; 0x28
    2802:	cmp	r4, r3
    2804:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    2806:	ldr	r0, [r0, #16]
    2808:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    280a:	ldr	r2, [r0, #0]
    280c:	ldr	r4, [r2, #40]	; 0x28
    280e:	cmp	r4, r3
    2810:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    2812:	ldr	r0, [r0, #16]
    2814:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2816:	ldr	r2, [r0, #0]
    2818:	ldr	r4, [r2, #40]	; 0x28
    281a:	cmp	r4, r3
    281c:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    281e:	ldr	r0, [r0, #16]
    2820:	cbz	r0, 282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2822:	ldr	r3, [r0, #0]
    2824:	mov.w	r2, #272	; 0x110
    2828:	ldr	r3, [r3, #40]	; 0x28
    282a:	mov	r1, r6
    282c:	blx	r3
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    282e:	mov	r0, r6
    2830:	add	sp, #8
    2832:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    Record ret;
    memset(&ret, 0, sizeof(ret));
    if (i > index_entries_) 
    { memset(&ret, 0, sizeof(ret));
    2836:	mov.w	r2, #272	; 0x110
    283a:	movs	r1, #0
    283c:	mov	r0, r6
    283e:	bl	106dc <memset>
    index_.seek(sizeof(ret) * i);
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    2842:	mov	r0, r6
    2844:	add	sp, #8
    2846:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    284a:	ldr	r4, [r7, #40]	; 0x28
    284c:	ldr	r3, [pc, #92]	; (28ac <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    284e:	cmp	r4, r3
    2850:	beq.n	282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2852:	mov.w	r2, #272	; 0x110
    2856:	mov	r1, r6
    2858:	blx	r4
    285a:	mov	r0, r6
    285c:	add	sp, #8
    285e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    2862:	str.w	ip, [sp]
    2866:	mov	r3, ip
    2868:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    286a:	ldr.w	r0, [r5, #184]	; 0xb8
    286e:	cmp	r0, #0
    2870:	beq.n	282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2872:	ldr	r2, [r0, #0]
    2874:	ldr	r3, [pc, #52]	; (28ac <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    2876:	ldr	r4, [r2, #40]	; 0x28
    2878:	cmp	r4, r3
    287a:	bne.n	2852 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    287c:	ldr	r0, [r0, #16]
    287e:	cmp	r0, #0
    2880:	bne.n	27c0 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x120>
    2882:	b.n	282e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    2884:	str.w	ip, [sp]
    2888:	mov	r3, ip
    288a:	mov	r0, lr
    288c:	blx	r8
    288e:	b.n	286a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    2890:	str.w	ip, [sp]
    2894:	mov	r3, ip
    2896:	mov	r0, r1
    2898:	blx	r8
    289a:	b.n	286a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    289c:	movs	r3, #0
    289e:	mov	r0, lr
    28a0:	str	r3, [sp, #0]
    28a2:	blx	r8
    28a4:	b.n	286a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    28a6:	nop
    28a8:	.word	0x000004c1
    28ac:	.word	0x00000475

000028b0 <MTPStorage_SD::GetNextObjectHandle(unsigned long)>:
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    28b0:	push	{r4, r5, lr}
    while (true) 
    { if (next_ == 0) return 0;
    28b2:	ldr.w	r5, [r0, #252]	; 0xfc
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    28b6:	sub	sp, #276	; 0x114
    28b8:	mov	r4, r0
    while (true) 
    { if (next_ == 0) return 0;
    28ba:	cbnz	r5, 28d0 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x20>
    28bc:	b.n	2906 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
    28be:	ldr	r3, [sp, #8]
    28c0:	str.w	r3, [r4, #252]	; 0xfc
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    28c4:	ldrb.w	r3, [sp, #16]
    28c8:	cbnz	r3, 2900 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x50>
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    28ca:	ldr.w	r5, [r4, #252]	; 0xfc
    28ce:	cbz	r5, 2906 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
    28d0:	mov	r2, r5
    28d2:	mov	r1, r4
    28d4:	mov	r0, sp
    28d6:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      if (follow_sibling_) 
    28da:	ldrb.w	r2, [r4, #256]	; 0x100
    28de:	cmp	r2, #0
    28e0:	bne.n	28be <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0xe>
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    28e2:	ldr.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    28e6:	ldr.w	r1, [r4, #244]	; 0xf4
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    28ea:	adds	r3, #1
    28ec:	str.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    28f0:	cmp	r3, r1
      }
      if (r.name[0]) return ret;
    28f2:	ldrb.w	r3, [sp, #16]
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
    28f6:	it	cs
    28f8:	strcs.w	r2, [r4, #252]	; 0xfc
      }
      if (r.name[0]) return ret;
    28fc:	cmp	r3, #0
    28fe:	beq.n	28ca <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x1a>
    }
  }
    2900:	mov	r0, r5
    2902:	add	sp, #276	; 0x114
    2904:	pop	{r4, r5, pc}
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    2906:	movs	r5, #0
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    }
  }
    2908:	mov	r0, r5
    290a:	add	sp, #276	; 0x114
    290c:	pop	{r4, r5, pc}
    290e:	nop

00002910 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)>:

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    2910:	push	{r4, r5, r6, r7, lr}
    2912:	sub	sp, #276	; 0x114
    2914:	mov	r7, r2
    Record r = ReadIndexRecord(handle);
    2916:	mov	r2, r1
    2918:	mov	r1, r0
    291a:	mov	r0, sp
      if (r.name[0]) return ret;
    }
  }

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    291c:	mov	r5, r3
    291e:	ldr	r6, [sp, #296]	; 0x128
    2920:	ldr	r4, [sp, #300]	; 0x12c
    Record r = ReadIndexRecord(handle);
    2922:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(name, r.name);
    2926:	mov	r0, r7
    2928:	add	r1, sp, #16
    292a:	bl	10bd0 <strcpy>
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    292e:	ldrb.w	r3, [sp, #12]

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    2932:	ldr	r2, [sp, #0]
    2934:	str	r2, [r6, #0]
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    2936:	cbnz	r3, 2946 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x36>
    2938:	ldr	r3, [sp, #4]
    *store = r.store;
    293a:	ldrh.w	r2, [sp, #14]
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    293e:	str	r3, [r5, #0]
    *store = r.store;
    2940:	strh	r2, [r4, #0]
  }
    2942:	add	sp, #276	; 0x114
    2944:	pop	{r4, r5, r6, r7, pc}
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    2946:	mov.w	r3, #4294967295
    294a:	b.n	293a <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x2a>

0000294c <MTPStorage_SD::GetSize(unsigned long)>:
    *store = r.store;
  }

  uint32_t MTPStorage_SD::GetSize(uint32_t handle) 
  {
    294c:	push	{lr}
    294e:	sub	sp, #276	; 0x114
    return ReadIndexRecord(handle).child;
    2950:	mov	r2, r1
    2952:	mov	r1, r0
    2954:	mov	r0, sp
    2956:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  }
    295a:	ldr	r0, [sp, #4]
    295c:	add	sp, #276	; 0x114
    295e:	ldr.w	pc, [sp], #4
    2962:	nop

00002964 <MTPStorage_SD::close()>:
      mtp_lock_storage(false);
      return ret;
  }

  void MTPStorage_SD::close() 
  {
    2964:	push	{r4, r5, r6, lr}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2966:	ldr.w	r3, [r0, #204]	; 0xcc
    296a:	sub	sp, #272	; 0x110
    296c:	mov	r4, r0
    296e:	cmp	r3, #0
    2970:	beq.n	2a0c <MTPStorage_SD::close()+0xa8>
    2972:	ldr	r5, [r3, #0]
    2974:	ldr	r1, [pc, #384]	; (2af8 <MTPStorage_SD::close()+0x194>)
    2976:	ldr	r2, [r5, #60]	; 0x3c
    2978:	cmp	r2, r1
    297a:	bne.w	2aec <MTPStorage_SD::close()+0x188>
    297e:	ldr	r2, [r3, #16]
    2980:	cmp	r2, #0
    2982:	beq.w	2adc <MTPStorage_SD::close()+0x178>
    2986:	ldr	r0, [r2, #0]
    2988:	ldr	r6, [r0, #60]	; 0x3c
    298a:	cmp	r6, r1
    298c:	bne.n	2a34 <MTPStorage_SD::close()+0xd0>
    298e:	ldr	r0, [r2, #16]
    2990:	cmp	r0, #0
    2992:	beq.n	29fe <MTPStorage_SD::close()+0x9a>
    2994:	ldr	r6, [r0, #0]
    2996:	ldr	r6, [r6, #60]	; 0x3c
    2998:	cmp	r6, r1
    299a:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    299c:	ldr	r0, [r0, #16]
    299e:	cmp	r0, #0
    29a0:	beq.n	29fe <MTPStorage_SD::close()+0x9a>
    29a2:	ldr	r6, [r0, #0]
    29a4:	ldr	r6, [r6, #60]	; 0x3c
    29a6:	cmp	r6, r1
    29a8:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29aa:	ldr	r0, [r0, #16]
    29ac:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29ae:	ldr	r6, [r0, #0]
    29b0:	ldr	r6, [r6, #60]	; 0x3c
    29b2:	cmp	r6, r1
    29b4:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29b6:	ldr	r0, [r0, #16]
    29b8:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29ba:	ldr	r6, [r0, #0]
    29bc:	ldr	r6, [r6, #60]	; 0x3c
    29be:	cmp	r6, r1
    29c0:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29c2:	ldr	r0, [r0, #16]
    29c4:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29c6:	ldr	r6, [r0, #0]
    29c8:	ldr	r6, [r6, #60]	; 0x3c
    29ca:	cmp	r6, r1
    29cc:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29ce:	ldr	r0, [r0, #16]
    29d0:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29d2:	ldr	r6, [r0, #0]
    29d4:	ldr	r6, [r6, #60]	; 0x3c
    29d6:	cmp	r6, r1
    29d8:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29da:	ldr	r0, [r0, #16]
    29dc:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29de:	ldr	r6, [r0, #0]
    29e0:	ldr	r6, [r6, #60]	; 0x3c
    29e2:	cmp	r6, r1
    29e4:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29e6:	ldr	r0, [r0, #16]
    29e8:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29ea:	ldr	r6, [r0, #0]
    29ec:	ldr	r6, [r6, #60]	; 0x3c
    29ee:	cmp	r6, r1
    29f0:	bne.n	2a36 <MTPStorage_SD::close()+0xd2>
    29f2:	ldr	r0, [r0, #16]
    29f4:	cbz	r0, 29fe <MTPStorage_SD::close()+0x9a>
    29f6:	ldr	r3, [r0, #0]
    29f8:	ldr	r3, [r3, #60]	; 0x3c
    29fa:	blx	r3
    29fc:	b.n	2a38 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    29fe:	ldr	r6, [r5, #64]	; 0x40
    2a00:	ldr	r1, [pc, #248]	; (2afc <MTPStorage_SD::close()+0x198>)
    2a02:	cmp	r6, r1
    2a04:	bne.n	2af2 <MTPStorage_SD::close()+0x18e>
    2a06:	mov	r0, r2
    2a08:	movs	r5, #0
    2a0a:	b.n	2a52 <MTPStorage_SD::close()+0xee>
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    2a0c:	mov	r5, r3
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    2a0e:	mov	r0, sp
    2a10:	ldr.w	r2, [r4, #240]	; 0xf0
    2a14:	mov	r1, r4
    2a16:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    r.child = size;
    WriteIndexRecord(open_file_, r);
    2a1a:	mov	r2, sp
    2a1c:	ldr.w	r1, [r4, #240]	; 0xf0
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    r.child = size;
    2a20:	str	r5, [sp, #4]
    WriteIndexRecord(open_file_, r);
    2a22:	mov	r0, r4
    2a24:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    open_file_ = 0xFFFFFFFEUL;
    2a28:	mvn.w	r3, #1
    2a2c:	str.w	r3, [r4, #240]	; 0xf0
  }
    2a30:	add	sp, #272	; 0x110
    2a32:	pop	{r4, r5, r6, pc}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2a34:	mov	r0, r2
    2a36:	blx	r6
	}
	virtual void close() {
		if (f) f->close();
    2a38:	ldr.w	r3, [r4, #204]	; 0xcc
  }

  void MTPStorage_SD::close() 
  {
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    2a3c:	mov	r5, r0
    2a3e:	cmp	r3, #0
    2a40:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a42:	ldr	r2, [r3, #0]
    2a44:	ldr	r1, [pc, #180]	; (2afc <MTPStorage_SD::close()+0x198>)
    2a46:	ldr	r6, [r2, #64]	; 0x40
    2a48:	cmp	r6, r1
    2a4a:	bne.n	2ae6 <MTPStorage_SD::close()+0x182>
    2a4c:	ldr	r0, [r3, #16]
    2a4e:	cmp	r0, #0
    2a50:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a52:	ldr	r3, [r0, #0]
    2a54:	ldr	r3, [r3, #64]	; 0x40
    2a56:	cmp	r3, r1
    2a58:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2a5a:	ldr	r0, [r0, #16]
    2a5c:	cmp	r0, #0
    2a5e:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a60:	ldr	r3, [r0, #0]
    2a62:	ldr	r3, [r3, #64]	; 0x40
    2a64:	cmp	r3, r1
    2a66:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2a68:	ldr	r0, [r0, #16]
    2a6a:	cmp	r0, #0
    2a6c:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a6e:	ldr	r3, [r0, #0]
    2a70:	ldr	r3, [r3, #64]	; 0x40
    2a72:	cmp	r3, r1
    2a74:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2a76:	ldr	r0, [r0, #16]
    2a78:	cmp	r0, #0
    2a7a:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a7c:	ldr	r3, [r0, #0]
    2a7e:	ldr	r3, [r3, #64]	; 0x40
    2a80:	cmp	r3, r1
    2a82:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2a84:	ldr	r0, [r0, #16]
    2a86:	cmp	r0, #0
    2a88:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a8a:	ldr	r3, [r0, #0]
    2a8c:	ldr	r3, [r3, #64]	; 0x40
    2a8e:	cmp	r3, r1
    2a90:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2a92:	ldr	r0, [r0, #16]
    2a94:	cmp	r0, #0
    2a96:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2a98:	ldr	r3, [r0, #0]
    2a9a:	ldr	r3, [r3, #64]	; 0x40
    2a9c:	cmp	r3, r1
    2a9e:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2aa0:	ldr	r0, [r0, #16]
    2aa2:	cmp	r0, #0
    2aa4:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2aa6:	ldr	r3, [r0, #0]
    2aa8:	ldr	r3, [r3, #64]	; 0x40
    2aaa:	cmp	r3, r1
    2aac:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2aae:	ldr	r0, [r0, #16]
    2ab0:	cmp	r0, #0
    2ab2:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2ab4:	ldr	r3, [r0, #0]
    2ab6:	ldr	r3, [r3, #64]	; 0x40
    2ab8:	cmp	r3, r1
    2aba:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2abc:	ldr	r0, [r0, #16]
    2abe:	cmp	r0, #0
    2ac0:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2ac2:	ldr	r3, [r0, #0]
    2ac4:	ldr	r3, [r3, #64]	; 0x40
    2ac6:	cmp	r3, r1
    2ac8:	bne.n	2ad8 <MTPStorage_SD::close()+0x174>
    2aca:	ldr	r0, [r0, #16]
    2acc:	cmp	r0, #0
    2ace:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2ad0:	ldr	r3, [r0, #0]
    2ad2:	ldr	r3, [r3, #64]	; 0x40
    2ad4:	blx	r3
    2ad6:	b.n	2a0e <MTPStorage_SD::close()+0xaa>
    2ad8:	blx	r3
    2ada:	b.n	2a0e <MTPStorage_SD::close()+0xaa>
    2adc:	ldr	r6, [r5, #64]	; 0x40
    2ade:	ldr	r1, [pc, #28]	; (2afc <MTPStorage_SD::close()+0x198>)
    2ae0:	cmp	r6, r1
    2ae2:	mov	r5, r2
    2ae4:	beq.n	2a0e <MTPStorage_SD::close()+0xaa>
    2ae6:	mov	r0, r3
    2ae8:	blx	r6
    2aea:	b.n	2a0e <MTPStorage_SD::close()+0xaa>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2aec:	mov	r0, r3
    2aee:	blx	r2
    2af0:	b.n	2a38 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    2af2:	movs	r5, #0
    2af4:	b.n	2ae6 <MTPStorage_SD::close()+0x182>
    2af6:	nop
    2af8:	.word	0x000004e5
    2afc:	.word	0x000004f5

00002b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>:

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    2b00:	push	{r4, r5, r6, lr}
    2b02:	mov	r6, r0
    2b04:	sub	sp, #272	; 0x110
    2b06:	mov	r4, r2
    Record tmp = ReadIndexRecord(i);
    2b08:	mov	r0, sp
    2b0a:	mov	r2, r1
    2b0c:	mov	r1, r6

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    2b0e:	mov	r5, r3
    Record tmp = ReadIndexRecord(i);
    2b10:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    2b14:	ldr	r1, [sp, #0]
    2b16:	adds	r3, r1, #1
    2b18:	beq.n	2b50 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x50>
    { strcpy(out, "/");
      return tmp.store;
    }
    else 
    { ConstructFilename(tmp.parent, out, len);
    2b1a:	mov	r3, r5
    2b1c:	mov	r2, r4
    2b1e:	mov	r0, r6
    2b20:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
    2b24:	mov	r0, r4
    2b26:	bl	10d40 <strlen>
    2b2a:	add	r0, r4
    2b2c:	ldrb.w	r3, [r0, #-1]
    2b30:	cmp	r3, #47	; 0x2f
    2b32:	beq.n	2b3e <MTPStorage_SD::ConstructFilename(int, char*, int)+0x3e>
    2b34:	mov	r2, r5
    2b36:	ldr	r1, [pc, #40]	; (2b60 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
    2b38:	mov	r0, r4
    2b3a:	bl	10c8c <strlcat>
      strlcat(out, tmp.name,len);
    2b3e:	mov	r2, r5
    2b40:	mov	r0, r4
    2b42:	add	r1, sp, #16
    2b44:	bl	10c8c <strlcat>
      return tmp.store;
    2b48:	ldrh.w	r0, [sp, #14]
    }
  }
    2b4c:	add	sp, #272	; 0x110
    2b4e:	pop	{r4, r5, r6, pc}
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2b50:	ldr	r3, [pc, #12]	; (2b60 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
      return tmp.store;
    2b52:	ldrh.w	r0, [sp, #14]
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2b56:	ldrh	r3, [r3, #0]
    2b58:	strh	r3, [r4, #0]
    { ConstructFilename(tmp.parent, out, len);
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
      strlcat(out, tmp.name,len);
      return tmp.store;
    }
  }
    2b5a:	add	sp, #272	; 0x110
    2b5c:	pop	{r4, r5, r6, pc}
    2b5e:	nop
    2b60:	.word	0x000144d4

00002b64 <MTPStorage_SD::rename(unsigned long, char const*)>:
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b64:	push	{r4, r5, r6, r7, lr}
    2b66:	subw	sp, sp, #1044	; 0x414
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b6a:	mov.w	r3, #256	; 0x100
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b6e:	mov	r7, r2
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b70:	mov	r2, sp
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b72:	mov	r5, r1
    2b74:	mov	r4, r0
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b76:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    2b7a:	mov	r6, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2b7c:	mov	r0, sp
    2b7e:	bl	10d40 <strlen>
    2b82:	mov	r1, r0
    2b84:	mov	r0, sp
    2b86:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2b8a:	ldr	r0, [pc, #132]	; (2c10 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    2b8c:	bl	e7bc <Print::println()>
    Serial.println(oldName);

    Record p1 = ReadIndexRecord(handle);
    2b90:	mov	r2, r5
    2b92:	mov	r1, r4
    2b94:	add	r0, sp, #768	; 0x300
    2b96:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strlcpy(temp,p1.name,MAX_FILENAME_LEN);
    2b9a:	add	r1, sp, #784	; 0x310
    2b9c:	mov.w	r2, #256	; 0x100
    2ba0:	add	r0, sp, #512	; 0x200
    2ba2:	bl	10ce0 <strlcpy>
    strlcpy(p1.name,name,MAX_FILENAME_LEN);
    2ba6:	mov	r1, r7
    2ba8:	mov.w	r2, #256	; 0x100
    2bac:	add	r0, sp, #784	; 0x310
    2bae:	bl	10ce0 <strlcpy>

    WriteIndexRecord(handle, p1);
    2bb2:	add	r2, sp, #768	; 0x300
    2bb4:	mov	r1, r5
    2bb6:	mov	r0, r4
    2bb8:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    2bbc:	add	r2, sp, #256	; 0x100
    2bbe:	mov.w	r3, #256	; 0x100
    2bc2:	mov	r1, r5
    2bc4:	mov	r0, r4
    2bc6:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2bca:	add	r0, sp, #256	; 0x100
    2bcc:	bl	10d40 <strlen>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    2bd0:	add.w	r6, r4, r6, lsl #2
    2bd4:	mov	r1, r0
    2bd6:	add	r0, sp, #256	; 0x100
    2bd8:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2bdc:	ldr	r0, [pc, #48]	; (2c10 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    2bde:	bl	e7bc <Print::println()>
    2be2:	ldr	r0, [r6, #88]	; 0x58
    2be4:	ldr	r3, [r0, #0]
    2be6:	add	r2, sp, #256	; 0x100
    2be8:	mov	r1, sp
    2bea:	ldr	r3, [r3, #12]
    2bec:	blx	r3
    Serial.println(newName);

    if (sd_rename(store,oldName,newName)) return true;
    2bee:	mov	r6, r0
    2bf0:	cbnz	r0, 2c08 <MTPStorage_SD::rename(unsigned long, char const*)+0xa4>

    // rename failed; undo index update
    strlcpy(p1.name,temp,MAX_FILENAME_LEN);
    2bf2:	add	r1, sp, #512	; 0x200
    2bf4:	mov.w	r2, #256	; 0x100
    2bf8:	add	r0, sp, #784	; 0x310
    2bfa:	bl	10ce0 <strlcpy>
    WriteIndexRecord(handle, p1);
    2bfe:	add	r2, sp, #768	; 0x300
    2c00:	mov	r1, r5
    2c02:	mov	r0, r4
    2c04:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
  }
    2c08:	mov	r0, r6
    2c0a:	addw	sp, sp, #1044	; 0x414
    2c0e:	pop	{r4, r5, r6, r7, pc}
    2c10:	.word	0x1fff8d50

00002c14 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>:
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    2c14:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (open_file_ == i && mode_ == mode) return;
    2c18:	ldr.w	r3, [r0, #240]	; 0xf0
    2c1c:	cmp	r3, r1
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    2c1e:	sub	sp, #292	; 0x124
    if (open_file_ == i && mode_ == mode) return;
    2c20:	beq.w	3018 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x404>
    2c24:	mov	r6, r2
    char filename[MAX_FILENAME_LEN];
    uint16_t store = ConstructFilename(i, filename, MAX_FILENAME_LEN);
    2c26:	mov.w	r3, #256	; 0x100
    2c2a:	add	r2, sp, #32
    2c2c:	mov	r4, r0
    2c2e:	mov	r5, r1
    2c30:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    2c34:	mov	r7, r0
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2c36:	ldr.w	r0, [r4, #204]	; 0xcc
    2c3a:	cmp	r0, #0
    2c3c:	beq.w	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c40:	ldr	r2, [r0, #0]
    2c42:	ldr	r3, [pc, #348]	; (2da0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x18c>)
    2c44:	ldr	r2, [r2, #68]	; 0x44
    2c46:	cmp	r2, r3
    2c48:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c4c:	ldr	r0, [r0, #16]
    2c4e:	cmp	r0, #0
    2c50:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c52:	ldr	r2, [r0, #0]
    2c54:	ldr	r2, [r2, #68]	; 0x44
    2c56:	cmp	r2, r3
    2c58:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c5c:	ldr	r0, [r0, #16]
    2c5e:	cmp	r0, #0
    2c60:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c62:	ldr	r2, [r0, #0]
    2c64:	ldr	r2, [r2, #68]	; 0x44
    2c66:	cmp	r2, r3
    2c68:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c6c:	ldr	r0, [r0, #16]
    2c6e:	cmp	r0, #0
    2c70:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c72:	ldr	r2, [r0, #0]
    2c74:	ldr	r2, [r2, #68]	; 0x44
    2c76:	cmp	r2, r3
    2c78:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c7c:	ldr	r0, [r0, #16]
    2c7e:	cmp	r0, #0
    2c80:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c82:	ldr	r2, [r0, #0]
    2c84:	ldr	r2, [r2, #68]	; 0x44
    2c86:	cmp	r2, r3
    2c88:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c8c:	ldr	r0, [r0, #16]
    2c8e:	cmp	r0, #0
    2c90:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c92:	ldr	r2, [r0, #0]
    2c94:	ldr	r2, [r2, #68]	; 0x44
    2c96:	cmp	r2, r3
    2c98:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c9c:	ldr	r0, [r0, #16]
    2c9e:	cmp	r0, #0
    2ca0:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2ca2:	ldr	r2, [r0, #0]
    2ca4:	ldr	r2, [r2, #68]	; 0x44
    2ca6:	cmp	r2, r3
    2ca8:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cac:	ldr	r0, [r0, #16]
    2cae:	cmp	r0, #0
    2cb0:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cb2:	ldr	r2, [r0, #0]
    2cb4:	ldr	r2, [r2, #68]	; 0x44
    2cb6:	cmp	r2, r3
    2cb8:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cbc:	ldr	r0, [r0, #16]
    2cbe:	cmp	r0, #0
    2cc0:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cc2:	ldr	r2, [r0, #0]
    2cc4:	ldr	r2, [r2, #68]	; 0x44
    2cc6:	cmp	r2, r3
    2cc8:	bne.w	3028 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2ccc:	ldr	r0, [r0, #16]
    2cce:	cmp	r0, #0
    2cd0:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cd2:	ldr	r3, [r0, #0]
    2cd4:	ldr	r3, [r3, #68]	; 0x44
    2cd6:	blx	r3

    mtp_lock_storage(true);
    if(sd_isOpen(file_)) file_.close();
    2cd8:	cmp	r0, #0
    2cda:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    2cdc:	ldr.w	r0, [r4, #204]	; 0xcc
    2ce0:	cmp	r0, #0
    2ce2:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2ce4:	ldr	r2, [r0, #0]
    2ce6:	ldr	r3, [pc, #188]	; (2da4 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x190>)
    2ce8:	ldr	r2, [r2, #64]	; 0x40
    2cea:	cmp	r2, r3
    2cec:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2cf0:	ldr	r0, [r0, #16]
    2cf2:	cmp	r0, #0
    2cf4:	beq.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cf6:	ldr	r2, [r0, #0]
    2cf8:	ldr	r2, [r2, #64]	; 0x40
    2cfa:	cmp	r2, r3
    2cfc:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d00:	ldr	r0, [r0, #16]
    2d02:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d04:	ldr	r2, [r0, #0]
    2d06:	ldr	r2, [r2, #64]	; 0x40
    2d08:	cmp	r2, r3
    2d0a:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d0e:	ldr	r0, [r0, #16]
    2d10:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d12:	ldr	r2, [r0, #0]
    2d14:	ldr	r2, [r2, #64]	; 0x40
    2d16:	cmp	r2, r3
    2d18:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d1c:	ldr	r0, [r0, #16]
    2d1e:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d20:	ldr	r2, [r0, #0]
    2d22:	ldr	r2, [r2, #64]	; 0x40
    2d24:	cmp	r2, r3
    2d26:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d2a:	ldr	r0, [r0, #16]
    2d2c:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d2e:	ldr	r2, [r0, #0]
    2d30:	ldr	r2, [r2, #64]	; 0x40
    2d32:	cmp	r2, r3
    2d34:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d38:	ldr	r0, [r0, #16]
    2d3a:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d3c:	ldr	r2, [r0, #0]
    2d3e:	ldr	r2, [r2, #64]	; 0x40
    2d40:	cmp	r2, r3
    2d42:	bne.w	302c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d46:	ldr	r0, [r0, #16]
    2d48:	cbz	r0, 2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d4a:	ldr	r3, [r0, #0]
    2d4c:	ldr	r3, [r3, #64]	; 0x40
    2d4e:	blx	r3
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    2d50:	add.w	r7, r4, r7, lsl #2
    2d54:	add	r2, sp, #32
    2d56:	ldr	r1, [r7, #88]	; 0x58
    2d58:	ldr	r3, [r1, #0]
    2d5a:	add	r0, sp, #12
    2d5c:	ldr	r7, [r3, #0]
    2d5e:	uxtb	r3, r6
    2d60:	blx	r7
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2d62:	ldr.w	r2, [r4, #204]	; 0xcc
    2d66:	cbz	r2, 2d70 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2d68:	ldr	r3, [r2, #16]
    2d6a:	subs	r3, #1
    2d6c:	str	r3, [r2, #16]
    2d6e:	cbz	r3, 2dac <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x198>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    2d70:	ldr	r2, [sp, #28]
    2d72:	str.w	r2, [r4, #204]	; 0xcc
		if (f) f->refcount++;
    2d76:	cbz	r2, 2d92 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2d78:	ldr	r1, [r2, #16]
		return *this;
	}
	virtual ~File() {
    2d7a:	ldr	r3, [pc, #44]	; (2da8 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x194>)
    2d7c:	str	r3, [sp, #12]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    2d7e:	adds	r1, #1
    2d80:	str	r1, [r2, #16]
    2d82:	ldr	r1, [sp, #28]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2d84:	cbz	r1, 2d92 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2d86:	ldr	r2, [r1, #16]
    2d88:	subs	r2, #1
    2d8a:	str	r2, [r1, #16]
    2d8c:	cmp	r2, #0
    2d8e:	beq.w	2ee8 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2d4>
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    2d92:	str.w	r5, [r4, #240]	; 0xf0
    mode_ = mode;
    2d96:	str.w	r6, [r4, #236]	; 0xec
    mtp_lock_storage(false);
  }
    2d9a:	add	sp, #292	; 0x124
    2d9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2da0:	.word	0x00000501
    2da4:	.word	0x000004f5
    2da8:	.word	0x000141ec
    2dac:	ldr.w	r7, [r4, #204]	; 0xcc
    2db0:	cmp	r7, #0
    2db2:	beq.n	2d70 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2db4:	ldr	r3, [r7, #0]
    2db6:	ldr	r1, [pc, #680]	; (3060 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    2db8:	ldr	r3, [r3, #32]
    2dba:	cmp	r3, r1
    2dbc:	bne.w	3030 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x41c>
    2dc0:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2dc2:	ldr	r3, [pc, #672]	; (3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
    2dc4:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2dc6:	cmp	r0, #0
    2dc8:	beq.w	2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2dcc:	ldr	r2, [r0, #16]
    2dce:	subs	r2, #1
    2dd0:	str	r2, [r0, #16]
    2dd2:	cmp	r2, #0
    2dd4:	bne.w	2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2dd8:	ldr.w	r8, [r7, #16]
    2ddc:	cmp.w	r8, #0
    2de0:	beq.n	2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2de2:	ldr.w	r2, [r8]
    2de6:	ldr	r2, [r2, #32]
    2de8:	cmp	r2, r1
    2dea:	bne.w	304e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x43a>
    2dee:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2df2:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2df6:	cmp	r0, #0
    2df8:	beq.n	2ed6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2dfa:	ldr	r2, [r0, #16]
    2dfc:	subs	r2, #1
    2dfe:	str	r2, [r0, #16]
    2e00:	cmp	r2, #0
    2e02:	bne.n	2ed6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2e04:	ldr.w	r9, [r8, #16]
    2e08:	cmp.w	r9, #0
    2e0c:	beq.n	2ed6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2e0e:	ldr.w	r2, [r9]
    2e12:	ldr	r2, [r2, #32]
    2e14:	cmp	r2, r1
    2e16:	bne.w	3042 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x42e>
    2e1a:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e1e:	str.w	r3, [r9]
    2e22:	ldr.w	lr, [pc, #576]	; 3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e26:	cmp	r0, #0
    2e28:	beq.n	2ece <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e2a:	ldr	r2, [r0, #16]
    2e2c:	subs	r2, #1
    2e2e:	str	r2, [r0, #16]
    2e30:	cmp	r2, #0
    2e32:	bne.n	2ece <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e34:	ldr.w	sl, [r9, #16]
    2e38:	cmp.w	sl, #0
    2e3c:	beq.n	2ece <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e3e:	ldr.w	r2, [sl]
    2e42:	ldr	r2, [r2, #32]
    2e44:	cmp	r2, r1
    2e46:	bne.w	305a <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x446>
    2e4a:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e4e:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e52:	cmp	r0, #0
    2e54:	beq.n	2ec6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e56:	ldr	r2, [r0, #16]
    2e58:	subs	r2, #1
    2e5a:	str	r2, [r0, #16]
    2e5c:	cmp	r2, #0
    2e5e:	bne.n	2ec6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e60:	ldr.w	fp, [sl, #16]
    2e64:	cmp.w	fp, #0
    2e68:	beq.n	2ec6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e6a:	ldr.w	r2, [fp]
    2e6e:	ldr	r2, [r2, #32]
    2e70:	cmp	r2, r1
    2e72:	bne.w	306e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x45a>
    2e76:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e7a:	str.w	r3, [fp]
    2e7e:	ldr	r0, [pc, #484]	; (3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e80:	cbz	r2, 2ebe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2e82:	ldr	r3, [r2, #16]
    2e84:	subs	r3, #1
    2e86:	str	r3, [r2, #16]
    2e88:	cbnz	r3, 2ebe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2e8a:	ldr.w	r2, [fp, #16]
    2e8e:	cbz	r2, 2ebe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2e90:	ldr	r3, [r2, #0]
    2e92:	ldr	r3, [r3, #32]
    2e94:	cmp	r3, r1
    2e96:	bne.w	307a <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x466>
    2e9a:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e9c:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e9e:	cbz	r1, 2eb6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2ea0:	ldr	r3, [r1, #16]
    2ea2:	subs	r3, #1
    2ea4:	str	r3, [r1, #16]
    2ea6:	cbnz	r3, 2eb6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2ea8:	ldr	r0, [r2, #16]
    2eaa:	cbz	r0, 2eb6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2eac:	ldr	r3, [r0, #0]
    2eae:	str	r2, [sp, #4]
    2eb0:	ldr	r3, [r3, #32]
    2eb2:	blx	r3
    2eb4:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2eb6:	mov	r0, r2
    2eb8:	movs	r1, #20
    2eba:	bl	e960 <operator delete(void*, unsigned int)>
    2ebe:	mov	r0, fp
    2ec0:	movs	r1, #20
    2ec2:	bl	e960 <operator delete(void*, unsigned int)>
    2ec6:	mov	r0, sl
    2ec8:	movs	r1, #20
    2eca:	bl	e960 <operator delete(void*, unsigned int)>
    2ece:	mov	r0, r9
    2ed0:	movs	r1, #20
    2ed2:	bl	e960 <operator delete(void*, unsigned int)>
    2ed6:	mov	r0, r8
    2ed8:	movs	r1, #20
    2eda:	bl	e960 <operator delete(void*, unsigned int)>
    2ede:	mov	r0, r7
    2ee0:	movs	r1, #20
    2ee2:	bl	e960 <operator delete(void*, unsigned int)>
    2ee6:	b.n	2d70 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2ee8:	ldr	r7, [sp, #28]
    2eea:	cmp	r7, #0
    2eec:	beq.w	2d92 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2ef0:	ldr	r2, [r7, #0]
    2ef2:	ldr	r1, [pc, #364]	; (3060 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    2ef4:	ldr	r2, [r2, #32]
    2ef6:	cmp	r2, r1
    2ef8:	bne.w	3036 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x422>
    2efc:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2efe:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f00:	cmp	r0, #0
    2f02:	beq.w	300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f06:	ldr	r2, [r0, #16]
    2f08:	subs	r2, #1
    2f0a:	str	r2, [r0, #16]
    2f0c:	cmp	r2, #0
    2f0e:	bne.n	300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f10:	ldr.w	r8, [r7, #16]
    2f14:	cmp.w	r8, #0
    2f18:	beq.n	300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f1a:	ldr.w	r2, [r8]
    2f1e:	ldr	r2, [r2, #32]
    2f20:	cmp	r2, r1
    2f22:	bne.w	3048 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x434>
    2f26:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f2a:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f2e:	cmp	r0, #0
    2f30:	beq.n	3006 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f32:	ldr	r2, [r0, #16]
    2f34:	subs	r2, #1
    2f36:	str	r2, [r0, #16]
    2f38:	cmp	r2, #0
    2f3a:	bne.n	3006 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f3c:	ldr.w	r9, [r8, #16]
    2f40:	cmp.w	r9, #0
    2f44:	beq.n	3006 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f46:	ldr.w	r2, [r9]
    2f4a:	ldr	r2, [r2, #32]
    2f4c:	cmp	r2, r1
    2f4e:	bne.n	303c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x428>
    2f50:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f54:	str.w	r3, [r9]
    2f58:	ldr.w	lr, [pc, #264]	; 3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f5c:	cmp	r0, #0
    2f5e:	beq.n	2ffe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f60:	ldr	r2, [r0, #16]
    2f62:	subs	r2, #1
    2f64:	str	r2, [r0, #16]
    2f66:	cmp	r2, #0
    2f68:	bne.n	2ffe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f6a:	ldr.w	sl, [r9, #16]
    2f6e:	cmp.w	sl, #0
    2f72:	beq.n	2ffe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f74:	ldr.w	r2, [sl]
    2f78:	ldr	r2, [r2, #32]
    2f7a:	cmp	r2, r1
    2f7c:	bne.n	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x440>
    2f7e:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f82:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f86:	cmp	r0, #0
    2f88:	beq.n	2ff6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2f8a:	ldr	r2, [r0, #16]
    2f8c:	subs	r2, #1
    2f8e:	str	r2, [r0, #16]
    2f90:	cmp	r2, #0
    2f92:	bne.n	2ff6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2f94:	ldr.w	fp, [sl, #16]
    2f98:	cmp.w	fp, #0
    2f9c:	beq.n	2ff6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2f9e:	ldr.w	r2, [fp]
    2fa2:	ldr	r2, [r2, #32]
    2fa4:	cmp	r2, r1
    2fa6:	bne.n	3068 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x454>
    2fa8:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2fac:	str.w	r3, [fp]
    2fb0:	ldr	r0, [pc, #176]	; (3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2fb2:	cbz	r2, 2fee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fb4:	ldr	r3, [r2, #16]
    2fb6:	subs	r3, #1
    2fb8:	str	r3, [r2, #16]
    2fba:	cbnz	r3, 2fee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fbc:	ldr.w	r2, [fp, #16]
    2fc0:	cbz	r2, 2fee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fc2:	ldr	r3, [r2, #0]
    2fc4:	ldr	r3, [r3, #32]
    2fc6:	cmp	r3, r1
    2fc8:	bne.n	3074 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x460>
    2fca:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2fcc:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2fce:	cbz	r1, 2fe6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2fd0:	ldr	r3, [r1, #16]
    2fd2:	subs	r3, #1
    2fd4:	str	r3, [r1, #16]
    2fd6:	cbnz	r3, 2fe6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2fd8:	ldr	r0, [r2, #16]
    2fda:	cbz	r0, 2fe6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2fdc:	ldr	r3, [r0, #0]
    2fde:	str	r2, [sp, #4]
    2fe0:	ldr	r3, [r3, #32]
    2fe2:	blx	r3
    2fe4:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2fe6:	mov	r0, r2
    2fe8:	movs	r1, #20
    2fea:	bl	e960 <operator delete(void*, unsigned int)>
    2fee:	mov	r0, fp
    2ff0:	movs	r1, #20
    2ff2:	bl	e960 <operator delete(void*, unsigned int)>
    2ff6:	mov	r0, sl
    2ff8:	movs	r1, #20
    2ffa:	bl	e960 <operator delete(void*, unsigned int)>
    2ffe:	mov	r0, r9
    3000:	movs	r1, #20
    3002:	bl	e960 <operator delete(void*, unsigned int)>
    3006:	mov	r0, r8
    3008:	movs	r1, #20
    300a:	bl	e960 <operator delete(void*, unsigned int)>
    300e:	mov	r0, r7
    3010:	movs	r1, #20
    3012:	bl	e960 <operator delete(void*, unsigned int)>
    3016:	b.n	2d92 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    if (open_file_ == i && mode_ == mode) return;
    3018:	ldr.w	r3, [r0, #236]	; 0xec
    301c:	cmp	r3, r2
    301e:	bne.w	2c24 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x10>
    if(sd_isOpen(file_)) file_.close();
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    mode_ = mode;
    mtp_lock_storage(false);
  }
    3022:	add	sp, #292	; 0x124
    3024:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3028:	blx	r2
    302a:	b.n	2cd8 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0xc4>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    302c:	blx	r2
    302e:	b.n	2d50 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3030:	mov	r0, r7
    3032:	blx	r3
    3034:	b.n	2d70 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    3036:	mov	r0, r7
    3038:	blx	r2
    303a:	b.n	2d92 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    303c:	mov	r0, r9
    303e:	blx	r2
    3040:	b.n	3006 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    3042:	mov	r0, r9
    3044:	blx	r2
    3046:	b.n	2ed6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    3048:	mov	r0, r8
    304a:	blx	r2
    304c:	b.n	300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    304e:	mov	r0, r8
    3050:	blx	r2
    3052:	b.n	2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    3054:	mov	r0, sl
    3056:	blx	r2
    3058:	b.n	2ffe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    305a:	mov	r0, sl
    305c:	blx	r2
    305e:	b.n	2ece <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    3060:	.word	0x00000f25
    3064:	.word	0x000141ec
    3068:	mov	r0, fp
    306a:	blx	r2
    306c:	b.n	2ff6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    306e:	mov	r0, fp
    3070:	blx	r2
    3072:	b.n	2ec6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    3074:	mov	r0, r2
    3076:	blx	r3
    3078:	b.n	2fee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    307a:	mov	r0, r2
    307c:	blx	r3
    307e:	b.n	2ebe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>

00003080 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)>:
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    3080:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3084:	mov	r5, r0
    3086:	sub	sp, #8
    3088:	mov	r7, r2
    OpenFileByIndex(handle);
    308a:	movs	r2, #0
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    308c:	mov	r8, r3
    308e:	ldr.w	r9, [sp, #40]	; 0x28
    OpenFileByIndex(handle);
    3092:	bl	2c14 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    3096:	ldr.w	r4, [r5, #204]	; 0xcc
    309a:	cmp	r4, #0
    309c:	beq.n	3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    309e:	ldr	r0, [r4, #0]
    30a0:	ldr	r2, [pc, #308]	; (31d8 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x158>)
    30a2:	ldr	r6, [r0, #52]	; 0x34
    30a4:	cmp	r6, r2
    30a6:	mov.w	r3, #0
    30aa:	bne.n	31a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x124>
    30ac:	ldr	r1, [r4, #16]
    30ae:	cmp	r1, #0
    30b0:	beq.n	316c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xec>
    30b2:	ldr	r2, [r1, #0]
    30b4:	ldr.w	sl, [r2, #52]	; 0x34
    30b8:	cmp	sl, r6
    30ba:	bne.n	31ae <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x12e>
    30bc:	ldr.w	lr, [r1, #16]
    30c0:	cmp.w	lr, #0
    30c4:	beq.n	317a <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    30c6:	ldr.w	r2, [lr]
    30ca:	ldr	r6, [r2, #52]	; 0x34
    30cc:	cmp	r6, sl
    30ce:	bne.n	31b8 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x138>
    30d0:	ldr.w	lr, [lr, #16]
    30d4:	cmp.w	lr, #0
    30d8:	beq.n	317a <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    30da:	ldr.w	r2, [lr]
    30de:	ldr.w	sl, [r2, #52]	; 0x34
    30e2:	cmp	sl, r6
    30e4:	bne.n	31c2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x142>
    30e6:	ldr.w	lr, [lr, #16]
    30ea:	cmp.w	lr, #0
    30ee:	beq.n	317a <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    30f0:	ldr.w	r3, [lr]
    30f4:	ldr	r6, [r3, #52]	; 0x34
    30f6:	cmp	r6, sl
    30f8:	bne.n	31cc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x14c>
    30fa:	ldr.w	r6, [lr, #16]
    30fe:	cmp	r6, #0
    3100:	beq.n	317a <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    3102:	ldr	r1, [r6, #0]
    3104:	movs	r3, #0
    3106:	str	r3, [sp, #0]
    3108:	mov	r2, r7
    310a:	mov	r0, r6
    310c:	ldr	r1, [r1, #52]	; 0x34
    310e:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    3110:	ldr.w	r4, [r5, #204]	; 0xcc
    3114:	cmp	r4, #0
    3116:	beq.n	3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3118:	ldr	r2, [r4, #0]
    311a:	ldr	r3, [pc, #192]	; (31dc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    311c:	ldr	r5, [r2, #40]	; 0x28
    311e:	cmp	r5, r3
    3120:	bne.n	3186 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    3122:	ldr	r0, [r4, #16]
    3124:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3126:	ldr	r2, [r0, #0]
    3128:	ldr	r4, [r2, #40]	; 0x28
    312a:	cmp	r4, r3
    312c:	bne.n	3196 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    312e:	ldr	r0, [r0, #16]
    3130:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3132:	ldr	r2, [r0, #0]
    3134:	ldr	r4, [r2, #40]	; 0x28
    3136:	cmp	r4, r3
    3138:	bne.n	3196 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    313a:	ldr	r0, [r0, #16]
    313c:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    313e:	ldr	r2, [r0, #0]
    3140:	ldr	r4, [r2, #40]	; 0x28
    3142:	cmp	r4, r3
    3144:	bne.n	3196 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    3146:	ldr	r0, [r0, #16]
    3148:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    314a:	ldr	r2, [r0, #0]
    314c:	ldr	r4, [r2, #40]	; 0x28
    314e:	cmp	r4, r3
    3150:	bne.n	3196 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    3152:	ldr	r0, [r0, #16]
    3154:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3156:	ldr	r2, [r0, #0]
    3158:	ldr	r4, [r2, #40]	; 0x28
    315a:	cmp	r4, r3
    315c:	bne.n	3196 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    315e:	ldr	r0, [r0, #16]
    3160:	cbz	r0, 3174 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3162:	ldr	r3, [r0, #0]
    3164:	mov	r2, r9
    3166:	mov	r1, r8
    3168:	ldr	r3, [r3, #40]	; 0x28
    316a:	b.n	318e <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x10e>
    316c:	ldr	r5, [r0, #40]	; 0x28
    316e:	ldr	r3, [pc, #108]	; (31dc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    3170:	cmp	r5, r3
    3172:	bne.n	3186 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    mtp_lock_storage(true);
    file_.seek(pos);
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }
    3174:	add	sp, #8
    3176:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    317a:	ldr	r5, [r0, #40]	; 0x28
    317c:	ldr	r3, [pc, #92]	; (31dc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    317e:	cmp	r5, r3
    3180:	bne.n	3186 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    3182:	mov	r0, r1
    3184:	b.n	3126 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xa6>
    3186:	mov	r2, r9
    3188:	mov	r1, r8
    318a:	mov	r0, r4
    318c:	mov	r3, r5
    318e:	add	sp, #8
    3190:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3194:	bx	r3
    3196:	mov	r2, r9
    3198:	mov	r1, r8
    319a:	mov	r3, r4
    319c:	add	sp, #8
    319e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    31a2:	bx	r3
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    31a4:	str	r3, [sp, #0]
    31a6:	mov	r2, r7
    31a8:	mov	r0, r4
    31aa:	blx	r6
    31ac:	b.n	3110 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31ae:	str	r3, [sp, #0]
    31b0:	mov	r2, r7
    31b2:	mov	r0, r1
    31b4:	blx	sl
    31b6:	b.n	3110 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31b8:	str	r3, [sp, #0]
    31ba:	mov	r2, r7
    31bc:	mov	r0, lr
    31be:	blx	r6
    31c0:	b.n	3110 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31c2:	str	r3, [sp, #0]
    31c4:	mov	r2, r7
    31c6:	mov	r0, lr
    31c8:	blx	sl
    31ca:	b.n	3110 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31cc:	movs	r3, #0
    31ce:	mov	r2, r7
    31d0:	mov	r0, lr
    31d2:	str	r3, [sp, #0]
    31d4:	blx	r6
    31d6:	b.n	3110 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31d8:	.word	0x000004c1
    31dc:	.word	0x00000475

000031e0 <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)>:
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    31e0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    31e4:	cmp.w	r2, #4294967295
    31e8:	ite	ne
    31ea:	movne	r6, r2
    31ec:	moveq	r6, r1
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    31ee:	sub.w	sp, sp, #800	; 0x320
    31f2:	mov	r4, r0
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    31f4:	mov	r2, r6
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    31f6:	mov	r7, r1
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    31f8:	mov	r1, r0
    31fa:	add	r0, sp, #256	; 0x100
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    31fc:	mov	r8, r3
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    31fe:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    3202:	ldr	r1, [sp, #824]	; 0x338
    3204:	mov.w	r2, #256	; 0x100
    3208:	add	r0, sp, #544	; 0x220
    320a:	bl	10ce0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    320e:	ldr.w	r5, [r4, #244]	; 0xf4
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    3212:	ldrh.w	r3, [sp, #270]	; 0x10e
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    3216:	ldr	r2, [sp, #260]	; 0x104
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    3218:	strh.w	r3, [sp, #542]	; 0x21e
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    321c:	adds	r1, r5, #1
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    321e:	movs	r3, #0
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3220:	str.w	r1, [r4, #244]	; 0xf4
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    3224:	str	r3, [sp, #532]	; 0x214
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    3226:	mov	r1, r5
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    3228:	movs	r3, #1
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    322a:	str	r2, [sp, #536]	; 0x218
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    322c:	mov	r0, r4
    322e:	add	r2, sp, #528	; 0x210
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    3230:	str	r6, [sp, #528]	; 0x210
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    3232:	strb.w	r8, [sp, #540]	; 0x21c
    // New folder is empty, scanned = true.
    r.scanned = 1;
    3236:	strb.w	r3, [sp, #541]	; 0x21d
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    323a:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    323e:	mov	r1, r6
    3240:	add	r2, sp, #256	; 0x100
    3242:	mov	r0, r4
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    3244:	str	r5, [sp, #260]	; 0x104
    WriteIndexRecord(parent, p);
    3246:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    if (folder) 
    324a:	cmp.w	r8, #0
    324e:	bne.n	3264 <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)+0x84>
      sd_mkdir(store,filename);
      mtp_lock_storage(false);
    } 
    else 
    {
      OpenFileByIndex(ret, FILE_WRITE_BEGIN);
    3250:	mov	r0, r4
    3252:	movs	r2, #2
    3254:	mov	r1, r5
    3256:	bl	2c14 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    325a:	mov	r0, r5
    325c:	add.w	sp, sp, #800	; 0x320
    3260:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    if (folder) 
    {
      char filename[MAX_FILENAME_LEN];
      ConstructFilename(ret, filename, MAX_FILENAME_LEN);
    3264:	mov	r0, r4
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    3266:	add.w	r4, r4, r7, lsl #2
    326a:	mov	r2, sp
    326c:	mov	r1, r5
    326e:	mov.w	r3, #256	; 0x100
    3272:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    3276:	ldr	r0, [r4, #88]	; 0x58
    3278:	ldr	r3, [r0, #0]
    327a:	mov	r1, sp
    327c:	ldr	r3, [r3, #8]
    327e:	blx	r3
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    3280:	mov	r0, r5
    3282:	add.w	sp, sp, #800	; 0x320
    3286:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    328a:	nop

0000328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>:
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    328c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3290:	cmp.w	r2, #4294967295
    3294:	ite	ne
    3296:	movne	r6, r2
    3298:	moveq	r6, r1
    329a:	sub.w	sp, sp, #564	; 0x234
    
    Record record = ReadIndexRecord(i);
    329e:	mov	r1, r0
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    32a0:	mov	r4, r0
    
    Record record = ReadIndexRecord(i);
    32a2:	mov	r2, r6
    32a4:	add	r0, sp, #16
    32a6:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if (record.isdir && !record.scanned) {
    32aa:	ldrb.w	r3, [sp, #28]
    32ae:	cbz	r3, 32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32b0:	ldrb.w	r2, [sp, #29]
    32b4:	cbz	r2, 32be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x32>
      }
      record.scanned = true;
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }
    32b6:	add.w	sp, sp, #564	; 0x234
    32ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    
    Record record = ReadIndexRecord(i);
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
    32be:	mov	r0, r4
    32c0:	mov	r1, r6
    32c2:	bl	2c14 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    32c6:	ldr.w	r0, [r4, #204]	; 0xcc
    32ca:	cmp	r0, #0
    32cc:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32ce:	ldr	r3, [r0, #0]
    32d0:	ldr.w	r8, [pc, #892]	; 3650 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c4>
    32d4:	ldr	r3, [r3, #68]	; 0x44
    32d6:	cmp	r3, r8
    32d8:	bne.n	3394 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    32da:	ldr	r0, [r0, #16]
    32dc:	cmp	r0, #0
    32de:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32e0:	ldr	r3, [r0, #0]
    32e2:	ldr	r3, [r3, #68]	; 0x44
    32e4:	cmp	r3, r8
    32e6:	bne.n	3394 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    32e8:	ldr	r0, [r0, #16]
    32ea:	cmp	r0, #0
    32ec:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32ee:	ldr	r3, [r0, #0]
    32f0:	ldr	r3, [r3, #68]	; 0x44
    32f2:	cmp	r3, r8
    32f4:	bne.n	3394 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    32f6:	ldr	r0, [r0, #16]
    32f8:	cmp	r0, #0
    32fa:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32fc:	ldr	r3, [r0, #0]
    32fe:	ldr	r3, [r3, #68]	; 0x44
    3300:	cmp	r3, r8
    3302:	bne.n	3394 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    3304:	ldr	r0, [r0, #16]
    3306:	cmp	r0, #0
    3308:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    330a:	ldr	r3, [r0, #0]
    330c:	ldr	r3, [r3, #68]	; 0x44
    330e:	cmp	r3, r8
    3310:	bne.n	3394 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    3312:	ldr	r0, [r0, #16]
    3314:	cmp	r0, #0
    3316:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3318:	ldr	r3, [r0, #0]
    331a:	ldr	r3, [r3, #68]	; 0x44
    331c:	blx	r3
      if (!sd_isOpen(file_)) return;
    331e:	cmp	r0, #0
    3320:	beq.n	32b6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    3322:	ldr.w	r9, [pc, #804]	; 3648 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>
    3326:	ldr.w	fp, [pc, #812]	; 3654 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c8>
    332a:	movs	r5, #0
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    332c:	ldr.w	r1, [r4, #204]	; 0xcc
    3330:	cmp	r1, #0
    3332:	beq.n	3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3334:	ldr	r3, [r1, #0]
    3336:	ldr	r3, [r3, #80]	; 0x50
    3338:	cmp	r3, fp
    333a:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    333e:	ldr	r1, [r1, #16]
    3340:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3342:	ldr	r3, [r1, #0]
    3344:	ldr	r3, [r3, #80]	; 0x50
    3346:	cmp	r3, fp
    3348:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    334c:	ldr	r1, [r1, #16]
    334e:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3350:	ldr	r3, [r1, #0]
    3352:	ldr	r3, [r3, #80]	; 0x50
    3354:	cmp	r3, fp
    3356:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    335a:	ldr	r1, [r1, #16]
    335c:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    335e:	ldr	r3, [r1, #0]
    3360:	ldr	r3, [r3, #80]	; 0x50
    3362:	cmp	r3, fp
    3364:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3368:	ldr	r1, [r1, #16]
    336a:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    336c:	ldr	r3, [r1, #0]
    336e:	ldr	r3, [r3, #80]	; 0x50
    3370:	cmp	r3, fp
    3372:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3376:	ldr	r1, [r1, #16]
    3378:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    337a:	ldr	r3, [r1, #0]
    337c:	ldr	r3, [r3, #80]	; 0x50
    337e:	cmp	r3, fp
    3380:	bne.w	384e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3384:	ldr	r1, [r1, #16]
    3386:	cbz	r1, 3398 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3388:	ldr	r3, [r1, #0]
    338a:	movs	r2, #0
    338c:	ldr	r3, [r3, #80]	; 0x50
    338e:	add	r0, sp, #288	; 0x120
    3390:	blx	r3
    3392:	b.n	33ae <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3394:	blx	r3
    3396:	b.n	331e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x92>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    3398:	movs	r3, #0
    339a:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    339e:	str.w	r9, [sp, #288]	; 0x120
    33a2:	strb.w	r3, [sp, #292]	; 0x124
    33a6:	strb.w	r3, [sp, #300]	; 0x12c
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    33aa:	str	r3, [sp, #304]	; 0x130
    33ac:	str	r2, [sp, #296]	; 0x128
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    33ae:	ldr.w	r2, [r4, #224]	; 0xe0
    33b2:	cmp	r2, #0
    33b4:	beq.n	344a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33b6:	ldr	r3, [r2, #16]
    33b8:	subs	r3, #1
    33ba:	str	r3, [r2, #16]
    33bc:	cmp	r3, #0
    33be:	bne.n	344a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33c0:	ldr.w	r7, [r4, #224]	; 0xe0
    33c4:	cmp	r7, #0
    33c6:	beq.n	344a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33c8:	ldr	r3, [r7, #0]
    33ca:	ldr	r0, [pc, #632]	; (3644 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    33cc:	ldr	r3, [r3, #32]
    33ce:	cmp	r3, r0
    33d0:	bne.w	3870 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5e4>
    33d4:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    33d6:	str.w	r9, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    33da:	cbz	r2, 3442 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    33dc:	ldr	r3, [r2, #16]
    33de:	subs	r3, #1
    33e0:	str	r3, [r2, #16]
    33e2:	cbnz	r3, 3442 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    33e4:	ldr.w	sl, [r7, #16]
    33e8:	cmp.w	sl, #0
    33ec:	beq.n	3442 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    33ee:	ldr.w	r3, [sl]
    33f2:	ldr	r3, [r3, #32]
    33f4:	cmp	r3, r0
    33f6:	bne.w	3a3e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b2>
    33fa:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    33fe:	ldr	r3, [pc, #584]	; (3648 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    3400:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3404:	cbz	r2, 343a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    3406:	ldr	r3, [r2, #16]
    3408:	subs	r3, #1
    340a:	str	r3, [r2, #16]
    340c:	cbnz	r3, 343a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    340e:	ldr.w	r3, [sl, #16]
    3412:	cbz	r3, 343a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    3414:	ldr	r2, [r3, #0]
    3416:	ldr	r2, [r2, #32]
    3418:	cmp	r2, r0
    341a:	bne.w	3a50 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7c4>
    341e:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3420:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3424:	cbz	r1, 3432 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    3426:	ldr	r2, [r1, #16]
    3428:	subs	r2, #1
    342a:	str	r2, [r1, #16]
    342c:	cmp	r2, #0
    342e:	beq.w	3888 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5fc>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3432:	mov	r0, r3
    3434:	movs	r1, #20
    3436:	bl	e960 <operator delete(void*, unsigned int)>
    343a:	mov	r0, sl
    343c:	movs	r1, #20
    343e:	bl	e960 <operator delete(void*, unsigned int)>
    3442:	mov	r0, r7
    3444:	movs	r1, #20
    3446:	bl	e960 <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    344a:	ldr	r3, [sp, #304]	; 0x130
    344c:	str.w	r3, [r4, #224]	; 0xe0
		if (f) f->refcount++;
    3450:	cmp	r3, #0
    3452:	beq.n	34f6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3454:	ldr	r2, [r3, #16]
    3456:	adds	r2, #1
    3458:	str	r2, [r3, #16]
    345a:	ldr	r2, [sp, #304]	; 0x130
		return *this;
	}
	virtual ~File() {
    345c:	str.w	r9, [sp, #288]	; 0x120
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3460:	cmp	r2, #0
    3462:	beq.n	34f6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3464:	ldr	r3, [r2, #16]
    3466:	subs	r3, #1
    3468:	str	r3, [r2, #16]
    346a:	cmp	r3, #0
    346c:	bne.n	34f6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    346e:	ldr	r7, [sp, #304]	; 0x130
    3470:	cmp	r7, #0
    3472:	beq.n	34f6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3474:	ldr	r3, [r7, #0]
    3476:	ldr	r0, [pc, #460]	; (3644 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    3478:	ldr	r3, [r3, #32]
    347a:	cmp	r3, r0
    347c:	bne.w	386a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5de>
    3480:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3482:	ldr	r3, [pc, #452]	; (3648 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    3484:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3486:	cbz	r2, 34ee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    3488:	ldr	r3, [r2, #16]
    348a:	subs	r3, #1
    348c:	str	r3, [r2, #16]
    348e:	cbnz	r3, 34ee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    3490:	ldr.w	sl, [r7, #16]
    3494:	cmp.w	sl, #0
    3498:	beq.n	34ee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    349a:	ldr.w	r3, [sl]
    349e:	ldr	r3, [r3, #32]
    34a0:	cmp	r3, r0
    34a2:	bne.w	3a44 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b8>
    34a6:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34aa:	ldr	r3, [pc, #412]	; (3648 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    34ac:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34b0:	cbz	r2, 34e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34b2:	ldr	r3, [r2, #16]
    34b4:	subs	r3, #1
    34b6:	str	r3, [r2, #16]
    34b8:	cbnz	r3, 34e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34ba:	ldr.w	r3, [sl, #16]
    34be:	cbz	r3, 34e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34c0:	ldr	r2, [r3, #0]
    34c2:	ldr	r2, [r2, #32]
    34c4:	cmp	r2, r0
    34c6:	bne.w	3a4a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7be>
    34ca:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34cc:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34d0:	cbz	r1, 34de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    34d2:	ldr	r2, [r1, #16]
    34d4:	subs	r2, #1
    34d6:	str	r2, [r1, #16]
    34d8:	cmp	r2, #0
    34da:	beq.w	3966 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6da>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    34de:	mov	r0, r3
    34e0:	movs	r1, #20
    34e2:	bl	e960 <operator delete(void*, unsigned int)>
    34e6:	mov	r0, sl
    34e8:	movs	r1, #20
    34ea:	bl	e960 <operator delete(void*, unsigned int)>
    34ee:	mov	r0, r7
    34f0:	movs	r1, #20
    34f2:	bl	e960 <operator delete(void*, unsigned int)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    34f6:	ldr.w	r0, [r4, #224]	; 0xe0
    34fa:	cmp	r0, #0
    34fc:	beq.w	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3500:	ldr	r3, [r0, #0]
    3502:	ldr	r3, [r3, #68]	; 0x44
    3504:	cmp	r3, r8
    3506:	bne.w	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    350a:	ldr	r0, [r0, #16]
    350c:	cmp	r0, #0
    350e:	beq.w	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3512:	ldr	r3, [r0, #0]
    3514:	ldr	r3, [r3, #68]	; 0x44
    3516:	cmp	r3, r8
    3518:	bne.w	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    351c:	ldr	r0, [r0, #16]
    351e:	cmp	r0, #0
    3520:	beq.w	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3524:	ldr	r3, [r0, #0]
    3526:	ldr	r3, [r3, #68]	; 0x44
    3528:	cmp	r3, r8
    352a:	bne.w	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    352e:	ldr	r0, [r0, #16]
    3530:	cmp	r0, #0
    3532:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3534:	ldr	r3, [r0, #0]
    3536:	ldr	r3, [r3, #68]	; 0x44
    3538:	cmp	r3, r8
    353a:	bne.w	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    353e:	ldr	r0, [r0, #16]
    3540:	cmp	r0, #0
    3542:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3544:	ldr	r3, [r0, #0]
    3546:	ldr	r3, [r3, #68]	; 0x44
    3548:	cmp	r3, r8
    354a:	bne.n	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    354c:	ldr	r0, [r0, #16]
    354e:	cmp	r0, #0
    3550:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3552:	ldr	r3, [r0, #0]
    3554:	ldr	r3, [r3, #68]	; 0x44
    3556:	cmp	r3, r8
    3558:	bne.n	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    355a:	ldr	r0, [r0, #16]
    355c:	cmp	r0, #0
    355e:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3560:	ldr	r3, [r0, #0]
    3562:	ldr	r3, [r3, #68]	; 0x44
    3564:	cmp	r3, r8
    3566:	bne.n	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3568:	ldr	r0, [r0, #16]
    356a:	cmp	r0, #0
    356c:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    356e:	ldr	r3, [r0, #0]
    3570:	ldr	r3, [r3, #68]	; 0x44
    3572:	cmp	r3, r8
    3574:	bne.n	3640 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3576:	ldr	r0, [r0, #16]
    3578:	cmp	r0, #0
    357a:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    357c:	ldr	r3, [r0, #0]
    357e:	ldr	r3, [r3, #68]	; 0x44
    3580:	blx	r3
      int sibling = 0;
      while (true) 
      { mtp_lock_storage(true);
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;
    3582:	cmp	r0, #0
    3584:	beq.n	3626 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3586:	ldr.w	r3, [r4, #224]	; 0xe0

        Record r;
        r.store = record.store;
    358a:	ldrh.w	r2, [sp, #30]
        r.parent = i;
    358e:	str	r6, [sp, #288]	; 0x120
        r.sibling = sibling;
    3590:	str	r5, [sp, #296]	; 0x128
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;

        Record r;
        r.store = record.store;
    3592:	strh.w	r2, [sp, #302]	; 0x12e
    3596:	cmp	r3, #0
    3598:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    359c:	ldr	r1, [r3, #0]
    359e:	ldr	r2, [pc, #172]	; (364c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c0>)
    35a0:	ldr	r1, [r1, #76]	; 0x4c
    35a2:	cmp	r1, r2
    35a4:	bne.n	3658 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3cc>
    35a6:	ldr	r0, [r3, #16]
    35a8:	cmp	r0, #0
    35aa:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35ae:	ldr	r1, [r0, #0]
    35b0:	ldr	r1, [r1, #76]	; 0x4c
    35b2:	cmp	r1, r2
    35b4:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35b6:	ldr	r0, [r0, #16]
    35b8:	cmp	r0, #0
    35ba:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35be:	ldr	r1, [r0, #0]
    35c0:	ldr	r1, [r1, #76]	; 0x4c
    35c2:	cmp	r1, r2
    35c4:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35c6:	ldr	r0, [r0, #16]
    35c8:	cmp	r0, #0
    35ca:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35ce:	ldr	r1, [r0, #0]
    35d0:	ldr	r1, [r1, #76]	; 0x4c
    35d2:	cmp	r1, r2
    35d4:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35d6:	ldr	r0, [r0, #16]
    35d8:	cmp	r0, #0
    35da:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35de:	ldr	r1, [r0, #0]
    35e0:	ldr	r1, [r1, #76]	; 0x4c
    35e2:	cmp	r1, r2
    35e4:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35e6:	ldr	r0, [r0, #16]
    35e8:	cmp	r0, #0
    35ea:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35ee:	ldr	r1, [r0, #0]
    35f0:	ldr	r1, [r1, #76]	; 0x4c
    35f2:	cmp	r1, r2
    35f4:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35f6:	ldr	r0, [r0, #16]
    35f8:	cmp	r0, #0
    35fa:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35fe:	ldr	r1, [r0, #0]
    3600:	ldr	r1, [r1, #76]	; 0x4c
    3602:	cmp	r1, r2
    3604:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    3606:	ldr	r0, [r0, #16]
    3608:	cmp	r0, #0
    360a:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    360e:	ldr	r1, [r0, #0]
    3610:	ldr	r1, [r1, #76]	; 0x4c
    3612:	cmp	r1, r2
    3614:	bne.n	365a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    3616:	ldr	r0, [r0, #16]
    3618:	cmp	r0, #0
    361a:	beq.w	37c2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    361e:	ldr	r3, [r0, #0]
    3620:	ldr	r3, [r3, #76]	; 0x4c
    3622:	blx	r3
    3624:	b.n	365c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3d0>
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    3626:	movs	r3, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    3628:	mov	r1, r6
    362a:	mov	r0, r4
    362c:	add	r2, sp, #16
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
      record.child = sibling;
    362e:	str	r5, [sp, #20]
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    3630:	strb.w	r3, [sp, #29]
      record.child = sibling;
      WriteIndexRecord(i, record);
    3634:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
  }
    3638:	add.w	sp, sp, #564	; 0x234
    363c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3640:	blx	r3
    3642:	b.n	3582 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2f6>
    3644:	.word	0x00000f25
    3648:	.word	0x000141ec
    364c:	.word	0x00000521
    3650:	.word	0x00000501
    3654:	.word	0x0000052d
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3658:	mov	r0, r3
    365a:	blx	r1

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    365c:	strb.w	r0, [sp, #300]	; 0x12c
    3660:	ldr.w	r3, [r4, #224]	; 0xe0
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    3664:	cmp	r0, #0
    3666:	beq.w	37c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x53c>
    366a:	movs	r0, #0
        r.scanned = false;
    366c:	movs	r2, #0
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    366e:	str	r0, [sp, #292]	; 0x124
        r.scanned = false;
    3670:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    3674:	cmp	r3, #0
    3676:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    367a:	ldr	r1, [r3, #0]
    367c:	ldr	r2, [pc, #504]	; (3878 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    367e:	ldr	r1, [r1, #72]	; 0x48
    3680:	cmp	r1, r2
    3682:	bne.w	3842 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5b6>
    3686:	ldr	r0, [r3, #16]
    3688:	cmp	r0, #0
    368a:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    368e:	ldr	r3, [r0, #0]
    3690:	ldr	r3, [r3, #72]	; 0x48
    3692:	cmp	r3, r2
    3694:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    3696:	ldr	r0, [r0, #16]
    3698:	cmp	r0, #0
    369a:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    369e:	ldr	r3, [r0, #0]
    36a0:	ldr	r3, [r3, #72]	; 0x48
    36a2:	cmp	r3, r2
    36a4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36a6:	ldr	r0, [r0, #16]
    36a8:	cmp	r0, #0
    36aa:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36ae:	ldr	r3, [r0, #0]
    36b0:	ldr	r3, [r3, #72]	; 0x48
    36b2:	cmp	r3, r2
    36b4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36b6:	ldr	r0, [r0, #16]
    36b8:	cmp	r0, #0
    36ba:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36be:	ldr	r3, [r0, #0]
    36c0:	ldr	r3, [r3, #72]	; 0x48
    36c2:	cmp	r3, r2
    36c4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36c6:	ldr	r0, [r0, #16]
    36c8:	cmp	r0, #0
    36ca:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36ce:	ldr	r3, [r0, #0]
    36d0:	ldr	r3, [r3, #72]	; 0x48
    36d2:	cmp	r3, r2
    36d4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36d6:	ldr	r0, [r0, #16]
    36d8:	cmp	r0, #0
    36da:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36de:	ldr	r3, [r0, #0]
    36e0:	ldr	r3, [r3, #72]	; 0x48
    36e2:	cmp	r3, r2
    36e4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36e6:	ldr	r0, [r0, #16]
    36e8:	cmp	r0, #0
    36ea:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36ee:	ldr	r3, [r0, #0]
    36f0:	ldr	r3, [r3, #72]	; 0x48
    36f2:	cmp	r3, r2
    36f4:	bne.n	3708 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36f6:	ldr	r0, [r0, #16]
    36f8:	cmp	r0, #0
    36fa:	beq.w	384a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36fe:	ldr	r3, [r0, #0]
    3700:	ldr	r3, [r3, #72]	; 0x48
    3702:	blx	r3
    3704:	mov	r1, r0
    3706:	b.n	370c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    3708:	blx	r3
    370a:	mov	r1, r0
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
    370c:	mov.w	r2, #256	; 0x100
    3710:	add	r0, sp, #304	; 0x130
    3712:	bl	10ce0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3716:	ldr.w	r5, [r4, #244]	; 0xf4
    371a:	adds	r3, r5, #1
    WriteIndexRecord(new_record, r);
    371c:	mov	r0, r4
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    371e:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    3722:	mov	r1, r5
    3724:	add	r2, sp, #288	; 0x120
    3726:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    372a:	ldr.w	r0, [r4, #224]	; 0xe0
    372e:	cmp	r0, #0
    3730:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3734:	ldr	r2, [r0, #0]
    3736:	ldr	r3, [pc, #324]	; (387c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f0>)
    3738:	ldr	r2, [r2, #64]	; 0x40
    373a:	cmp	r2, r3
    373c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    373e:	ldr	r0, [r0, #16]
    3740:	cmp	r0, #0
    3742:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3746:	ldr	r2, [r0, #0]
    3748:	ldr	r2, [r2, #64]	; 0x40
    374a:	cmp	r2, r3
    374c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    374e:	ldr	r0, [r0, #16]
    3750:	cmp	r0, #0
    3752:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3756:	ldr	r2, [r0, #0]
    3758:	ldr	r2, [r2, #64]	; 0x40
    375a:	cmp	r2, r3
    375c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    375e:	ldr	r0, [r0, #16]
    3760:	cmp	r0, #0
    3762:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3766:	ldr	r2, [r0, #0]
    3768:	ldr	r2, [r2, #64]	; 0x40
    376a:	cmp	r2, r3
    376c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    376e:	ldr	r0, [r0, #16]
    3770:	cmp	r0, #0
    3772:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3776:	ldr	r2, [r0, #0]
    3778:	ldr	r2, [r2, #64]	; 0x40
    377a:	cmp	r2, r3
    377c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    377e:	ldr	r0, [r0, #16]
    3780:	cmp	r0, #0
    3782:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3786:	ldr	r2, [r0, #0]
    3788:	ldr	r2, [r2, #64]	; 0x40
    378a:	cmp	r2, r3
    378c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    378e:	ldr	r0, [r0, #16]
    3790:	cmp	r0, #0
    3792:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    3796:	ldr	r2, [r0, #0]
    3798:	ldr	r2, [r2, #64]	; 0x40
    379a:	cmp	r2, r3
    379c:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    379e:	ldr	r0, [r0, #16]
    37a0:	cmp	r0, #0
    37a2:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37a6:	ldr	r2, [r0, #0]
    37a8:	ldr	r2, [r2, #64]	; 0x40
    37aa:	cmp	r2, r3
    37ac:	bne.n	37be <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    37ae:	ldr	r0, [r0, #16]
    37b0:	cmp	r0, #0
    37b2:	beq.w	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37b6:	ldr	r3, [r0, #0]
    37b8:	ldr	r3, [r3, #64]	; 0x40
    37ba:	blx	r3
    37bc:	b.n	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37be:	blx	r2
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
      if (!sd_isOpen(file_)) return;
    
      int sibling = 0;
      while (true) 
    37c0:	b.n	332c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    37c2:	movs	r2, #0
    37c4:	strb.w	r2, [sp, #300]	; 0x12c
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    37c8:	cmp	r3, #0
    37ca:	beq.n	3860 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5d4>
    37cc:	ldr	r1, [r3, #0]
    37ce:	ldr	r2, [pc, #176]	; (3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f4>)
    37d0:	ldr	r1, [r1, #60]	; 0x3c
    37d2:	cmp	r1, r2
    37d4:	bne.n	3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ca>
    37d6:	ldr	r0, [r3, #16]
    37d8:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    37da:	ldr	r1, [r0, #0]
    37dc:	ldr	r1, [r1, #60]	; 0x3c
    37de:	cmp	r1, r2
    37e0:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    37e2:	ldr	r0, [r0, #16]
    37e4:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    37e6:	ldr	r1, [r0, #0]
    37e8:	ldr	r1, [r1, #60]	; 0x3c
    37ea:	cmp	r1, r2
    37ec:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    37ee:	ldr	r0, [r0, #16]
    37f0:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    37f2:	ldr	r1, [r0, #0]
    37f4:	ldr	r1, [r1, #60]	; 0x3c
    37f6:	cmp	r1, r2
    37f8:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    37fa:	ldr	r0, [r0, #16]
    37fc:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    37fe:	ldr	r1, [r0, #0]
    3800:	ldr	r1, [r1, #60]	; 0x3c
    3802:	cmp	r1, r2
    3804:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    3806:	ldr	r0, [r0, #16]
    3808:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    380a:	ldr	r1, [r0, #0]
    380c:	ldr	r1, [r1, #60]	; 0x3c
    380e:	cmp	r1, r2
    3810:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    3812:	ldr	r0, [r0, #16]
    3814:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    3816:	ldr	r1, [r0, #0]
    3818:	ldr	r1, [r1, #60]	; 0x3c
    381a:	cmp	r1, r2
    381c:	bne.n	3858 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    381e:	ldr	r0, [r0, #16]
    3820:	cbz	r0, 382e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    3822:	ldr	r3, [r0, #0]
    3824:	ldr	r3, [r3, #60]	; 0x3c
    3826:	blx	r3
    3828:	ldr.w	r3, [r4, #224]	; 0xe0
    382c:	b.n	366c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    382e:	movs	r2, #0
        r.scanned = false;
    3830:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    3834:	ldr	r1, [r3, #0]
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    3836:	str	r2, [sp, #292]	; 0x124
    3838:	ldr	r1, [r1, #72]	; 0x48
    383a:	ldr	r2, [pc, #60]	; (3878 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    383c:	cmp	r1, r2
    383e:	beq.w	3686 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3fa>
    3842:	mov	r0, r3
    3844:	blx	r1
    3846:	mov	r1, r0
    3848:	b.n	370c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    384a:	ldr	r1, [pc, #56]	; (3884 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    384c:	b.n	370c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    384e:	movs	r2, #0
    3850:	add	r0, sp, #288	; 0x120
    3852:	blx	r3
    3854:	b.n	33ae <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    3856:	mov	r0, r3
    3858:	blx	r1
    385a:	ldr.w	r3, [r4, #224]	; 0xe0
    385e:	b.n	366c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
    3860:	str	r3, [sp, #292]	; 0x124
        r.scanned = false;
    3862:	strb.w	r3, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    3866:	ldr	r1, [pc, #28]	; (3884 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    3868:	b.n	370c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    386a:	mov	r0, r7
    386c:	blx	r3
    386e:	b.n	34f6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3870:	mov	r0, r7
    3872:	blx	r3
    3874:	b.n	344a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    3876:	nop
    3878:	.word	0x0000050d
    387c:	.word	0x000004f5
    3880:	.word	0x000004e5
    3884:	.word	0x000143a8
    3888:	ldr	r2, [r3, #16]
    388a:	cmp	r2, #0
    388c:	beq.w	3432 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    3890:	ldr	r1, [r2, #0]
    3892:	ldr	r1, [r1, #32]
    3894:	cmp	r1, r0
    3896:	bne.w	3a60 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7d4>
    389a:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    389e:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    38a2:	cmp.w	lr, #0
    38a6:	beq.n	3958 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38a8:	ldr.w	r1, [lr, #16]
    38ac:	subs	r1, #1
    38ae:	str.w	r1, [lr, #16]
    38b2:	cmp	r1, #0
    38b4:	bne.n	3958 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38b6:	ldr	r1, [r2, #16]
    38b8:	str	r1, [sp, #0]
    38ba:	cmp	r1, #0
    38bc:	beq.n	3958 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38be:	ldr	r1, [sp, #0]
    38c0:	ldr	r1, [r1, #0]
    38c2:	ldr	r1, [r1, #32]
    38c4:	cmp	r1, r0
    38c6:	bne.w	3a78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ec>
    38ca:	ldr	r1, [sp, #0]
    38cc:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    38d0:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    38d4:	cmp.w	lr, #0
    38d8:	beq.n	3948 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    38da:	ldr.w	r1, [lr, #16]
    38de:	subs	r1, #1
    38e0:	str.w	r1, [lr, #16]
    38e4:	cbnz	r1, 3948 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    38e6:	ldr	r1, [sp, #0]
    38e8:	ldr.w	ip, [r1, #16]
    38ec:	cmp.w	ip, #0
    38f0:	beq.n	3948 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    38f2:	ldr.w	r1, [ip]
    38f6:	ldr	r1, [r1, #32]
    38f8:	cmp	r1, r0
    38fa:	bne.w	3a94 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x808>
    38fe:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3902:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3906:	cbz	r0, 3938 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    3908:	ldr	r1, [r0, #16]
    390a:	add.w	lr, r1, #4294967295
    390e:	str.w	lr, [r0, #16]
    3912:	cmp.w	lr, #0
    3916:	bne.n	3938 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    3918:	ldr.w	r0, [ip, #16]
    391c:	cbz	r0, 3938 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    391e:	ldr.w	lr, [r0]
    3922:	str.w	ip, [sp, #12]
    3926:	str	r2, [sp, #8]
    3928:	str	r3, [sp, #4]
    392a:	ldr.w	r3, [lr, #32]
    392e:	blx	r3
    3930:	ldr.w	ip, [sp, #12]
    3934:	ldr	r2, [sp, #8]
    3936:	ldr	r3, [sp, #4]
    3938:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    393a:	mov	r0, ip
    393c:	movs	r1, #20
    393e:	str	r3, [sp, #4]
    3940:	bl	e960 <operator delete(void*, unsigned int)>
    3944:	ldr	r3, [sp, #4]
    3946:	ldr	r2, [sp, #8]
    3948:	ldr	r0, [sp, #0]
    394a:	str	r2, [sp, #8]
    394c:	movs	r1, #20
    394e:	str	r3, [sp, #4]
    3950:	bl	e960 <operator delete(void*, unsigned int)>
    3954:	ldr	r3, [sp, #4]
    3956:	ldr	r2, [sp, #8]
    3958:	str	r3, [sp, #0]
    395a:	mov	r0, r2
    395c:	movs	r1, #20
    395e:	bl	e960 <operator delete(void*, unsigned int)>
    3962:	ldr	r3, [sp, #0]
    3964:	b.n	3432 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3966:	ldr	r2, [r3, #16]
    3968:	cmp	r2, #0
    396a:	beq.w	34de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    396e:	ldr	r1, [r2, #0]
    3970:	ldr	r1, [r1, #32]
    3972:	cmp	r1, r0
    3974:	bne.n	3a56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ca>
    3976:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    397a:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    397e:	cmp.w	lr, #0
    3982:	beq.n	3a30 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    3984:	ldr.w	r1, [lr, #16]
    3988:	subs	r1, #1
    398a:	str.w	r1, [lr, #16]
    398e:	cmp	r1, #0
    3990:	bne.n	3a30 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    3992:	ldr	r1, [r2, #16]
    3994:	str	r1, [sp, #0]
    3996:	cmp	r1, #0
    3998:	beq.n	3a30 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    399a:	ldr	r1, [sp, #0]
    399c:	ldr	r1, [r1, #0]
    399e:	ldr	r1, [r1, #32]
    39a0:	cmp	r1, r0
    39a2:	bne.n	3a6a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7de>
    39a4:	ldr	r1, [sp, #0]
    39a6:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    39aa:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    39ae:	cmp.w	lr, #0
    39b2:	beq.n	3a20 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39b4:	ldr.w	r1, [lr, #16]
    39b8:	subs	r1, #1
    39ba:	str.w	r1, [lr, #16]
    39be:	cbnz	r1, 3a20 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39c0:	ldr	r1, [sp, #0]
    39c2:	ldr.w	ip, [r1, #16]
    39c6:	cmp.w	ip, #0
    39ca:	beq.n	3a20 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39cc:	ldr.w	r1, [ip]
    39d0:	ldr	r1, [r1, #32]
    39d2:	cmp	r1, r0
    39d4:	bne.n	3a86 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7fa>
    39d6:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    39da:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    39de:	cbz	r0, 3a10 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    39e0:	ldr	r1, [r0, #16]
    39e2:	add.w	lr, r1, #4294967295
    39e6:	str.w	lr, [r0, #16]
    39ea:	cmp.w	lr, #0
    39ee:	bne.n	3a10 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    39f0:	ldr.w	r0, [ip, #16]
    39f4:	cbz	r0, 3a10 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    39f6:	ldr.w	lr, [r0]
    39fa:	str.w	ip, [sp, #12]
    39fe:	str	r2, [sp, #8]
    3a00:	str	r3, [sp, #4]
    3a02:	ldr.w	r3, [lr, #32]
    3a06:	blx	r3
    3a08:	ldr.w	ip, [sp, #12]
    3a0c:	ldr	r2, [sp, #8]
    3a0e:	ldr	r3, [sp, #4]
    3a10:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3a12:	mov	r0, ip
    3a14:	movs	r1, #20
    3a16:	str	r3, [sp, #4]
    3a18:	bl	e960 <operator delete(void*, unsigned int)>
    3a1c:	ldr	r3, [sp, #4]
    3a1e:	ldr	r2, [sp, #8]
    3a20:	ldr	r0, [sp, #0]
    3a22:	str	r2, [sp, #8]
    3a24:	movs	r1, #20
    3a26:	str	r3, [sp, #4]
    3a28:	bl	e960 <operator delete(void*, unsigned int)>
    3a2c:	ldr	r3, [sp, #4]
    3a2e:	ldr	r2, [sp, #8]
    3a30:	str	r3, [sp, #0]
    3a32:	mov	r0, r2
    3a34:	movs	r1, #20
    3a36:	bl	e960 <operator delete(void*, unsigned int)>
    3a3a:	ldr	r3, [sp, #0]
    3a3c:	b.n	34de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3a3e:	mov	r0, sl
    3a40:	blx	r3
    3a42:	b.n	3442 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    3a44:	mov	r0, sl
    3a46:	blx	r3
    3a48:	b.n	34ee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    3a4a:	mov	r0, r3
    3a4c:	blx	r2
    3a4e:	b.n	34e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    3a50:	mov	r0, r3
    3a52:	blx	r2
    3a54:	b.n	343a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    3a56:	str	r3, [sp, #0]
    3a58:	mov	r0, r2
    3a5a:	blx	r1
    3a5c:	ldr	r3, [sp, #0]
    3a5e:	b.n	34de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    3a60:	str	r3, [sp, #0]
    3a62:	mov	r0, r2
    3a64:	blx	r1
    3a66:	ldr	r3, [sp, #0]
    3a68:	b.n	3432 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    3a6a:	str	r2, [sp, #8]
    3a6c:	str	r3, [sp, #4]
    3a6e:	ldr	r0, [sp, #0]
    3a70:	blx	r1
    3a72:	ldr	r2, [sp, #8]
    3a74:	ldr	r3, [sp, #4]
    3a76:	b.n	3a30 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    3a78:	str	r2, [sp, #8]
    3a7a:	str	r3, [sp, #4]
    3a7c:	ldr	r0, [sp, #0]
    3a7e:	blx	r1
    3a80:	ldr	r2, [sp, #8]
    3a82:	ldr	r3, [sp, #4]
    3a84:	b.n	3958 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    3a86:	str	r2, [sp, #8]
    3a88:	str	r3, [sp, #4]
    3a8a:	mov	r0, ip
    3a8c:	blx	r1
    3a8e:	ldr	r2, [sp, #8]
    3a90:	ldr	r3, [sp, #4]
    3a92:	b.n	3a20 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    3a94:	str	r2, [sp, #8]
    3a96:	str	r3, [sp, #4]
    3a98:	mov	r0, ip
    3a9a:	blx	r1
    3a9c:	ldr	r2, [sp, #8]
    3a9e:	ldr	r3, [sp, #4]
    3aa0:	b.n	3948 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    3aa2:	nop

00003aa4 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>:

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3aa4:	ldrb.w	r3, [r0, #248]	; 0xf8
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;
    3aa8:	movs	r2, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    3aaa:	push	{r4, r5, r6, lr}
    3aac:	mov	r5, r0
  { if (all_scanned_) return;
    all_scanned_ = true;
    3aae:	strb.w	r2, [r0, #249]	; 0xf9
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    3ab2:	mov	r6, r1

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3ab4:	cbz	r3, 3ad4 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x30>
  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
    3ab6:	ldr.w	r3, [r5, #244]	; 0xf4
    3aba:	cbz	r3, 3ad2 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x2e>
    3abc:	movs	r4, #0
    3abe:	mov	r2, r4
    3ac0:	mov	r1, r6
    3ac2:	mov	r0, r5
    3ac4:	bl	328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
    3ac8:	ldr.w	r3, [r5, #244]	; 0xf4
    3acc:	adds	r4, #1
    3ace:	cmp	r3, r4
    3ad0:	bhi.n	3abe <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x1a>
    3ad2:	pop	{r4, r5, r6, pc}
    3ad4:	bl	261c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3ad8:	b.n	3ab6 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x12>
    3ada:	nop

00003adc <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>:
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    3adc:	push	{r4, r5, lr}
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization
    3ade:	cmp.w	r2, #4294967295
    3ae2:	ite	ne
    3ae4:	movne	r5, r2
    3ae6:	moveq	r5, r1

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    3ae8:	mov	r4, r0
    3aea:	sub	sp, #276	; 0x114
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization

      ScanDir(store, parent);
    3aec:	mov	r2, r5
    3aee:	bl	328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      follow_sibling_ = true;
    3af2:	movs	r3, #1
    3af4:	strb.w	r3, [r4, #256]	; 0x100
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    3af8:	mov	r2, r5
    3afa:	mov	r1, r4
    3afc:	mov	r0, sp
    3afe:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    3b02:	ldr	r3, [sp, #4]
    3b04:	str.w	r3, [r4, #252]	; 0xfc
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    3b08:	add	sp, #276	; 0x114
    3b0a:	pop	{r4, r5, pc}

00003b0c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)>:
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    3b0c:	push	{r4, lr}

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3b0e:	ldrb.w	r3, [r0, #248]	; 0xf8
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    3b12:	sub	sp, #8
    3b14:	mov	r4, r0

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3b16:	cbz	r3, 3b3c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x30>
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    GenerateIndex(store);
    if (parent) 
    3b18:	cbz	r2, 3b26 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x1a>
    3b1a:	mov	r0, r4
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    3b1c:	add	sp, #8
    3b1e:	ldmia.w	sp!, {r4, lr}
    3b22:	b.w	3adc <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    3b26:	ldrb.w	r3, [r4, #249]	; 0xf9
    3b2a:	cbz	r3, 3b4a <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x3e>
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    3b2c:	movs	r2, #0
      next_ = 1;
    3b2e:	movs	r3, #1
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    3b30:	strb.w	r2, [r4, #256]	; 0x100
      next_ = 1;
    3b34:	str.w	r3, [r4, #252]	; 0xfc
    }
  }
    3b38:	add	sp, #8
    3b3a:	pop	{r4, pc}
    3b3c:	stmia.w	sp, {r1, r2}
    3b40:	bl	261c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3b44:	ldmia.w	sp, {r1, r2}
    3b48:	b.n	3b18 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0xc>
    3b4a:	mov	r0, r4
    3b4c:	bl	3aa4 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>
    3b50:	b.n	3b2c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x20>
    3b52:	nop

00003b54 <MTPStorage_SD::removeFile(unsigned long, char*)>:
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }

void MTPStorage_SD::removeFile(uint32_t store, char *file)
{ 
    3b54:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3b58:	add.w	r9, r0, r1, lsl #2
    3b5c:	sub	sp, #340	; 0x154
    3b5e:	str	r1, [sp, #12]
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    3b60:	ldr.w	r1, [r9, #88]	; 0x58
    3b64:	str	r0, [sp, #8]
    3b66:	ldr	r3, [r1, #0]
    3b68:	str	r2, [sp, #4]
    3b6a:	ldr	r4, [r3, #0]
    3b6c:	add	r0, sp, #40	; 0x28
    3b6e:	movs	r3, #0
    3b70:	blx	r4
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3b72:	ldr	r0, [sp, #56]	; 0x38
    3b74:	cmp	r0, #0
    3b76:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3b7a:	ldr	r3, [r0, #0]
    3b7c:	ldr.w	sl, [pc, #868]	; 3ee4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x390>
    3b80:	ldr	r3, [r3, #76]	; 0x4c
    3b82:	cmp	r3, sl
    3b84:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3b88:	ldr	r0, [r0, #16]
    3b8a:	cmp	r0, #0
    3b8c:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3b90:	ldr	r3, [r0, #0]
    3b92:	ldr	r3, [r3, #76]	; 0x4c
    3b94:	cmp	r3, sl
    3b96:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3b9a:	ldr	r0, [r0, #16]
    3b9c:	cmp	r0, #0
    3b9e:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3ba2:	ldr	r3, [r0, #0]
    3ba4:	ldr	r3, [r3, #76]	; 0x4c
    3ba6:	cmp	r3, sl
    3ba8:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bac:	ldr	r0, [r0, #16]
    3bae:	cmp	r0, #0
    3bb0:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bb4:	ldr	r3, [r0, #0]
    3bb6:	ldr	r3, [r3, #76]	; 0x4c
    3bb8:	cmp	r3, sl
    3bba:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bbe:	ldr	r0, [r0, #16]
    3bc0:	cmp	r0, #0
    3bc2:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bc6:	ldr	r3, [r0, #0]
    3bc8:	ldr	r3, [r3, #76]	; 0x4c
    3bca:	cmp	r3, sl
    3bcc:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bd0:	ldr	r0, [r0, #16]
    3bd2:	cmp	r0, #0
    3bd4:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bd8:	ldr	r3, [r0, #0]
    3bda:	ldr	r3, [r3, #76]	; 0x4c
    3bdc:	cmp	r3, sl
    3bde:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3be2:	ldr	r0, [r0, #16]
    3be4:	cmp	r0, #0
    3be6:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bea:	ldr	r3, [r0, #0]
    3bec:	ldr	r3, [r3, #76]	; 0x4c
    3bee:	cmp	r3, sl
    3bf0:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bf4:	ldr	r0, [r0, #16]
    3bf6:	cmp	r0, #0
    3bf8:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bfc:	ldr	r3, [r0, #0]
    3bfe:	ldr	r3, [r3, #76]	; 0x4c
    3c00:	cmp	r3, sl
    3c02:	bne.w	4084 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3c06:	ldr	r0, [r0, #16]
    3c08:	cmp	r0, #0
    3c0a:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c0e:	ldr	r3, [r0, #0]
    3c10:	ldr	r3, [r3, #76]	; 0x4c
    3c12:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
    3c14:	cmp	r0, #0
    3c16:	beq.w	3f20 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c1a:	ldr.w	fp, [pc, #700]	; 3ed8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
    3c1e:	ldr.w	r8, [pc, #712]	; 3ee8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x394>
    3c22:	movs	r4, #0
    3c24:	mov	r7, fp
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3c26:	ldr	r1, [sp, #56]	; 0x38
    3c28:	cmp	r1, #0
    3c2a:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c2e:	ldr	r3, [r1, #0]
    3c30:	ldr	r2, [pc, #668]	; (3ed0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x37c>)
    3c32:	ldr	r3, [r3, #80]	; 0x50
    3c34:	cmp	r3, r2
    3c36:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c3a:	ldr	r1, [r1, #16]
    3c3c:	cmp	r1, #0
    3c3e:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c42:	ldr	r3, [r1, #0]
    3c44:	ldr	r3, [r3, #80]	; 0x50
    3c46:	cmp	r3, r2
    3c48:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c4c:	ldr	r1, [r1, #16]
    3c4e:	cmp	r1, #0
    3c50:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c54:	ldr	r3, [r1, #0]
    3c56:	ldr	r3, [r3, #80]	; 0x50
    3c58:	cmp	r3, r2
    3c5a:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c5e:	ldr	r1, [r1, #16]
    3c60:	cmp	r1, #0
    3c62:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c66:	ldr	r3, [r1, #0]
    3c68:	ldr	r3, [r3, #80]	; 0x50
    3c6a:	cmp	r3, r2
    3c6c:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c70:	ldr	r1, [r1, #16]
    3c72:	cmp	r1, #0
    3c74:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c78:	ldr	r3, [r1, #0]
    3c7a:	ldr	r3, [r3, #80]	; 0x50
    3c7c:	cmp	r3, r2
    3c7e:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c82:	ldr	r1, [r1, #16]
    3c84:	cmp	r1, #0
    3c86:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c8a:	ldr	r3, [r1, #0]
    3c8c:	ldr	r3, [r3, #80]	; 0x50
    3c8e:	cmp	r3, r2
    3c90:	bne.w	4088 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c94:	ldr	r1, [r1, #16]
    3c96:	cmp	r1, #0
    3c98:	beq.w	3f0a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c9c:	ldr	r3, [r1, #0]
    3c9e:	movs	r2, #0
    3ca0:	ldr	r3, [r3, #80]	; 0x50
    3ca2:	add	r0, sp, #60	; 0x3c
    3ca4:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3ca6:	cbz	r4, 3cc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    3ca8:	ldr	r3, [r4, #16]
    3caa:	subs	r3, #1
    3cac:	str	r3, [r4, #16]
    3cae:	cbnz	r3, 3cc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    3cb0:	ldr	r3, [r4, #0]
    3cb2:	ldr	r2, [pc, #544]	; (3ed4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3cb4:	ldr	r3, [r3, #32]
    3cb6:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3cb8:	mov	r0, r4
    3cba:	bne.w	4278 <MTPStorage_SD::removeFile(unsigned long, char*)+0x724>
    3cbe:	movs	r1, #20
    3cc0:	bl	e960 <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    3cc4:	ldr	r4, [sp, #76]	; 0x4c
		if (f) f->refcount++;
    3cc6:	cmp	r4, #0
    3cc8:	beq.w	4244 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
    3ccc:	ldr	r3, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3cce:	ldr	r2, [r4, #0]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    3cd0:	adds	r0, r3, #1
    3cd2:	str	r0, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3cd4:	ldr	r2, [r2, #68]	; 0x44
    3cd6:	cmp	r2, r8
    3cd8:	bne.w	4230 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6dc>
    3cdc:	cmp	r0, #0
    3cde:	beq.w	4210 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3ce2:	ldr.w	r3, [r3, #1]
    3ce6:	ldr	r3, [r3, #68]	; 0x44
    3ce8:	cmp	r3, r8
    3cea:	bne.w	4228 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3cee:	ldr	r0, [r0, #16]
    3cf0:	cmp	r0, #0
    3cf2:	beq.w	4210 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3cf6:	ldr	r3, [r0, #0]
    3cf8:	ldr	r3, [r3, #68]	; 0x44
    3cfa:	cmp	r3, r8
    3cfc:	bne.w	4228 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d00:	ldr	r0, [r0, #16]
    3d02:	cmp	r0, #0
    3d04:	beq.w	4210 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d08:	ldr	r3, [r0, #0]
    3d0a:	ldr	r3, [r3, #68]	; 0x44
    3d0c:	cmp	r3, r8
    3d0e:	bne.w	4228 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d12:	ldr	r0, [r0, #16]
    3d14:	cmp	r0, #0
    3d16:	beq.w	4210 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d1a:	ldr	r3, [r0, #0]
    3d1c:	ldr	r3, [r3, #68]	; 0x44
    3d1e:	cmp	r3, r8
    3d20:	bne.w	4228 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d24:	ldr	r0, [r0, #16]
    3d26:	cmp	r0, #0
    3d28:	beq.w	4210 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d2c:	ldr	r3, [r0, #0]
    3d2e:	ldr	r3, [r3, #68]	; 0x44
    3d30:	blx	r3
    3d32:	ldr	r2, [sp, #76]	; 0x4c
    3d34:	mov	r6, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d36:	str	r7, [sp, #60]	; 0x3c
    3d38:	ldr	r1, [pc, #412]	; (3ed8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d3a:	cmp	r2, #0
    3d3c:	beq.n	3dd4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d3e:	ldr	r3, [r2, #16]
    3d40:	subs	r3, #1
    3d42:	str	r3, [r2, #16]
    3d44:	cmp	r3, #0
    3d46:	bne.n	3dd4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d48:	ldr	r5, [sp, #76]	; 0x4c
    3d4a:	cmp	r5, #0
    3d4c:	beq.n	3dd4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d4e:	ldr	r3, [r5, #0]
    3d50:	ldr	r2, [pc, #384]	; (3ed4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3d52:	ldr	r3, [r3, #32]
    3d54:	cmp	r3, r2
    3d56:	bne.w	423a <MTPStorage_SD::removeFile(unsigned long, char*)+0x6e6>
    3d5a:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d5c:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d5e:	cmp	r2, #0
    3d60:	beq.n	3dcc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d62:	ldr	r3, [r2, #16]
    3d64:	subs	r3, #1
    3d66:	str	r3, [r2, #16]
    3d68:	cbnz	r3, 3dcc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d6a:	ldr.w	fp, [r5, #16]
    3d6e:	cmp.w	fp, #0
    3d72:	beq.n	3dcc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d74:	ldr.w	r3, [fp]
    3d78:	ldr	r2, [pc, #344]	; (3ed4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3d7a:	ldr	r3, [r3, #32]
    3d7c:	cmp	r3, r2
    3d7e:	bne.w	427c <MTPStorage_SD::removeFile(unsigned long, char*)+0x728>
    3d82:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d86:	str.w	r1, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d8a:	cbz	r2, 3dc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3d8c:	ldr	r3, [r2, #16]
    3d8e:	subs	r3, #1
    3d90:	str	r3, [r2, #16]
    3d92:	cbnz	r3, 3dc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3d94:	ldr.w	r3, [fp, #16]
    3d98:	cbz	r3, 3dc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3d9a:	ldr	r2, [r3, #0]
    3d9c:	ldr	r1, [pc, #308]	; (3ed4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3d9e:	ldr	r2, [r2, #32]
    3da0:	cmp	r2, r1
    3da2:	bne.w	4282 <MTPStorage_SD::removeFile(unsigned long, char*)+0x72e>
    3da6:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3da8:	str	r7, [r3, #0]
    3daa:	ldr.w	ip, [pc, #300]	; 3ed8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3dae:	cbz	r1, 3dbc <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    3db0:	ldr	r2, [r1, #16]
    3db2:	subs	r2, #1
    3db4:	str	r2, [r1, #16]
    3db6:	cmp	r2, #0
    3db8:	beq.w	409c <MTPStorage_SD::removeFile(unsigned long, char*)+0x548>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3dbc:	mov	r0, r3
    3dbe:	movs	r1, #20
    3dc0:	bl	e960 <operator delete(void*, unsigned int)>
    3dc4:	mov	r0, fp
    3dc6:	movs	r1, #20
    3dc8:	bl	e960 <operator delete(void*, unsigned int)>
    3dcc:	mov	r0, r5
    3dce:	movs	r1, #20
    3dd0:	bl	e960 <operator delete(void*, unsigned int)>
  {
    File f2;
    while(f2=f1.openNextFile())
    3dd4:	cmp	r6, #0
    3dd6:	beq.w	4244 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    3dda:	cmp	r4, #0
    3ddc:	beq.w	41e0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x68c>
    3de0:	ldr	r2, [r4, #0]
    3de2:	ldr	r3, [pc, #248]	; (3edc <MTPStorage_SD::removeFile(unsigned long, char*)+0x388>)
    3de4:	ldr	r2, [r2, #72]	; 0x48
    3de6:	cmp	r2, r3
    3de8:	bne.w	421c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c8>
    3dec:	ldr	r0, [r4, #16]
    3dee:	cmp	r0, #0
    3df0:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3df4:	ldr	r2, [r0, #0]
    3df6:	ldr	r2, [r2, #72]	; 0x48
    3df8:	cmp	r2, r3
    3dfa:	bne.w	421e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3dfe:	ldr	r0, [r0, #16]
    3e00:	cmp	r0, #0
    3e02:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e06:	ldr	r2, [r0, #0]
    3e08:	ldr	r2, [r2, #72]	; 0x48
    3e0a:	cmp	r2, r3
    3e0c:	bne.w	421e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e10:	ldr	r0, [r0, #16]
    3e12:	cmp	r0, #0
    3e14:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e18:	ldr	r2, [r0, #0]
    3e1a:	ldr	r2, [r2, #72]	; 0x48
    3e1c:	cmp	r2, r3
    3e1e:	bne.w	421e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e22:	ldr	r0, [r0, #16]
    3e24:	cmp	r0, #0
    3e26:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e2a:	ldr	r2, [r0, #0]
    3e2c:	ldr	r2, [r2, #72]	; 0x48
    3e2e:	cmp	r2, r3
    3e30:	bne.w	421e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e34:	ldr	r0, [r0, #16]
    3e36:	cmp	r0, #0
    3e38:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e3c:	ldr	r2, [r0, #0]
    3e3e:	ldr	r2, [r2, #72]	; 0x48
    3e40:	cmp	r2, r3
    3e42:	bne.w	421e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e46:	ldr	r0, [r0, #16]
    3e48:	cmp	r0, #0
    3e4a:	beq.w	4224 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e4e:	ldr	r3, [r0, #0]
    3e50:	ldr	r3, [r3, #72]	; 0x48
    3e52:	blx	r3
    3e54:	mov	r3, r0
    { sprintf(tname,"%s/%s",file,f2.name());
    3e56:	add	r5, sp, #80	; 0x50
    3e58:	ldr	r1, [pc, #132]	; (3ee0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x38c>)
    3e5a:	ldr	r2, [sp, #4]
    3e5c:	mov	r0, r5
    3e5e:	bl	10b84 <sprintf>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3e62:	ldr	r3, [r4, #0]
    3e64:	ldr	r3, [r3, #76]	; 0x4c
    3e66:	cmp	r3, sl
    3e68:	bne.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c2>
    3e6c:	ldr	r0, [r4, #16]
    3e6e:	cmp	r0, #0
    3e70:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3e74:	ldr	r3, [r0, #0]
    3e76:	ldr	r3, [r3, #76]	; 0x4c
    3e78:	cmp	r3, sl
    3e7a:	bne.w	4218 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3e7e:	ldr	r0, [r0, #16]
    3e80:	cmp	r0, #0
    3e82:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3e86:	ldr	r3, [r0, #0]
    3e88:	ldr	r3, [r3, #76]	; 0x4c
    3e8a:	cmp	r3, sl
    3e8c:	bne.w	4218 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3e90:	ldr	r0, [r0, #16]
    3e92:	cmp	r0, #0
    3e94:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3e98:	ldr	r3, [r0, #0]
    3e9a:	ldr	r3, [r3, #76]	; 0x4c
    3e9c:	cmp	r3, sl
    3e9e:	bne.w	4218 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3ea2:	ldr	r0, [r0, #16]
    3ea4:	cmp	r0, #0
    3ea6:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3eaa:	ldr	r3, [r0, #0]
    3eac:	ldr	r3, [r3, #76]	; 0x4c
    3eae:	cmp	r3, sl
    3eb0:	bne.w	4218 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3eb4:	ldr	r0, [r0, #16]
    3eb6:	cmp	r0, #0
    3eb8:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ebc:	ldr	r3, [r0, #0]
    3ebe:	ldr	r3, [r3, #76]	; 0x4c
    3ec0:	cmp	r3, sl
    3ec2:	bne.w	4218 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3ec6:	ldr	r0, [r0, #16]
    3ec8:	cmp	r0, #0
    3eca:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ece:	b.n	3eec <MTPStorage_SD::removeFile(unsigned long, char*)+0x398>
    3ed0:	.word	0x0000052d
    3ed4:	.word	0x00000f25
    3ed8:	.word	0x000141ec
    3edc:	.word	0x0000050d
    3ee0:	.word	0x000144d8
    3ee4:	.word	0x00000521
    3ee8:	.word	0x00000501
    3eec:	ldr	r3, [r0, #0]
    3eee:	ldr	r3, [r3, #76]	; 0x4c
    3ef0:	blx	r3
      if(f2.isDirectory()) removeFile(store,tname); else sd_remove(store,tname);
    3ef2:	cmp	r0, #0
    3ef4:	beq.w	41ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ef8:	ldr	r1, [sp, #12]
    3efa:	ldr	r0, [sp, #8]
    3efc:	mov	r2, r5
    3efe:	bl	3b54 <MTPStorage_SD::removeFile(unsigned long, char*)>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3f02:	ldr	r1, [sp, #56]	; 0x38
    3f04:	cmp	r1, #0
    3f06:	bne.w	3c2e <MTPStorage_SD::removeFile(unsigned long, char*)+0xda>
    3f0a:	movs	r3, #0
    3f0c:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    3f10:	str	r7, [sp, #60]	; 0x3c
    3f12:	strb.w	r3, [sp, #64]	; 0x40
    3f16:	strb.w	r3, [sp, #72]	; 0x48
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    3f1a:	str	r3, [sp, #76]	; 0x4c
    3f1c:	str	r2, [sp, #68]	; 0x44
    3f1e:	b.n	3ca6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    3f20:	ldr	r4, [sp, #4]
    3f22:	ldr.w	fp, [pc, #368]	; 4094 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>
    3f26:	mov	r0, r4
    3f28:	bl	10d40 <strlen>
    3f2c:	mov	r1, r0
    3f2e:	mov	r0, r4
    3f30:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    3f34:	ldr	r0, [pc, #344]	; (4090 <MTPStorage_SD::removeFile(unsigned long, char*)+0x53c>)
    3f36:	bl	e7bc <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    3f3a:	ldr.w	r0, [r9, #88]	; 0x58
    3f3e:	ldr	r3, [r0, #0]
    3f40:	mov	r1, r4
    3f42:	ldr	r3, [r3, #16]
    3f44:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f46:	ldr	r2, [sp, #56]	; 0x38
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3f48:	str.w	fp, [sp, #40]	; 0x28
    3f4c:	ldr	r1, [pc, #324]	; (4094 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f4e:	cmp	r2, #0
    3f50:	beq.w	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f54:	ldr	r3, [r2, #16]
    3f56:	subs	r3, #1
    3f58:	str	r3, [r2, #16]
    3f5a:	cmp	r3, #0
    3f5c:	bne.w	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f60:	ldr	r4, [sp, #56]	; 0x38
    3f62:	cmp	r4, #0
    3f64:	beq.w	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f68:	ldr	r3, [r4, #0]
    3f6a:	ldr	r0, [pc, #300]	; (4098 <MTPStorage_SD::removeFile(unsigned long, char*)+0x544>)
    3f6c:	ldr	r3, [r3, #32]
    3f6e:	cmp	r3, r0
    3f70:	bne.w	4288 <MTPStorage_SD::removeFile(unsigned long, char*)+0x734>
    3f74:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3f76:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f78:	cmp	r2, #0
    3f7a:	beq.n	4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3f7c:	ldr	r3, [r2, #16]
    3f7e:	subs	r3, #1
    3f80:	str	r3, [r2, #16]
    3f82:	cmp	r3, #0
    3f84:	bne.n	4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3f86:	ldr	r5, [r4, #16]
    3f88:	cmp	r5, #0
    3f8a:	beq.n	4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3f8c:	ldr	r3, [r5, #0]
    3f8e:	ldr	r3, [r3, #32]
    3f90:	cmp	r3, r0
    3f92:	bne.w	429c <MTPStorage_SD::removeFile(unsigned long, char*)+0x748>
    3f96:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3f98:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f9a:	cmp	r2, #0
    3f9c:	beq.n	406e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3f9e:	ldr	r3, [r2, #16]
    3fa0:	subs	r3, #1
    3fa2:	str	r3, [r2, #16]
    3fa4:	cmp	r3, #0
    3fa6:	bne.n	406e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3fa8:	ldr	r6, [r5, #16]
    3faa:	cmp	r6, #0
    3fac:	beq.n	406e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3fae:	ldr	r3, [r6, #0]
    3fb0:	ldr	r3, [r3, #32]
    3fb2:	cmp	r3, r0
    3fb4:	bne.w	42b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x75c>
    3fb8:	ldr	r2, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3fba:	str.w	fp, [r6]
    3fbe:	ldr	r1, [pc, #212]	; (4094 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3fc0:	cmp	r2, #0
    3fc2:	beq.n	4066 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3fc4:	ldr	r3, [r2, #16]
    3fc6:	subs	r3, #1
    3fc8:	str	r3, [r2, #16]
    3fca:	cmp	r3, #0
    3fcc:	bne.n	4066 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3fce:	ldr	r7, [r6, #16]
    3fd0:	cmp	r7, #0
    3fd2:	beq.n	4066 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3fd4:	ldr	r3, [r7, #0]
    3fd6:	ldr	r3, [r3, #32]
    3fd8:	cmp	r3, r0
    3fda:	bne.w	42b6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x762>
    3fde:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3fe0:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3fe2:	cmp	r2, #0
    3fe4:	beq.n	405e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    3fe6:	ldr	r3, [r2, #16]
    3fe8:	subs	r3, #1
    3fea:	str	r3, [r2, #16]
    3fec:	cmp	r3, #0
    3fee:	bne.n	405e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    3ff0:	ldr.w	r8, [r7, #16]
    3ff4:	cmp.w	r8, #0
    3ff8:	beq.n	405e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    3ffa:	ldr.w	r3, [r8]
    3ffe:	ldr	r3, [r3, #32]
    4000:	cmp	r3, r0
    4002:	bne.w	42d8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x784>
    4006:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    400a:	str.w	fp, [r8]
    400e:	ldr	r1, [pc, #132]	; (4094 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4010:	cbz	r2, 4056 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    4012:	ldr	r3, [r2, #16]
    4014:	subs	r3, #1
    4016:	str	r3, [r2, #16]
    4018:	cbnz	r3, 4056 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    401a:	ldr.w	r9, [r8, #16]
    401e:	cmp.w	r9, #0
    4022:	beq.n	4056 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    4024:	ldr.w	r3, [r9]
    4028:	ldr	r3, [r3, #32]
    402a:	cmp	r3, r0
    402c:	bne.w	42ee <MTPStorage_SD::removeFile(unsigned long, char*)+0x79a>
    4030:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4034:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4038:	cbz	r2, 404e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    403a:	ldr	r3, [r2, #16]
    403c:	subs	r3, #1
    403e:	str	r3, [r2, #16]
    4040:	cbnz	r3, 404e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    4042:	ldr.w	r0, [r9, #16]
    4046:	cbz	r0, 404e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    4048:	ldr	r3, [r0, #0]
    404a:	ldr	r3, [r3, #32]
    404c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    404e:	mov	r0, r9
    4050:	movs	r1, #20
    4052:	bl	e960 <operator delete(void*, unsigned int)>
    4056:	mov	r0, r8
    4058:	movs	r1, #20
    405a:	bl	e960 <operator delete(void*, unsigned int)>
    405e:	mov	r0, r7
    4060:	movs	r1, #20
    4062:	bl	e960 <operator delete(void*, unsigned int)>
    4066:	mov	r0, r6
    4068:	movs	r1, #20
    406a:	bl	e960 <operator delete(void*, unsigned int)>
    406e:	mov	r0, r5
    4070:	movs	r1, #20
    4072:	bl	e960 <operator delete(void*, unsigned int)>
    4076:	mov	r0, r4
    4078:	movs	r1, #20
    407a:	bl	e960 <operator delete(void*, unsigned int)>
  }
  else
  {
    sd_remove(store,file);
  }
}
    407e:	add	sp, #340	; 0x154
    4080:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    4084:	blx	r3
    4086:	b.n	3c14 <MTPStorage_SD::removeFile(unsigned long, char*)+0xc0>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    4088:	movs	r2, #0
    408a:	add	r0, sp, #60	; 0x3c
    408c:	blx	r3
    408e:	b.n	3ca6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
    4090:	.word	0x1fff8d50
    4094:	.word	0x000141ec
    4098:	.word	0x00000f25
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    409c:	ldr	r2, [r3, #16]
    409e:	cmp	r2, #0
    40a0:	beq.w	3dbc <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    40a4:	ldr	r1, [r2, #0]
    40a6:	ldr	r0, [pc, #588]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    40a8:	ldr	r1, [r1, #32]
    40aa:	cmp	r1, r0
    40ac:	bne.w	4292 <MTPStorage_SD::removeFile(unsigned long, char*)+0x73e>
    40b0:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    40b4:	str.w	ip, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    40b8:	cmp.w	lr, #0
    40bc:	beq.w	41d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    40c0:	ldr.w	r1, [lr, #16]
    40c4:	subs	r1, #1
    40c6:	str.w	r1, [lr, #16]
    40ca:	cmp	r1, #0
    40cc:	bne.w	41d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    40d0:	ldr	r1, [r2, #16]
    40d2:	str	r1, [sp, #16]
    40d4:	cmp	r1, #0
    40d6:	beq.n	41d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    40d8:	ldr	r1, [sp, #16]
    40da:	ldr	r0, [pc, #536]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    40dc:	ldr	r1, [r1, #0]
    40de:	ldr	r1, [r1, #32]
    40e0:	cmp	r1, r0
    40e2:	bne.w	42a2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x74e>
    40e6:	ldr	r1, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    40e8:	ldr.w	ip, [pc, #536]	; 4304 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7b0>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    40ec:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    40f0:	str	r7, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    40f2:	cmp.w	lr, #0
    40f6:	beq.n	41c2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    40f8:	ldr.w	r1, [lr, #16]
    40fc:	subs	r1, #1
    40fe:	str.w	r1, [lr, #16]
    4102:	cmp	r1, #0
    4104:	bne.n	41c2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    4106:	ldr	r1, [sp, #16]
    4108:	ldr	r1, [r1, #16]
    410a:	str	r1, [sp, #20]
    410c:	cmp	r1, #0
    410e:	beq.n	41c2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    4110:	ldr	r1, [sp, #20]
    4112:	ldr	r0, [pc, #480]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    4114:	ldr	r1, [r1, #0]
    4116:	ldr	r1, [r1, #32]
    4118:	cmp	r1, r0
    411a:	bne.w	42bc <MTPStorage_SD::removeFile(unsigned long, char*)+0x768>
    411e:	ldr	r0, [sp, #20]
    4120:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4124:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4128:	cmp.w	lr, #0
    412c:	beq.n	41b2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    412e:	ldr.w	r1, [lr, #16]
    4132:	subs	r1, #1
    4134:	str.w	r1, [lr, #16]
    4138:	cmp	r1, #0
    413a:	bne.n	41b2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    413c:	ldr	r1, [sp, #20]
    413e:	ldr	r1, [r1, #16]
    4140:	str	r1, [sp, #24]
    4142:	cmp	r1, #0
    4144:	beq.n	41b2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    4146:	ldr	r1, [sp, #24]
    4148:	ldr	r0, [pc, #424]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    414a:	ldr	r1, [r1, #0]
    414c:	ldr	r1, [r1, #32]
    414e:	cmp	r1, r0
    4150:	bne.w	42ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x776>
    4154:	ldr	r0, [sp, #24]
    4156:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    415a:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    415e:	cmp.w	lr, #0
    4162:	beq.n	41a2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    4164:	ldr.w	r1, [lr, #16]
    4168:	subs	r1, #1
    416a:	str.w	r1, [lr, #16]
    416e:	cbnz	r1, 41a2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    4170:	ldr	r1, [sp, #24]
    4172:	ldr	r1, [r1, #16]
    4174:	cbz	r1, 41a2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    4176:	ldr	r0, [r1, #0]
    4178:	ldr	r0, [r0, #32]
    417a:	mov	lr, r0
    417c:	ldr	r0, [pc, #372]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    417e:	cmp	lr, r0
    4180:	bne.w	42de <MTPStorage_SD::removeFile(unsigned long, char*)+0x78a>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4184:	mov	r0, r1
    4186:	str	r2, [sp, #36]	; 0x24
    4188:	str.w	r7, [r0], #16
    418c:	str	r3, [sp, #32]
    418e:	str	r1, [sp, #28]
		invalidate();
    4190:	bl	2088 <File::invalidate() [clone .isra.1]>
	}
    4194:	ldr	r1, [sp, #28]
    4196:	mov	r0, r1
    4198:	movs	r1, #20
    419a:	bl	e960 <operator delete(void*, unsigned int)>
    419e:	ldr	r3, [sp, #32]
    41a0:	ldr	r2, [sp, #36]	; 0x24
    41a2:	ldr	r0, [sp, #24]
    41a4:	str	r2, [sp, #32]
    41a6:	movs	r1, #20
    41a8:	str	r3, [sp, #28]
    41aa:	bl	e960 <operator delete(void*, unsigned int)>
    41ae:	ldr	r3, [sp, #28]
    41b0:	ldr	r2, [sp, #32]
    41b2:	ldr	r0, [sp, #20]
    41b4:	str	r2, [sp, #28]
    41b6:	movs	r1, #20
    41b8:	str	r3, [sp, #24]
    41ba:	bl	e960 <operator delete(void*, unsigned int)>
    41be:	ldr	r3, [sp, #24]
    41c0:	ldr	r2, [sp, #28]
    41c2:	ldr	r0, [sp, #16]
    41c4:	str	r2, [sp, #24]
    41c6:	movs	r1, #20
    41c8:	str	r3, [sp, #20]
    41ca:	bl	e960 <operator delete(void*, unsigned int)>
    41ce:	ldr	r3, [sp, #20]
    41d0:	ldr	r2, [sp, #24]
    41d2:	str	r3, [sp, #16]
    41d4:	mov	r0, r2
    41d6:	movs	r1, #20
    41d8:	bl	e960 <operator delete(void*, unsigned int)>
    41dc:	ldr	r3, [sp, #16]
    41de:	b.n	3dbc <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    { sprintf(tname,"%s/%s",file,f2.name());
    41e0:	add	r5, sp, #80	; 0x50
    41e2:	mov	r0, r5
    41e4:	ldr	r3, [pc, #272]	; (42f8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    41e6:	ldr	r1, [pc, #276]	; (42fc <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a8>)
    41e8:	ldr	r2, [sp, #4]
    41ea:	bl	10b84 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    41ee:	mov	r0, r5
    41f0:	bl	10d40 <strlen>
    41f4:	mov	r1, r0
    41f6:	mov	r0, r5
    41f8:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    41fc:	ldr	r0, [pc, #256]	; (4300 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7ac>)
    41fe:	bl	e7bc <Print::println()>
    4202:	ldr.w	r0, [r9, #88]	; 0x58
    4206:	ldr	r3, [r0, #0]
    4208:	mov	r1, r5
    420a:	ldr	r3, [r3, #16]
    420c:	blx	r3
    420e:	b.n	3c26 <MTPStorage_SD::removeFile(unsigned long, char*)+0xd2>
    4210:	ldr	r2, [sp, #76]	; 0x4c
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4212:	movs	r6, #0
    4214:	b.n	3d36 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    4216:	mov	r0, r4
    4218:	blx	r3
    421a:	b.n	3ef2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x39e>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    421c:	mov	r0, r4
    421e:	blx	r2
    4220:	mov	r3, r0
    4222:	b.n	3e56 <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
    4224:	ldr	r3, [pc, #208]	; (42f8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    4226:	b.n	3e56 <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4228:	blx	r3
    422a:	ldr	r2, [sp, #76]	; 0x4c
    422c:	mov	r6, r0
    422e:	b.n	3d36 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
    4230:	mov	r0, r4
    4232:	blx	r2
    4234:	ldr	r2, [sp, #76]	; 0x4c
    4236:	mov	r6, r0
    4238:	b.n	3d36 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    423a:	mov	r0, r5
    423c:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    423e:	cmp	r6, #0
    4240:	bne.w	3dda <MTPStorage_SD::removeFile(unsigned long, char*)+0x286>
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    4244:	ldr.w	r0, [r9, #88]	; 0x58
    4248:	ldr	r1, [sp, #4]
    424a:	ldr	r3, [r0, #0]
    424c:	ldr	r3, [r3, #20]
    424e:	mov	fp, r7
    4250:	blx	r3
    4252:	cmp	r4, #0
    4254:	beq.w	3f46 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    4258:	ldr	r3, [r4, #16]
    425a:	subs	r3, #1
    425c:	str	r3, [r4, #16]
    425e:	cmp	r3, #0
    4260:	bne.w	3f46 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    4264:	ldr	r3, [r4, #0]
    4266:	ldr	r2, [pc, #140]	; (42f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    4268:	ldr	r3, [r3, #32]
    426a:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    426c:	mov	r0, r4
    426e:	bne.n	428e <MTPStorage_SD::removeFile(unsigned long, char*)+0x73a>
    4270:	movs	r1, #20
    4272:	bl	e960 <operator delete(void*, unsigned int)>
    4276:	b.n	3f46 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4278:	blx	r3
    427a:	b.n	3cc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    427c:	mov	r0, fp
    427e:	blx	r3
    4280:	b.n	3dcc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    4282:	mov	r0, r3
    4284:	blx	r2
    4286:	b.n	3dc4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    4288:	mov	r0, r4
    428a:	blx	r3
  }
  else
  {
    sd_remove(store,file);
  }
}
    428c:	b.n	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    428e:	blx	r3
    4290:	b.n	3f46 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    4292:	str	r3, [sp, #16]
    4294:	mov	r0, r2
    4296:	blx	r1
    4298:	ldr	r3, [sp, #16]
    429a:	b.n	3dbc <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    429c:	mov	r0, r5
    429e:	blx	r3
    42a0:	b.n	4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    42a2:	str	r2, [sp, #24]
    42a4:	str	r3, [sp, #20]
    42a6:	ldr	r0, [sp, #16]
    42a8:	blx	r1
    42aa:	ldr	r2, [sp, #24]
    42ac:	ldr	r3, [sp, #20]
    42ae:	b.n	41d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    42b0:	mov	r0, r6
    42b2:	blx	r3
    42b4:	b.n	406e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    42b6:	mov	r0, r7
    42b8:	blx	r3
    42ba:	b.n	4066 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    42bc:	str	r2, [sp, #28]
    42be:	str	r3, [sp, #24]
    42c0:	ldr	r0, [sp, #20]
    42c2:	blx	r1
    42c4:	ldr	r2, [sp, #28]
    42c6:	ldr	r3, [sp, #24]
    42c8:	b.n	41c2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    42ca:	str	r2, [sp, #32]
    42cc:	str	r3, [sp, #28]
    42ce:	ldr	r0, [sp, #24]
    42d0:	blx	r1
    42d2:	ldr	r2, [sp, #32]
    42d4:	ldr	r3, [sp, #28]
    42d6:	b.n	41b2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    42d8:	mov	r0, r8
    42da:	blx	r3
    42dc:	b.n	405e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    42de:	str	r2, [sp, #32]
    42e0:	str	r3, [sp, #28]
    42e2:	mov	r0, r1
    42e4:	mov	r3, lr
    42e6:	blx	r3
    42e8:	ldr	r2, [sp, #32]
    42ea:	ldr	r3, [sp, #28]
    42ec:	b.n	41a2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    42ee:	mov	r0, r9
    42f0:	blx	r3
    42f2:	b.n	4056 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    42f4:	.word	0x00000f25
    42f8:	.word	0x000143a8
    42fc:	.word	0x000144d8
    4300:	.word	0x1fff8d50
    4304:	.word	0x000141ec

00004308 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>:

  bool MTPStorage_SD::DeleteObject(uint32_t object)
    4308:	push	{r4, r5, r6, r7, lr}
    430a:	subw	sp, sp, #1348	; 0x544
    430e:	mov	r5, r0
    4310:	mov	r6, r1
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below

    // first create full filename
    char filename[MAX_FILENAME_LEN];
    ConstructFilename(object, filename, MAX_FILENAME_LEN);
    4312:	mov.w	r3, #256	; 0x100
    4316:	add	r2, sp, #272	; 0x110
    4318:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    Record r = ReadIndexRecord(object);
    431c:	mov	r2, r6
    431e:	mov	r1, r5
    4320:	add	r0, sp, #528	; 0x210
    4322:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    // remove file from storage (assume it is always working)
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    4326:	add	r2, sp, #272	; 0x110
    4328:	ldrh.w	r1, [sp, #542]	; 0x21e
    432c:	mov	r0, r5
    432e:	bl	3b54 <MTPStorage_SD::removeFile(unsigned long, char*)>
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    4332:	movs	r3, #0
    WriteIndexRecord(object, r);
    4334:	add	r2, sp, #528	; 0x210
    4336:	mov	r1, r6
    4338:	mov	r0, r5
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    433a:	strb.w	r3, [sp, #544]	; 0x220
    WriteIndexRecord(object, r);
    433e:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    4342:	ldr	r2, [sp, #528]	; 0x210
    4344:	mov	r1, r5
    4346:	add	r0, sp, #800	; 0x320
    4348:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if(t.child==object)
    434c:	ldr	r7, [sp, #804]	; 0x324
    434e:	cmp	r6, r7
    4350:	beq.n	43a2 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x9a>
    }
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
    4352:	add.w	r0, sp, #1072	; 0x430
    4356:	mov	r2, r7
    4358:	mov	r1, r5
    435a:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    435e:	ldr.w	r4, [sp, #1080]	; 0x438
    4362:	cmp	r6, r4
    4364:	bne.n	436a <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x62>
    4366:	b.n	43b6 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0xae>
    4368:	mov	r4, r3
    436a:	mov	r2, r4
    436c:	mov	r1, r5
    436e:	mov	r0, sp
    4370:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    4374:	mov.w	r2, #272	; 0x110
    4378:	mov	r1, sp
    437a:	add.w	r0, sp, #1072	; 0x430
    437e:	bl	cb10 <memcpy>
    4382:	ldr.w	r3, [sp, #1080]	; 0x438
    4386:	cmp	r6, r3
    4388:	bne.n	4368 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x60>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    438a:	mov	r0, r5
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
      // is points now to junder sibling
      x.sibling = r.sibling;
    438c:	ldr	r3, [sp, #536]	; 0x218
    438e:	str.w	r3, [sp, #1080]	; 0x438
      WriteIndexRecord(is, x);
    4392:	add.w	r2, sp, #1072	; 0x430
    4396:	mov	r1, r4
    4398:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
    return 1;
  }
    439c:	addw	sp, sp, #1348	; 0x544
    43a0:	pop	{r4, r5, r6, r7, pc}
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
      WriteIndexRecord(r.parent, t);
    43a2:	mov	r0, r5
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    43a4:	ldr	r3, [sp, #536]	; 0x218
      WriteIndexRecord(r.parent, t);
    43a6:	ldr	r1, [sp, #528]	; 0x210
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    43a8:	str	r3, [sp, #804]	; 0x324
      WriteIndexRecord(r.parent, t);
    43aa:	add	r2, sp, #800	; 0x320
    43ac:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    43b0:	addw	sp, sp, #1348	; 0x544
    43b4:	pop	{r4, r5, r6, r7, pc}
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    43b6:	mov	r4, r7
    43b8:	b.n	438a <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x82>
    43ba:	nop

000043bc <MTPStorage_SD::DeleteObject(unsigned long)>:
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below
    43bc:	adds	r2, r1, #1
    43be:	beq.n	43ca <MTPStorage_SD::DeleteObject(unsigned long)+0xe>
    sd_remove(store,file);
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    43c0:	push	{r3, lr}
    43c2:	bl	4308 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    43c6:	movs	r0, #1
    43c8:	pop	{r3, pc}
    43ca:	movs	r0, #1
    43cc:	bx	lr
    43ce:	nop

000043d0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>:
  WriteIndexRecord(newHandle,p2);
  return true;
}
/************************************** mSD_Base *******************************/
bool mSD_Base::sd_copy(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{
    43d0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    43d4:	add.w	r1, r0, r1, lsl #2
    43d8:	mov	r6, r0
    43da:	ldr	r1, [r1, #84]	; 0x54
    43dc:	ldr	r0, [r1, #0]
    43de:	subw	sp, sp, #2092	; 0x82c
    43e2:	ldr	r4, [r0, #0]
    43e4:	mov	r7, r3
    43e6:	mov	r0, sp
    43e8:	movs	r3, #0
    43ea:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    43ec:	ldr	r3, [sp, #16]
    43ee:	cmp	r3, #0
    43f0:	beq.w	481a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x44a>
    43f4:	ldr	r2, [r3, #0]
    43f6:	ldr	r5, [pc, #624]	; (4668 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x298>)
    43f8:	ldr	r2, [r2, #68]	; 0x44
    43fa:	cmp	r2, r5
    43fc:	bne.w	4778 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3a8>
    4400:	ldr	r0, [r3, #16]
    4402:	cmp	r0, #0
    4404:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4408:	ldr	r2, [r0, #0]
    440a:	ldr	r2, [r2, #68]	; 0x44
    440c:	cmp	r2, r5
    440e:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4412:	ldr	r0, [r0, #16]
    4414:	cmp	r0, #0
    4416:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    441a:	ldr	r2, [r0, #0]
    441c:	ldr	r2, [r2, #68]	; 0x44
    441e:	cmp	r2, r5
    4420:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4424:	ldr	r0, [r0, #16]
    4426:	cmp	r0, #0
    4428:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    442c:	ldr	r2, [r0, #0]
    442e:	ldr	r2, [r2, #68]	; 0x44
    4430:	cmp	r2, r5
    4432:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4436:	ldr	r0, [r0, #16]
    4438:	cmp	r0, #0
    443a:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    443e:	ldr	r2, [r0, #0]
    4440:	ldr	r2, [r2, #68]	; 0x44
    4442:	cmp	r2, r5
    4444:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4448:	ldr	r0, [r0, #16]
    444a:	cmp	r0, #0
    444c:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4450:	ldr	r2, [r0, #0]
    4452:	ldr	r2, [r2, #68]	; 0x44
    4454:	cmp	r2, r5
    4456:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    445a:	ldr	r0, [r0, #16]
    445c:	cmp	r0, #0
    445e:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4462:	ldr	r2, [r0, #0]
    4464:	ldr	r2, [r2, #68]	; 0x44
    4466:	cmp	r2, r5
    4468:	bne.w	477a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    446c:	ldr	r0, [r0, #16]
    446e:	cmp	r0, #0
    4470:	beq.w	4628 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4474:	ldr	r3, [r0, #0]
    4476:	ldr	r3, [r3, #68]	; 0x44
    4478:	blx	r3
    447a:	mov	r4, r0
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    447c:	cmp	r4, #0
    447e:	beq.w	4c62 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x892>
    4482:	add.w	r6, r6, r7, lsl #2
    4486:	add	r0, sp, #20
    4488:	ldr	r1, [r6, #84]	; 0x54
    448a:	ldr.w	r2, [sp, #2128]	; 0x850
    448e:	ldr	r3, [r1, #0]
    4490:	ldr	r4, [r3, #0]
    4492:	movs	r3, #2
    4494:	blx	r4
    4496:	ldr	r0, [sp, #36]	; 0x24
    4498:	cmp	r0, #0
    449a:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    449e:	ldr	r3, [r0, #0]
    44a0:	ldr	r3, [r3, #68]	; 0x44
    44a2:	cmp	r3, r5
    44a4:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44a8:	ldr	r0, [r0, #16]
    44aa:	cmp	r0, #0
    44ac:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44b0:	ldr	r3, [r0, #0]
    44b2:	ldr	r3, [r3, #68]	; 0x44
    44b4:	cmp	r3, r5
    44b6:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44ba:	ldr	r0, [r0, #16]
    44bc:	cmp	r0, #0
    44be:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44c2:	ldr	r3, [r0, #0]
    44c4:	ldr	r3, [r3, #68]	; 0x44
    44c6:	cmp	r3, r5
    44c8:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44cc:	ldr	r0, [r0, #16]
    44ce:	cmp	r0, #0
    44d0:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44d4:	ldr	r3, [r0, #0]
    44d6:	ldr	r3, [r3, #68]	; 0x44
    44d8:	cmp	r3, r5
    44da:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44de:	ldr	r0, [r0, #16]
    44e0:	cmp	r0, #0
    44e2:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44e6:	ldr	r3, [r0, #0]
    44e8:	ldr	r3, [r3, #68]	; 0x44
    44ea:	cmp	r3, r5
    44ec:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44f0:	ldr	r0, [r0, #16]
    44f2:	cmp	r0, #0
    44f4:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44f8:	ldr	r3, [r0, #0]
    44fa:	ldr	r3, [r3, #68]	; 0x44
    44fc:	cmp	r3, r5
    44fe:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4502:	ldr	r0, [r0, #16]
    4504:	cmp	r0, #0
    4506:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    450a:	ldr	r3, [r0, #0]
    450c:	ldr	r3, [r3, #68]	; 0x44
    450e:	cmp	r3, r5
    4510:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4514:	ldr	r0, [r0, #16]
    4516:	cmp	r0, #0
    4518:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    451c:	ldr	r3, [r0, #0]
    451e:	ldr	r3, [r3, #68]	; 0x44
    4520:	cmp	r3, r5
    4522:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4526:	ldr	r0, [r0, #16]
    4528:	cmp	r0, #0
    452a:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    452e:	ldr	r3, [r0, #0]
    4530:	ldr	r3, [r3, #68]	; 0x44
    4532:	cmp	r3, r5
    4534:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4538:	ldr	r0, [r0, #16]
    453a:	cmp	r0, #0
    453c:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4540:	ldr	r3, [r0, #0]
    4542:	ldr	r3, [r3, #68]	; 0x44
    4544:	cmp	r3, r5
    4546:	bne.w	494a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    454a:	ldr	r0, [r0, #16]
    454c:	cmp	r0, #0
    454e:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4552:	ldr	r3, [r0, #0]
    4554:	ldr	r3, [r3, #68]	; 0x44
    4556:	blx	r3
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    4558:	cmp	r0, #0
    455a:	beq.w	4780 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    455e:	ldr	r5, [pc, #268]	; (466c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x29c>)
    4560:	mov.w	r4, #4294967295
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4564:	ldr	r3, [sp, #16]
    4566:	cmp	r3, #0
    4568:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    456c:	ldr	r1, [r3, #0]
    456e:	ldr	r2, [r1, #16]
    4570:	cmp	r2, r5
    4572:	bne.w	4b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x788>
    4576:	ldr	r2, [r3, #16]
    4578:	cmp	r2, #0
    457a:	beq.w	4b5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x78e>
    457e:	ldr	r0, [r2, #0]
    4580:	ldr	r6, [r0, #16]
    4582:	cmp	r6, r5
    4584:	bne.w	4a00 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x630>
    4588:	ldr	r0, [r2, #16]
    458a:	cmp	r0, #0
    458c:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4590:	ldr	r6, [r0, #0]
    4592:	ldr	r6, [r6, #16]
    4594:	cmp	r6, r5
    4596:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    459a:	ldr	r0, [r0, #16]
    459c:	cmp	r0, #0
    459e:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45a2:	ldr	r6, [r0, #0]
    45a4:	ldr	r6, [r6, #16]
    45a6:	cmp	r6, r5
    45a8:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45ac:	ldr	r0, [r0, #16]
    45ae:	cmp	r0, #0
    45b0:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45b4:	ldr	r6, [r0, #0]
    45b6:	ldr	r6, [r6, #16]
    45b8:	cmp	r6, r5
    45ba:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45be:	ldr	r0, [r0, #16]
    45c0:	cmp	r0, #0
    45c2:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45c6:	ldr	r6, [r0, #0]
    45c8:	ldr	r6, [r6, #16]
    45ca:	cmp	r6, r5
    45cc:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45d0:	ldr	r0, [r0, #16]
    45d2:	cmp	r0, #0
    45d4:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45d8:	ldr	r6, [r0, #0]
    45da:	ldr	r6, [r6, #16]
    45dc:	cmp	r6, r5
    45de:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45e2:	ldr	r0, [r0, #16]
    45e4:	cmp	r0, #0
    45e6:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45ea:	ldr	r6, [r0, #0]
    45ec:	ldr	r6, [r6, #16]
    45ee:	cmp	r6, r5
    45f0:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45f4:	ldr	r0, [r0, #16]
    45f6:	cmp	r0, #0
    45f8:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45fc:	ldr	r6, [r0, #0]
    45fe:	ldr	r6, [r6, #16]
    4600:	cmp	r6, r5
    4602:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    4606:	ldr	r0, [r0, #16]
    4608:	cmp	r0, #0
    460a:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    460e:	ldr	r6, [r0, #0]
    4610:	ldr	r6, [r6, #16]
    4612:	cmp	r6, r5
    4614:	bne.w	4a02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    4618:	ldr	r0, [r0, #16]
    461a:	cmp	r0, #0
    461c:	beq.w	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4620:	ldr	r3, [r0, #0]
    4622:	ldr	r3, [r3, #16]
    4624:	blx	r3
    4626:	b.n	4a04 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4628:	ldr	r6, [pc, #68]	; (4670 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a0>)
    462a:	str	r6, [sp, #0]
    462c:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    462e:	ldr	r2, [r3, #16]
    4630:	subs	r2, #1
    4632:	str	r2, [r3, #16]
    4634:	cbnz	r2, 465c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    4636:	ldr	r5, [sp, #16]
    4638:	cbz	r5, 465c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    463a:	ldr	r3, [r5, #0]
    463c:	ldr	r2, [pc, #52]	; (4674 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a4>)
    463e:	ldr	r3, [r3, #32]
    4640:	cmp	r3, r2
    4642:	bne.w	4bf6 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x826>
    4646:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4648:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    464a:	cbz	r1, 4654 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    464c:	ldr	r3, [r1, #16]
    464e:	subs	r3, #1
    4650:	str	r3, [r1, #16]
    4652:	cbz	r3, 4678 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a8>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4654:	mov	r0, r5
    4656:	movs	r1, #20
    4658:	bl	e960 <operator delete(void*, unsigned int)>
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    465c:	mov	r0, r4
    465e:	addw	sp, sp, #2092	; 0x82c
    4662:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4666:	nop
    4668:	.word	0x00000501
    466c:	.word	0x0000048d
    4670:	.word	0x000141ec
    4674:	.word	0x00000f25
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4678:	ldr	r7, [r5, #16]
    467a:	cmp	r7, #0
    467c:	beq.n	4654 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    467e:	ldr	r3, [r7, #0]
    4680:	ldr	r3, [r3, #32]
    4682:	cmp	r3, r2
    4684:	bne.w	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x848>
    4688:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    468a:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    468c:	cmp	r1, #0
    468e:	beq.n	476e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    4690:	ldr	r3, [r1, #16]
    4692:	subs	r3, #1
    4694:	str	r3, [r1, #16]
    4696:	cmp	r3, #0
    4698:	bne.n	476e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    469a:	ldr.w	r8, [r7, #16]
    469e:	cmp.w	r8, #0
    46a2:	beq.n	476e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    46a4:	ldr.w	r3, [r8]
    46a8:	ldr	r3, [r3, #32]
    46aa:	cmp	r3, r2
    46ac:	bne.w	4c3e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x86e>
    46b0:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46b4:	str.w	r6, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46b8:	cmp	r1, #0
    46ba:	beq.n	4766 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46bc:	ldr	r3, [r1, #16]
    46be:	subs	r3, #1
    46c0:	str	r3, [r1, #16]
    46c2:	cmp	r3, #0
    46c4:	bne.n	4766 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46c6:	ldr.w	r9, [r8, #16]
    46ca:	cmp.w	r9, #0
    46ce:	beq.n	4766 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46d0:	ldr.w	r3, [r9]
    46d4:	ldr	r3, [r3, #32]
    46d6:	cmp	r3, r2
    46d8:	bne.w	4c44 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x874>
    46dc:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46e0:	str.w	r6, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46e4:	cmp	r1, #0
    46e6:	beq.n	475e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    46e8:	ldr	r3, [r1, #16]
    46ea:	subs	r3, #1
    46ec:	str	r3, [r1, #16]
    46ee:	cmp	r3, #0
    46f0:	bne.n	475e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    46f2:	ldr.w	sl, [r9, #16]
    46f6:	cmp.w	sl, #0
    46fa:	beq.n	475e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    46fc:	ldr.w	r3, [sl]
    4700:	ldr	r3, [r3, #32]
    4702:	cmp	r3, r2
    4704:	bne.w	4c56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x886>
    4708:	ldr.w	r1, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    470c:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4710:	cbz	r1, 4756 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4712:	ldr	r3, [r1, #16]
    4714:	subs	r3, #1
    4716:	str	r3, [r1, #16]
    4718:	cbnz	r3, 4756 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    471a:	ldr.w	fp, [sl, #16]
    471e:	cmp.w	fp, #0
    4722:	beq.n	4756 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4724:	ldr.w	r3, [fp]
    4728:	ldr	r3, [r3, #32]
    472a:	cmp	r3, r2
    472c:	bne.w	4c5c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x88c>
    4730:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4734:	str.w	r6, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4738:	cbz	r2, 474e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    473a:	ldr	r3, [r2, #16]
    473c:	subs	r3, #1
    473e:	str	r3, [r2, #16]
    4740:	cbnz	r3, 474e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    4742:	ldr.w	r0, [fp, #16]
    4746:	cbz	r0, 474e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    4748:	ldr	r3, [r0, #0]
    474a:	ldr	r3, [r3, #32]
    474c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    474e:	mov	r0, fp
    4750:	movs	r1, #20
    4752:	bl	e960 <operator delete(void*, unsigned int)>
    4756:	mov	r0, sl
    4758:	movs	r1, #20
    475a:	bl	e960 <operator delete(void*, unsigned int)>
    475e:	mov	r0, r9
    4760:	movs	r1, #20
    4762:	bl	e960 <operator delete(void*, unsigned int)>
    4766:	mov	r0, r8
    4768:	movs	r1, #20
    476a:	bl	e960 <operator delete(void*, unsigned int)>
    476e:	mov	r0, r7
    4770:	movs	r1, #20
    4772:	bl	e960 <operator delete(void*, unsigned int)>
    4776:	b.n	4654 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4778:	mov	r0, r3
    477a:	blx	r2
    477c:	mov	r4, r0
    477e:	b.n	447c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0xac>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4780:	ldr	r0, [sp, #16]
    4782:	cmp	r0, #0
    4784:	beq.n	4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    4786:	ldr	r3, [r0, #0]
    4788:	ldr	r1, [pc, #616]	; (49f4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    478a:	ldr	r3, [r3, #64]	; 0x40
    478c:	cmp	r3, r1
    478e:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    4792:	ldr	r0, [r0, #16]
    4794:	cmp	r0, #0
    4796:	beq.n	4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    4798:	ldr	r3, [r0, #0]
    479a:	ldr	r3, [r3, #64]	; 0x40
    479c:	cmp	r3, r1
    479e:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47a2:	ldr	r0, [r0, #16]
    47a4:	cmp	r0, #0
    47a6:	beq.n	4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47a8:	ldr	r3, [r0, #0]
    47aa:	ldr	r3, [r3, #64]	; 0x40
    47ac:	cmp	r3, r1
    47ae:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47b2:	ldr	r0, [r0, #16]
    47b4:	cmp	r0, #0
    47b6:	beq.n	4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47b8:	ldr	r3, [r0, #0]
    47ba:	ldr	r3, [r3, #64]	; 0x40
    47bc:	cmp	r3, r1
    47be:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47c2:	ldr	r0, [r0, #16]
    47c4:	cmp	r0, #0
    47c6:	beq.n	4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47c8:	ldr	r3, [r0, #0]
    47ca:	ldr	r3, [r3, #64]	; 0x40
    47cc:	cmp	r3, r1
    47ce:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47d2:	ldr	r0, [r0, #16]
    47d4:	cbz	r0, 4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47d6:	ldr	r3, [r0, #0]
    47d8:	ldr	r3, [r3, #64]	; 0x40
    47da:	cmp	r3, r1
    47dc:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47e0:	ldr	r0, [r0, #16]
    47e2:	cbz	r0, 4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47e4:	ldr	r3, [r0, #0]
    47e6:	ldr	r3, [r3, #64]	; 0x40
    47e8:	cmp	r3, r1
    47ea:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47ee:	ldr	r0, [r0, #16]
    47f0:	cbz	r0, 4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47f2:	ldr	r3, [r0, #0]
    47f4:	ldr	r3, [r3, #64]	; 0x40
    47f6:	cmp	r3, r1
    47f8:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47fc:	ldr	r0, [r0, #16]
    47fe:	cbz	r0, 4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    4800:	ldr	r3, [r0, #0]
    4802:	ldr	r3, [r3, #64]	; 0x40
    4804:	cmp	r3, r1
    4806:	bne.w	4942 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    480a:	ldr	r0, [r0, #16]
    480c:	cbz	r0, 4826 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    480e:	ldr	r3, [r0, #0]
    4810:	ldr	r3, [r3, #64]	; 0x40
    4812:	blx	r3
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    4814:	movs	r4, #0
    4816:	ldr	r3, [sp, #36]	; 0x24
    4818:	b.n	482a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    481a:	mov	r4, r3
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    481c:	mov	r0, r4
    481e:	addw	sp, sp, #2092	; 0x82c
    4822:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4826:	ldr	r3, [sp, #36]	; 0x24
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    4828:	movs	r4, #0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    482a:	ldr	r6, [pc, #460]	; (49f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
    482c:	str	r6, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    482e:	cmp	r3, #0
    4830:	beq.w	4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    4834:	ldr	r2, [r3, #16]
    4836:	subs	r2, #1
    4838:	str	r2, [r3, #16]
    483a:	cmp	r2, #0
    483c:	bne.n	4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    483e:	ldr	r5, [sp, #36]	; 0x24
    4840:	cmp	r5, #0
    4842:	beq.n	4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    4844:	ldr	r3, [r5, #0]
    4846:	ldr	r2, [pc, #436]	; (49fc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x62c>)
    4848:	ldr	r3, [r3, #32]
    484a:	cmp	r3, r2
    484c:	bne.w	4c1e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x84e>
    4850:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4852:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4854:	cmp	r1, #0
    4856:	beq.n	492e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4858:	ldr	r3, [r1, #16]
    485a:	subs	r3, #1
    485c:	str	r3, [r1, #16]
    485e:	cmp	r3, #0
    4860:	bne.n	492e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4862:	ldr	r7, [r5, #16]
    4864:	cmp	r7, #0
    4866:	beq.n	492e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4868:	ldr	r3, [r7, #0]
    486a:	ldr	r3, [r3, #32]
    486c:	cmp	r3, r2
    486e:	bne.w	4c38 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x868>
    4872:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4874:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4876:	cmp	r1, #0
    4878:	beq.n	4926 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    487a:	ldr	r3, [r1, #16]
    487c:	subs	r3, #1
    487e:	str	r3, [r1, #16]
    4880:	cmp	r3, #0
    4882:	bne.n	4926 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    4884:	ldr.w	r8, [r7, #16]
    4888:	cmp.w	r8, #0
    488c:	beq.n	4926 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    488e:	ldr.w	r3, [r8]
    4892:	ldr	r3, [r3, #32]
    4894:	cmp	r3, r2
    4896:	bne.w	4c4a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x87a>
    489a:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    489e:	str.w	r6, [r8]
    48a2:	ldr	r0, [pc, #340]	; (49f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    48a4:	cmp	r1, #0
    48a6:	beq.n	491e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48a8:	ldr	r3, [r1, #16]
    48aa:	subs	r3, #1
    48ac:	str	r3, [r1, #16]
    48ae:	cmp	r3, #0
    48b0:	bne.n	491e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48b2:	ldr.w	r9, [r8, #16]
    48b6:	cmp.w	r9, #0
    48ba:	beq.n	491e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48bc:	ldr.w	r3, [r9]
    48c0:	ldr	r3, [r3, #32]
    48c2:	cmp	r3, r2
    48c4:	bne.w	4c50 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x880>
    48c8:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    48cc:	str.w	r0, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    48d0:	cbz	r1, 4916 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    48d2:	ldr	r3, [r1, #16]
    48d4:	subs	r3, #1
    48d6:	str	r3, [r1, #16]
    48d8:	cbnz	r3, 4916 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    48da:	ldr.w	sl, [r9, #16]
    48de:	cmp.w	sl, #0
    48e2:	beq.n	4916 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    48e4:	ldr.w	r3, [sl]
    48e8:	ldr	r3, [r3, #32]
    48ea:	cmp	r3, r2
    48ec:	bne.w	4c6c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x89c>
    48f0:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    48f4:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    48f8:	cbz	r2, 490e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    48fa:	ldr	r3, [r2, #16]
    48fc:	subs	r3, #1
    48fe:	str	r3, [r2, #16]
    4900:	cbnz	r3, 490e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    4902:	ldr.w	r0, [sl, #16]
    4906:	cbz	r0, 490e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    4908:	ldr	r3, [r0, #0]
    490a:	ldr	r3, [r3, #32]
    490c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    490e:	mov	r0, sl
    4910:	movs	r1, #20
    4912:	bl	e960 <operator delete(void*, unsigned int)>
    4916:	mov	r0, r9
    4918:	movs	r1, #20
    491a:	bl	e960 <operator delete(void*, unsigned int)>
    491e:	mov	r0, r8
    4920:	movs	r1, #20
    4922:	bl	e960 <operator delete(void*, unsigned int)>
    4926:	mov	r0, r7
    4928:	movs	r1, #20
    492a:	bl	e960 <operator delete(void*, unsigned int)>
    492e:	mov	r0, r5
    4930:	movs	r1, #20
    4932:	bl	e960 <operator delete(void*, unsigned int)>
    4936:	ldr	r3, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4938:	str	r6, [sp, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    493a:	cmp	r3, #0
    493c:	bne.w	462e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x25e>
    4940:	b.n	465c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4942:	blx	r3
    4944:	movs	r4, #0
    4946:	ldr	r3, [sp, #36]	; 0x24
    4948:	b.n	482a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    494a:	blx	r3
    494c:	b.n	4558 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x188>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    494e:	ldr	r5, [r1, #64]	; 0x40
    4950:	ldr	r1, [pc, #160]	; (49f4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    4952:	cmp	r5, r1
    4954:	bne.w	4c24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4958:	mov	r0, r2
    495a:	ldr	r3, [r0, #0]
    495c:	ldr	r3, [r3, #64]	; 0x40
    495e:	cmp	r3, r1
    4960:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    4964:	ldr	r0, [r0, #16]
    4966:	cmp	r0, #0
    4968:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    496c:	ldr	r3, [r0, #0]
    496e:	ldr	r3, [r3, #64]	; 0x40
    4970:	cmp	r3, r1
    4972:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    4976:	ldr	r0, [r0, #16]
    4978:	cmp	r0, #0
    497a:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    497e:	ldr	r3, [r0, #0]
    4980:	ldr	r3, [r3, #64]	; 0x40
    4982:	cmp	r3, r1
    4984:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    4988:	ldr	r0, [r0, #16]
    498a:	cmp	r0, #0
    498c:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4990:	ldr	r3, [r0, #0]
    4992:	ldr	r3, [r3, #64]	; 0x40
    4994:	cmp	r3, r1
    4996:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    499a:	ldr	r0, [r0, #16]
    499c:	cmp	r0, #0
    499e:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49a2:	ldr	r3, [r0, #0]
    49a4:	ldr	r3, [r3, #64]	; 0x40
    49a6:	cmp	r3, r1
    49a8:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49ac:	ldr	r0, [r0, #16]
    49ae:	cmp	r0, #0
    49b0:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49b4:	ldr	r3, [r0, #0]
    49b6:	ldr	r3, [r3, #64]	; 0x40
    49b8:	cmp	r3, r1
    49ba:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49be:	ldr	r0, [r0, #16]
    49c0:	cmp	r0, #0
    49c2:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49c6:	ldr	r3, [r0, #0]
    49c8:	ldr	r3, [r3, #64]	; 0x40
    49ca:	cmp	r3, r1
    49cc:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49d0:	ldr	r0, [r0, #16]
    49d2:	cmp	r0, #0
    49d4:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49d8:	ldr	r3, [r0, #0]
    49da:	ldr	r3, [r3, #64]	; 0x40
    49dc:	cmp	r3, r1
    49de:	bne.w	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49e2:	ldr	r0, [r0, #16]
    49e4:	cmp	r0, #0
    49e6:	beq.w	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49ea:	ldr	r3, [r0, #0]
    49ec:	ldr	r3, [r3, #64]	; 0x40
    49ee:	blx	r3
    49f0:	b.n	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49f2:	nop
    49f4:	.word	0x000004f5
    49f8:	.word	0x000141ec
    49fc:	.word	0x00000f25
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4a00:	mov	r0, r2
    4a02:	blx	r6

  while(f1.available()>0)
    4a04:	cmp	r0, #0
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    4a06:	ldr	r3, [sp, #16]
    4a08:	ble.n	4ab4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e4>
    4a0a:	cmp	r3, #0
    4a0c:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a0e:	ldr	r1, [r3, #0]
    4a10:	ldr	r2, [pc, #536]	; (4c2c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x85c>)
    4a12:	ldr	r4, [r1, #40]	; 0x28
    4a14:	cmp	r4, r2
    4a16:	bne.n	4a96 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c6>
    4a18:	ldr	r0, [r3, #16]
    4a1a:	cmp	r0, #0
    4a1c:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a1e:	ldr	r1, [r0, #0]
    4a20:	ldr	r4, [r1, #40]	; 0x28
    4a22:	cmp	r4, r2
    4a24:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a26:	ldr	r0, [r0, #16]
    4a28:	cmp	r0, #0
    4a2a:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a2c:	ldr	r1, [r0, #0]
    4a2e:	ldr	r4, [r1, #40]	; 0x28
    4a30:	cmp	r4, r2
    4a32:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a34:	ldr	r0, [r0, #16]
    4a36:	cmp	r0, #0
    4a38:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a3a:	ldr	r1, [r0, #0]
    4a3c:	ldr	r4, [r1, #40]	; 0x28
    4a3e:	cmp	r4, r2
    4a40:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a42:	ldr	r0, [r0, #16]
    4a44:	cmp	r0, #0
    4a46:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a48:	ldr	r1, [r0, #0]
    4a4a:	ldr	r4, [r1, #40]	; 0x28
    4a4c:	cmp	r4, r2
    4a4e:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a50:	ldr	r0, [r0, #16]
    4a52:	cmp	r0, #0
    4a54:	beq.n	4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a56:	ldr	r1, [r0, #0]
    4a58:	ldr	r4, [r1, #40]	; 0x28
    4a5a:	cmp	r4, r2
    4a5c:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a5e:	ldr	r0, [r0, #16]
    4a60:	cbz	r0, 4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a62:	ldr	r1, [r0, #0]
    4a64:	ldr	r4, [r1, #40]	; 0x28
    4a66:	cmp	r4, r2
    4a68:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a6a:	ldr	r0, [r0, #16]
    4a6c:	cbz	r0, 4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a6e:	ldr	r1, [r0, #0]
    4a70:	ldr	r4, [r1, #40]	; 0x28
    4a72:	cmp	r4, r2
    4a74:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a76:	ldr	r0, [r0, #16]
    4a78:	cbz	r0, 4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a7a:	ldr	r1, [r0, #0]
    4a7c:	ldr	r4, [r1, #40]	; 0x28
    4a7e:	cmp	r4, r2
    4a80:	bne.n	4a98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a82:	ldr	r0, [r0, #16]
    4a84:	cbz	r0, 4abc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a86:	ldr	r3, [r0, #0]
    4a88:	mov.w	r2, #2048	; 0x800
    4a8c:	ldr	r3, [r3, #40]	; 0x28
    4a8e:	add	r1, sp, #40	; 0x28
    4a90:	blx	r3
    4a92:	mov	r2, r0
    4a94:	b.n	4aa2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6d2>
    4a96:	mov	r0, r3
    4a98:	mov.w	r2, #2048	; 0x800
    4a9c:	add	r1, sp, #40	; 0x28
    4a9e:	blx	r4
    4aa0:	mov	r2, r0
  {
    nd=f1.read(buffer,nbuf);
    if(nd<0) break;     // read error
    4aa2:	subs	r4, r2, #0
    4aa4:	blt.n	4ab2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e2>
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    4aa6:	ldr	r0, [sp, #36]	; 0x24
    4aa8:	cbnz	r0, 4ac8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6f8>
    f2.write(buffer,nd);
    if(nd<nbuf) break;  // end of file
    4aaa:	cmp.w	r4, #2048	; 0x800
    4aae:	bge.w	4564 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x194>
    4ab2:	ldr	r3, [sp, #16]
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4ab4:	cmp	r3, #0
    4ab6:	bne.w	4c02 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x832>
    4aba:	b.n	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    4abc:	ldr	r0, [sp, #36]	; 0x24
    4abe:	cmp	r0, #0
    4ac0:	beq.w	4bfc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x82c>
    4ac4:	movs	r2, #0
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    4ac6:	mov	r4, r2
    4ac8:	ldr	r1, [r0, #0]
    4aca:	ldr	r3, [pc, #356]	; (4c30 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x860>)
    4acc:	ldr	r6, [r1, #44]	; 0x2c
    4ace:	cmp	r6, r3
    4ad0:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4ad2:	ldr	r0, [r0, #16]
    4ad4:	cmp	r0, #0
    4ad6:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4ad8:	ldr	r1, [r0, #0]
    4ada:	ldr	r6, [r1, #44]	; 0x2c
    4adc:	cmp	r6, r3
    4ade:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4ae0:	ldr	r0, [r0, #16]
    4ae2:	cmp	r0, #0
    4ae4:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4ae6:	ldr	r1, [r0, #0]
    4ae8:	ldr	r6, [r1, #44]	; 0x2c
    4aea:	cmp	r6, r3
    4aec:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4aee:	ldr	r0, [r0, #16]
    4af0:	cmp	r0, #0
    4af2:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4af4:	ldr	r1, [r0, #0]
    4af6:	ldr	r6, [r1, #44]	; 0x2c
    4af8:	cmp	r6, r3
    4afa:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4afc:	ldr	r0, [r0, #16]
    4afe:	cmp	r0, #0
    4b00:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b02:	ldr	r1, [r0, #0]
    4b04:	ldr	r6, [r1, #44]	; 0x2c
    4b06:	cmp	r6, r3
    4b08:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b0a:	ldr	r0, [r0, #16]
    4b0c:	cmp	r0, #0
    4b0e:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b10:	ldr	r1, [r0, #0]
    4b12:	ldr	r6, [r1, #44]	; 0x2c
    4b14:	cmp	r6, r3
    4b16:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b18:	ldr	r0, [r0, #16]
    4b1a:	cmp	r0, #0
    4b1c:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b1e:	ldr	r1, [r0, #0]
    4b20:	ldr	r6, [r1, #44]	; 0x2c
    4b22:	cmp	r6, r3
    4b24:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b26:	ldr	r0, [r0, #16]
    4b28:	cmp	r0, #0
    4b2a:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b2c:	ldr	r1, [r0, #0]
    4b2e:	ldr	r6, [r1, #44]	; 0x2c
    4b30:	cmp	r6, r3
    4b32:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b34:	ldr	r0, [r0, #16]
    4b36:	cmp	r0, #0
    4b38:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b3a:	ldr	r1, [r0, #0]
    4b3c:	ldr	r6, [r1, #44]	; 0x2c
    4b3e:	cmp	r6, r3
    4b40:	bne.n	4b52 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b42:	ldr	r0, [r0, #16]
    4b44:	cmp	r0, #0
    4b46:	beq.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b48:	ldr	r3, [r0, #0]
    4b4a:	add	r1, sp, #40	; 0x28
    4b4c:	ldr	r3, [r3, #44]	; 0x2c
    4b4e:	blx	r3
    4b50:	b.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b52:	add	r1, sp, #40	; 0x28
    4b54:	blx	r6
    4b56:	b.n	4aaa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4b58:	mov	r0, r3
    4b5a:	blx	r2
    4b5c:	b.n	4a04 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4b5e:	ldr	r5, [r1, #64]	; 0x40
    4b60:	ldr	r2, [pc, #208]	; (4c34 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4b62:	cmp	r5, r2
    4b64:	bne.n	4c24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4b66:	ldr	r3, [sp, #36]	; 0x24
    4b68:	cmp	r3, #0
    4b6a:	beq.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4b6c:	ldr	r2, [r3, #0]
    4b6e:	ldr	r1, [pc, #196]	; (4c34 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4b70:	ldr	r2, [r2, #64]	; 0x40
    4b72:	cmp	r2, r1
    4b74:	bne.n	4bea <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81a>
    4b76:	ldr	r0, [r3, #16]
    4b78:	cmp	r0, #0
    4b7a:	beq.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4b7c:	ldr	r2, [r0, #0]
    4b7e:	ldr	r2, [r2, #64]	; 0x40
    4b80:	cmp	r2, r1
    4b82:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4b84:	ldr	r0, [r0, #16]
    4b86:	cmp	r0, #0
    4b88:	beq.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4b8a:	ldr	r2, [r0, #0]
    4b8c:	ldr	r2, [r2, #64]	; 0x40
    4b8e:	cmp	r2, r1
    4b90:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4b92:	ldr	r0, [r0, #16]
    4b94:	cmp	r0, #0
    4b96:	beq.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4b98:	ldr	r2, [r0, #0]
    4b9a:	ldr	r2, [r2, #64]	; 0x40
    4b9c:	cmp	r2, r1
    4b9e:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4ba0:	ldr	r0, [r0, #16]
    4ba2:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4ba4:	ldr	r2, [r0, #0]
    4ba6:	ldr	r2, [r2, #64]	; 0x40
    4ba8:	cmp	r2, r1
    4baa:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bac:	ldr	r0, [r0, #16]
    4bae:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bb0:	ldr	r2, [r0, #0]
    4bb2:	ldr	r2, [r2, #64]	; 0x40
    4bb4:	cmp	r2, r1
    4bb6:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bb8:	ldr	r0, [r0, #16]
    4bba:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bbc:	ldr	r2, [r0, #0]
    4bbe:	ldr	r2, [r2, #64]	; 0x40
    4bc0:	cmp	r2, r1
    4bc2:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bc4:	ldr	r0, [r0, #16]
    4bc6:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bc8:	ldr	r2, [r0, #0]
    4bca:	ldr	r2, [r2, #64]	; 0x40
    4bcc:	cmp	r2, r1
    4bce:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bd0:	ldr	r0, [r0, #16]
    4bd2:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bd4:	ldr	r2, [r0, #0]
    4bd6:	ldr	r2, [r2, #64]	; 0x40
    4bd8:	cmp	r2, r1
    4bda:	bne.n	4bec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bdc:	ldr	r0, [r0, #16]
    4bde:	cbz	r0, 4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4be0:	ldr	r3, [r0, #0]
    4be2:	ldr	r3, [r3, #64]	; 0x40
    4be4:	blx	r3
    4be6:	ldr	r3, [sp, #36]	; 0x24
    4be8:	b.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bea:	mov	r0, r3
    4bec:	blx	r2
    4bee:	ldr	r3, [sp, #36]	; 0x24
    if(nd<nbuf) break;  // end of file
  }
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
    4bf0:	mvns	r4, r4
    4bf2:	lsrs	r4, r4, #31
    4bf4:	b.n	482a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4bf6:	mov	r0, r5
    4bf8:	blx	r3
    4bfa:	b.n	465c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    4bfc:	mov	r4, r0
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4bfe:	cmp	r3, #0
    4c00:	beq.n	4c68 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x898>
    4c02:	ldr	r2, [r3, #0]
    4c04:	ldr	r1, [pc, #44]	; (4c34 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4c06:	ldr	r5, [r2, #64]	; 0x40
    4c08:	cmp	r5, r1
    4c0a:	bne.n	4c24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4c0c:	ldr	r0, [r3, #16]
    4c0e:	cmp	r0, #0
    4c10:	beq.n	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4c12:	b.n	495a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x58a>
    4c14:	blx	r3
    4c16:	b.n	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c18:	mov	r0, r7
    4c1a:	blx	r3
    4c1c:	b.n	4654 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    4c1e:	mov	r0, r5
    4c20:	blx	r3
    4c22:	b.n	4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4c24:	mov	r0, r3
    4c26:	blx	r5
    4c28:	b.n	4b66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4c2a:	nop
    4c2c:	.word	0x00000475
    4c30:	.word	0x00000481
    4c34:	.word	0x000004f5
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c38:	mov	r0, r7
    4c3a:	blx	r3
    4c3c:	b.n	492e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4c3e:	mov	r0, r8
    4c40:	blx	r3
    4c42:	b.n	476e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    4c44:	mov	r0, r9
    4c46:	blx	r3
    4c48:	b.n	4766 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    4c4a:	mov	r0, r8
    4c4c:	blx	r3
    4c4e:	b.n	4926 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    4c50:	mov	r0, r9
    4c52:	blx	r3
    4c54:	b.n	491e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    4c56:	mov	r0, sl
    4c58:	blx	r3
    4c5a:	b.n	475e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    4c5c:	mov	r0, fp
    4c5e:	blx	r3
    4c60:	b.n	4756 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4c62:	ldr	r3, [sp, #16]
    4c64:	ldr	r6, [pc, #12]	; (4c74 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x8a4>)
    4c66:	b.n	4938 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x568>
    4c68:	mov	r4, r3
    4c6a:	b.n	4bf0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4c6c:	mov	r0, sl
    4c6e:	blx	r3
    4c70:	b.n	4916 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    4c72:	nop
    4c74:	.word	0x000141ec

00004c78 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)>:
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4c78:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4c7c:	mov	r8, r1
    4c7e:	sub.w	sp, sp, #1336	; 0x538
    if(newParent==0xFFFFFFFFUL) newParent=newStore;
    4c82:	cmp.w	r3, #4294967295
    4c86:	ite	ne
    4c88:	movne	r7, r3
    4c8a:	moveq	r7, r2

    Record p1 = ReadIndexRecord(handle);
    4c8c:	mov	r1, r0
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4c8e:	mov	r4, r0
    if(newParent==0xFFFFFFFFUL) newParent=newStore;

    Record p1 = ReadIndexRecord(handle);
    4c90:	mov	r2, r8
    4c92:	add	r0, sp, #520	; 0x208
    4c94:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    4c98:	mov	r2, r7
    4c9a:	mov	r1, r4
    4c9c:	add	r0, sp, #792	; 0x318
    4c9e:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    uint32_t newHandle;
    if(p1.isdir)
    4ca2:	ldrb.w	r6, [sp, #532]	; 0x214
    4ca6:	cmp	r6, #0
    4ca8:	bne.n	4d30 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)+0xb8>
      CopyFiles(handle, p2.store, newHandle);
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
    4caa:	add	r1, sp, #536	; 0x218
    4cac:	mov.w	r2, #256	; 0x100
    4cb0:	add.w	r0, sp, #1080	; 0x438
    4cb4:	bl	10ce0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4cb8:	ldr.w	r5, [r4, #244]	; 0xf4
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    4cbc:	ldrh.w	r0, [sp, #806]	; 0x326
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    4cc0:	ldr	r3, [sp, #796]	; 0x31c
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    4cc2:	strh.w	r0, [sp, #1078]	; 0x436
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4cc6:	adds	r2, r5, #1
    4cc8:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    4ccc:	mov	r1, r5
    4cce:	add.w	r2, sp, #1064	; 0x428
    4cd2:	mov	r0, r4
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    4cd4:	str.w	r3, [sp, #1072]	; 0x430
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
    4cd8:	str.w	r7, [sp, #1064]	; 0x428
      r.child = 0;
    4cdc:	str.w	r6, [sp, #1068]	; 0x42c
      r.sibling = p2.child;
      r.isdir = 0;
    4ce0:	strb.w	r6, [sp, #1076]	; 0x434
      r.scanned = 0;
    4ce4:	strb.w	r6, [sp, #1077]	; 0x435
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4ce8:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);
    4cec:	add	r2, sp, #792	; 0x318
    4cee:	mov	r1, r7
    4cf0:	mov	r0, r4
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
    4cf2:	str	r5, [sp, #796]	; 0x31c
      WriteIndexRecord(newParent, p2);
    4cf4:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4cf8:	mov	r1, r8
    4cfa:	add	r2, sp, #8
    4cfc:	mov.w	r3, #256	; 0x100
    4d00:	mov	r0, r4
    4d02:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    4d06:	add	r6, sp, #264	; 0x108
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4d08:	mov	r7, r0
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    4d0a:	mov	r1, r5
    4d0c:	mov	r2, r6
    4d0e:	mov.w	r3, #256	; 0x100
    4d12:	mov	r0, r4
    4d14:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>

      sd_copy(store0,oldfilename,store1,newfilename);
    4d18:	str	r6, [sp, #0]
    4d1a:	mov	r3, r0
    4d1c:	add	r2, sp, #8
    4d1e:	mov	r1, r7
    4d20:	adds	r0, r4, #4
    4d22:	bl	43d0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }

    return newHandle;
  }
    4d26:	mov	r0, r5
    4d28:	add.w	sp, sp, #1336	; 0x538
    4d2c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
    4d30:	ldrh.w	r1, [sp, #534]	; 0x216
    4d34:	mov	r2, r8
    4d36:	mov	r0, r4
    4d38:	adds	r1, #1
    4d3a:	bl	328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    4d3e:	ldrb.w	r3, [sp, #532]	; 0x214
    4d42:	ldr	r0, [r4, #0]
    4d44:	ldrh.w	r1, [sp, #806]	; 0x326
    4d48:	add	r2, sp, #536	; 0x218
    4d4a:	adds	r3, #0
    4d4c:	str	r2, [sp, #0]
    4d4e:	it	ne
    4d50:	movne	r3, #1
    4d52:	mov	r2, r7
    4d54:	ldr	r5, [r0, #44]	; 0x2c
    4d56:	mov	r0, r4
    4d58:	blx	r5
      CopyFiles(handle, p2.store, newHandle);
    4d5a:	ldr	r3, [r4, #0]
    4d5c:	ldrh.w	r2, [sp, #806]	; 0x326
    4d60:	ldr	r6, [r3, #84]	; 0x54

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    4d62:	mov	r5, r0
      CopyFiles(handle, p2.store, newHandle);
    4d64:	mov	r3, r0
    4d66:	mov	r1, r8
    4d68:	mov	r0, r4
    4d6a:	blx	r6

      sd_copy(store0,oldfilename,store1,newfilename);
    }

    return newHandle;
  }
    4d6c:	mov	r0, r5
    4d6e:	add.w	sp, sp, #1336	; 0x538
    4d72:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4d76:	nop

00004d78 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)>:

bool MTPStorage_SD::CopyFiles(uint32_t handle, uint32_t store, uint32_t newHandle)
{ // assume handle and newHandle point to existing directories
    4d78:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4d7c:	mov	r4, r0
    4d7e:	subw	sp, sp, #1612	; 0x64c
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
    4d82:	cmp.w	r3, #4294967295
    4d86:	ite	ne
    4d88:	movne	r8, r3
    4d8a:	moveq	r8, r2
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    4d8c:	add	r0, sp, #520	; 0x208
    4d8e:	mov	r2, r1
    4d90:	mov	r1, r4
    4d92:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  Record p2=ReadIndexRecord(newHandle);
    4d96:	mov	r2, r8
    4d98:	mov	r1, r4
    4d9a:	add	r0, sp, #792	; 0x318
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    4d9c:	ldrh.w	r9, [sp, #534]	; 0x216
  Record p2=ReadIndexRecord(newHandle);
    4da0:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  uint32_t ix= p1.child;
    4da4:	ldr	r6, [sp, #524]	; 0x20c
  uint32_t iy= 0;
  while(ix)
    4da6:	cmp	r6, #0
    4da8:	beq.n	4e7e <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x106>
    4daa:	movs	r5, #0
    4dac:	add	r7, sp, #264	; 0x108

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4dae:	add.w	sl, r4, #4
    4db2:	b.n	4de8 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    4db4:	ldrh.w	r3, [sp, #1350]	; 0x546
    4db8:	add.w	r3, r4, r3, lsl #2
    4dbc:	ldr	r0, [r3, #88]	; 0x58
    4dbe:	ldr	r3, [r0, #0]
    4dc0:	ldr	r3, [r3, #8]
    4dc2:	blx	r3

    if(py.isdir) 
    { 
      sd_mkdir(py.store,newfilename);

      ScanDir(p1.store,ix); 
    4dc4:	mov	r2, r6
    4dc6:	mov	r1, r9
    4dc8:	mov	r0, r4
    4dca:	bl	328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      CopyFiles(ix,p2.store,iy); 
    4dce:	ldr	r3, [r4, #0]
    4dd0:	ldrh.w	r2, [sp, #806]	; 0x326
    4dd4:	ldr.w	fp, [r3, #84]	; 0x54
    4dd8:	mov	r1, r6
    4dda:	mov	r3, r5
    4ddc:	mov	r0, r4
    4dde:	blx	fp
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
    4de0:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4de4:	cmp	r6, #0
    4de6:	beq.n	4e68 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
  { // get child
    Record px = ReadIndexRecord(ix) ;
    4de8:	mov	r2, r6
    4dea:	mov	r1, r4
    4dec:	add.w	r0, sp, #1064	; 0x428
    4df0:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record py = px;
    4df4:	mov.w	r2, #272	; 0x110
    4df8:	add.w	r1, sp, #1064	; 0x428
    4dfc:	add.w	r0, sp, #1336	; 0x538
    4e00:	bl	cb10 <memcpy>
    py.store = p2.store;
    py.parent = newHandle;
    py.sibling = iy;
    4e04:	str.w	r5, [sp, #1344]	; 0x540
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4e08:	ldr.w	r5, [r4, #244]	; 0xf4
  uint32_t iy= 0;
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    4e0c:	ldrh.w	r3, [sp, #806]	; 0x326
    4e10:	strh.w	r3, [sp, #1350]	; 0x546
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4e14:	adds	r2, r5, #1
    4e16:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    4e1a:	mov	r1, r5
    4e1c:	add.w	r2, sp, #1336	; 0x538
    4e20:	mov	r0, r4
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    py.parent = newHandle;
    4e22:	str.w	r8, [sp, #1336]	; 0x538
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4e26:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    py.sibling = iy;
    iy = AppendIndexRecord(py);

    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    4e2a:	mov.w	r3, #256	; 0x100
    4e2e:	add	r2, sp, #8
    4e30:	mov	r1, r6
    4e32:	mov	r0, r4
    4e34:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);
    4e38:	mov	r1, r5
    4e3a:	mov.w	r3, #256	; 0x100
    4e3e:	mov	r2, r7
    4e40:	mov	r0, r4
    4e42:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    if(py.isdir) 
    4e46:	ldrb.w	r3, [sp, #1348]	; 0x544
    4e4a:	mov	r1, r7

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4e4c:	add	r2, sp, #8
    4e4e:	mov	r0, sl
    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);

    if(py.isdir) 
    4e50:	cmp	r3, #0
    4e52:	bne.n	4db4 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x3c>

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4e54:	ldrh.w	r3, [sp, #1350]	; 0x546
    4e58:	str	r7, [sp, #0]
    4e5a:	mov	r1, r9
    4e5c:	bl	43d0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }
    ix = px.sibling;
    4e60:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4e64:	cmp	r6, #0
    4e66:	bne.n	4de8 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
  WriteIndexRecord(newHandle,p2);
    4e68:	mov	r0, r4
    4e6a:	mov	r1, r8
    4e6c:	add	r2, sp, #792	; 0x318
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
    4e6e:	str	r5, [sp, #796]	; 0x31c
  WriteIndexRecord(newHandle,p2);
    4e70:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
  return true;
}
    4e74:	movs	r0, #1
    4e76:	addw	sp, sp, #1612	; 0x64c
    4e7a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  #endif

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
    4e7e:	mov	r5, r6
    4e80:	b.n	4e68 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
    4e82:	nop

00004e84 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>:
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{ // old and new are directory paths
    4e84:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4e88:	mov	r5, r3
    4e8a:	add.w	r3, r0, r3, lsl #2
    4e8e:	mov	r4, r0
    4e90:	ldr	r0, [r3, #84]	; 0x54
    4e92:	ldr	r6, [sp, #24]
    4e94:	ldr	r3, [r0, #0]
    4e96:	mov	r7, r1
    4e98:	ldr	r3, [r3, #8]
    4e9a:	mov	r1, r6
    4e9c:	mov	r8, r2
    4e9e:	blx	r3

  char tmp0Name[MAX_FILENAME_LEN];
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}
    4ea0:	cbnz	r0, 4ea6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)+0x22>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    4ea2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4ea6:	str	r6, [sp, #24]
    4ea8:	mov	r3, r5
    4eaa:	mov	r2, r8
    4eac:	mov	r1, r7
    4eae:	mov	r0, r4
    4eb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    4eb4:	b.w	4eb8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>

00004eb8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>:
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
    4eb8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4ebc:	add.w	sl, r0, r1, lsl #2
    4ec0:	mov	r8, r1
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    4ec2:	ldr.w	r1, [sl, #84]	; 0x54
    4ec6:	sub.w	sp, sp, #596	; 0x254
    4eca:	mov	r9, r0
    4ecc:	ldr	r0, [r1, #0]
    4ece:	str	r3, [sp, #8]
    4ed0:	ldr	r4, [r0, #0]
    4ed2:	str	r2, [sp, #12]
    4ed4:	movs	r3, #0
    4ed6:	add	r0, sp, #40	; 0x28
    4ed8:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4eda:	ldr	r3, [sp, #56]	; 0x38
    4edc:	cmp	r3, #0
    4ede:	beq.w	5836 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x97e>
    4ee2:	ldr	r2, [r3, #0]
    4ee4:	ldr	r6, [pc, #460]	; (50b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1fc>)
    4ee6:	ldr	r2, [r2, #68]	; 0x44
    4ee8:	cmp	r2, r6
    4eea:	bne.w	51c2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30a>
    4eee:	ldr	r0, [r3, #16]
    4ef0:	cmp	r0, #0
    4ef2:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4ef6:	ldr	r2, [r0, #0]
    4ef8:	ldr	r2, [r2, #68]	; 0x44
    4efa:	cmp	r2, r6
    4efc:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f00:	ldr	r0, [r0, #16]
    4f02:	cmp	r0, #0
    4f04:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f08:	ldr	r2, [r0, #0]
    4f0a:	ldr	r2, [r2, #68]	; 0x44
    4f0c:	cmp	r2, r6
    4f0e:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f12:	ldr	r0, [r0, #16]
    4f14:	cmp	r0, #0
    4f16:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f1a:	ldr	r2, [r0, #0]
    4f1c:	ldr	r2, [r2, #68]	; 0x44
    4f1e:	cmp	r2, r6
    4f20:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f24:	ldr	r0, [r0, #16]
    4f26:	cmp	r0, #0
    4f28:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f2c:	ldr	r2, [r0, #0]
    4f2e:	ldr	r2, [r2, #68]	; 0x44
    4f30:	cmp	r2, r6
    4f32:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f36:	ldr	r0, [r0, #16]
    4f38:	cmp	r0, #0
    4f3a:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f3e:	ldr	r2, [r0, #0]
    4f40:	ldr	r2, [r2, #68]	; 0x44
    4f42:	cmp	r2, r6
    4f44:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f48:	ldr	r0, [r0, #16]
    4f4a:	cmp	r0, #0
    4f4c:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f50:	ldr	r2, [r0, #0]
    4f52:	ldr	r2, [r2, #68]	; 0x44
    4f54:	cmp	r2, r6
    4f56:	bne.w	51c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f5a:	ldr	r0, [r0, #16]
    4f5c:	cmp	r0, #0
    4f5e:	beq.w	5070 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f62:	ldr	r3, [r0, #0]
    4f64:	ldr	r3, [r3, #68]	; 0x44
    4f66:	blx	r3
    4f68:	mov	r4, r0
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    4f6a:	cmp	r4, #0
    4f6c:	beq.w	58ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa34>
    4f70:	ldr.w	fp, [pc, #336]	; 50c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    4f74:	add	r4, sp, #336	; 0x150
  { while(1)
    {
      strlcpy(tmp0Name,oldfilename,MAX_FILENAME_LEN);
    4f76:	mov.w	r2, #256	; 0x100
    4f7a:	ldr	r1, [sp, #12]
    4f7c:	add	r0, sp, #80	; 0x50
    4f7e:	bl	10ce0 <strlcpy>
      if(tmp0Name[strlen(tmp0Name)-1]!='/') strlcat(tmp0Name,"/",MAX_FILENAME_LEN);
    4f82:	add	r0, sp, #80	; 0x50
    4f84:	bl	10d40 <strlen>
    4f88:	add	r3, sp, #80	; 0x50
    4f8a:	add	r0, r3
    4f8c:	ldrb.w	r3, [r0, #-1]
    4f90:	cmp	r3, #47	; 0x2f
    4f92:	beq.n	4fa0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xe8>
    4f94:	mov.w	r2, #256	; 0x100
    4f98:	ldr	r1, [pc, #284]	; (50b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    4f9a:	add	r0, sp, #80	; 0x50
    4f9c:	bl	10c8c <strlcat>

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
    4fa0:	mov.w	r2, #256	; 0x100
    4fa4:	ldr	r1, [sp, #632]	; 0x278
    4fa6:	mov	r0, r4
    4fa8:	bl	10ce0 <strlcpy>
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);
    4fac:	mov	r0, r4
    4fae:	bl	10d40 <strlen>
    4fb2:	add	r0, r4
    4fb4:	ldrb.w	r3, [r0, #-1]
    4fb8:	cmp	r3, #47	; 0x2f
    4fba:	beq.n	4fc8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x110>
    4fbc:	mov.w	r2, #256	; 0x100
    4fc0:	ldr	r1, [pc, #244]	; (50b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    4fc2:	mov	r0, r4
    4fc4:	bl	10c8c <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    4fc8:	ldr	r1, [sp, #56]	; 0x38
    4fca:	cmp	r1, #0
    4fcc:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4fd0:	ldr	r3, [r1, #0]
    4fd2:	ldr	r2, [pc, #232]	; (50bc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x204>)
    4fd4:	ldr	r3, [r3, #80]	; 0x50
    4fd6:	cmp	r3, r2
    4fd8:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4fdc:	ldr	r1, [r1, #16]
    4fde:	cmp	r1, #0
    4fe0:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4fe4:	ldr	r3, [r1, #0]
    4fe6:	ldr	r3, [r3, #80]	; 0x50
    4fe8:	cmp	r3, r2
    4fea:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4fee:	ldr	r1, [r1, #16]
    4ff0:	cmp	r1, #0
    4ff2:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4ff6:	ldr	r3, [r1, #0]
    4ff8:	ldr	r3, [r3, #80]	; 0x50
    4ffa:	cmp	r3, r2
    4ffc:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5000:	ldr	r1, [r1, #16]
    5002:	cmp	r1, #0
    5004:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5008:	ldr	r3, [r1, #0]
    500a:	ldr	r3, [r3, #80]	; 0x50
    500c:	cmp	r3, r2
    500e:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5012:	ldr	r1, [r1, #16]
    5014:	cmp	r1, #0
    5016:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    501a:	ldr	r3, [r1, #0]
    501c:	ldr	r3, [r3, #80]	; 0x50
    501e:	cmp	r3, r2
    5020:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5024:	ldr	r1, [r1, #16]
    5026:	cmp	r1, #0
    5028:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    502c:	ldr	r3, [r1, #0]
    502e:	ldr	r3, [r3, #80]	; 0x50
    5030:	cmp	r3, r2
    5032:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5036:	ldr	r1, [r1, #16]
    5038:	cmp	r1, #0
    503a:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    503e:	ldr	r3, [r1, #0]
    5040:	ldr	r3, [r3, #80]	; 0x50
    5042:	cmp	r3, r2
    5044:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5048:	ldr	r1, [r1, #16]
    504a:	cmp	r1, #0
    504c:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5050:	ldr	r3, [r1, #0]
    5052:	ldr	r3, [r3, #80]	; 0x50
    5054:	cmp	r3, r2
    5056:	bne.w	52ac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    505a:	ldr	r1, [r1, #16]
    505c:	cmp	r1, #0
    505e:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5062:	ldr	r3, [r1, #0]
    5064:	add	r5, sp, #60	; 0x3c
    5066:	ldr	r3, [r3, #80]	; 0x50
    5068:	mov	r0, r5
    506a:	movs	r2, #0
    506c:	blx	r3
    506e:	b.n	52b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3fc>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5070:	ldr.w	fp, [pc, #80]	; 50c4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    5074:	str.w	fp, [sp, #40]	; 0x28
    5078:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    507a:	ldr	r2, [r3, #16]
    507c:	subs	r2, #1
    507e:	str	r2, [r3, #16]
    5080:	cbnz	r2, 50aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    5082:	ldr	r5, [sp, #56]	; 0x38
    5084:	cbz	r5, 50aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    5086:	ldr	r2, [r5, #0]
    5088:	ldr	r3, [pc, #52]	; (50c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x208>)
    508a:	ldr	r2, [r2, #32]
    508c:	cmp	r2, r3
    508e:	bne.w	5850 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x998>
    5092:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5094:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5098:	cbz	r1, 50a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    509a:	ldr	r2, [r1, #16]
    509c:	subs	r2, #1
    509e:	str	r2, [r1, #16]
    50a0:	cbz	r2, 50c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x210>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    50a2:	mov	r0, r5
    50a4:	movs	r1, #20
    50a6:	bl	e960 <operator delete(void*, unsigned int)>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    50aa:	mov	r0, r4
    50ac:	add.w	sp, sp, #596	; 0x254
    50b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    50b4:	.word	0x00000501
    50b8:	.word	0x000144d4
    50bc:	.word	0x0000052d
    50c0:	.word	0x00000f25
    50c4:	.word	0x000141ec
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    50c8:	ldr	r6, [r5, #16]
    50ca:	cmp	r6, #0
    50cc:	beq.n	50a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    50ce:	ldr	r2, [r6, #0]
    50d0:	ldr	r2, [r2, #32]
    50d2:	cmp	r2, r3
    50d4:	bne.w	5866 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ae>
    50d8:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    50da:	str.w	fp, [r6]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    50de:	cmp	r1, #0
    50e0:	beq.n	51b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    50e2:	ldr	r2, [r1, #16]
    50e4:	subs	r2, #1
    50e6:	str	r2, [r1, #16]
    50e8:	cmp	r2, #0
    50ea:	bne.n	51b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    50ec:	ldr	r7, [r6, #16]
    50ee:	cmp	r7, #0
    50f0:	beq.n	51b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    50f2:	ldr	r2, [r7, #0]
    50f4:	ldr	r2, [r2, #32]
    50f6:	cmp	r2, r3
    50f8:	bne.w	5882 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ca>
    50fc:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    50fe:	str.w	fp, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5102:	cmp	r1, #0
    5104:	beq.n	51b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    5106:	ldr	r2, [r1, #16]
    5108:	subs	r2, #1
    510a:	str	r2, [r1, #16]
    510c:	cmp	r2, #0
    510e:	bne.n	51b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    5110:	ldr.w	r8, [r7, #16]
    5114:	cmp.w	r8, #0
    5118:	beq.n	51b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    511a:	ldr.w	r2, [r8]
    511e:	ldr	r2, [r2, #32]
    5120:	cmp	r2, r3
    5122:	bne.w	5898 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e0>
    5126:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    512a:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    512e:	cmp	r1, #0
    5130:	beq.n	51a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    5132:	ldr	r2, [r1, #16]
    5134:	subs	r2, #1
    5136:	str	r2, [r1, #16]
    5138:	cmp	r2, #0
    513a:	bne.n	51a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    513c:	ldr.w	r9, [r8, #16]
    5140:	cmp.w	r9, #0
    5144:	beq.n	51a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    5146:	ldr.w	r2, [r9]
    514a:	ldr	r2, [r2, #32]
    514c:	cmp	r2, r3
    514e:	bne.w	58c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa08>
    5152:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5156:	str.w	fp, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    515a:	cbz	r1, 51a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    515c:	ldr	r2, [r1, #16]
    515e:	subs	r2, #1
    5160:	str	r2, [r1, #16]
    5162:	cbnz	r2, 51a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    5164:	ldr.w	sl, [r9, #16]
    5168:	cmp.w	sl, #0
    516c:	beq.n	51a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    516e:	ldr.w	r2, [sl]
    5172:	ldr	r2, [r2, #32]
    5174:	cmp	r2, r3
    5176:	bne.w	58c6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa0e>
    517a:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    517e:	str.w	fp, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5182:	cbz	r2, 5198 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    5184:	ldr	r3, [r2, #16]
    5186:	subs	r3, #1
    5188:	str	r3, [r2, #16]
    518a:	cbnz	r3, 5198 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    518c:	ldr.w	r0, [sl, #16]
    5190:	cbz	r0, 5198 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    5192:	ldr	r3, [r0, #0]
    5194:	ldr	r3, [r3, #32]
    5196:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    5198:	mov	r0, sl
    519a:	movs	r1, #20
    519c:	bl	e960 <operator delete(void*, unsigned int)>
    51a0:	mov	r0, r9
    51a2:	movs	r1, #20
    51a4:	bl	e960 <operator delete(void*, unsigned int)>
    51a8:	mov	r0, r8
    51aa:	movs	r1, #20
    51ac:	bl	e960 <operator delete(void*, unsigned int)>
    51b0:	mov	r0, r7
    51b2:	movs	r1, #20
    51b4:	bl	e960 <operator delete(void*, unsigned int)>
    51b8:	mov	r0, r6
    51ba:	movs	r1, #20
    51bc:	bl	e960 <operator delete(void*, unsigned int)>
    51c0:	b.n	50a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    51c2:	mov	r0, r3
    51c4:	blx	r2
    51c6:	mov	r4, r0
    51c8:	b.n	4f6a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xb2>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    51ca:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    51ce:	ldr	r3, [r2, #16]
    51d0:	subs	r3, #1
    51d2:	str	r3, [r2, #16]
    51d4:	cmp	r3, #0
    51d6:	bne.n	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    51d8:	ldr	r4, [r5, #16]
    51da:	cmp	r4, #0
    51dc:	beq.n	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    51de:	ldr	r2, [r4, #0]
    51e0:	ldr	r3, [pc, #192]	; (52a4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ec>)
    51e2:	ldr	r2, [r2, #32]
    51e4:	cmp	r2, r3
    51e6:	bne.w	5872 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ba>
    51ea:	ldr	r1, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    51ec:	str.w	fp, [r4]
    51f0:	ldr	r0, [pc, #180]	; (52a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    51f2:	cmp	r1, #0
    51f4:	beq.n	527e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    51f6:	ldr	r2, [r1, #16]
    51f8:	subs	r2, #1
    51fa:	str	r2, [r1, #16]
    51fc:	cmp	r2, #0
    51fe:	bne.n	527e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    5200:	ldr	r5, [r4, #16]
    5202:	cmp	r5, #0
    5204:	beq.n	527e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    5206:	ldr	r2, [r5, #0]
    5208:	ldr	r2, [r2, #32]
    520a:	cmp	r2, r3
    520c:	bne.w	5888 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d0>
    5210:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5212:	str	r0, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5214:	cmp	r1, #0
    5216:	beq.n	5276 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    5218:	ldr	r2, [r1, #16]
    521a:	subs	r2, #1
    521c:	str	r2, [r1, #16]
    521e:	cbnz	r2, 5276 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    5220:	ldr	r6, [r5, #16]
    5222:	cbz	r6, 5276 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    5224:	ldr	r2, [r6, #0]
    5226:	ldr	r2, [r2, #32]
    5228:	cmp	r2, r3
    522a:	bne.w	58ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9f6>
    522e:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5230:	str.w	fp, [r6]
    5234:	ldr	r0, [pc, #112]	; (52a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5236:	cbz	r1, 526e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    5238:	ldr	r2, [r1, #16]
    523a:	subs	r2, #1
    523c:	str	r2, [r1, #16]
    523e:	cbnz	r2, 526e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    5240:	ldr	r7, [r6, #16]
    5242:	cbz	r7, 526e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    5244:	ldr	r2, [r7, #0]
    5246:	ldr	r2, [r2, #32]
    5248:	cmp	r2, r3
    524a:	bne.w	58b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9fc>
    524e:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5250:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5252:	cbz	r2, 5266 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    5254:	ldr	r3, [r2, #16]
    5256:	subs	r3, #1
    5258:	str	r3, [r2, #16]
    525a:	cbnz	r3, 5266 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    525c:	ldr	r0, [r7, #16]
    525e:	cbz	r0, 5266 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    5260:	ldr	r3, [r0, #0]
    5262:	ldr	r3, [r3, #32]
    5264:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    5266:	mov	r0, r7
    5268:	movs	r1, #20
    526a:	bl	e960 <operator delete(void*, unsigned int)>
    526e:	mov	r0, r6
    5270:	movs	r1, #20
    5272:	bl	e960 <operator delete(void*, unsigned int)>
    5276:	mov	r0, r5
    5278:	movs	r1, #20
    527a:	bl	e960 <operator delete(void*, unsigned int)>
    527e:	mov	r0, r4
    5280:	movs	r1, #20
    5282:	bl	e960 <operator delete(void*, unsigned int)>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    5286:	ldr.w	r0, [sl, #84]	; 0x54
    528a:	ldr	r1, [sp, #12]
    528c:	ldr	r3, [r0, #0]
    528e:	ldr	r3, [r3, #20]
    5290:	blx	r3
    5292:	ldr	r3, [sp, #56]	; 0x38
    5294:	mov	r4, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5296:	str.w	fp, [sp, #40]	; 0x28
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    529a:	cmp	r3, #0
    529c:	bne.w	507a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1c2>
    52a0:	b.n	50aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    52a2:	nop
    52a4:	.word	0x00000f25
    52a8:	.word	0x000141ec
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    52ac:	add	r5, sp, #60	; 0x3c
    52ae:	mov	r0, r5
    52b0:	movs	r2, #0
    52b2:	blx	r3
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    52b4:	ldr	r2, [r5, #16]
    52b6:	cmp	r2, #0
    52b8:	beq.n	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    52ba:	ldr	r3, [r2, #0]
    52bc:	ldr	r3, [r3, #68]	; 0x44
    52be:	cmp	r3, r6
    52c0:	bne.w	5804 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94c>
    52c4:	ldr	r0, [r2, #16]
    52c6:	cmp	r0, #0
    52c8:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    52cc:	ldr	r1, [r0, #0]
    52ce:	ldr	r1, [r1, #68]	; 0x44
    52d0:	cmp	r1, r6
    52d2:	bne.w	581a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x962>
    52d6:	ldr	r0, [r0, #16]
    52d8:	cmp	r0, #0
    52da:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    52de:	ldr	r3, [r0, #0]
    52e0:	ldr	r3, [r3, #68]	; 0x44
    52e2:	cmp	r3, r6
    52e4:	bne.w	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    52e8:	ldr	r0, [r0, #16]
    52ea:	cmp	r0, #0
    52ec:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    52f0:	ldr	r3, [r0, #0]
    52f2:	ldr	r3, [r3, #68]	; 0x44
    52f4:	cmp	r3, r6
    52f6:	bne.w	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    52fa:	ldr	r0, [r0, #16]
    52fc:	cmp	r0, #0
    52fe:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    5302:	ldr	r3, [r0, #0]
    5304:	ldr	r3, [r3, #68]	; 0x44
    5306:	cmp	r3, r6
    5308:	bne.w	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    530c:	ldr	r0, [r0, #16]
    530e:	cmp	r0, #0
    5310:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    5314:	ldr	r3, [r0, #0]
    5316:	ldr	r3, [r3, #68]	; 0x44
    5318:	cmp	r3, r6
    531a:	bne.w	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    531e:	ldr	r0, [r0, #16]
    5320:	cmp	r0, #0
    5322:	beq.w	51ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    5326:	ldr	r3, [r0, #0]
    5328:	ldr	r3, [r3, #68]	; 0x44
    532a:	blx	r3

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);

      File f2=f1.openNextFile();
      if(!f2) break;
    532c:	cmp	r0, #0
    532e:	beq.w	58de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa26>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    5332:	ldr	r0, [r5, #16]
    5334:	cmp	r0, #0
    5336:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    533a:	ldr	r2, [r0, #0]
    533c:	ldr	r3, [pc, #696]	; (55f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    533e:	ldr	r2, [r2, #72]	; 0x48
    5340:	cmp	r2, r3
    5342:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    5346:	ldr	r0, [r0, #16]
    5348:	cmp	r0, #0
    534a:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    534e:	ldr	r2, [r0, #0]
    5350:	ldr	r2, [r2, #72]	; 0x48
    5352:	cmp	r2, r3
    5354:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    5358:	ldr	r0, [r0, #16]
    535a:	cmp	r0, #0
    535c:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5360:	ldr	r2, [r0, #0]
    5362:	ldr	r2, [r2, #72]	; 0x48
    5364:	cmp	r2, r3
    5366:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    536a:	ldr	r0, [r0, #16]
    536c:	cmp	r0, #0
    536e:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5372:	ldr	r2, [r0, #0]
    5374:	ldr	r2, [r2, #72]	; 0x48
    5376:	cmp	r2, r3
    5378:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    537c:	ldr	r0, [r0, #16]
    537e:	cmp	r0, #0
    5380:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5384:	ldr	r2, [r0, #0]
    5386:	ldr	r2, [r2, #72]	; 0x48
    5388:	cmp	r2, r3
    538a:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    538e:	ldr	r0, [r0, #16]
    5390:	cmp	r0, #0
    5392:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5396:	ldr	r2, [r0, #0]
    5398:	ldr	r2, [r2, #72]	; 0x48
    539a:	cmp	r2, r3
    539c:	bne.w	580a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    53a0:	ldr	r0, [r0, #16]
    53a2:	cmp	r0, #0
    53a4:	beq.w	5800 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    53a8:	ldr	r3, [r0, #0]
    53aa:	ldr	r3, [r3, #72]	; 0x48
    53ac:	blx	r3
    53ae:	mov	r1, r0
      { // generate filenames
        strlcat(tmp0Name,f2.name(),MAX_FILENAME_LEN);
    53b0:	mov.w	r2, #256	; 0x100
    53b4:	add	r0, sp, #80	; 0x50
    53b6:	bl	10c8c <strlcat>
    53ba:	ldr	r0, [r5, #16]
    53bc:	cmp	r0, #0
    53be:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53c2:	ldr	r2, [r0, #0]
    53c4:	ldr	r3, [pc, #560]	; (55f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    53c6:	ldr	r2, [r2, #72]	; 0x48
    53c8:	cmp	r2, r3
    53ca:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    53ce:	ldr	r0, [r0, #16]
    53d0:	cmp	r0, #0
    53d2:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53d6:	ldr	r2, [r0, #0]
    53d8:	ldr	r2, [r2, #72]	; 0x48
    53da:	cmp	r2, r3
    53dc:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    53e0:	ldr	r0, [r0, #16]
    53e2:	cmp	r0, #0
    53e4:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53e8:	ldr	r2, [r0, #0]
    53ea:	ldr	r2, [r2, #72]	; 0x48
    53ec:	cmp	r2, r3
    53ee:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    53f2:	ldr	r0, [r0, #16]
    53f4:	cmp	r0, #0
    53f6:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53fa:	ldr	r2, [r0, #0]
    53fc:	ldr	r2, [r2, #72]	; 0x48
    53fe:	cmp	r2, r3
    5400:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    5404:	ldr	r0, [r0, #16]
    5406:	cmp	r0, #0
    5408:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    540c:	ldr	r2, [r0, #0]
    540e:	ldr	r2, [r2, #72]	; 0x48
    5410:	cmp	r2, r3
    5412:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    5416:	ldr	r0, [r0, #16]
    5418:	cmp	r0, #0
    541a:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    541e:	ldr	r2, [r0, #0]
    5420:	ldr	r2, [r2, #72]	; 0x48
    5422:	cmp	r2, r3
    5424:	bne.w	5814 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    5428:	ldr	r0, [r0, #16]
    542a:	cmp	r0, #0
    542c:	beq.w	57fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5430:	ldr	r3, [r0, #0]
    5432:	ldr	r3, [r3, #72]	; 0x48
    5434:	blx	r3
    5436:	mov	r1, r0
        strlcat(tmp1Name,f2.name(),MAX_FILENAME_LEN);
    5438:	mov.w	r2, #256	; 0x100
    543c:	mov	r0, r4
    543e:	bl	10c8c <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    5442:	ldr	r0, [r5, #16]
    5444:	cmp	r0, #0
    5446:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    544a:	ldr	r2, [r0, #0]
    544c:	ldr	r3, [pc, #428]	; (55fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x744>)
    544e:	ldr	r2, [r2, #76]	; 0x4c
    5450:	cmp	r2, r3
    5452:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    5456:	ldr	r0, [r0, #16]
    5458:	cmp	r0, #0
    545a:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    545e:	ldr	r2, [r0, #0]
    5460:	ldr	r2, [r2, #76]	; 0x4c
    5462:	cmp	r2, r3
    5464:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    5468:	ldr	r0, [r0, #16]
    546a:	cmp	r0, #0
    546c:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5470:	ldr	r2, [r0, #0]
    5472:	ldr	r2, [r2, #76]	; 0x4c
    5474:	cmp	r2, r3
    5476:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    547a:	ldr	r0, [r0, #16]
    547c:	cmp	r0, #0
    547e:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5482:	ldr	r2, [r0, #0]
    5484:	ldr	r2, [r2, #76]	; 0x4c
    5486:	cmp	r2, r3
    5488:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    548c:	ldr	r0, [r0, #16]
    548e:	cmp	r0, #0
    5490:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5494:	ldr	r2, [r0, #0]
    5496:	ldr	r2, [r2, #76]	; 0x4c
    5498:	cmp	r2, r3
    549a:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    549e:	ldr	r0, [r0, #16]
    54a0:	cmp	r0, #0
    54a2:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54a6:	ldr	r2, [r0, #0]
    54a8:	ldr	r2, [r2, #76]	; 0x4c
    54aa:	cmp	r2, r3
    54ac:	bne.w	5810 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    54b0:	ldr	r0, [r0, #16]
    54b2:	cmp	r0, #0
    54b4:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54b8:	ldr	r3, [r0, #0]
    54ba:	ldr	r3, [r3, #76]	; 0x4c
    54bc:	blx	r3

        if(f2.isDirectory())
    54be:	cmp	r0, #0
    54c0:	beq.w	56c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
        { 
          if(!sd_moveDir(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    54c4:	str	r4, [sp, #0]
    54c6:	ldr	r3, [sp, #8]
    54c8:	add	r2, sp, #80	; 0x50
    54ca:	mov	r1, r8
    54cc:	mov	r0, r9
    54ce:	bl	4e84 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    54d2:	cmp	r0, #0
    54d4:	beq.w	56fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    54d8:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    54da:	str.w	fp, [r5]
    54de:	ldr	r1, [pc, #288]	; (5600 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    54e0:	cmp	r2, #0
    54e2:	beq.w	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    54e6:	ldr	r3, [r2, #16]
    54e8:	subs	r3, #1
    54ea:	str	r3, [r2, #16]
    54ec:	cmp	r3, #0
    54ee:	bne.w	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    54f2:	ldr	r5, [r5, #16]
    54f4:	cmp	r5, #0
    54f6:	beq.w	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    54fa:	ldr	r2, [r5, #0]
    54fc:	ldr	r3, [pc, #260]	; (5604 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x74c>)
    54fe:	ldr	r2, [r2, #32]
    5500:	cmp	r2, r3
    5502:	bne.w	581e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x966>
    5506:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5508:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    550a:	cmp	r0, #0
    550c:	beq.w	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    5510:	ldr	r2, [r0, #16]
    5512:	subs	r2, #1
    5514:	str	r2, [r0, #16]
    5516:	cmp	r2, #0
    5518:	bne.w	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    551c:	ldr	r7, [r5, #16]
    551e:	cmp	r7, #0
    5520:	beq.w	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    5524:	ldr	r2, [r7, #0]
    5526:	ldr	r2, [r2, #32]
    5528:	cmp	r2, r3
    552a:	bne.w	5826 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x96e>
    552e:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5530:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5532:	cmp	r0, #0
    5534:	beq.w	56b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    5538:	ldr	r2, [r0, #16]
    553a:	subs	r2, #1
    553c:	str	r2, [r0, #16]
    553e:	cmp	r2, #0
    5540:	bne.w	56b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    5544:	ldr	r2, [r7, #16]
    5546:	cmp	r2, #0
    5548:	beq.w	56b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    554c:	ldr	r1, [r2, #0]
    554e:	ldr	r1, [r1, #32]
    5550:	cmp	r1, r3
    5552:	bne.w	5842 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x98a>
    5556:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    555a:	str.w	fp, [r2]
    555e:	ldr	r0, [pc, #160]	; (5600 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5560:	cmp.w	lr, #0
    5564:	beq.w	56ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5568:	ldr.w	r1, [lr, #16]
    556c:	subs	r1, #1
    556e:	str.w	r1, [lr, #16]
    5572:	cmp	r1, #0
    5574:	bne.w	56ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5578:	ldr	r1, [r2, #16]
    557a:	str	r1, [sp, #16]
    557c:	cmp	r1, #0
    557e:	beq.w	56ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5582:	ldr	r1, [sp, #16]
    5584:	ldr	r1, [r1, #0]
    5586:	ldr	r1, [r1, #32]
    5588:	cmp	r1, r3
    558a:	bne.w	5856 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x99e>
    558e:	ldr	r1, [sp, #16]
    5590:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5594:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5596:	cmp.w	lr, #0
    559a:	beq.w	56a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    559e:	ldr.w	r1, [lr, #16]
    55a2:	subs	r1, #1
    55a4:	str.w	r1, [lr, #16]
    55a8:	cmp	r1, #0
    55aa:	bne.n	56a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    55ac:	ldr	r1, [sp, #16]
    55ae:	ldr	r1, [r1, #16]
    55b0:	str	r1, [sp, #20]
    55b2:	cmp	r1, #0
    55b4:	beq.n	56a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    55b6:	ldr	r0, [sp, #20]
    55b8:	ldr	r1, [r0, #0]
    55ba:	ldr	r1, [r1, #32]
    55bc:	cmp	r1, r3
    55be:	bne.w	5878 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9c0>
    55c2:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    55c6:	str.w	fp, [r0]
    55ca:	ldr	r0, [pc, #52]	; (5600 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    55cc:	cmp.w	lr, #0
    55d0:	beq.n	5696 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    55d2:	ldr.w	r1, [lr, #16]
    55d6:	subs	r1, #1
    55d8:	str.w	r1, [lr, #16]
    55dc:	cmp	r1, #0
    55de:	bne.n	5696 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    55e0:	ldr	r1, [sp, #20]
    55e2:	ldr	r1, [r1, #16]
    55e4:	str	r1, [sp, #24]
    55e6:	cmp	r1, #0
    55e8:	beq.n	5696 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    55ea:	ldr	r1, [sp, #24]
    55ec:	ldr	r1, [r1, #0]
    55ee:	ldr	r1, [r1, #32]
    55f0:	cmp	r1, r3
    55f2:	bne.w	588e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d6>
    55f6:	b.n	5608 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x750>
    55f8:	.word	0x0000050d
    55fc:	.word	0x00000521
    5600:	.word	0x000141ec
    5604:	.word	0x00000f25
    5608:	ldr	r1, [sp, #24]
    560a:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    560e:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5610:	cmp.w	lr, #0
    5614:	beq.n	568a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    5616:	ldr.w	r1, [lr, #16]
    561a:	subs	r1, #1
    561c:	str.w	r1, [lr, #16]
    5620:	cmp	r1, #0
    5622:	bne.n	568a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    5624:	ldr	r1, [sp, #24]
    5626:	ldr	r1, [r1, #16]
    5628:	str	r1, [sp, #28]
    562a:	cbz	r1, 568a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    562c:	ldr	r1, [sp, #28]
    562e:	ldr	r1, [r1, #0]
    5630:	ldr	r1, [r1, #32]
    5632:	cmp	r1, r3
    5634:	bne.w	58a4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ec>
    5638:	ldr	r1, [sp, #28]
    563a:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    563e:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5640:	cmp.w	lr, #0
    5644:	beq.n	567e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    5646:	ldr.w	r1, [lr, #16]
    564a:	subs	r1, #1
    564c:	str.w	r1, [lr, #16]
    5650:	cbnz	r1, 567e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    5652:	ldr	r1, [sp, #28]
    5654:	ldr	r1, [r1, #16]
    5656:	cbz	r1, 567e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    5658:	ldr	r0, [r1, #0]
    565a:	ldr	r0, [r0, #32]
    565c:	cmp	r0, r3
    565e:	mov	lr, r0
    5660:	bne.w	58cc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa14>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5664:	mov	r0, r1
    5666:	str	r2, [sp, #36]	; 0x24
    5668:	str.w	fp, [r0], #16
    566c:	str	r1, [sp, #32]
		invalidate();
    566e:	bl	2088 <File::invalidate() [clone .isra.1]>
	}
    5672:	ldr	r1, [sp, #32]
    5674:	mov	r0, r1
    5676:	movs	r1, #20
    5678:	bl	e960 <operator delete(void*, unsigned int)>
    567c:	ldr	r2, [sp, #36]	; 0x24
    567e:	ldr	r0, [sp, #28]
    5680:	str	r2, [sp, #32]
    5682:	movs	r1, #20
    5684:	bl	e960 <operator delete(void*, unsigned int)>
    5688:	ldr	r2, [sp, #32]
    568a:	ldr	r0, [sp, #24]
    568c:	str	r2, [sp, #28]
    568e:	movs	r1, #20
    5690:	bl	e960 <operator delete(void*, unsigned int)>
    5694:	ldr	r2, [sp, #28]
    5696:	ldr	r0, [sp, #20]
    5698:	str	r2, [sp, #24]
    569a:	movs	r1, #20
    569c:	bl	e960 <operator delete(void*, unsigned int)>
    56a0:	ldr	r2, [sp, #24]
    56a2:	ldr	r0, [sp, #16]
    56a4:	str	r2, [sp, #20]
    56a6:	movs	r1, #20
    56a8:	bl	e960 <operator delete(void*, unsigned int)>
    56ac:	ldr	r2, [sp, #20]
    56ae:	mov	r0, r2
    56b0:	movs	r1, #20
    56b2:	bl	e960 <operator delete(void*, unsigned int)>
    56b6:	mov	r0, r7
    56b8:	movs	r1, #20
    56ba:	bl	e960 <operator delete(void*, unsigned int)>
    56be:	mov	r0, r5
    56c0:	movs	r1, #20
    56c2:	bl	e960 <operator delete(void*, unsigned int)>
    56c6:	b.n	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
        }
        else
        { 
          if(!sd_copy(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    56c8:	str	r4, [sp, #0]
    56ca:	ldr	r3, [sp, #8]
    56cc:	add	r2, sp, #80	; 0x50
    56ce:	mov	r1, r8
    56d0:	mov	r0, r9
    56d2:	bl	43d0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    56d6:	cbz	r0, 56fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    56d8:	add	r0, sp, #80	; 0x50
    56da:	bl	10d40 <strlen>
    56de:	mov	r1, r0
    56e0:	add	r0, sp, #80	; 0x50
    56e2:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    56e6:	ldr	r0, [pc, #524]	; (58f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa3c>)
    56e8:	bl	e7bc <Print::println()>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    56ec:	ldr.w	r0, [sl, #84]	; 0x54
    56f0:	ldr	r3, [r0, #0]
    56f2:	add	r1, sp, #80	; 0x50
    56f4:	ldr	r3, [r3, #16]
    56f6:	blx	r3
          if(!sd_remove(store0,tmp0Name)) {DBG_FAIL_MACRO; return false;}
    56f8:	cmp	r0, #0
    56fa:	bne.w	54d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x620>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    56fe:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5700:	str.w	fp, [r5]
    5704:	ldr	r1, [pc, #496]	; (58f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5706:	cmp	r2, #0
    5708:	beq.n	57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    570a:	ldr	r3, [r2, #16]
    570c:	subs	r3, #1
    570e:	str	r3, [r2, #16]
    5710:	cmp	r3, #0
    5712:	bne.n	57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    5714:	ldr	r4, [r5, #16]
    5716:	cmp	r4, #0
    5718:	beq.n	57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    571a:	ldr	r2, [r4, #0]
    571c:	ldr	r3, [pc, #476]	; (58fc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa44>)
    571e:	ldr	r2, [r2, #32]
    5720:	cmp	r2, r3
    5722:	bne.w	586c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9b4>
    5726:	ldr	r0, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5728:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    572a:	cmp	r0, #0
    572c:	beq.n	57ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    572e:	ldr	r2, [r0, #16]
    5730:	subs	r2, #1
    5732:	str	r2, [r0, #16]
    5734:	cmp	r2, #0
    5736:	bne.n	57ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    5738:	ldr	r5, [r4, #16]
    573a:	cmp	r5, #0
    573c:	beq.n	57ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    573e:	ldr	r2, [r5, #0]
    5740:	ldr	r2, [r2, #32]
    5742:	cmp	r2, r3
    5744:	bne.w	5860 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9a8>
    5748:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    574a:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    574c:	cmp	r0, #0
    574e:	beq.n	57e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    5750:	ldr	r2, [r0, #16]
    5752:	subs	r2, #1
    5754:	str	r2, [r0, #16]
    5756:	cmp	r2, #0
    5758:	bne.n	57e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    575a:	ldr	r6, [r5, #16]
    575c:	cmp	r6, #0
    575e:	beq.n	57e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    5760:	ldr	r2, [r6, #0]
    5762:	ldr	r2, [r2, #32]
    5764:	cmp	r2, r3
    5766:	bne.w	589e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e6>
    576a:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    576c:	str.w	fp, [r6]
    5770:	ldr	r0, [pc, #388]	; (58f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5772:	cmp	r1, #0
    5774:	beq.n	57de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    5776:	ldr	r2, [r1, #16]
    5778:	subs	r2, #1
    577a:	str	r2, [r1, #16]
    577c:	cbnz	r2, 57de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    577e:	ldr	r7, [r6, #16]
    5780:	cbz	r7, 57de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    5782:	ldr	r2, [r7, #0]
    5784:	ldr	r2, [r2, #32]
    5786:	cmp	r2, r3
    5788:	bne.w	58ba <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa02>
    578c:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    578e:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5790:	cbz	r1, 57d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    5792:	ldr	r2, [r1, #16]
    5794:	subs	r2, #1
    5796:	str	r2, [r1, #16]
    5798:	cbnz	r2, 57d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    579a:	ldr.w	r8, [r7, #16]
    579e:	cmp.w	r8, #0
    57a2:	beq.n	57d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    57a4:	ldr.w	r2, [r8]
    57a8:	ldr	r2, [r2, #32]
    57aa:	cmp	r2, r3
    57ac:	bne.w	58d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa20>
    57b0:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    57b4:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    57b8:	cbz	r2, 57ce <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57ba:	ldr	r3, [r2, #16]
    57bc:	subs	r3, #1
    57be:	str	r3, [r2, #16]
    57c0:	cbnz	r3, 57ce <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57c2:	ldr.w	r0, [r8, #16]
    57c6:	cbz	r0, 57ce <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57c8:	ldr	r3, [r0, #0]
    57ca:	ldr	r3, [r3, #32]
    57cc:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    57ce:	mov	r0, r8
    57d0:	movs	r1, #20
    57d2:	bl	e960 <operator delete(void*, unsigned int)>
    57d6:	mov	r0, r7
    57d8:	movs	r1, #20
    57da:	bl	e960 <operator delete(void*, unsigned int)>
    57de:	mov	r0, r6
    57e0:	movs	r1, #20
    57e2:	bl	e960 <operator delete(void*, unsigned int)>
    57e6:	mov	r0, r5
    57e8:	movs	r1, #20
    57ea:	bl	e960 <operator delete(void*, unsigned int)>
    57ee:	mov	r0, r4
    57f0:	movs	r1, #20
    57f2:	bl	e960 <operator delete(void*, unsigned int)>
    57f6:	ldr	r3, [sp, #56]	; 0x38
    57f8:	movs	r4, #0
    57fa:	b.n	5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    57fc:	ldr	r1, [pc, #256]	; (5900 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    57fe:	b.n	5438 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
    5800:	ldr	r1, [pc, #252]	; (5900 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    5802:	b.n	53b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    5804:	mov	r0, r2
    5806:	blx	r3
    5808:	b.n	532c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    580a:	blx	r2
    580c:	mov	r1, r0
    580e:	b.n	53b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    5810:	blx	r2
    5812:	b.n	54be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x606>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    5814:	blx	r2
    5816:	mov	r1, r0
    5818:	b.n	5438 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    581a:	blx	r1
    581c:	b.n	532c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    581e:	mov	r0, r5
    5820:	blx	r2
    5822:	b.w	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    5826:	mov	r0, r7
    5828:	blx	r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    582a:	mov	r0, r5
    582c:	movs	r1, #20
    582e:	bl	e960 <operator delete(void*, unsigned int)>
    5832:	b.w	4f76 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    5836:	mov	r4, r3
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    5838:	mov	r0, r4
    583a:	add.w	sp, sp, #596	; 0x254
    583e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5842:	mov	r0, r2
    5844:	blx	r1
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    5846:	mov	r0, r7
    5848:	movs	r1, #20
    584a:	bl	e960 <operator delete(void*, unsigned int)>
    584e:	b.n	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5850:	mov	r0, r5
    5852:	blx	r2
    5854:	b.n	50aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    5856:	str	r2, [sp, #20]
    5858:	ldr	r0, [sp, #16]
    585a:	blx	r1
    585c:	ldr	r2, [sp, #20]
    585e:	b.n	56ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5860:	mov	r0, r5
    5862:	blx	r2
    5864:	b.n	57ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    5866:	mov	r0, r6
    5868:	blx	r2
    586a:	b.n	50a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    586c:	mov	r0, r4
    586e:	blx	r2
    5870:	b.n	57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    5872:	mov	r0, r4
    5874:	blx	r2
    5876:	b.n	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5878:	str	r2, [sp, #24]
    587a:	ldr	r0, [sp, #20]
    587c:	blx	r1
    587e:	ldr	r2, [sp, #24]
    5880:	b.n	56a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    5882:	mov	r0, r7
    5884:	blx	r2
    5886:	b.n	51b8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    5888:	mov	r0, r5
    588a:	blx	r2
    588c:	b.n	527e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    588e:	str	r2, [sp, #28]
    5890:	ldr	r0, [sp, #24]
    5892:	blx	r1
    5894:	ldr	r2, [sp, #28]
    5896:	b.n	5696 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    5898:	mov	r0, r8
    589a:	blx	r2
    589c:	b.n	51b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    589e:	mov	r0, r6
    58a0:	blx	r2
    58a2:	b.n	57e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    58a4:	str	r2, [sp, #32]
    58a6:	ldr	r0, [sp, #28]
    58a8:	blx	r1
    58aa:	ldr	r2, [sp, #32]
    58ac:	b.n	568a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    58ae:	mov	r0, r6
    58b0:	blx	r2
    58b2:	b.n	5276 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    58b4:	mov	r0, r7
    58b6:	blx	r2
    58b8:	b.n	526e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    58ba:	mov	r0, r7
    58bc:	blx	r2
    58be:	b.n	57de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    58c0:	mov	r0, r9
    58c2:	blx	r2
    58c4:	b.n	51a8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    58c6:	mov	r0, sl
    58c8:	blx	r2
    58ca:	b.n	51a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    58cc:	str	r2, [sp, #32]
    58ce:	mov	r0, r1
    58d0:	mov	r3, lr
    58d2:	blx	r3
    58d4:	ldr	r2, [sp, #32]
    58d6:	b.n	567e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    58d8:	mov	r0, r8
    58da:	blx	r2
    58dc:	b.n	57d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    58de:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    58e0:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    58e4:	cmp	r2, #0
    58e6:	beq.w	5286 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    58ea:	b.n	51ce <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x316>
    58ec:	ldr	r3, [sp, #56]	; 0x38
    58ee:	ldr.w	fp, [pc, #8]	; 58f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>
    58f2:	b.n	5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
    58f4:	.word	0x1fff8d50
    58f8:	.word	0x000141ec
    58fc:	.word	0x00000f25
    5900:	.word	0x000143a8

00005904 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)>:
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    5904:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5908:	mov	r6, r1
    590a:	subw	sp, sp, #2696	; 0xa88
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0
    590e:	cmp.w	r3, #4294967295
    5912:	ite	ne
    5914:	movne	r7, r3
    5916:	moveq	r7, r2
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    5918:	mov	r4, r0
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0

    Record p1 = ReadIndexRecord(handle);
    591a:	mov	r1, r0
    591c:	mov	r2, r6
    591e:	add	r0, sp, #792	; 0x318
    5920:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    5924:	mov	r2, r7
    5926:	mov	r1, r4
    5928:	add.w	r0, sp, #1064	; 0x428
    592c:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p3 = ReadIndexRecord(p1.parent); 
    5930:	ldr	r2, [sp, #792]	; 0x318
    5932:	mov	r1, r4
    5934:	add.w	r0, sp, #1336	; 0x538
    5938:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    if(p1.isdir) 
    593c:	ldrb.w	r3, [sp, #804]	; 0x324
    5940:	cbz	r3, 594c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
    { if(!p1.scanned) 
    5942:	ldrb.w	r3, [sp, #805]	; 0x325
    5946:	cmp	r3, #0
    5948:	beq.w	5af8 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1f4>
      { ScanDir(p1.store, handle) ; // in case scan directory
        WriteIndexRecord(handle, p1);
      }
    }

    Record p1o = p1;
    594c:	mov.w	r2, #272	; 0x110
    5950:	add	r1, sp, #792	; 0x318
    5952:	add.w	r0, sp, #1608	; 0x648
    5956:	bl	cb10 <memcpy>
    Record p2o = p2;
    595a:	mov.w	r2, #272	; 0x110
    595e:	add.w	r1, sp, #1064	; 0x428
    5962:	add.w	r0, sp, #1880	; 0x758
    5966:	bl	cb10 <memcpy>
    Record p3o = p3;

    char oldName[MAX_FILENAME_LEN];
    ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    596a:	add	r2, sp, #280	; 0x118
    596c:	mov.w	r3, #256	; 0x100
    5970:	mov	r1, r6
    5972:	mov	r0, r4
    5974:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    uint32_t jx=-1;
    Record pxo;

      // remove index from old parent
      Record px;
      if(p3.child==handle)
    5978:	ldr.w	r8, [sp, #1340]	; 0x53c
    597c:	cmp	r6, r8
    597e:	beq.w	5abe <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1ba>
        p3.child = p1.sibling;
        WriteIndexRecord(p1.parent, p3);    
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
    5982:	add	r0, sp, #8
    5984:	mov	r2, r8
    5986:	mov	r1, r4
    5988:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    598c:	add	r1, sp, #8
    598e:	mov.w	r2, #272	; 0x110
    5992:	addw	r0, sp, #2424	; 0x978
    5996:	bl	cb10 <memcpy>
        pxo = px;
    599a:	addw	r1, sp, #2424	; 0x978
    599e:	addw	r0, sp, #2152	; 0x868
    59a2:	mov.w	r2, #272	; 0x110
    59a6:	bl	cb10 <memcpy>
        while(handle != px.sibling)
    59aa:	ldr.w	r5, [sp, #2432]	; 0x980
    59ae:	cmp	r6, r5
    59b0:	bne.n	59b6 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb2>
    59b2:	b.n	5b10 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x20c>
    59b4:	mov	r5, r3
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
    59b6:	mov	r2, r5
    59b8:	mov	r1, r4
    59ba:	add	r0, sp, #8
    59bc:	bl	26a0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    59c0:	mov.w	r2, #272	; 0x110
    59c4:	add	r1, sp, #8
    59c6:	addw	r0, sp, #2424	; 0x978
    59ca:	bl	cb10 <memcpy>
          pxo = px;
    59ce:	mov.w	r2, #272	; 0x110
    59d2:	addw	r1, sp, #2424	; 0x978
    59d6:	addw	r0, sp, #2152	; 0x868
    59da:	bl	cb10 <memcpy>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    59de:	ldr.w	r3, [sp, #2432]	; 0x980
    59e2:	cmp	r6, r3
    59e4:	bne.n	59b4 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb0>
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
          pxo = px;
        }
        px.sibling = p1.sibling;
    59e6:	ldr	r3, [sp, #800]	; 0x320
    59e8:	str.w	r3, [sp, #2432]	; 0x980
        WriteIndexRecord(jx, px);
    59ec:	addw	r2, sp, #2424	; 0x978
    59f0:	mov	r1, r5
    59f2:	mov	r0, r4
    59f4:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    59f8:	ldrh.w	r0, [sp, #1078]	; 0x436
      p1.sibling = p2.child;
    59fc:	ldr.w	r3, [sp, #1068]	; 0x42c
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    5a00:	strh.w	r0, [sp, #806]	; 0x326
      p1.sibling = p2.child;
      p2.child = handle;
      WriteIndexRecord(handle, p1);
    5a04:	add	r2, sp, #792	; 0x318
    5a06:	mov	r1, r6
    5a08:	mov	r0, r4
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
      p1.sibling = p2.child;
    5a0a:	str	r3, [sp, #800]	; 0x320
        px.sibling = p1.sibling;
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
    5a0c:	str	r7, [sp, #792]	; 0x318
      p1.store = p2.store;
      p1.sibling = p2.child;
      p2.child = handle;
    5a0e:	str.w	r6, [sp, #1068]	; 0x42c
      WriteIndexRecord(handle, p1);
    5a12:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      WriteIndexRecord(newParent,p2);
    5a16:	add.w	r2, sp, #1064	; 0x428
    5a1a:	mov	r1, r7
    5a1c:	mov	r0, r4
    5a1e:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      // now working on disk storage
      char newName[MAX_FILENAME_LEN];
      ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    5a22:	mov.w	r3, #256	; 0x100
    5a26:	mov	r1, r6
    5a28:	add	r2, sp, #536	; 0x218
    5a2a:	mov	r0, r4
    5a2c:	bl	2b00 <MTPStorage_SD::ConstructFilename(int, char*, int)>
        Serial.print(p1.store); Serial.print(": ");Serial.println(newName);
        dumpIndexList();
      #endif


    if(p1o.store == p2o.store)
    5a30:	ldrh.w	r1, [sp, #1622]	; 0x656
    5a34:	ldrh.w	r3, [sp, #1894]	; 0x766
    5a38:	cmp	r1, r3
    5a3a:	beq.n	5ad6 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1d2>
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    5a3c:	ldrb.w	r2, [sp, #1620]	; 0x654
    5a40:	cbz	r2, 5a84 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x180>
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    }
    else
    { // move directory cross mtp-disks
      if(sd_moveDir(p1o.store,oldName,p2o.store,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    5a42:	add	r2, sp, #536	; 0x218
    5a44:	str	r2, [sp, #0]
    5a46:	adds	r0, r4, #4
    5a48:	add	r2, sp, #280	; 0x118
    5a4a:	bl	4e84 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    5a4e:	cmp	r0, #0
    5a50:	bne.n	5aea <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1e6>
    }

  fail:
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    5a52:	mov	r1, r5
    5a54:	addw	r2, sp, #2152	; 0x868
    5a58:	mov	r0, r4
    5a5a:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(handle, p1o);
    5a5e:	add.w	r2, sp, #1608	; 0x648
    5a62:	mov	r1, r6
    5a64:	mov	r0, r4
    5a66:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(newParent,p2o);      
    5a6a:	add.w	r2, sp, #1880	; 0x758
    5a6e:	mov	r1, r7
    5a70:	mov	r0, r4
    5a72:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
    5a76:	mov.w	r8, #0
  }
    5a7a:	mov	r0, r8
    5a7c:	addw	sp, sp, #2696	; 0xa88
    5a80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
    5a84:	add	r2, sp, #536	; 0x218
    5a86:	str	r2, [sp, #0]
    5a88:	adds	r0, r4, #4
    5a8a:	add	r2, sp, #280	; 0x118
    5a8c:	bl	43d0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    5a90:	mov	r8, r0
    5a92:	cmp	r0, #0
    5a94:	beq.n	5a52 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    5a96:	add	r0, sp, #280	; 0x118
    5a98:	bl	10d40 <strlen>
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    5a9c:	ldrh.w	r5, [sp, #1894]	; 0x766
    5aa0:	mov	r1, r0
    5aa2:	add.w	r4, r4, r5, lsl #2
    5aa6:	add	r0, sp, #280	; 0x118
    5aa8:	bl	cd84 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    5aac:	ldr	r0, [pc, #100]	; (5b14 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x210>)
    5aae:	bl	e7bc <Print::println()>
    5ab2:	ldr	r0, [r4, #88]	; 0x58
    5ab4:	ldr	r3, [r0, #0]
    5ab6:	add	r1, sp, #280	; 0x118
    5ab8:	ldr	r3, [r3, #16]
    5aba:	blx	r3
    5abc:	b.n	5a7a <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x176>

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    5abe:	ldr	r3, [sp, #800]	; 0x320
        WriteIndexRecord(p1.parent, p3);    
    5ac0:	ldr	r1, [sp, #792]	; 0x318

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    5ac2:	str.w	r3, [sp, #1340]	; 0x53c
        WriteIndexRecord(p1.parent, p3);    
    5ac6:	add.w	r2, sp, #1336	; 0x538
    5aca:	mov	r0, r4
    5acc:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    #if DEBUG>1
      Serial.print(p1.store); Serial.print(": "); Serial.println(oldName);
      dumpIndexList();
    #endif

    uint32_t jx=-1;
    5ad0:	mov.w	r5, #4294967295
    5ad4:	b.n	59f8 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xf4>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    5ad6:	add.w	r1, r4, r1, lsl #2
    5ada:	add	r2, sp, #536	; 0x218
    5adc:	ldr	r0, [r1, #88]	; 0x58
    5ade:	ldr	r3, [r0, #0]
    5ae0:	add	r1, sp, #280	; 0x118
    5ae2:	ldr	r3, [r3, #12]
    5ae4:	blx	r3
      #endif


    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    5ae6:	cmp	r0, #0
    5ae8:	beq.n	5a52 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
    5aea:	mov.w	r8, #1
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    WriteIndexRecord(handle, p1o);
    WriteIndexRecord(newParent,p2o);      
    return false;
  }
    5aee:	mov	r0, r8
    5af0:	addw	sp, sp, #2696	; 0xa88
    5af4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);
    Record p3 = ReadIndexRecord(p1.parent); 

    if(p1.isdir) 
    { if(!p1.scanned) 
      { ScanDir(p1.store, handle) ; // in case scan directory
    5af8:	mov	r2, r6
    5afa:	ldrh.w	r1, [sp, #806]	; 0x326
    5afe:	mov	r0, r4
    5b00:	bl	328c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
        WriteIndexRecord(handle, p1);
    5b04:	add	r2, sp, #792	; 0x318
    5b06:	mov	r1, r6
    5b08:	mov	r0, r4
    5b0a:	bl	24c0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    5b0e:	b.n	594c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    5b10:	mov	r5, r8
    5b12:	b.n	59e6 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xe2>
    5b14:	.word	0x1fff8d50

00005b18 <MTPD::GetNumObjects(unsigned long, unsigned long)>:

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5b18:	push	{r4, r5, r6, lr}
    5b1a:	mov	r6, r0
    storage_->StartGetObjectHandles(store, parent);
    5b1c:	ldr	r0, [r0, #0]
    5b1e:	ldr	r3, [r0, #0]

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5b20:	subs	r5, r1, #1
    storage_->StartGetObjectHandles(store, parent);
    5b22:	ldr	r3, [r3, #28]
    5b24:	mov	r1, r5
    5b26:	blx	r3
    int num = 0;
    5b28:	movs	r4, #0
    5b2a:	b.n	5b2e <MTPD::GetNumObjects(unsigned long, unsigned long)+0x16>
    while (storage_->GetNextObjectHandle(store)) num++;
    5b2c:	adds	r4, #1
    5b2e:	ldr	r0, [r6, #0]
    5b30:	ldr	r3, [r0, #0]
    5b32:	mov	r1, r5
    5b34:	ldr	r3, [r3, #32]
    5b36:	blx	r3
    5b38:	cmp	r0, #0
    5b3a:	bne.n	5b2c <MTPD::GetNumObjects(unsigned long, unsigned long)+0x14>
    return num;
  }
    5b3c:	mov	r0, r4
    5b3e:	pop	{r4, r5, r6, pc}

00005b40 <MTPD::get_buffer()>:


#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

//  usb_packet_t *data_buffer_ = NULL;
  void MTPD::get_buffer() {
    5b40:	push	{r4, lr}
    5b42:	mov	r4, r0
    5b44:	ldr	r0, [r4, #4]
    while (!data_buffer_) {
    5b46:	cbnz	r0, 5b50 <MTPD::get_buffer()+0x10>
      data_buffer_ = usb_malloc();
    5b48:	bl	d984 <usb_malloc>
    5b4c:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    5b4e:	cbz	r0, 5b52 <MTPD::get_buffer()+0x12>
    5b50:	pop	{r4, pc}
    5b52:	bl	2128 <mtp_yield()>
    5b56:	b.n	5b44 <MTPD::get_buffer()+0x4>

00005b58 <MTPD::write(char const*, int) [clone .part.2]>:
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b58:	cmp	r2, #0
    5b5a:	ble.n	5bba <MTPD::write(char const*, int) [clone .part.2]+0x62>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    5b5c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b60:	mov.w	r9, #0
    5b64:	mov	r6, r2
    5b66:	mov	r7, r1
    5b68:	mov	r5, r0
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    5b6a:	mov	r8, r9
    5b6c:	b.n	5b72 <MTPD::write(char const*, int) [clone .part.2]+0x1a>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b6e:	cmp	r6, r9
    5b70:	ble.n	5bb6 <MTPD::write(char const*, int) [clone .part.2]+0x5e>
        get_buffer();
    5b72:	mov	r0, r5
    5b74:	bl	5b40 <MTPD::get_buffer()>
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    5b78:	ldr	r3, [r5, #4]
    5b7a:	ldrh.w	r0, [r3], #8
    5b7e:	rsb	r2, r9, r6
    5b82:	rsb	r4, r0, #64	; 0x40
    5b86:	cmp	r4, r2
    5b88:	it	ge
    5b8a:	movge	r4, r2
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
    5b8c:	add.w	r1, r7, r9
    5b90:	add	r0, r3
    5b92:	mov	r2, r4
    5b94:	bl	cb10 <memcpy>
        data_buffer_->len += to_copy;
    5b98:	ldr	r1, [r5, #4]
    5b9a:	ldrh	r3, [r1, #0]
    5b9c:	add	r3, r4
    5b9e:	uxth	r3, r3
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    5ba0:	cmp	r3, #64	; 0x40
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
    5ba2:	add	r9, r4
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
    5ba4:	strh	r3, [r1, #0]
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    5ba6:	bne.n	5b6e <MTPD::write(char const*, int) [clone .part.2]+0x16>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    5ba8:	movs	r0, #4
    5baa:	bl	dafc <usb_tx>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5bae:	cmp	r6, r9
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    5bb0:	str.w	r8, [r5, #4]
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5bb4:	bgt.n	5b72 <MTPD::write(char const*, int) [clone .part.2]+0x1a>
    5bb6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5bba:	bx	lr

00005bbc <MTPD::writestring(char const*)>:
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    5bbc:	push	{r4, r5, lr}
    if (*str) 
    5bbe:	ldrb	r3, [r1, #0]
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    5bc0:	sub	sp, #12
    5bc2:	mov	r4, r0
    if (*str) 
    5bc4:	cbz	r3, 5c20 <MTPD::writestring(char const*)+0x64>
    { write8(strlen(str) + 1);
    5bc6:	mov	r0, r1
    5bc8:	mov	r5, r1
    5bca:	bl	10d40 <strlen>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5bce:	ldrb	r1, [r4, #8]
    5bd0:	adds	r0, #1
    5bd2:	strb.w	r0, [sp, #3]
    5bd6:	cbz	r1, 5c32 <MTPD::writestring(char const*)+0x76>
      write_length_ += len;
    5bd8:	ldr	r3, [r4, #12]
    5bda:	adds	r3, #1
    5bdc:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5bde:	ldrb	r2, [r5, #0]
    5be0:	cbnz	r2, 5bf0 <MTPD::writestring(char const*)+0x34>
    5be2:	b.n	5c18 <MTPD::writestring(char const*)+0x5c>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5be4:	ldr	r3, [r4, #12]
    5be6:	adds	r3, #2
    5be8:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5bea:	ldrb.w	r2, [r5, #1]!
    5bee:	cbz	r2, 5c0e <MTPD::writestring(char const*)+0x52>
    5bf0:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5bf4:	cmp	r1, #0
    5bf6:	bne.n	5be4 <MTPD::writestring(char const*)+0x28>
    5bf8:	movs	r2, #2
    5bfa:	add.w	r1, sp, #6
    5bfe:	mov	r0, r4
    5c00:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c04:	ldrb.w	r2, [r5, #1]!
    5c08:	ldrb	r1, [r4, #8]
    5c0a:	cmp	r2, #0
    5c0c:	bne.n	5bf0 <MTPD::writestring(char const*)+0x34>
    5c0e:	movs	r3, #0
    5c10:	strh.w	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c14:	cbz	r1, 5c56 <MTPD::writestring(char const*)+0x9a>
    5c16:	ldr	r3, [r4, #12]
      write_length_ += len;
    5c18:	adds	r3, #2
    5c1a:	str	r3, [r4, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    5c1c:	add	sp, #12
    5c1e:	pop	{r4, r5, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c20:	ldrb	r2, [r0, #8]
    5c22:	strb.w	r3, [sp, #2]
    5c26:	cbz	r2, 5c48 <MTPD::writestring(char const*)+0x8c>
      write_length_ += len;
    5c28:	ldr	r3, [r0, #12]
    5c2a:	adds	r3, #1
    5c2c:	str	r3, [r0, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    5c2e:	add	sp, #12
    5c30:	pop	{r4, r5, pc}
    5c32:	movs	r2, #1
    5c34:	add.w	r1, sp, #3
    5c38:	mov	r0, r4
    5c3a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c3e:	ldrb	r2, [r5, #0]
    5c40:	ldrb	r1, [r4, #8]
    5c42:	cmp	r2, #0
    5c44:	bne.n	5bf0 <MTPD::writestring(char const*)+0x34>
    5c46:	b.n	5c0e <MTPD::writestring(char const*)+0x52>
    5c48:	movs	r2, #1
    5c4a:	add.w	r1, sp, #2
    5c4e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    } else 
    { write8(0);
    }
  }
    5c52:	add	sp, #12
    5c54:	pop	{r4, r5, pc}
    5c56:	mov	r0, r4
    5c58:	movs	r2, #2
    5c5a:	add	r1, sp, #4
    5c5c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5c60:	add	sp, #12
    5c62:	pop	{r4, r5, pc}

00005c64 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>:
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5c64:	push	{r4, r5, r6, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c66:	ldrb	r3, [r0, #8]
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5c68:	sub	sp, #8
    5c6a:	mov	r4, r0
    5c6c:	mov	r5, r1
    5c6e:	strh.w	r1, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c72:	cbz	r3, 5cac <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x48>
      write_length_ += len;
    5c74:	ldr	r3, [r0, #12]
    5c76:	movw	r2, #65535	; 0xffff
    5c7a:	adds	r3, #2
    5c7c:	str	r3, [r0, #12]
    5c7e:	strh.w	r2, [sp, #6]
    5c82:	adds	r3, #2
    5c84:	movs	r2, #0
    5c86:	str	r3, [r4, #12]
    5c88:	strb.w	r2, [sp, #2]
    5c8c:	adds	r3, #1
    5c8e:	str	r3, [r4, #12]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5c90:	movw	r3, #54274	; 0xd402
    5c94:	cmp	r5, r3
    5c96:	beq.n	5ce8 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x84>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c98:	ldrb	r3, [r4, #8]
    5c9a:	movs	r2, #0
    5c9c:	strb.w	r2, [sp, #3]
    5ca0:	cbz	r3, 5d04 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xa0>
      write_length_ += len;
    5ca2:	ldr	r3, [r4, #12]
    5ca4:	adds	r3, #1
    5ca6:	str	r3, [r4, #12]
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    5ca8:	add	sp, #8
    5caa:	pop	{r4, r5, r6, pc}
    5cac:	movs	r2, #2
    5cae:	add	r1, sp, #4
    5cb0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5cb4:	ldrb	r6, [r4, #8]
    5cb6:	movw	r3, #65535	; 0xffff
    5cba:	strh.w	r3, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5cbe:	cbnz	r6, 5d14 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb0>
    5cc0:	movs	r2, #2
    5cc2:	add.w	r1, sp, #6
    5cc6:	mov	r0, r4
    5cc8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5ccc:	ldrb	r3, [r4, #8]
    5cce:	strb.w	r6, [sp, #2]
    5cd2:	cbnz	r3, 5d18 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb4>
    5cd4:	movs	r2, #1
    5cd6:	add.w	r1, sp, #2
    5cda:	mov	r0, r4
    5cdc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5ce0:	movw	r3, #54274	; 0xd402
    5ce4:	cmp	r5, r3
    5ce6:	bne.n	5c98 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x34>
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5ce8:	ldr	r1, [pc, #48]	; (5d1c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    5cea:	mov	r0, r4
    5cec:	bl	5bbc <MTPD::writestring(char const*)>
    5cf0:	ldr	r1, [pc, #40]	; (5d1c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    5cf2:	mov	r0, r4
    5cf4:	bl	5bbc <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5cf8:	ldrb	r3, [r4, #8]
    5cfa:	movs	r2, #0
    5cfc:	strb.w	r2, [sp, #3]
    5d00:	cmp	r3, #0
    5d02:	bne.n	5ca2 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x3e>
    5d04:	mov	r0, r4
    5d06:	movs	r2, #1
    5d08:	add.w	r1, sp, #3
    5d0c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    5d10:	add	sp, #8
    5d12:	pop	{r4, r5, r6, pc}
    5d14:	ldr	r3, [r4, #12]
    5d16:	b.n	5c82 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x1e>
    5d18:	ldr	r3, [r4, #12]
    5d1a:	b.n	5c8c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x28>
    5d1c:	.word	0x00014544

00005d20 <MTPD::WriteDescriptor()>:
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5d20:	push	{r4, r5, r6, r7, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d22:	ldrb	r3, [r0, #8]
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5d24:	sub	sp, #68	; 0x44
    5d26:	movs	r5, #100	; 0x64
    5d28:	mov	r4, r0
    5d2a:	strh.w	r5, [sp, #8]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d2e:	cmp	r3, #0
    5d30:	beq.w	5e7e <MTPD::WriteDescriptor()+0x15e>
      write_length_ += len;
    5d34:	ldr	r3, [r0, #12]
    5d36:	movs	r2, #6
    5d38:	adds	r3, #2
    5d3a:	str	r3, [r0, #12]
    5d3c:	str	r2, [sp, #24]
    5d3e:	adds	r3, #4
    5d40:	movs	r2, #100	; 0x64
    5d42:	str	r3, [r4, #12]
    5d44:	strh.w	r2, [sp, #6]
    5d48:	adds	r3, #2
    5d4a:	str	r3, [r4, #12]
  void MTPD::WriteDescriptor() {
    write16(100);  // MTP version
    write32(6);    // MTP extension
//    write32(0xFFFFFFFFUL);    // MTP extension
    write16(100);  // MTP version
    writestring("microsoft.com: 1.0;");
    5d4c:	ldr	r1, [pc, #552]	; (5f78 <MTPD::WriteDescriptor()+0x258>)
    5d4e:	mov	r0, r4
    5d50:	bl	5bbc <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d54:	ldrb	r3, [r4, #8]
    5d56:	movs	r2, #0
    5d58:	strh.w	r2, [sp, #4]
    5d5c:	cmp	r3, #0
    5d5e:	beq.w	5f38 <MTPD::WriteDescriptor()+0x218>
      write_length_ += len;
    5d62:	ldr	r3, [r4, #12]
    5d64:	movs	r2, #20
    5d66:	adds	r3, #2
    5d68:	str	r3, [r4, #12]
    5d6a:	str	r2, [sp, #20]
    5d6c:	adds	r3, #4
    5d6e:	str	r3, [r4, #12]
    5d70:	movs	r6, #1
    5d72:	ldr	r5, [pc, #520]	; (5f7c <MTPD::WriteDescriptor()+0x25c>)
    5d74:	movw	r3, #4097	; 0x1001
    5d78:	add.w	r7, r5, #38	; 0x26
    5d7c:	b.n	5d8e <MTPD::WriteDescriptor()+0x6e>
    5d7e:	ldr	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5d80:	cmp	r5, r7
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5d82:	add.w	r3, r3, #2
    5d86:	str	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5d88:	beq.n	5da8 <MTPD::WriteDescriptor()+0x88>
    5d8a:	ldrh.w	r3, [r5, #2]!
    5d8e:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d92:	cmp	r6, #0
    5d94:	bne.n	5d7e <MTPD::WriteDescriptor()+0x5e>
    5d96:	movs	r2, #2
    5d98:	add.w	r1, sp, #10
    5d9c:	mov	r0, r4
    5d9e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5da2:	cmp	r5, r7
    5da4:	ldrb	r6, [r4, #8]
    5da6:	bne.n	5d8a <MTPD::WriteDescriptor()+0x6a>
    5da8:	movs	r2, #4
    5daa:	str	r2, [sp, #28]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dac:	cmp	r6, #0
    5dae:	beq.w	5f2c <MTPD::WriteDescriptor()+0x20c>
      write_length_ += len;
    5db2:	ldr	r3, [r4, #12]
    5db4:	adds	r3, #4
    5db6:	str	r3, [r4, #12]
    5db8:	ldr	r5, [pc, #452]	; (5f80 <MTPD::WriteDescriptor()+0x260>)
    5dba:	movw	r3, #16388	; 0x4004
    5dbe:	adds	r7, r5, #6
    5dc0:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dc4:	cbz	r6, 5dde <MTPD::WriteDescriptor()+0xbe>
      write_length_ += len;
    5dc6:	ldr	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5dc8:	cmp	r7, r5
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5dca:	add.w	r3, r3, #2
    5dce:	str	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5dd0:	beq.n	5dee <MTPD::WriteDescriptor()+0xce>
    5dd2:	ldrh.w	r3, [r5, #2]!
    5dd6:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dda:	cmp	r6, #0
    5ddc:	bne.n	5dc6 <MTPD::WriteDescriptor()+0xa6>
    5dde:	movs	r2, #2
    5de0:	add	r1, sp, #12
    5de2:	mov	r0, r4
    5de4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5de8:	cmp	r7, r5
    5dea:	ldrb	r6, [r4, #8]
    5dec:	bne.n	5dd2 <MTPD::WriteDescriptor()+0xb2>
    5dee:	movs	r3, #1
    5df0:	str	r3, [sp, #40]	; 0x28
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5df2:	cmp	r6, #0
    5df4:	beq.n	5eb2 <MTPD::WriteDescriptor()+0x192>
      write_length_ += len;
    5df6:	ldr	r3, [r4, #12]
    5df8:	movw	r2, #54274	; 0xd402
    5dfc:	adds	r3, #4
    5dfe:	str	r3, [r4, #12]
    5e00:	strh.w	r2, [sp, #18]
    5e04:	adds	r3, #2
    5e06:	movs	r2, #0
    5e08:	str	r3, [r4, #12]
    5e0a:	str	r2, [sp, #36]	; 0x24
    5e0c:	adds	r3, #4
    5e0e:	movs	r2, #2
    5e10:	str	r3, [r4, #12]
    5e12:	str	r2, [sp, #32]
    5e14:	adds	r3, #4
    5e16:	mov.w	r2, #12288	; 0x3000
    5e1a:	str	r3, [r4, #12]
    5e1c:	strh.w	r2, [sp, #16]
    5e20:	adds	r3, #2
    5e22:	movw	r2, #12289	; 0x3001
    5e26:	str	r3, [r4, #12]
    5e28:	strh.w	r2, [sp, #14]
    5e2c:	adds	r3, #2
    5e2e:	str	r3, [r4, #12]

    write32(2);       // Playback formats (array of uint16)
    write16(0x3000);  // Undefined format
    write16(0x3001);  // Folders (associations)

    writestring(MTP_MANUF);     // Manufacturer
    5e30:	ldr	r1, [pc, #336]	; (5f84 <MTPD::WriteDescriptor()+0x264>)
    5e32:	mov	r0, r4
    5e34:	bl	5bbc <MTPD::writestring(char const*)>
    writestring(MTP_MODEL);     // Model
    5e38:	ldr	r1, [pc, #332]	; (5f88 <MTPD::WriteDescriptor()+0x268>)
    5e3a:	mov	r0, r4
    5e3c:	bl	5bbc <MTPD::writestring(char const*)>
    //writestring(MTP_VERS);      // version
    //writestring(MTP_SERNR);     // serial
    
    char buf[20];    
    dtostrf( (float)(TEENSYDUINO / 100.0f), 3, 2, buf);
    5e40:	add	r3, sp, #44	; 0x2c
    5e42:	movs	r2, #2
    5e44:	movs	r1, #3
    5e46:	ldr	r0, [pc, #324]	; (5f8c <MTPD::WriteDescriptor()+0x26c>)
    5e48:	bl	d1cc <dtostrf>
    strlcat(buf, " / MTP " MTP_VERS, sizeof(buf) );
    5e4c:	movs	r2, #20
    5e4e:	ldr	r1, [pc, #320]	; (5f90 <MTPD::WriteDescriptor()+0x270>)
    5e50:	add	r0, sp, #44	; 0x2c
    5e52:	bl	10c8c <strlcat>
    writestring( buf );    
    5e56:	mov	r0, r4
    5e58:	add	r1, sp, #44	; 0x2c
    5e5a:	bl	5bbc <MTPD::writestring(char const*)>
    5e5e:	ldr	r2, [pc, #308]	; (5f94 <MTPD::WriteDescriptor()+0x274>)
    5e60:	add	r3, sp, #44	; 0x2c
    5e62:	add.w	r0, sp, #54	; 0x36
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    5e66:	ldrh.w	r1, [r2, #2]!
    5e6a:	strb.w	r1, [r3], #1
    5e6e:	cmp	r3, r0
    5e70:	bne.n	5e66 <MTPD::WriteDescriptor()+0x146>
    #pragma GCC diagnostic pop
    writestring(buf);    
    5e72:	add	r1, sp, #44	; 0x2c
    5e74:	mov	r0, r4
    5e76:	bl	5bbc <MTPD::writestring(char const*)>
  }
    5e7a:	add	sp, #68	; 0x44
    5e7c:	pop	{r4, r5, r6, r7, pc}
    5e7e:	movs	r2, #2
    5e80:	add	r1, sp, #8
    5e82:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5e86:	ldrb	r3, [r4, #8]
    5e88:	movs	r2, #6
    5e8a:	str	r2, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5e8c:	cmp	r3, #0
    5e8e:	bne.n	5f58 <MTPD::WriteDescriptor()+0x238>
    5e90:	movs	r2, #4
    5e92:	add	r1, sp, #24
    5e94:	mov	r0, r4
    5e96:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5e9a:	ldrb	r3, [r4, #8]
    5e9c:	strh.w	r5, [sp, #6]
    5ea0:	cmp	r3, #0
    5ea2:	bne.n	5f5c <MTPD::WriteDescriptor()+0x23c>
    5ea4:	movs	r2, #2
    5ea6:	add.w	r1, sp, #6
    5eaa:	mov	r0, r4
    5eac:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5eb0:	b.n	5d4c <MTPD::WriteDescriptor()+0x2c>
    5eb2:	movs	r2, #4
    5eb4:	add	r1, sp, #40	; 0x28
    5eb6:	mov	r0, r4
    5eb8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5ebc:	ldrb	r3, [r4, #8]
    5ebe:	movw	r2, #54274	; 0xd402
    5ec2:	strh.w	r2, [sp, #18]
    5ec6:	cmp	r3, #0
    5ec8:	bne.n	5f60 <MTPD::WriteDescriptor()+0x240>
    5eca:	movs	r2, #2
    5ecc:	add.w	r1, sp, #18
    5ed0:	mov	r0, r4
    5ed2:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5ed6:	ldrb	r3, [r4, #8]
    5ed8:	str	r6, [sp, #36]	; 0x24
    5eda:	cmp	r3, #0
    5edc:	bne.n	5f64 <MTPD::WriteDescriptor()+0x244>
    5ede:	movs	r2, #4
    5ee0:	add	r1, sp, #36	; 0x24
    5ee2:	mov	r0, r4
    5ee4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5ee8:	ldrb	r3, [r4, #8]
    5eea:	movs	r5, #2
    5eec:	str	r5, [sp, #32]
    5eee:	cmp	r3, #0
    5ef0:	bne.n	5f68 <MTPD::WriteDescriptor()+0x248>
    5ef2:	movs	r2, #4
    5ef4:	add	r1, sp, #32
    5ef6:	mov	r0, r4
    5ef8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5efc:	ldrb	r3, [r4, #8]
    5efe:	mov.w	r2, #12288	; 0x3000
    5f02:	strh.w	r2, [sp, #16]
    5f06:	cbnz	r3, 5f6c <MTPD::WriteDescriptor()+0x24c>
    5f08:	mov	r2, r5
    5f0a:	add	r1, sp, #16
    5f0c:	mov	r0, r4
    5f0e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5f12:	ldrb	r3, [r4, #8]
    5f14:	movw	r2, #12289	; 0x3001
    5f18:	strh.w	r2, [sp, #14]
    5f1c:	cbnz	r3, 5f70 <MTPD::WriteDescriptor()+0x250>
    5f1e:	mov	r2, r5
    5f20:	add.w	r1, sp, #14
    5f24:	mov	r0, r4
    5f26:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5f2a:	b.n	5e30 <MTPD::WriteDescriptor()+0x110>
    5f2c:	add	r1, sp, #28
    5f2e:	mov	r0, r4
    5f30:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5f34:	ldrb	r6, [r4, #8]
    5f36:	b.n	5db8 <MTPD::WriteDescriptor()+0x98>
    5f38:	movs	r2, #2
    5f3a:	add	r1, sp, #4
    5f3c:	mov	r0, r4
    5f3e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5f42:	ldrb	r3, [r4, #8]
    5f44:	movs	r2, #20
    5f46:	str	r2, [sp, #20]
    5f48:	cbnz	r3, 5f74 <MTPD::WriteDescriptor()+0x254>
    5f4a:	movs	r2, #4
    5f4c:	add	r1, sp, #20
    5f4e:	mov	r0, r4
    5f50:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5f54:	ldrb	r6, [r4, #8]
    5f56:	b.n	5d72 <MTPD::WriteDescriptor()+0x52>
    5f58:	ldr	r3, [r4, #12]
    5f5a:	b.n	5d3e <MTPD::WriteDescriptor()+0x1e>
    5f5c:	ldr	r3, [r4, #12]
    5f5e:	b.n	5d48 <MTPD::WriteDescriptor()+0x28>
    5f60:	ldr	r3, [r4, #12]
    5f62:	b.n	5e04 <MTPD::WriteDescriptor()+0xe4>
    5f64:	ldr	r3, [r4, #12]
    5f66:	b.n	5e0c <MTPD::WriteDescriptor()+0xec>
    5f68:	ldr	r3, [r4, #12]
    5f6a:	b.n	5e14 <MTPD::WriteDescriptor()+0xf4>
    5f6c:	ldr	r3, [r4, #12]
    5f6e:	b.n	5e20 <MTPD::WriteDescriptor()+0x100>
    5f70:	ldr	r3, [r4, #12]
    5f72:	b.n	5e2c <MTPD::WriteDescriptor()+0x10c>
    5f74:	ldr	r3, [r4, #12]
    5f76:	b.n	5d6c <MTPD::WriteDescriptor()+0x4c>
    5f78:	.word	0x0001454c
    5f7c:	.word	0x0001450c
    5f80:	.word	0x00014590
    5f84:	.word	0x00014560
    5f88:	.word	0x00014544
    5f8c:	.word	0x3fc51eb8
    5f90:	.word	0x00014568
    5f94:	.word	0x1fff8c50

00005f98 <MTPD::WriteStorageIDs()>:
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    5f98:	push	{r4, r5, r6, lr}
    5f9a:	mov	r5, r0
    uint32_t num=storage_->get_FSCount();
    5f9c:	ldr	r0, [r0, #0]
    5f9e:	ldr	r2, [pc, #92]	; (5ffc <MTPD::WriteStorageIDs()+0x64>)
    5fa0:	ldr	r3, [r0, #0]
    5fa2:	ldr	r3, [r3, #4]
    5fa4:	cmp	r3, r2
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    5fa6:	sub	sp, #8
    5fa8:	bne.n	5ff4 <MTPD::WriteStorageIDs()+0x5c>
    {
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    5faa:	ldr	r6, [r0, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5fac:	ldrb	r3, [r5, #8]
    5fae:	str	r6, [sp, #0]
    5fb0:	cbz	r3, 5fe8 <MTPD::WriteStorageIDs()+0x50>
      write_length_ += len;
    5fb2:	ldr	r3, [r5, #12]
    5fb4:	adds	r3, #4
    5fb6:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fb8:	cbz	r6, 5fe4 <MTPD::WriteStorageIDs()+0x4c>
    5fba:	movs	r4, #0
    5fbc:	b.n	5fca <MTPD::WriteStorageIDs()+0x32>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5fbe:	ldr	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fc0:	cmp	r6, r4
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5fc2:	add.w	r3, r3, #4
    5fc6:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fc8:	beq.n	5fe4 <MTPD::WriteStorageIDs()+0x4c>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5fca:	ldrb	r3, [r5, #8]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fcc:	adds	r4, #1
    5fce:	str	r4, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5fd0:	cmp	r3, #0
    5fd2:	bne.n	5fbe <MTPD::WriteStorageIDs()+0x26>
    5fd4:	movs	r2, #4
    5fd6:	add.w	r1, sp, r2
    5fda:	mov	r0, r5
    5fdc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fe0:	cmp	r6, r4
    5fe2:	bne.n	5fca <MTPD::WriteStorageIDs()+0x32>
  }
    5fe4:	add	sp, #8
    5fe6:	pop	{r4, r5, r6, pc}
    5fe8:	movs	r2, #4
    5fea:	mov	r1, sp
    5fec:	mov	r0, r5
    5fee:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    5ff2:	b.n	5fb8 <MTPD::WriteStorageIDs()+0x20>
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    5ff4:	blx	r3
    5ff6:	mov	r6, r0
    5ff8:	b.n	5fac <MTPD::WriteStorageIDs()+0x14>
    5ffa:	nop
    5ffc:	.word	0x00001e49

00006000 <MTPD::GetObjectHandles(unsigned long, unsigned long)>:
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    6000:	push	{r4, r5, r6, lr}
    if (write_get_length_) {
    6002:	ldrb	r3, [r0, #8]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    6004:	sub	sp, #8
    6006:	mov	r4, r0
    if (write_get_length_) {
    6008:	cbnz	r3, 6054 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x54>
    600a:	mov	r5, r1
    600c:	mov	r6, r2
      write_length_ = GetNumObjects(storage, parent);
      write_length_++;
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
    600e:	bl	5b18 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6012:	ldrb	r3, [r4, #8]
    6014:	str	r0, [sp, #0]
    6016:	cbz	r3, 6062 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x62>
      write_length_ += len;
    6018:	ldr	r3, [r4, #12]
    601a:	adds	r3, #4
    601c:	str	r3, [r4, #12]
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    601e:	ldr	r0, [r4, #0]
    6020:	ldr	r3, [r0, #0]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    6022:	subs	r5, #1
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    6024:	mov	r2, r6
    6026:	ldr	r3, [r3, #28]
    6028:	mov	r1, r5
    602a:	blx	r3
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    602c:	ldr	r0, [r4, #0]
    602e:	ldr	r3, [r0, #0]
    6030:	mov	r1, r5
    6032:	ldr	r3, [r3, #32]
    6034:	blx	r3
    6036:	cbz	r0, 605e <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x5e>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6038:	ldrb	r3, [r4, #8]
    603a:	str	r0, [sp, #4]
    603c:	cbz	r3, 6046 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x46>
      write_length_ += len;
    603e:	ldr	r3, [r4, #12]
    6040:	adds	r3, #4
    6042:	str	r3, [r4, #12]
    6044:	b.n	602c <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
    6046:	movs	r2, #4
    6048:	add.w	r1, sp, r2
    604c:	mov	r0, r4
    604e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6052:	b.n	602c <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    if (write_get_length_) {
      write_length_ = GetNumObjects(storage, parent);
    6054:	bl	5b18 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      write_length_++;
      write_length_ *= 4;
    6058:	adds	r0, #1
    605a:	lsls	r0, r0, #2
    605c:	str	r0, [r4, #12]
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    }
  }
    605e:	add	sp, #8
    6060:	pop	{r4, r5, r6, pc}
    6062:	movs	r2, #4
    6064:	mov	r1, sp
    6066:	mov	r0, r4
    6068:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    606c:	b.n	601e <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x1e>
    606e:	nop

00006070 <MTPD::GetObjectInfo(unsigned long)>:
  
  void MTPD::GetObjectInfo(uint32_t handle) 
  {
    6070:	push	{r4, r5, r6, r7, lr}
    6072:	mov	r4, r0
    6074:	sub	sp, #332	; 0x14c
    char filename[MAX_FILENAME_LEN];
    uint32_t size, parent;
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);
    6076:	ldr	r0, [r0, #0]
    6078:	add.w	r6, sp, #10
    607c:	add	r5, sp, #24
    607e:	ldr	r3, [r0, #0]
    6080:	stmia.w	sp, {r5, r6}
    6084:	add	r2, sp, #72	; 0x48
    6086:	ldr	r7, [r3, #36]	; 0x24
    6088:	add	r3, sp, #20
    608a:	blx	r7
    608c:	ldrh	r3, [r6, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    608e:	ldrb	r2, [r4, #8]
    6090:	adds	r3, #1
    6092:	str	r3, [sp, #28]
    6094:	cmp	r2, #0
    6096:	beq.n	614c <MTPD::GetObjectInfo(unsigned long)+0xdc>
      write_length_ += len;
    6098:	ldr	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    609a:	ldr	r2, [sp, #20]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    609c:	adds	r3, #4
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    609e:	adds	r2, #1
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    60a0:	str	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    60a2:	beq.w	627c <MTPD::GetObjectInfo(unsigned long)+0x20c>
    60a6:	movs	r2, #0
    60a8:	strh.w	r2, [sp, #16]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    60ac:	adds	r3, #2
    60ae:	movs	r2, #0
    60b0:	str	r3, [r4, #12]
    60b2:	strh.w	r2, [sp, #14]
    60b6:	adds	r3, #2
    60b8:	ldr	r2, [sp, #20]
    60ba:	str	r3, [r4, #12]
    60bc:	str	r2, [sp, #60]	; 0x3c
    60be:	adds	r3, #4
    60c0:	movs	r2, #0
    60c2:	str	r3, [r4, #12]
    60c4:	strh.w	r2, [sp, #12]
    60c8:	adds	r3, #2
    60ca:	movs	r2, #0
    60cc:	str	r3, [r4, #12]
    60ce:	str	r2, [sp, #56]	; 0x38
    60d0:	adds	r3, #4
    60d2:	movs	r2, #0
    60d4:	str	r3, [r4, #12]
    60d6:	str	r2, [sp, #52]	; 0x34
    60d8:	adds	r3, #4
    60da:	movs	r2, #0
    60dc:	str	r3, [r4, #12]
    60de:	str	r2, [sp, #48]	; 0x30
    60e0:	adds	r3, #4
    60e2:	movs	r2, #0
    60e4:	str	r3, [r4, #12]
    60e6:	str	r2, [sp, #44]	; 0x2c
    60e8:	adds	r3, #4
    60ea:	movs	r2, #0
    60ec:	str	r3, [r4, #12]
    60ee:	str	r2, [sp, #40]	; 0x28
    60f0:	adds	r3, #4
    60f2:	movs	r2, #0
    60f4:	str	r3, [r4, #12]
    60f6:	str	r2, [sp, #36]	; 0x24
    60f8:	adds	r3, #4
    60fa:	ldr	r2, [r5, #0]
    60fc:	str	r3, [r4, #12]
    60fe:	str	r2, [sp, #32]
    6100:	ldr	r2, [sp, #20]
    6102:	sub.w	r2, r2, #4294967295
    6106:	clz	r2, r2
    610a:	lsrs	r2, r2, #5
    610c:	adds	r3, #4
    610e:	str	r3, [r4, #12]
    6110:	strh.w	r2, [sp, #18]
    6114:	adds	r3, #2
    6116:	movs	r2, #0
    6118:	str	r3, [r4, #12]
    611a:	str	r2, [sp, #68]	; 0x44
    611c:	adds	r3, #4
    611e:	movs	r2, #0
    6120:	str	r3, [r4, #12]
    6122:	str	r2, [sp, #64]	; 0x40
    6124:	adds	r3, #4
    6126:	str	r3, [r4, #12]
    write32(0); // bit depth
    write32(parent); // parent
    write16(size == 0xFFFFFFFFUL ? 1 : 0); // association type
    write32(0); // association description
    write32(0);  // sequence number
    writestring(filename);
    6128:	add	r1, sp, #72	; 0x48
    612a:	mov	r0, r4
    612c:	bl	5bbc <MTPD::writestring(char const*)>
    writestring("");  // date created
    6130:	mov	r0, r4
    6132:	ldr	r1, [pc, #396]	; (62c0 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    6134:	bl	5bbc <MTPD::writestring(char const*)>
    writestring("");  // date modified
    6138:	mov	r0, r4
    613a:	ldr	r1, [pc, #388]	; (62c0 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    613c:	bl	5bbc <MTPD::writestring(char const*)>
    writestring("");  // keywords
    6140:	mov	r0, r4
    6142:	ldr	r1, [pc, #380]	; (62c0 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    6144:	bl	5bbc <MTPD::writestring(char const*)>
  }
    6148:	add	sp, #332	; 0x14c
    614a:	pop	{r4, r5, r6, r7, pc}
    614c:	add	r1, sp, #28
    614e:	movs	r2, #4
    6150:	mov	r0, r4
    6152:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    6156:	ldr	r3, [sp, #20]
    6158:	ldrb	r6, [r4, #8]
    615a:	adds	r3, #1
    615c:	movw	r3, #12289	; 0x3001
    6160:	it	ne
    6162:	movne	r3, #0
    6164:	strh.w	r3, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6168:	cmp	r6, #0
    616a:	bne.w	628e <MTPD::GetObjectInfo(unsigned long)+0x21e>
    616e:	add	r1, sp, #16
    6170:	movs	r2, #2
    6172:	mov	r0, r4
    6174:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6178:	ldrb	r3, [r4, #8]
    617a:	strh.w	r6, [sp, #14]
    617e:	cmp	r3, #0
    6180:	bne.w	6292 <MTPD::GetObjectInfo(unsigned long)+0x222>
    6184:	movs	r2, #2
    6186:	add.w	r1, sp, #14
    618a:	mov	r0, r4
    618c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6190:	ldrb	r3, [r4, #8]
    6192:	ldr	r2, [sp, #20]
    6194:	str	r2, [sp, #60]	; 0x3c
    6196:	cmp	r3, #0
    6198:	bne.n	6296 <MTPD::GetObjectInfo(unsigned long)+0x226>
    619a:	add	r1, sp, #60	; 0x3c
    619c:	movs	r2, #4
    619e:	mov	r0, r4
    61a0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    61a4:	ldrb	r3, [r4, #8]
    61a6:	strh.w	r6, [sp, #12]
    61aa:	cmp	r3, #0
    61ac:	bne.n	629a <MTPD::GetObjectInfo(unsigned long)+0x22a>
    61ae:	add	r1, sp, #12
    61b0:	movs	r2, #2
    61b2:	mov	r0, r4
    61b4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    61b8:	ldrb	r3, [r4, #8]
    61ba:	str	r6, [sp, #56]	; 0x38
    61bc:	cmp	r3, #0
    61be:	bne.n	629e <MTPD::GetObjectInfo(unsigned long)+0x22e>
    61c0:	add	r1, sp, #56	; 0x38
    61c2:	movs	r2, #4
    61c4:	mov	r0, r4
    61c6:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    61ca:	ldrb	r3, [r4, #8]
    61cc:	str	r6, [sp, #52]	; 0x34
    61ce:	cmp	r3, #0
    61d0:	bne.n	62a2 <MTPD::GetObjectInfo(unsigned long)+0x232>
    61d2:	add	r1, sp, #52	; 0x34
    61d4:	movs	r2, #4
    61d6:	mov	r0, r4
    61d8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    61dc:	ldrb	r3, [r4, #8]
    61de:	str	r6, [sp, #48]	; 0x30
    61e0:	cmp	r3, #0
    61e2:	bne.n	62a6 <MTPD::GetObjectInfo(unsigned long)+0x236>
    61e4:	add	r1, sp, #48	; 0x30
    61e6:	movs	r2, #4
    61e8:	mov	r0, r4
    61ea:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    61ee:	ldrb	r3, [r4, #8]
    61f0:	str	r6, [sp, #44]	; 0x2c
    61f2:	cmp	r3, #0
    61f4:	bne.n	62aa <MTPD::GetObjectInfo(unsigned long)+0x23a>
    61f6:	add	r1, sp, #44	; 0x2c
    61f8:	movs	r2, #4
    61fa:	mov	r0, r4
    61fc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6200:	ldrb	r3, [r4, #8]
    6202:	str	r6, [sp, #40]	; 0x28
    6204:	cmp	r3, #0
    6206:	bne.n	62ae <MTPD::GetObjectInfo(unsigned long)+0x23e>
    6208:	add	r1, sp, #40	; 0x28
    620a:	movs	r2, #4
    620c:	mov	r0, r4
    620e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6212:	ldrb	r3, [r4, #8]
    6214:	str	r6, [sp, #36]	; 0x24
    6216:	cmp	r3, #0
    6218:	bne.n	62b2 <MTPD::GetObjectInfo(unsigned long)+0x242>
    621a:	movs	r2, #4
    621c:	add	r1, sp, #36	; 0x24
    621e:	mov	r0, r4
    6220:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6224:	ldrb	r3, [r4, #8]
    6226:	ldr	r2, [r5, #0]
    6228:	str	r2, [sp, #32]
    622a:	cmp	r3, #0
    622c:	bne.n	62b6 <MTPD::GetObjectInfo(unsigned long)+0x246>
    622e:	add	r1, sp, #32
    6230:	movs	r2, #4
    6232:	mov	r0, r4
    6234:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6238:	ldr	r3, [sp, #20]
    623a:	ldrb	r6, [r4, #8]
    623c:	sub.w	r3, r3, #4294967295
    6240:	clz	r3, r3
    6244:	lsrs	r3, r3, #5
    6246:	strh.w	r3, [sp, #18]
    624a:	cmp	r6, #0
    624c:	bne.n	62ba <MTPD::GetObjectInfo(unsigned long)+0x24a>
    624e:	add.w	r1, sp, #18
    6252:	movs	r2, #2
    6254:	mov	r0, r4
    6256:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    625a:	ldrb	r5, [r4, #8]
    625c:	str	r6, [sp, #68]	; 0x44
    625e:	cbnz	r5, 628a <MTPD::GetObjectInfo(unsigned long)+0x21a>
    6260:	add	r1, sp, #68	; 0x44
    6262:	movs	r2, #4
    6264:	mov	r0, r4
    6266:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    626a:	ldrb	r3, [r4, #8]
    626c:	str	r5, [sp, #64]	; 0x40
    626e:	cbnz	r3, 6286 <MTPD::GetObjectInfo(unsigned long)+0x216>
    6270:	add	r1, sp, #64	; 0x40
    6272:	movs	r2, #4
    6274:	mov	r0, r4
    6276:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    627a:	b.n	6128 <MTPD::GetObjectInfo(unsigned long)+0xb8>
    627c:	movw	r2, #12289	; 0x3001
    6280:	strh.w	r2, [sp, #16]
    6284:	b.n	60ac <MTPD::GetObjectInfo(unsigned long)+0x3c>
    6286:	ldr	r3, [r4, #12]
    6288:	b.n	6124 <MTPD::GetObjectInfo(unsigned long)+0xb4>
    628a:	ldr	r3, [r4, #12]
    628c:	b.n	611c <MTPD::GetObjectInfo(unsigned long)+0xac>
    628e:	ldr	r3, [r4, #12]
    6290:	b.n	60ac <MTPD::GetObjectInfo(unsigned long)+0x3c>
    6292:	ldr	r3, [r4, #12]
    6294:	b.n	60b6 <MTPD::GetObjectInfo(unsigned long)+0x46>
    6296:	ldr	r3, [r4, #12]
    6298:	b.n	60be <MTPD::GetObjectInfo(unsigned long)+0x4e>
    629a:	ldr	r3, [r4, #12]
    629c:	b.n	60c8 <MTPD::GetObjectInfo(unsigned long)+0x58>
    629e:	ldr	r3, [r4, #12]
    62a0:	b.n	60d0 <MTPD::GetObjectInfo(unsigned long)+0x60>
    62a2:	ldr	r3, [r4, #12]
    62a4:	b.n	60d8 <MTPD::GetObjectInfo(unsigned long)+0x68>
    62a6:	ldr	r3, [r4, #12]
    62a8:	b.n	60e0 <MTPD::GetObjectInfo(unsigned long)+0x70>
    62aa:	ldr	r3, [r4, #12]
    62ac:	b.n	60e8 <MTPD::GetObjectInfo(unsigned long)+0x78>
    62ae:	ldr	r3, [r4, #12]
    62b0:	b.n	60f0 <MTPD::GetObjectInfo(unsigned long)+0x80>
    62b2:	ldr	r3, [r4, #12]
    62b4:	b.n	60f8 <MTPD::GetObjectInfo(unsigned long)+0x88>
    62b6:	ldr	r3, [r4, #12]
    62b8:	b.n	6100 <MTPD::GetObjectInfo(unsigned long)+0x90>
    62ba:	ldr	r3, [r4, #12]
    62bc:	b.n	6114 <MTPD::GetObjectInfo(unsigned long)+0xa4>
    62be:	nop
    62c0:	.word	0x000143a8

000062c4 <MTPD::getObjectPropsSupported(unsigned long)>:
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    62c4:	push	{r4, r5, r6, r7, lr}
      write32(propertyListNum);
    62c6:	ldr	r7, [pc, #96]	; (6328 <MTPD::getObjectPropsSupported(unsigned long)+0x64>)
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    62c8:	ldrb	r2, [r0, #8]
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    62ca:	ldr	r3, [r7, #0]
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    62cc:	sub	sp, #12
    62ce:	mov	r4, r0
    62d0:	str	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    62d2:	cbz	r2, 631a <MTPD::getObjectPropsSupported(unsigned long)+0x56>
      write_length_ += len;
    62d4:	ldr	r2, [r0, #12]
    62d6:	adds	r2, #4
    62d8:	str	r2, [r0, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    62da:	cbz	r3, 6316 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    62dc:	ldr	r6, [pc, #76]	; (632c <MTPD::getObjectPropsSupported(unsigned long)+0x68>)
    62de:	movw	r3, #56321	; 0xdc01
    62e2:	movs	r5, #0
    62e4:	b.n	62f8 <MTPD::getObjectPropsSupported(unsigned long)+0x34>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    62e6:	ldr	r3, [r4, #12]
    62e8:	adds	r3, #2
    62ea:	str	r3, [r4, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    62ec:	ldr	r3, [r7, #0]
    62ee:	adds	r5, #1
    62f0:	cmp	r3, r5
    62f2:	bls.n	6316 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    62f4:	ldrh.w	r3, [r6, #2]!
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    62f8:	ldrb	r2, [r4, #8]
    62fa:	strh.w	r3, [sp, #2]
    62fe:	cmp	r2, #0
    6300:	bne.n	62e6 <MTPD::getObjectPropsSupported(unsigned long)+0x22>
    6302:	movs	r2, #2
    6304:	add.w	r1, sp, r2
    6308:	mov	r0, r4
    630a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    630e:	ldr	r3, [r7, #0]
    6310:	adds	r5, #1
    6312:	cmp	r3, r5
    6314:	bhi.n	62f4 <MTPD::getObjectPropsSupported(unsigned long)+0x30>
    }
    6316:	add	sp, #12
    6318:	pop	{r4, r5, r6, r7, pc}
    631a:	movs	r2, #4
    631c:	add.w	r1, sp, r2
    6320:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6324:	ldr	r3, [r7, #0]
    6326:	b.n	62da <MTPD::getObjectPropsSupported(unsigned long)+0x16>
    6328:	.word	0x1fff8a5c
    632c:	.word	0x00014534

00006330 <MTPD::getObjectPropValue(unsigned long, unsigned long)>:
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6330:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6334:	mov	r5, r0
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6336:	ldr	r0, [r0, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6338:	sub	sp, #316	; 0x13c
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    633a:	ldr	r3, [r0, #0]
    633c:	add.w	r6, sp, #10
    6340:	add	r7, sp, #20
    6342:	str	r6, [sp, #4]
    6344:	str	r7, [sp, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6346:	mov	r4, r2
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6348:	ldr.w	r8, [r3, #36]	; 0x24
    634c:	add	r2, sp, #56	; 0x38
    634e:	add	r3, sp, #16
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6350:	mov	r9, r1
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6352:	blx	r8
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
      switch(p2)
    6354:	sub.w	r2, r4, #56320	; 0xdc00
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    6358:	ldrh	r3, [r6, #0]
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
    635a:	ldr	r1, [sp, #16]
      uint32_t storage = Store2Storage(store);
      switch(p2)
    635c:	subs	r2, #1
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    635e:	adds	r4, r3, #1
      switch(p2)
    6360:	cmp	r2, #67	; 0x43
    6362:	bhi.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6364:	tbb	[pc, r2]
    6368:	.word	0x776a4b41
    636c:	.word	0x333a3030
    6370:	.word	0x305c3033
    6374:	.word	0x30303030
    6378:	.word	0x30303030
    637c:	.word	0x30303030
    6380:	.word	0x30303030
    6384:	.word	0x30303030
    6388:	.word	0x30303030
    638c:	.word	0x30303030
    6390:	.word	0x30303030
    6394:	.word	0x30303030
    6398:	.word	0x30303030
    639c:	.word	0x30303030
    63a0:	.word	0x30303030
    63a4:	.word	0x30303030
    63a8:	.word	0x3a303022
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    63ac:	ldrb	r3, [r5, #8]
    63ae:	str.w	r9, [sp, #52]	; 0x34
    63b2:	cmp	r3, #0
    63b4:	beq.n	6466 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x136>
      write_length_ += len;
    63b6:	ldr	r3, [r5, #12]
    63b8:	adds	r3, #4
    63ba:	str	r3, [r5, #12]
    63bc:	adds	r3, #4
    63be:	str	r3, [r5, #12]
    63c0:	adds	r3, #4
    63c2:	str	r3, [r5, #12]
    63c4:	adds	r3, #4
    63c6:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    63c8:	add	sp, #316	; 0x13c
    63ca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_CREATED:       //0xDC08:
          writestring("");
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
    63ce:	mov	r0, r5
    63d0:	ldr	r1, [pc, #276]	; (64e8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b8>)
    63d2:	bl	5bbc <MTPD::writestring(char const*)>
          writestring(name);
          break;
        default:
          break;
      }
    }
    63d6:	add	sp, #316	; 0x13c
    63d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          write32(parent);
          write32(storage);
          write32(0);
          break;
        case MTP_PROPERTY_NAME:               //0xDC44:
          writestring(name);
    63dc:	add	r1, sp, #56	; 0x38
    63de:	mov	r0, r5
    63e0:	bl	5bbc <MTPD::writestring(char const*)>
          break;
        default:
          break;
      }
    }
    63e4:	add	sp, #316	; 0x13c
    63e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    63ea:	ldrb	r3, [r5, #8]
    63ec:	str	r4, [sp, #24]
    63ee:	cmp	r3, #0
    63f0:	beq.n	64b2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x182>
      write_length_ += len;
    63f2:	ldr	r3, [r5, #12]
    63f4:	adds	r3, #4
    63f6:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    63f8:	add	sp, #316	; 0x13c
    63fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    63fe:	adds	r1, #1
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6400:	ldrb	r2, [r5, #8]
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    6402:	movw	r3, #12289	; 0x3001
    6406:	it	ne
    6408:	movne.w	r3, #12288	; 0x3000
    640c:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6410:	cmp	r2, #0
    6412:	beq.n	64a6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x176>
      write_length_ += len;
    6414:	ldr	r3, [r5, #12]
    6416:	adds	r3, #2
    6418:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    641a:	add	sp, #316	; 0x13c
    641c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    6420:	ldr	r2, [r7, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6422:	ldrb	r1, [r5, #8]
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    6424:	cmp	r3, r2
    6426:	it	eq
    6428:	moveq	r2, #0
    642a:	str	r2, [sp, #36]	; 0x24
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    642c:	cmp	r1, #0
    642e:	bne.n	63f2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc2>
    6430:	add	r1, sp, #36	; 0x24
    6432:	mov	r0, r5
    6434:	movs	r2, #4
    6436:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    643a:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    643c:	ldrb	r3, [r5, #8]
    643e:	movs	r2, #0
    6440:	strh.w	r2, [sp, #14]
    6444:	cmp	r3, #0
    6446:	bne.n	6414 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xe4>
    6448:	add.w	r1, sp, #14
    644c:	mov	r0, r5
    644e:	movs	r2, #2
    6450:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6454:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6456:	ldrb	r4, [r5, #8]
    6458:	str	r1, [sp, #32]
    645a:	cmp	r4, #0
    645c:	beq.n	64be <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x18e>
      write_length_ += len;
    645e:	ldr	r3, [r5, #12]
    6460:	adds	r3, #4
    6462:	str	r3, [r5, #12]
    6464:	b.n	63c4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    6466:	movs	r2, #4
    6468:	add	r1, sp, #52	; 0x34
    646a:	mov	r0, r5
    646c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6470:	ldrb	r3, [r5, #8]
    6472:	ldr	r2, [r7, #0]
    6474:	str	r2, [sp, #48]	; 0x30
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6476:	cmp	r3, #0
    6478:	bne.n	64e2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b2>
    647a:	add	r1, sp, #48	; 0x30
    647c:	movs	r2, #4
    647e:	mov	r0, r5
    6480:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6484:	ldrb	r6, [r5, #8]
    6486:	str	r4, [sp, #44]	; 0x2c
    6488:	cbnz	r6, 64de <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1ae>
    648a:	add	r1, sp, #44	; 0x2c
    648c:	movs	r2, #4
    648e:	mov	r0, r5
    6490:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6494:	ldrb	r3, [r5, #8]
    6496:	str	r6, [sp, #40]	; 0x28
    6498:	cbnz	r3, 64da <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    649a:	add	r1, sp, #40	; 0x28
    649c:	mov	r0, r5
    649e:	movs	r2, #4
    64a0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    64a4:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64a6:	add	r1, sp, #12
    64a8:	mov	r0, r5
    64aa:	movs	r2, #2
    64ac:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    64b0:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64b2:	add	r1, sp, #24
    64b4:	mov	r0, r5
    64b6:	movs	r2, #4
    64b8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    64bc:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64be:	add	r1, sp, #32
    64c0:	movs	r2, #4
    64c2:	mov	r0, r5
    64c4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    64c8:	ldrb	r3, [r5, #8]
    64ca:	str	r4, [sp, #28]
    64cc:	cbnz	r3, 64da <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    64ce:	add	r1, sp, #28
    64d0:	mov	r0, r5
    64d2:	movs	r2, #4
    64d4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    64d8:	b.n	63c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64da:	ldr	r3, [r5, #12]
    64dc:	b.n	63c4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    64de:	ldr	r3, [r5, #12]
    64e0:	b.n	63c0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x90>
    64e2:	ldr	r3, [r5, #12]
    64e4:	b.n	63bc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8c>
    64e6:	nop
    64e8:	.word	0x000143a8

000064ec <MTPD::GetStorageInfo(unsigned long)>:
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    64ec:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    64f0:	mov	r4, r0
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    64f2:	ldr	r0, [r0, #0]
    64f4:	ldr	r3, [r0, #0]
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    64f6:	subs	r5, r1, #1
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    64f8:	sub	sp, #36	; 0x24
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    64fa:	ldr	r3, [r3, #20]
    64fc:	mov	r1, r5
    64fe:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6500:	ldrb	r3, [r4, #8]
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    6502:	cmp	r0, #0
    6504:	ite	eq
    6506:	moveq	r2, #4
    6508:	movne	r2, #1
    650a:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    650e:	cmp	r3, #0
    6510:	beq.n	65ac <MTPD::GetStorageInfo(unsigned long)+0xc0>
      write_length_ += len;
    6512:	ldr	r3, [r4, #12]
    6514:	adds	r3, #2
    6516:	str	r3, [r4, #12]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    6518:	ldr	r0, [r4, #0]
    651a:	ldr	r3, [r0, #0]
    651c:	mov	r1, r5
    651e:	ldr	r3, [r3, #24]
    6520:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6522:	ldrb	r6, [r4, #8]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    6524:	cmp	r0, #0
    6526:	ite	eq
    6528:	moveq	r3, #1
    652a:	movne	r3, #2
    652c:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6530:	cmp	r6, #0
    6532:	beq.n	65f4 <MTPD::GetStorageInfo(unsigned long)+0x108>
      write_length_ += len;
    6534:	ldr	r3, [r4, #12]
    6536:	movs	r2, #0
    6538:	adds	r3, #2
    653a:	str	r3, [r4, #12]
    653c:	strh.w	r2, [sp, #8]
    6540:	adds	r3, #2
    6542:	str	r3, [r4, #12]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    6544:	ldr	r0, [r4, #0]
    6546:	ldr	r3, [r0, #0]
    6548:	mov	r1, r5
    654a:	ldr	r3, [r3, #12]
    654c:	blx	r3
    654e:	mov	r6, r0
    uint64_t nused = storage_->usedSize(store) ; 
    6550:	ldr	r0, [r4, #0]
    6552:	ldr	r3, [r0, #0]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    6554:	mov	r7, r1
    uint64_t nused = storage_->usedSize(store) ; 
    6556:	ldr	r3, [r3, #16]
    6558:	mov	r1, r5
    655a:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    655c:	ldrb	r3, [r4, #8]
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    uint64_t nused = storage_->usedSize(store) ; 
    655e:	mov	r8, r0
    6560:	mov	r9, r1
    6562:	strd	r6, r7, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6566:	cbz	r3, 65ba <MTPD::GetStorageInfo(unsigned long)+0xce>
    6568:	subs	r6, r6, r0
      write_length_ += len;
    656a:	ldr	r3, [r4, #12]
    656c:	sbc.w	r7, r7, r1
    6570:	strd	r6, r7, [sp, #16]
    6574:	adds	r3, #8
    6576:	str	r3, [r4, #12]
    6578:	adds	r3, #8
    657a:	mov.w	r2, #4294967295
    657e:	str	r3, [r4, #12]
    6580:	str	r2, [sp, #12]
    6582:	adds	r3, #4
    6584:	str	r3, [r4, #12]

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    6586:	ldr	r0, [r4, #0]
    6588:	ldr	r2, [pc, #156]	; (6628 <MTPD::GetStorageInfo(unsigned long)+0x13c>)
    658a:	ldr	r3, [r0, #0]
    658c:	ldr	r3, [r3, #8]
    658e:	cmp	r3, r2
    6590:	bne.n	6614 <MTPD::GetStorageInfo(unsigned long)+0x128>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    6592:	add.w	r0, r0, r5, lsl #2
    6596:	ldr	r1, [r0, #8]
    writestring(name);  // storage descriptor
    6598:	mov	r0, r4
    659a:	bl	5bbc <MTPD::writestring(char const*)>
    writestring("");  // volume identifier
    659e:	mov	r0, r4
    65a0:	ldr	r1, [pc, #136]	; (662c <MTPD::GetStorageInfo(unsigned long)+0x140>)
    65a2:	bl	5bbc <MTPD::writestring(char const*)>

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }
    65a6:	add	sp, #36	; 0x24
    65a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    65ac:	movs	r2, #2
    65ae:	add.w	r1, sp, #6
    65b2:	mov	r0, r4
    65b4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    65b8:	b.n	6518 <MTPD::GetStorageInfo(unsigned long)+0x2c>
    65ba:	movs	r2, #8
    65bc:	add	r1, sp, #24
    65be:	mov	r0, r4
    65c0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    65c4:	subs.w	r6, r6, r8
    65c8:	ldrb	r3, [r4, #8]
    65ca:	sbc.w	r7, r7, r9
    65ce:	strd	r6, r7, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    65d2:	cbnz	r3, 6620 <MTPD::GetStorageInfo(unsigned long)+0x134>
    65d4:	movs	r2, #8
    65d6:	add	r1, sp, #16
    65d8:	mov	r0, r4
    65da:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    65de:	ldrb	r3, [r4, #8]
    65e0:	mov.w	r2, #4294967295
    65e4:	str	r2, [sp, #12]
    65e6:	cbnz	r3, 661c <MTPD::GetStorageInfo(unsigned long)+0x130>
    65e8:	movs	r2, #4
    65ea:	add	r1, sp, #12
    65ec:	mov	r0, r4
    65ee:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    65f2:	b.n	6586 <MTPD::GetStorageInfo(unsigned long)+0x9a>
    65f4:	movs	r2, #2
    65f6:	add.w	r1, sp, #10
    65fa:	mov	r0, r4
    65fc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6600:	ldrb	r3, [r4, #8]
    6602:	strh.w	r6, [sp, #8]
    6606:	cbnz	r3, 6624 <MTPD::GetStorageInfo(unsigned long)+0x138>
    6608:	movs	r2, #2
    660a:	add	r1, sp, #8
    660c:	mov	r0, r4
    660e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6612:	b.n	6544 <MTPD::GetStorageInfo(unsigned long)+0x58>

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    6614:	mov	r1, r5
    6616:	blx	r3
    6618:	mov	r1, r0
    661a:	b.n	6598 <MTPD::GetStorageInfo(unsigned long)+0xac>
    661c:	ldr	r3, [r4, #12]
    661e:	b.n	6582 <MTPD::GetStorageInfo(unsigned long)+0x96>
    6620:	ldr	r3, [r4, #12]
    6622:	b.n	6578 <MTPD::GetStorageInfo(unsigned long)+0x8c>
    6624:	ldr	r3, [r4, #12]
    6626:	b.n	6540 <MTPD::GetStorageInfo(unsigned long)+0x54>
    6628:	.word	0x00001e4d
    662c:	.word	0x000143a8

00006630 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>:
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    6630:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      switch(p1)
    6634:	sub.w	r1, r1, #56320	; 0xdc00
    6638:	subs	r1, #1
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    663a:	sub	sp, #148	; 0x94
    663c:	mov	r4, r0
      switch(p1)
    663e:	cmp	r1, #67	; 0x43
    6640:	bhi.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6642:	tbh	[pc, r1, lsl #1]
    6646:	.short	0x005c
    6648:	.word	0x0080006e
    664c:	.word	0x005900c6
    6650:	.word	0x00d80059
    6654:	.word	0x01690121
    6658:	.word	0x01b10059
    665c:	.word	0x00590059
    6660:	.word	0x00590059
    6664:	.word	0x00590059
    6668:	.word	0x00590059
    666c:	.word	0x00590059
    6670:	.word	0x00590059
    6674:	.word	0x00590059
    6678:	.word	0x00590059
    667c:	.word	0x00590059
    6680:	.word	0x00590059
    6684:	.word	0x00590059
    6688:	.word	0x00590059
    668c:	.word	0x00590059
    6690:	.word	0x00590059
    6694:	.word	0x00590059
    6698:	.word	0x00590059
    669c:	.word	0x00590059
    66a0:	.word	0x00590059
    66a4:	.word	0x00590059
    66a8:	.word	0x00590059
    66ac:	.word	0x00590059
    66b0:	.word	0x00590059
    66b4:	.word	0x00590059
    66b8:	.word	0x00590059
    66bc:	.word	0x00590059
    66c0:	.word	0x00590059
    66c4:	.word	0x01f70059
    66c8:	.word	0x00590059
    66cc:	.short	0x0044
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    66ce:	ldrb	r3, [r0, #8]
    66d0:	movw	r2, #56388	; 0xdc44
    66d4:	strh.w	r2, [sp, #70]	; 0x46
    66d8:	cmp	r3, #0
    66da:	beq.w	6b58 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x528>
      write_length_ += len;
    66de:	ldr	r3, [r4, #12]
    66e0:	adds	r3, #2
    66e2:	str	r3, [r4, #12]
    66e4:	adds	r3, #2
    66e6:	str	r3, [r4, #12]
    66e8:	adds	r3, #1
    66ea:	str	r3, [r4, #12]
    66ec:	adds	r3, #1
    66ee:	str	r3, [r4, #12]
    66f0:	adds	r3, #4
    66f2:	str	r3, [r4, #12]
    66f4:	adds	r3, #1
    66f6:	str	r3, [r4, #12]
          write8(0);
          break;
        default:
          break;
      }
    }
    66f8:	add	sp, #148	; 0x94
    66fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    66fe:	ldrb	r3, [r0, #8]
    6700:	movw	r2, #56321	; 0xdc01
    6704:	strh.w	r2, [sp, #30]
    6708:	cmp	r3, #0
    670a:	beq.w	6c6c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x63c>
      write_length_ += len;
    670e:	ldr	r3, [r4, #12]
    6710:	adds	r3, #2
    6712:	str	r3, [r4, #12]
    6714:	adds	r3, #2
    6716:	str	r3, [r4, #12]
    6718:	adds	r3, #1
    671a:	str	r3, [r4, #12]
    671c:	adds	r3, #4
    671e:	str	r3, [r4, #12]
    6720:	b.n	66f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6722:	ldrb	r3, [r0, #8]
    6724:	movw	r2, #56322	; 0xdc02
    6728:	strh.w	r2, [sp, #36]	; 0x24
    672c:	cmp	r3, #0
    672e:	beq.w	6ada <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4aa>
      write_length_ += len;
    6732:	ldr	r3, [r4, #12]
    6734:	adds	r3, #2
    6736:	str	r3, [r4, #12]
    6738:	adds	r3, #2
    673a:	str	r3, [r4, #12]
    673c:	adds	r3, #1
    673e:	str	r3, [r4, #12]
    6740:	adds	r3, #2
    6742:	str	r3, [r4, #12]
    6744:	b.n	66f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6746:	ldrb	r3, [r0, #8]
    6748:	movw	r2, #56323	; 0xdc03
    674c:	strh.w	r2, [sp, #42]	; 0x2a
    6750:	cmp	r3, #0
    6752:	bne.n	6732 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x102>
    6754:	movs	r2, #2
    6756:	add.w	r1, sp, #42	; 0x2a
    675a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    675e:	ldrb	r7, [r4, #8]
    6760:	movs	r6, #4
    6762:	strh.w	r6, [sp, #40]	; 0x28
    6766:	cmp	r7, #0
    6768:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    676c:	movs	r2, #2
    676e:	add	r1, sp, #40	; 0x28
    6770:	mov	r0, r4
    6772:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6776:	ldrb	r5, [r4, #8]
    6778:	strb.w	r7, [sp, #9]
    677c:	cmp	r5, #0
    677e:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    6782:	movs	r2, #1
    6784:	add.w	r1, sp, #9
    6788:	mov	r0, r4
    678a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    678e:	ldrb	r7, [r4, #8]
    6790:	strh.w	r5, [sp, #38]	; 0x26
    6794:	cmp	r7, #0
    6796:	bne.w	6cfa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    679a:	movs	r2, #2
    679c:	add.w	r1, sp, #38	; 0x26
    67a0:	mov	r0, r4
    67a2:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    67a6:	ldrb	r5, [r4, #8]
    67a8:	str	r7, [sp, #84]	; 0x54
    67aa:	cmp	r5, #0
    67ac:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    67b0:	mov	r2, r6
    67b2:	add	r1, sp, #84	; 0x54
    67b4:	mov	r0, r4
    67b6:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    67ba:	ldrb	r3, [r4, #8]
    67bc:	strb.w	r5, [sp, #8]
    67c0:	cmp	r3, #0
    67c2:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    67c6:	mov	r0, r4
    67c8:	movs	r2, #1
    67ca:	add	r1, sp, #8
    67cc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    67d0:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    67d2:	ldrb	r3, [r0, #8]
    67d4:	movw	r2, #56324	; 0xdc04
    67d8:	strh.w	r2, [sp, #46]	; 0x2e
    67dc:	cmp	r3, #0
    67de:	beq.w	6a58 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x428>
      write_length_ += len;
    67e2:	ldr	r3, [r0, #12]
    67e4:	adds	r3, #2
    67e6:	str	r3, [r0, #12]
    67e8:	adds	r3, #2
    67ea:	str	r3, [r4, #12]
    67ec:	adds	r3, #1
    67ee:	str	r3, [r4, #12]
    67f0:	adds	r3, #8
    67f2:	str	r3, [r4, #12]
    67f4:	b.n	66f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    67f6:	ldrb	r3, [r0, #8]
    67f8:	movw	r2, #56327	; 0xdc07
    67fc:	strh.w	r2, [sp, #50]	; 0x32
    6800:	cmp	r3, #0
    6802:	bne.w	66de <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    6806:	movs	r2, #2
    6808:	add.w	r1, sp, #50	; 0x32
    680c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6810:	ldrb	r3, [r4, #8]
    6812:	movw	r2, #65535	; 0xffff
    6816:	strh.w	r2, [sp, #48]	; 0x30
    681a:	cmp	r3, #0
    681c:	bne.w	6cea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    6820:	movs	r2, #2
    6822:	add	r1, sp, #48	; 0x30
    6824:	mov	r0, r4
    6826:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    682a:	ldrb	r6, [r4, #8]
    682c:	movs	r5, #1
    682e:	strb.w	r5, [sp, #14]
    6832:	cmp	r6, #0
    6834:	bne.w	6ce6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6838:	mov	r2, r5
    683a:	add.w	r1, sp, #14
    683e:	mov	r0, r4
    6840:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6844:	ldrb	r7, [r4, #8]
    6846:	strb.w	r6, [sp, #13]
    684a:	cmp	r7, #0
    684c:	bne.w	6cf6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    6850:	mov	r2, r5
    6852:	add.w	r1, sp, #13
    6856:	mov	r0, r4
    6858:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    685c:	ldrb	r6, [r4, #8]
    685e:	str	r7, [sp, #92]	; 0x5c
    6860:	cmp	r6, #0
    6862:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6866:	movs	r2, #4
    6868:	add	r1, sp, #92	; 0x5c
    686a:	mov	r0, r4
    686c:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6870:	ldrb	r3, [r4, #8]
    6872:	strb.w	r6, [sp, #12]
    6876:	cmp	r3, #0
    6878:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    687c:	mov	r2, r5
    687e:	mov	r0, r4
    6880:	add	r1, sp, #12
    6882:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6886:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6888:	ldrb	r3, [r0, #8]
    688a:	movw	r2, #56328	; 0xdc08
    688e:	strh.w	r2, [sp, #54]	; 0x36
    6892:	cmp	r3, #0
    6894:	bne.w	66de <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    6898:	movs	r2, #2
    689a:	add.w	r1, sp, #54	; 0x36
    689e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    68a2:	ldrb	r6, [r4, #8]
    68a4:	movw	r3, #65535	; 0xffff
    68a8:	strh.w	r3, [sp, #52]	; 0x34
    68ac:	cmp	r6, #0
    68ae:	bne.w	6cea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    68b2:	movs	r2, #2
    68b4:	add	r1, sp, #52	; 0x34
    68b6:	mov	r0, r4
    68b8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    68bc:	ldrb	r5, [r4, #8]
    68be:	strb.w	r6, [sp, #17]
    68c2:	cmp	r5, #0
    68c4:	bne.w	6ce6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    68c8:	movs	r2, #1
    68ca:	add.w	r1, sp, #17
    68ce:	mov	r0, r4
    68d0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    68d4:	ldrb	r6, [r4, #8]
    68d6:	strb.w	r5, [sp, #16]
    68da:	cmp	r6, #0
    68dc:	bne.w	6cf6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    68e0:	movs	r2, #1
    68e2:	add	r1, sp, #16
    68e4:	mov	r0, r4
    68e6:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    68ea:	ldrb	r5, [r4, #8]
    68ec:	str	r6, [sp, #96]	; 0x60
    68ee:	cmp	r5, #0
    68f0:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    68f4:	movs	r2, #4
    68f6:	add	r1, sp, #96	; 0x60
    68f8:	mov	r0, r4
    68fa:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    68fe:	ldrb	r3, [r4, #8]
    6900:	strb.w	r5, [sp, #15]
    6904:	cmp	r3, #0
    6906:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    690a:	mov	r0, r4
    690c:	movs	r2, #1
    690e:	add.w	r1, sp, #15
    6912:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6916:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6918:	ldrb	r3, [r0, #8]
    691a:	movw	r2, #56329	; 0xdc09
    691e:	strh.w	r2, [sp, #58]	; 0x3a
    6922:	cmp	r3, #0
    6924:	bne.w	66de <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    6928:	movs	r2, #2
    692a:	add.w	r1, sp, #58	; 0x3a
    692e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6932:	ldrb	r6, [r4, #8]
    6934:	movw	r3, #65535	; 0xffff
    6938:	strh.w	r3, [sp, #56]	; 0x38
    693c:	cmp	r6, #0
    693e:	bne.w	6cea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    6942:	movs	r2, #2
    6944:	add	r1, sp, #56	; 0x38
    6946:	mov	r0, r4
    6948:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    694c:	ldrb	r5, [r4, #8]
    694e:	strb.w	r6, [sp, #20]
    6952:	cmp	r5, #0
    6954:	bne.w	6ce6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6958:	movs	r2, #1
    695a:	add	r1, sp, #20
    695c:	mov	r0, r4
    695e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6962:	ldrb	r6, [r4, #8]
    6964:	strb.w	r5, [sp, #19]
    6968:	cmp	r6, #0
    696a:	bne.w	6cf6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    696e:	movs	r2, #1
    6970:	add.w	r1, sp, #19
    6974:	mov	r0, r4
    6976:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    697a:	ldrb	r5, [r4, #8]
    697c:	str	r6, [sp, #100]	; 0x64
    697e:	cmp	r5, #0
    6980:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6984:	movs	r2, #4
    6986:	add	r1, sp, #100	; 0x64
    6988:	mov	r0, r4
    698a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    698e:	ldrb	r3, [r4, #8]
    6990:	strb.w	r5, [sp, #18]
    6994:	cmp	r3, #0
    6996:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    699a:	mov	r0, r4
    699c:	movs	r2, #1
    699e:	add.w	r1, sp, #18
    69a2:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    69a6:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    69a8:	ldrb	r3, [r0, #8]
    69aa:	movw	r2, #56331	; 0xdc0b
    69ae:	strh.w	r2, [sp, #62]	; 0x3e
    69b2:	cmp	r3, #0
    69b4:	bne.w	670e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde>
    69b8:	movs	r2, #2
    69ba:	add.w	r1, sp, #62	; 0x3e
    69be:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    69c2:	ldrb	r6, [r4, #8]
    69c4:	movs	r3, #6
    69c6:	strh.w	r3, [sp, #60]	; 0x3c
    69ca:	cmp	r6, #0
    69cc:	bne.w	6ce2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    69d0:	movs	r2, #2
    69d2:	add	r1, sp, #60	; 0x3c
    69d4:	mov	r0, r4
    69d6:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    69da:	ldrb	r5, [r4, #8]
    69dc:	strb.w	r6, [sp, #22]
    69e0:	cmp	r5, #0
    69e2:	bne.w	6cde <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    69e6:	movs	r2, #1
    69e8:	add.w	r1, sp, #22
    69ec:	mov	r0, r4
    69ee:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    69f2:	ldrb	r6, [r4, #8]
    69f4:	str	r5, [sp, #108]	; 0x6c
    69f6:	cmp	r6, #0
    69f8:	bne.w	6cda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    69fc:	movs	r2, #4
    69fe:	add	r1, sp, #108	; 0x6c
    6a00:	mov	r0, r4
    6a02:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a06:	ldrb	r5, [r4, #8]
    6a08:	str	r6, [sp, #104]	; 0x68
    6a0a:	cmp	r5, #0
    6a0c:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6a10:	movs	r2, #4
    6a12:	add	r1, sp, #104	; 0x68
    6a14:	mov	r0, r4
    6a16:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a1a:	ldrb	r3, [r4, #8]
    6a1c:	strb.w	r5, [sp, #21]
    6a20:	cmp	r3, #0
    6a22:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6a26:	mov	r0, r4
    6a28:	movs	r2, #1
    6a2a:	add.w	r1, sp, #21
    6a2e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a32:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6a34:	ldrb	r3, [r0, #8]
    6a36:	movw	r2, #56385	; 0xdc41
    6a3a:	strh.w	r2, [sp, #66]	; 0x42
    6a3e:	cmp	r3, #0
    6a40:	beq.w	6bda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5aa>
      write_length_ += len;
    6a44:	ldr	r3, [r0, #12]
    6a46:	adds	r3, #2
    6a48:	str	r3, [r0, #12]
    6a4a:	adds	r3, #2
    6a4c:	str	r3, [r4, #12]
    6a4e:	adds	r3, #1
    6a50:	str	r3, [r4, #12]
    6a52:	adds	r3, #8
    6a54:	str	r3, [r4, #12]
    6a56:	b.n	67f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    6a58:	movs	r2, #2
    6a5a:	add.w	r1, sp, #46	; 0x2e
    6a5e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a62:	ldrb	r6, [r4, #8]
    6a64:	movs	r5, #8
    6a66:	strh.w	r5, [sp, #44]	; 0x2c
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6a6a:	cmp	r6, #0
    6a6c:	bne.w	6cf2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c2>
    6a70:	movs	r2, #2
    6a72:	add	r1, sp, #44	; 0x2c
    6a74:	mov	r0, r4
    6a76:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a7a:	ldrb	r3, [r4, #8]
    6a7c:	strb.w	r6, [sp, #11]
    6a80:	cmp	r3, #0
    6a82:	bne.w	6cee <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6be>
    6a86:	movs	r2, #1
    6a88:	add.w	r1, sp, #11
    6a8c:	mov	r0, r4
    6a8e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6a92:	ldrb	r6, [r4, #8]
    6a94:	movs	r2, #0
    6a96:	movs	r3, #0
    6a98:	strd	r2, r3, [sp, #120]	; 0x78
    6a9c:	cmp	r6, #0
    6a9e:	bne.w	6d06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    6aa2:	mov	r2, r5
    6aa4:	add	r1, sp, #120	; 0x78
    6aa6:	mov	r0, r4
    6aa8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6aac:	ldrb	r5, [r4, #8]
    6aae:	str	r6, [sp, #88]	; 0x58
    6ab0:	cmp	r5, #0
    6ab2:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6ab6:	movs	r2, #4
    6ab8:	add	r1, sp, #88	; 0x58
    6aba:	mov	r0, r4
    6abc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6ac0:	ldrb	r3, [r4, #8]
    6ac2:	strb.w	r5, [sp, #10]
    6ac6:	cmp	r3, #0
    6ac8:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6acc:	mov	r0, r4
    6ace:	movs	r2, #1
    6ad0:	add.w	r1, sp, #10
    6ad4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6ad8:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6ada:	movs	r2, #2
    6adc:	add	r1, sp, #36	; 0x24
    6ade:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6ae2:	ldrb	r7, [r4, #8]
    6ae4:	movs	r6, #4
    6ae6:	strh.w	r6, [sp, #34]	; 0x22
    6aea:	cmp	r7, #0
    6aec:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    6af0:	movs	r2, #2
    6af2:	add.w	r1, sp, #34	; 0x22
    6af6:	mov	r0, r4
    6af8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6afc:	ldrb	r5, [r4, #8]
    6afe:	strb.w	r7, [sp, #7]
    6b02:	cmp	r5, #0
    6b04:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    6b08:	movs	r2, #1
    6b0a:	add.w	r1, sp, #7
    6b0e:	mov	r0, r4
    6b10:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b14:	ldrb	r7, [r4, #8]
    6b16:	strh.w	r5, [sp, #32]
    6b1a:	cmp	r7, #0
    6b1c:	bne.w	6cfa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    6b20:	movs	r2, #2
    6b22:	add	r1, sp, #32
    6b24:	mov	r0, r4
    6b26:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b2a:	ldrb	r5, [r4, #8]
    6b2c:	str	r7, [sp, #80]	; 0x50
    6b2e:	cmp	r5, #0
    6b30:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6b34:	mov	r2, r6
    6b36:	add	r1, sp, #80	; 0x50
    6b38:	mov	r0, r4
    6b3a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b3e:	ldrb	r3, [r4, #8]
    6b40:	strb.w	r5, [sp, #6]
    6b44:	cmp	r3, #0
    6b46:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6b4a:	mov	r0, r4
    6b4c:	movs	r2, #1
    6b4e:	add.w	r1, sp, #6
    6b52:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b56:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6b58:	movs	r2, #2
    6b5a:	add.w	r1, sp, #70	; 0x46
    6b5e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b62:	ldrb	r6, [r4, #8]
    6b64:	movw	r3, #65535	; 0xffff
    6b68:	strh.w	r3, [sp, #68]	; 0x44
    6b6c:	cmp	r6, #0
    6b6e:	bne.w	6cea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    6b72:	movs	r2, #2
    6b74:	add	r1, sp, #68	; 0x44
    6b76:	mov	r0, r4
    6b78:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b7c:	ldrb	r5, [r4, #8]
    6b7e:	strb.w	r6, [sp, #27]
    6b82:	cmp	r5, #0
    6b84:	bne.w	6ce6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6b88:	movs	r2, #1
    6b8a:	add.w	r1, sp, #27
    6b8e:	mov	r0, r4
    6b90:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6b94:	ldrb	r6, [r4, #8]
    6b96:	strb.w	r5, [sp, #26]
    6b9a:	cmp	r6, #0
    6b9c:	bne.w	6cf6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    6ba0:	movs	r2, #1
    6ba2:	add.w	r1, sp, #26
    6ba6:	mov	r0, r4
    6ba8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6bac:	ldrb	r5, [r4, #8]
    6bae:	str	r6, [sp, #116]	; 0x74
    6bb0:	cmp	r5, #0
    6bb2:	bne.w	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6bb6:	movs	r2, #4
    6bb8:	add	r1, sp, #116	; 0x74
    6bba:	mov	r0, r4
    6bbc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6bc0:	ldrb	r3, [r4, #8]
    6bc2:	strb.w	r5, [sp, #25]
    6bc6:	cmp	r3, #0
    6bc8:	bne.w	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6bcc:	mov	r0, r4
    6bce:	movs	r2, #1
    6bd0:	add.w	r1, sp, #25
    6bd4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6bd8:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6bda:	movs	r2, #2
    6bdc:	add.w	r1, sp, #66	; 0x42
    6be0:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6be4:	ldrb	r5, [r4, #8]
    6be6:	movs	r3, #10
    6be8:	strh.w	r3, [sp, #64]	; 0x40
    6bec:	cmp	r5, #0
    6bee:	bne.w	6d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6e2>
    6bf2:	movs	r2, #2
    6bf4:	add	r1, sp, #64	; 0x40
    6bf6:	mov	r0, r4
    6bf8:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6bfc:	ldrb	r3, [r4, #8]
    6bfe:	strb.w	r5, [sp, #24]
    6c02:	cmp	r3, #0
    6c04:	bne.w	6d0e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6de>
    6c08:	movs	r2, #1
    6c0a:	add	r1, sp, #24
    6c0c:	mov	r0, r4
    6c0e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c12:	ldrb	r3, [r4, #8]
    6c14:	mov.w	r8, #0
    6c18:	mov.w	r9, #0
    6c1c:	strd	r8, r9, [sp, #136]	; 0x88
    6c20:	cmp	r3, #0
    6c22:	bne.n	6d0a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6da>
    6c24:	movs	r2, #8
    6c26:	add	r1, sp, #136	; 0x88
    6c28:	mov	r0, r4
    6c2a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c2e:	ldrb	r6, [r4, #8]
    6c30:	strd	r8, r9, [sp, #128]	; 0x80
    6c34:	cmp	r6, #0
    6c36:	bne.n	6d06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    6c38:	movs	r2, #8
    6c3a:	add	r1, sp, #128	; 0x80
    6c3c:	mov	r0, r4
    6c3e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c42:	ldrb	r5, [r4, #8]
    6c44:	str	r6, [sp, #112]	; 0x70
    6c46:	cmp	r5, #0
    6c48:	bne.n	6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6c4a:	movs	r2, #4
    6c4c:	add	r1, sp, #112	; 0x70
    6c4e:	mov	r0, r4
    6c50:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c54:	ldrb	r3, [r4, #8]
    6c56:	strb.w	r5, [sp, #23]
    6c5a:	cmp	r3, #0
    6c5c:	bne.n	6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6c5e:	mov	r0, r4
    6c60:	movs	r2, #1
    6c62:	add.w	r1, sp, #23
    6c66:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c6a:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6c6c:	movs	r2, #2
    6c6e:	add.w	r1, sp, #30
    6c72:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c76:	ldrb	r6, [r4, #8]
    6c78:	movs	r3, #6
    6c7a:	strh.w	r3, [sp, #28]
    6c7e:	cbnz	r6, 6ce2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    6c80:	movs	r2, #2
    6c82:	add	r1, sp, #28
    6c84:	mov	r0, r4
    6c86:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c8a:	ldrb	r5, [r4, #8]
    6c8c:	strb.w	r6, [sp, #5]
    6c90:	cbnz	r5, 6cde <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    6c92:	movs	r2, #1
    6c94:	add.w	r1, sp, #5
    6c98:	mov	r0, r4
    6c9a:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6c9e:	ldrb	r6, [r4, #8]
    6ca0:	str	r5, [sp, #76]	; 0x4c
    6ca2:	cbnz	r6, 6cda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    6ca4:	movs	r2, #4
    6ca6:	add	r1, sp, #76	; 0x4c
    6ca8:	mov	r0, r4
    6caa:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6cae:	ldrb	r5, [r4, #8]
    6cb0:	str	r6, [sp, #72]	; 0x48
    6cb2:	cbnz	r5, 6cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6cb4:	movs	r2, #4
    6cb6:	add	r1, sp, #72	; 0x48
    6cb8:	mov	r0, r4
    6cba:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6cbe:	ldrb	r3, [r4, #8]
    6cc0:	strb.w	r5, [sp, #4]
    6cc4:	cbnz	r3, 6cd2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6cc6:	mov	r0, r4
    6cc8:	movs	r2, #1
    6cca:	add	r1, sp, #4
    6ccc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    6cd0:	b.n	66f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6cd2:	ldr	r3, [r4, #12]
    6cd4:	b.n	66f4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc4>
    6cd6:	ldr	r3, [r4, #12]
    6cd8:	b.n	66f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
    6cda:	ldr	r3, [r4, #12]
    6cdc:	b.n	671c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xec>
    6cde:	ldr	r3, [r4, #12]
    6ce0:	b.n	6718 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe8>
    6ce2:	ldr	r3, [r4, #12]
    6ce4:	b.n	6714 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4>
    6ce6:	ldr	r3, [r4, #12]
    6ce8:	b.n	66e8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    6cea:	ldr	r3, [r4, #12]
    6cec:	b.n	66e4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
    6cee:	ldr	r3, [r4, #12]
    6cf0:	b.n	67ec <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bc>
    6cf2:	ldr	r3, [r4, #12]
    6cf4:	b.n	67e8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b8>
    6cf6:	ldr	r3, [r4, #12]
    6cf8:	b.n	66ec <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbc>
    6cfa:	ldr	r3, [r4, #12]
    6cfc:	b.n	6740 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x110>
    6cfe:	ldr	r3, [r4, #12]
    6d00:	b.n	673c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10c>
    6d02:	ldr	r3, [r4, #12]
    6d04:	b.n	6738 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x108>
    6d06:	ldr	r3, [r4, #12]
    6d08:	b.n	67f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    6d0a:	ldr	r3, [r4, #12]
    6d0c:	b.n	6a52 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x422>
    6d0e:	ldr	r3, [r4, #12]
    6d10:	b.n	6a4e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41e>
    6d12:	ldr	r3, [r4, #12]
    6d14:	b.n	6a4a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41a>
    6d16:	nop

00006d18 <MTPD::receive_buffer()>:
      data_buffer_ = usb_malloc();
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    6d18:	push	{r4, lr}
    6d1a:	mov	r4, r0
    6d1c:	ldr	r3, [r4, #4]
    while (!data_buffer_) {
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6d1e:	movs	r0, #5
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    while (!data_buffer_) {
    6d20:	cbnz	r3, 6d2a <MTPD::receive_buffer()+0x12>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6d22:	bl	da10 <usb_rx>
    6d26:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    6d28:	cbz	r0, 6d2c <MTPD::receive_buffer()+0x14>
    6d2a:	pop	{r4, pc}
    6d2c:	bl	2128 <mtp_yield()>
    6d30:	b.n	6d1c <MTPD::receive_buffer()+0x4>
    6d32:	nop

00006d34 <MTPD::GetObject(unsigned long)>:
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d34:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6d38:	mov	r6, r0
    uint32_t size = storage_->GetSize(object_id);
    6d3a:	ldr	r0, [r0, #0]
    6d3c:	ldr	r3, [r0, #0]
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d3e:	sub	sp, #8
    uint32_t size = storage_->GetSize(object_id);
    6d40:	ldr	r3, [r3, #40]	; 0x28
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d42:	mov	r8, r1
    uint32_t size = storage_->GetSize(object_id);
    6d44:	blx	r3
    if (write_get_length_) {
    6d46:	ldrb	r5, [r6, #8]
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    6d48:	mov	r7, r0
    if (write_get_length_) {
    6d4a:	cbnz	r5, 6da4 <MTPD::GetObject(unsigned long)+0x70>
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d4c:	cbz	r0, 6d9e <MTPD::GetObject(unsigned long)+0x6a>
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    6d4e:	mov	r9, r5
    6d50:	b.n	6d56 <MTPD::GetObject(unsigned long)+0x22>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d52:	cmp	r7, r5
    6d54:	bls.n	6d9e <MTPD::GetObject(unsigned long)+0x6a>
        get_buffer();
    6d56:	mov	r0, r6
    6d58:	bl	5b40 <MTPD::get_buffer()>
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
    6d5c:	ldmia.w	r6, {r0, r3}
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
        get_buffer();
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    6d60:	ldrh.w	r2, [r3], #8
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
    6d64:	ldr	r1, [r0, #0]
    6d66:	subs	r4, r7, r5
    6d68:	rsb	lr, r2, #64	; 0x40
    6d6c:	cmp	r4, lr
    6d6e:	it	cs
    6d70:	movcs	r4, lr
    6d72:	str	r4, [sp, #0]
    6d74:	add	r3, r2
    6d76:	ldr.w	sl, [r1, #48]	; 0x30
    6d7a:	mov	r2, r5
    6d7c:	mov	r1, r8
    6d7e:	blx	sl
        pos += to_copy;
        data_buffer_->len += to_copy;
    6d80:	ldr	r1, [r6, #4]
    6d82:	ldrh	r3, [r1, #0]
    6d84:	add	r3, r4
    6d86:	uxth	r3, r3
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6d88:	cmp	r3, #64	; 0x40
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
    6d8a:	add	r5, r4
        data_buffer_->len += to_copy;
    6d8c:	strh	r3, [r1, #0]
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6d8e:	bne.n	6d52 <MTPD::GetObject(unsigned long)+0x1e>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    6d90:	movs	r0, #4
    6d92:	bl	dafc <usb_tx>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d96:	cmp	r7, r5
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    6d98:	str.w	r9, [r6, #4]
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d9c:	bhi.n	6d56 <MTPD::GetObject(unsigned long)+0x22>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    6d9e:	add	sp, #8
    6da0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    6da4:	ldr	r3, [r6, #12]
    6da6:	add	r7, r3
    6da8:	str	r7, [r6, #12]
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    6daa:	add	sp, #8
    6dac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00006db0 <MTPD::read(char*, unsigned long)>:
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6db0:	cbz	r2, 6e1c <MTPD::read(char*, unsigned long)+0x6c>
      if(CONTAINER->len>20) printf(" %x", CONTAINER->params[2]); \
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    6db2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6db6:	mov	r6, r0
    6db8:	mov	r5, r1
    while (size) {
    6dba:	mov	r8, r2
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    6dbc:	movs	r7, #0
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
      receive_buffer();
    6dbe:	mov	r0, r6
    6dc0:	bl	6d18 <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    6dc4:	ldr	r3, [r6, #4]
    6dc6:	ldrh.w	lr, [r3, #2]
    6dca:	ldrh.w	ip, [r3]
    6dce:	rsb	r4, lr, ip
    6dd2:	cmp	r4, r8
    6dd4:	it	cs
    6dd6:	movcs	r4, r8
      to_copy = min(to_copy, size);
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    6dd8:	add.w	r1, r3, #8
    6ddc:	add	r1, lr
    6dde:	mov	r0, r5
    6de0:	mov	r2, r4
        data += to_copy;
      }
      size -= to_copy;
    6de2:	rsb	r8, r4, r8
  {
    while (size) {
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, size);
      if (data) {
    6de6:	cbz	r5, 6df8 <MTPD::read(char*, unsigned long)+0x48>
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    6de8:	bl	cb10 <memcpy>
    6dec:	ldr	r3, [r6, #4]
    6dee:	ldrh.w	lr, [r3, #2]
    6df2:	ldrh.w	ip, [r3]
        data += to_copy;
    6df6:	add	r5, r4
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    6df8:	add	r4, lr
    6dfa:	uxth	r4, r4
      if (data_buffer_->index == data_buffer_->len) {
    6dfc:	cmp	ip, r4
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    6dfe:	strh	r4, [r3, #2]
      if (data_buffer_->index == data_buffer_->len) {
    6e00:	beq.n	6e0c <MTPD::read(char*, unsigned long)+0x5c>
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6e02:	cmp.w	r8, #0
    6e06:	bne.n	6dbe <MTPD::read(char*, unsigned long)+0xe>
    6e08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
    6e0c:	mov	r0, r3
    6e0e:	bl	d9c4 <usb_free>
        data_buffer_ = NULL;
    6e12:	str	r7, [r6, #4]
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6e14:	cmp.w	r8, #0
    6e18:	bne.n	6dbe <MTPD::read(char*, unsigned long)+0xe>
    6e1a:	b.n	6e08 <MTPD::read(char*, unsigned long)+0x58>
    6e1c:	bx	lr
    6e1e:	nop

00006e20 <MTPD::readstring(char*)>:

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e20:	push	{r4, r5, r6, lr}
    6e22:	sub	sp, #8
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e24:	movs	r2, #1
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e26:	mov	r4, r1
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e28:	add.w	r1, sp, #6
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e2c:	mov	r6, r0
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e2e:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6e32:	ldrb.w	r2, [sp, #6]
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
    6e36:	cbz	r4, 6e58 <MTPD::readstring(char*)+0x38>
    6e38:	adds	r5, r4, r2
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    6e3a:	cbz	r2, 6e54 <MTPD::readstring(char*)+0x34>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6e3c:	movs	r2, #2
    6e3e:	add.w	r1, sp, #6
    6e42:	mov	r0, r6
    6e44:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6e48:	ldrh.w	r3, [sp, #6]
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
        int16_t c2;
        *(buffer++) = c2 = read16();
    6e4c:	strb.w	r3, [r4], #1
  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    6e50:	cmp	r5, r4
    6e52:	bne.n	6e3c <MTPD::readstring(char*)+0x1c>
        int16_t c2;
        *(buffer++) = c2 = read16();
      }
    }
  }
    6e54:	add	sp, #8
    6e56:	pop	{r4, r5, r6, pc}
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    6e58:	lsls	r2, r2, #1
    6e5a:	mov	r1, r4
    6e5c:	mov	r0, r6
    6e5e:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6e62:	b.n	6e54 <MTPD::readstring(char*)+0x34>

00006e64 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>:
    }
    storage_->close();
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    6e64:	push	{r4, r5, lr}
    6e66:	sub	sp, #260	; 0x104
    6e68:	mov	r4, r0
    6e6a:	mov	r5, r1
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6e6c:	movs	r2, #12
    6e6e:	mov	r1, sp
    6e70:	bl	6db0 <MTPD::read(char*, unsigned long)>
      receive_buffer();
      if(p2==0xDC07)
      {
        char filename[MAX_FILENAME_LEN];
        ReadMTPHeader();
        readstring(filename);
    6e74:	mov	r1, sp
    6e76:	mov	r0, r4
    6e78:	bl	6e20 <MTPD::readstring(char*)>

        storage_->rename(p1,filename);
    6e7c:	ldr	r0, [r4, #0]
    6e7e:	ldr	r3, [r0, #0]
    6e80:	mov	r2, sp
    6e82:	mov	r1, r5
    6e84:	ldr	r3, [r3, #72]	; 0x48
    6e86:	blx	r3

        return 0x2001;
      }
      else
        return 0x2005;
    }
    6e88:	movw	r0, #8193	; 0x2001
    6e8c:	add	sp, #260	; 0x104
    6e8e:	pop	{r4, r5, pc}

00006e90 <MTPD::SendObjectInfo(unsigned long, unsigned long)>:
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6e90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6e94:	sub	sp, #276	; 0x114
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6e96:	add	r7, sp, #16
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6e98:	mov	r9, r1
    6e9a:	mov	fp, r2
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6e9c:	mov	r1, r7
    6e9e:	movs	r2, #12
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6ea0:	mov	r5, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ea2:	bl	6db0 <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    6ea6:	ldrh	r3, [r7, #4]
    6ea8:	cmp	r3, #2
    6eaa:	it	eq
    6eac:	ldreq	r4, [r7, #0]
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6eae:	mov.w	r2, #4
    6eb2:	mov	r1, r7
    6eb4:	mov	r0, r5
    6eb6:	ite	eq
    6eb8:	subeq	r4, #65	; 0x41
  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
    6eba:	mvnne.w	r4, #52	; 0x34
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ebe:	bl	6db0 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ec2:	movs	r2, #2
    6ec4:	mov	r1, r7
    6ec6:	mov	r0, r5
    6ec8:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6ecc:	ldrh.w	sl, [r7]
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6ed0:	movw	r3, #12289	; 0x3001
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ed4:	movs	r2, #2
    6ed6:	mov	r1, r7
    6ed8:	mov	r0, r5
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6eda:	rsb	sl, r3, sl
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ede:	bl	6db0 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ee2:	movs	r2, #4
    6ee4:	mov	r1, r7
    6ee6:	mov	r0, r5
    6ee8:	bl	6db0 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6eec:	movs	r2, #2
    6eee:	mov	r1, r7
    6ef0:	mov	r0, r5
    6ef2:	bl	6db0 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6ef6:	movs	r2, #4
    6ef8:	mov	r1, r7
    6efa:	mov	r0, r5
    6efc:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f00:	movs	r2, #4
    6f02:	mov	r1, r7
    6f04:	mov	r0, r5
    6f06:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f0a:	movs	r2, #4
    6f0c:	mov	r1, r7
    6f0e:	mov	r0, r5
    6f10:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f14:	movs	r2, #4
    6f16:	mov	r1, r7
    6f18:	mov	r0, r5
    6f1a:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f1e:	movs	r2, #4
    6f20:	mov	r1, r7
    6f22:	mov	r0, r5
    6f24:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f28:	movs	r2, #4
    6f2a:	mov	r1, r7
    6f2c:	mov	r0, r5
    6f2e:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f32:	movs	r2, #4
    6f34:	mov	r1, r7
    6f36:	mov	r0, r5
    6f38:	bl	6db0 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f3c:	movs	r2, #2
    6f3e:	mov	r1, r7
    6f40:	mov	r0, r5
    6f42:	bl	6db0 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f46:	movs	r2, #4
    6f48:	mov	r1, r7
    6f4a:	mov	r0, r5
    6f4c:	bl	6db0 <MTPD::read(char*, unsigned long)>
    6f50:	movs	r2, #4
    6f52:	mov	r1, r7
    6f54:	mov	r0, r5
    6f56:	bl	6db0 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // parent
    read16(); len-=2; // association type
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    6f5a:	mov	r1, r7
    6f5c:	mov	r0, r5
    6f5e:	bl	6e20 <MTPD::readstring(char*)>
    6f62:	mov	r0, r7
    6f64:	bl	10d40 <strlen>
    6f68:	adds	r0, #1
    6f6a:	sub.w	r4, r4, r0, lsl #1
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6f6e:	clz	sl, sl
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6f72:	cmp	r4, #3
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6f74:	mov.w	sl, sl, lsr #5

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    uint32_t len = ReadMTPHeader();
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);
    6f78:	add.w	r9, r9, #4294967295
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6f7c:	bls.n	6f98 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x108>
    6f7e:	mov	r6, r4
    6f80:	add.w	r8, sp, #12
    6f84:	subs	r6, #4
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f86:	movs	r2, #4
    6f88:	mov	r1, r8
    6f8a:	mov	r0, r5
    6f8c:	bl	6db0 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6f90:	cmp	r6, #3
    6f92:	bhi.n	6f84 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0xf4>
    6f94:	and.w	r4, r4, #3
    6f98:	add.w	r8, sp, #12
    while(len) {read8(); len--;}
    6f9c:	cbz	r4, 6fac <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x11c>
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6f9e:	movs	r2, #1
    6fa0:	mov	r1, r8
    6fa2:	mov	r0, r5
    6fa4:	bl	6db0 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    while(len) {read8(); len--;}
    6fa8:	subs	r4, #1
    6faa:	bne.n	6f9e <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x10e>
    
    return storage_->Create(store, parent, dir, filename);
    6fac:	ldr	r0, [r5, #0]
    6fae:	ldr	r4, [r0, #0]
    6fb0:	str	r7, [sp, #0]
    6fb2:	mov	r3, sl
    6fb4:	mov	r2, fp
    6fb6:	mov	r1, r9
    6fb8:	ldr	r4, [r4, #44]	; 0x2c
    6fba:	blx	r4
  }
    6fbc:	add	sp, #276	; 0x114
    6fbe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6fc2:	nop

00006fc4 <MTPD::SendObject()>:

  bool MTPD::SendObject() {
    6fc4:	push	{r4, r5, r6, r7, lr}
    6fc6:	sub	sp, #20
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6fc8:	movs	r2, #12
    6fca:	add	r1, sp, #4
    while(len) {read8(); len--;}
    
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    6fcc:	mov	r6, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6fce:	bl	6db0 <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    6fd2:	ldrh.w	r3, [sp, #8]
    6fd6:	cmp	r3, #2
    6fd8:	beq.n	6fe8 <MTPD::SendObject()+0x24>
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
      }
    }
    storage_->close();
    6fda:	ldr	r0, [r6, #0]
    6fdc:	ldr	r3, [r0, #0]
    6fde:	ldr	r3, [r3, #56]	; 0x38
    6fe0:	blx	r3
    return true;
    6fe2:	movs	r0, #1
  }
    6fe4:	add	sp, #20
    6fe6:	pop	{r4, r5, r6, r7, pc}
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
      return header.len - 12;
    6fe8:	ldr	r7, [sp, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    6fea:	subs	r7, #12
    6fec:	beq.n	6fda <MTPD::SendObject()+0x16>
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    6fee:	movs	r5, #0

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
    6ff0:	mov	r0, r6
    6ff2:	bl	6d18 <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    6ff6:	ldmia.w	r6, {r0, r1}
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    6ffa:	ldrh	r2, [r1, #2]
    6ffc:	ldrh.w	r4, [r1], #8
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    7000:	ldr	r3, [r0, #0]
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    7002:	subs	r4, r4, r2
    7004:	cmp	r4, r7
    7006:	it	cs
    7008:	movcs	r4, r7
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    700a:	add	r1, r2
    700c:	ldr	r3, [r3, #52]	; 0x34
    700e:	mov	r2, r4
    7010:	blx	r3
      data_buffer_->index += to_copy;
      len -= to_copy;
    7012:	subs	r7, r7, r4
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    7014:	cmp	r0, #0
    7016:	beq.n	6fe4 <MTPD::SendObject()+0x20>
      data_buffer_->index += to_copy;
    7018:	ldr	r0, [r6, #4]
    701a:	ldrh	r3, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    701c:	ldrh	r2, [r0, #0]
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    701e:	add	r4, r3
    7020:	uxth	r4, r4
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    7022:	cmp	r2, r4
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    7024:	strh	r4, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    7026:	beq.n	702e <MTPD::SendObject()+0x6a>
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    7028:	cmp	r7, #0
    702a:	bne.n	6ff0 <MTPD::SendObject()+0x2c>
    702c:	b.n	6fda <MTPD::SendObject()+0x16>
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
    702e:	bl	d9c4 <usb_free>
        data_buffer_ = NULL;
    7032:	str	r5, [r6, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    7034:	cmp	r7, #0
    7036:	bne.n	6ff0 <MTPD::SendObject()+0x2c>
    7038:	b.n	6fda <MTPD::SendObject()+0x16>
    703a:	nop

0000703c <MTPD::loop()>:
      else
        return 0x2005;
    }

  void MTPD::loop(void) 
  {
    703c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7040:	mov	r5, r0
    7042:	sub	sp, #36	; 0x24
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
    7044:	movs	r0, #5
    7046:	bl	da10 <usb_rx>
    704a:	cmp	r0, #0
    704c:	beq.n	70b2 <MTPD::loop()+0x76>
      printContainer();
    704e:	ldr	r1, [r0, #16]
    7050:	ldr	r3, [r0, #8]
    7052:	ldrh	r2, [r0, #14]
    7054:	str	r1, [sp, #4]
    7056:	ldrh	r1, [r0, #12]
    7058:	str	r1, [sp, #0]
    705a:	mov	r4, r0
    705c:	ldr	r1, [pc, #764]	; (735c <MTPD::loop()+0x320>)
    705e:	ldr	r0, [pc, #768]	; (7360 <MTPD::loop()+0x324>)
    7060:	bl	e7ec <Print::printf(char const*, ...)>
    7064:	ldr	r3, [r4, #8]
    7066:	cmp	r3, #12
    7068:	bhi.n	70fa <MTPD::loop()+0xbe>
    706a:	ldr	r1, [pc, #760]	; (7364 <MTPD::loop()+0x328>)
    706c:	ldr	r0, [pc, #752]	; (7360 <MTPD::loop()+0x324>)
    706e:	bl	e7ec <Print::printf(char const*, ...)>
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    7072:	ldrh	r2, [r4, #0]
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
    7074:	ldr	r6, [r4, #16]
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
    7076:	ldrh	r0, [r4, #14]
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
    7078:	ldr	r7, [r4, #8]
        int typ= CONTAINER->type;
    707a:	ldrh	r1, [r4, #12]
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    707c:	add.w	r3, r4, #20
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    7080:	cmp	r2, #11
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    7082:	ldmia.w	r3, {r3, r9, fp}
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;
    7086:	str	r6, [r5, #16]

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    7088:	bls.n	70f2 <MTPD::loop()+0xb6>
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    708a:	mov.w	sl, #12
        
        if (typ == 1) { // command
    708e:	cmp	r1, #1
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    7090:	strh.w	sl, [r4]
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    7094:	mov	r8, r3
      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
    7096:	beq.n	7152 <MTPD::loop()+0x116>
    7098:	mov.w	r0, #8192	; 0x2000
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    709c:	movs	r3, #3
        CONTAINER->len=len;
        CONTAINER->op=return_code;
    709e:	strh	r0, [r4, #14]
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
        CONTAINER->len=len;
    70a0:	str	r7, [r4, #8]
        CONTAINER->op=return_code;
        CONTAINER->transaction_id=id;
    70a2:	str	r6, [r4, #16]
        CONTAINER->params[0]=p1;
    70a4:	str.w	r8, [r4, #20]
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    70a8:	strh	r3, [r4, #12]
        CONTAINER->params[0]=p1;
        #if DEBUG>1
          printContainer();
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
    70aa:	mov	r1, r4
    70ac:	movs	r0, #4
    70ae:	bl	dafc <usb_tx>
      } else {
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
    70b2:	movs	r0, #6
    70b4:	bl	da10 <usb_rx>
    70b8:	mov	r4, r0
    70ba:	cbz	r0, 70ec <MTPD::loop()+0xb0>
      printf("Event: "); printContainer();
    70bc:	ldr	r1, [pc, #680]	; (7368 <MTPD::loop()+0x32c>)
    70be:	ldr	r0, [pc, #672]	; (7360 <MTPD::loop()+0x324>)
    70c0:	bl	e7ec <Print::printf(char const*, ...)>
    70c4:	ldr	r1, [r4, #16]
    70c6:	ldr	r3, [r4, #8]
    70c8:	ldrh	r2, [r4, #14]
    70ca:	str	r1, [sp, #4]
    70cc:	ldrh	r1, [r4, #12]
    70ce:	str	r1, [sp, #0]
    70d0:	ldr	r0, [pc, #652]	; (7360 <MTPD::loop()+0x324>)
    70d2:	ldr	r1, [pc, #648]	; (735c <MTPD::loop()+0x320>)
    70d4:	bl	e7ec <Print::printf(char const*, ...)>
    70d8:	ldr	r3, [r4, #8]
    70da:	cmp	r3, #12
    70dc:	bhi.n	7126 <MTPD::loop()+0xea>
    70de:	ldr	r1, [pc, #644]	; (7364 <MTPD::loop()+0x328>)
    70e0:	ldr	r0, [pc, #636]	; (7360 <MTPD::loop()+0x324>)
    70e2:	bl	e7ec <Print::printf(char const*, ...)>
      usb_free(receive_buffer);
    70e6:	mov	r0, r4
    70e8:	bl	d9c4 <usb_free>
    }
  }
    70ec:	add	sp, #36	; 0x24
    70ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
        receive_buffer = 0;
      } else {
          usb_free(receive_buffer);
    70f2:	mov	r0, r4
    70f4:	bl	d9c4 <usb_free>
    70f8:	b.n	70b2 <MTPD::loop()+0x76>

  void MTPD::loop(void) 
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
    70fa:	ldr	r2, [r4, #20]
    70fc:	ldr	r1, [pc, #620]	; (736c <MTPD::loop()+0x330>)
    70fe:	ldr	r0, [pc, #608]	; (7360 <MTPD::loop()+0x324>)
    7100:	bl	e7ec <Print::printf(char const*, ...)>
    7104:	ldr	r3, [r4, #8]
    7106:	cmp	r3, #16
    7108:	bls.n	706a <MTPD::loop()+0x2e>
    710a:	ldr	r2, [r4, #24]
    710c:	ldr	r1, [pc, #604]	; (736c <MTPD::loop()+0x330>)
    710e:	ldr	r0, [pc, #592]	; (7360 <MTPD::loop()+0x324>)
    7110:	bl	e7ec <Print::printf(char const*, ...)>
    7114:	ldr	r3, [r4, #8]
    7116:	cmp	r3, #20
    7118:	bls.n	706a <MTPD::loop()+0x2e>
    711a:	ldr	r2, [r4, #28]
    711c:	ldr	r1, [pc, #588]	; (736c <MTPD::loop()+0x330>)
    711e:	ldr	r0, [pc, #576]	; (7360 <MTPD::loop()+0x324>)
    7120:	bl	e7ec <Print::printf(char const*, ...)>
    7124:	b.n	706a <MTPD::loop()+0x2e>
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
      printf("Event: "); printContainer();
    7126:	ldr	r2, [r4, #20]
    7128:	ldr	r1, [pc, #576]	; (736c <MTPD::loop()+0x330>)
    712a:	ldr	r0, [pc, #564]	; (7360 <MTPD::loop()+0x324>)
    712c:	bl	e7ec <Print::printf(char const*, ...)>
    7130:	ldr	r3, [r4, #8]
    7132:	cmp	r3, #16
    7134:	bls.n	70de <MTPD::loop()+0xa2>
    7136:	ldr	r2, [r4, #24]
    7138:	ldr	r1, [pc, #560]	; (736c <MTPD::loop()+0x330>)
    713a:	ldr	r0, [pc, #548]	; (7360 <MTPD::loop()+0x324>)
    713c:	bl	e7ec <Print::printf(char const*, ...)>
    7140:	ldr	r3, [r4, #8]
    7142:	cmp	r3, #20
    7144:	bls.n	70de <MTPD::loop()+0xa2>
    7146:	ldr	r2, [r4, #28]
    7148:	ldr	r1, [pc, #544]	; (736c <MTPD::loop()+0x330>)
    714a:	ldr	r0, [pc, #532]	; (7360 <MTPD::loop()+0x324>)
    714c:	bl	e7ec <Print::printf(char const*, ...)>
    7150:	b.n	70de <MTPD::loop()+0xa2>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7152:	movw	r2, #4108	; 0x100c
    7156:	cmp	r0, r2
    7158:	beq.w	7496 <MTPD::loop()+0x45a>
    715c:	bhi.n	719a <MTPD::loop()+0x15e>
    715e:	movw	r2, #4101	; 0x1005
    7162:	cmp	r0, r2
    7164:	beq.w	759c <MTPD::loop()+0x560>
    7168:	bls.n	7224 <MTPD::loop()+0x1e8>
    716a:	movw	r2, #4104	; 0x1008
    716e:	cmp	r0, r2
    7170:	beq.w	755c <MTPD::loop()+0x520>
    7174:	bhi.w	72f0 <MTPD::loop()+0x2b4>
    7178:	movw	r2, #4102	; 0x1006
    717c:	cmp	r0, r2
    717e:	beq.w	73dc <MTPD::loop()+0x3a0>
    7182:	movw	r2, #4103	; 0x1007
    7186:	cmp	r0, r2
    7188:	bne.w	72ea <MTPD::loop()+0x2ae>
              } else {
                p1 = GetNumObjects(p1, p3);
              }
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
    718c:	cmp.w	r9, #0
    7190:	beq.w	7600 <MTPD::loop()+0x5c4>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    7194:	movw	r0, #8212	; 0x2014
    7198:	b.n	709c <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    719a:	movw	r2, #4121	; 0x1019
    719e:	cmp	r0, r2
    71a0:	beq.w	7534 <MTPD::loop()+0x4f8>
    71a4:	bls.n	7280 <MTPD::loop()+0x244>
    71a6:	movw	r2, #38914	; 0x9802
    71aa:	cmp	r0, r2
    71ac:	beq.w	74b0 <MTPD::loop()+0x474>
    71b0:	bhi.w	7326 <MTPD::loop()+0x2ea>
    71b4:	movw	r2, #4122	; 0x101a
    71b8:	cmp	r0, r2
    71ba:	beq.w	75dc <MTPD::loop()+0x5a0>
    71be:	movw	r2, #38913	; 0x9801
    71c2:	cmp	r0, r2
    71c4:	bne.w	72ea <MTPD::loop()+0x2ae>
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
              else {p1 = return_code; return_code=0x2001;}
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    71c8:	movs	r2, #1
    71ca:	mov.w	r9, #0
    71ce:	mov	r1, r3
    71d0:	strb	r2, [r5, #8]
    71d2:	mov	r0, r5
    71d4:	str.w	r9, [r5, #12]
    71d8:	str	r3, [sp, #12]
    71da:	bl	62c4 <MTPD::getObjectPropsSupported(unsigned long)>
    71de:	ldr	r2, [r5, #12]
    71e0:	strb.w	r9, [r5, #8]
    71e4:	adds	r2, #12
    71e6:	movs	r1, #2
    71e8:	strh.w	r1, [sp, #24]
    71ec:	str	r2, [sp, #20]
    71ee:	ldrh	r2, [r4, #14]
    71f0:	strh.w	r2, [sp, #26]
    71f4:	ldr	r2, [r4, #16]
    71f6:	str	r2, [sp, #28]
    71f8:	add	r1, sp, #20
    71fa:	mov	r0, r5
    71fc:	movs	r2, #12
    71fe:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    7202:	ldr	r3, [sp, #12]
    7204:	mov	r0, r5
    7206:	mov	r1, r3
    7208:	bl	62c4 <MTPD::getObjectPropsSupported(unsigned long)>
    720c:	mov	r0, r5
    720e:	bl	5b40 <MTPD::get_buffer()>
    7212:	ldr	r1, [r5, #4]
    7214:	movs	r0, #4
    7216:	bl	dafc <usb_tx>
    721a:	str.w	r9, [r5, #4]
              break;
    721e:	movw	r0, #8193	; 0x2001
    7222:	b.n	709c <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7224:	movw	r3, #4098	; 0x1002
    7228:	cmp	r0, r3
    722a:	beq.w	73c8 <MTPD::loop()+0x38c>
    722e:	bls.w	7384 <MTPD::loop()+0x348>
    7232:	movw	r3, #4099	; 0x1003
    7236:	cmp	r0, r3
    7238:	beq.n	721e <MTPD::loop()+0x1e2>
    723a:	movw	r3, #4100	; 0x1004
    723e:	cmp	r0, r3
    7240:	bne.n	72ea <MTPD::loop()+0x2ae>
              openSession(p1);
              break;
            case 0x1003:  // CloseSession
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    7242:	mov.w	r9, #0
    7246:	movs	r3, #1
    7248:	strb	r3, [r5, #8]
    724a:	mov	r0, r5
    724c:	str.w	r9, [r5, #12]
    7250:	bl	5f98 <MTPD::WriteStorageIDs()>
    7254:	ldr	r3, [r5, #12]
    7256:	strb.w	r9, [r5, #8]
    725a:	adds	r3, #12
    725c:	movs	r2, #2
    725e:	strh.w	r2, [sp, #24]
    7262:	str	r3, [sp, #20]
    7264:	ldrh	r3, [r4, #14]
    7266:	strh.w	r3, [sp, #26]
    726a:	ldr	r3, [r4, #16]
    726c:	str	r3, [sp, #28]
    726e:	mov	r0, r5
    7270:	movs	r2, #12
    7272:	add	r1, sp, #20
    7274:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    7278:	mov	r0, r5
    727a:	bl	5f98 <MTPD::WriteStorageIDs()>
    727e:	b.n	720c <MTPD::loop()+0x1d0>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7280:	movw	r2, #4112	; 0x1010
    7284:	cmp	r0, r2
    7286:	beq.n	72ea <MTPD::loop()+0x2ae>
    7288:	bls.n	7370 <MTPD::loop()+0x334>
    728a:	movw	r2, #4116	; 0x1014
    728e:	cmp	r0, r2
    7290:	beq.w	73f6 <MTPD::loop()+0x3ba>
    7294:	movw	r2, #4117	; 0x1015
    7298:	cmp	r0, r2
    729a:	bne.n	72ea <MTPD::loop()+0x2ae>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    729c:	movw	r2, #54274	; 0xd402
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72a0:	mov.w	r9, #0
    72a4:	movs	r1, #1
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    72a6:	cmp	r3, r2
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72a8:	str.w	r9, [r5, #12]
    72ac:	strb	r1, [r5, #8]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    72ae:	beq.w	7646 <MTPD::loop()+0x60a>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72b2:	movs	r3, #2
    72b4:	movs	r2, #12
    72b6:	strb.w	r9, [r5, #8]
    72ba:	str	r2, [sp, #20]
    72bc:	strh.w	r3, [sp, #24]
    72c0:	ldrh	r3, [r4, #14]
    72c2:	strh.w	r3, [sp, #26]
    72c6:	ldr	r3, [r4, #16]
    72c8:	str	r3, [sp, #28]
    72ca:	add	r1, sp, #20
    72cc:	mov	r0, r5
    72ce:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    72d2:	mov	r0, r5
    72d4:	bl	5b40 <MTPD::get_buffer()>
    72d8:	movs	r0, #4
    72da:	ldr	r1, [r5, #4]
    72dc:	bl	dafc <usb_tx>
    72e0:	movs	r3, #0
    72e2:	str	r3, [r5, #4]
              break;
    72e4:	movw	r0, #8193	; 0x2001
    72e8:	b.n	709c <MTPD::loop()+0x60>
              return_code = setObjectPropValue(p1,p2);
              break;
              
            default:
              return_code = 0x2005;  // operation not supported
              break;
    72ea:	movw	r0, #8197	; 0x2005
    72ee:	b.n	709c <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    72f0:	movw	r2, #4105	; 0x1009
    72f4:	cmp	r0, r2
    72f6:	beq.w	74f4 <MTPD::loop()+0x4b8>
    72fa:	movw	r2, #4107	; 0x100b
    72fe:	cmp	r0, r2
    7300:	bne.n	72ea <MTPD::loop()+0x2ae>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    7302:	cmp.w	r9, #0
    7306:	bne.w	7194 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                if (!storage_->DeleteObject(p1)) {
    730a:	ldr	r0, [r5, #0]
    730c:	ldr	r2, [r0, #0]
    730e:	mov	r1, r3
    7310:	ldr	r3, [r2, #60]	; 0x3c
    7312:	blx	r3
    7314:	movw	r3, #8210	; 0x2012
    7318:	movw	r2, #8193	; 0x2001
    731c:	cmp	r0, #0
    731e:	ite	eq
    7320:	moveq	r0, r3
    7322:	movne	r0, r2
    7324:	b.n	709c <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7326:	movw	r2, #38915	; 0x9803
    732a:	cmp	r0, r2
    732c:	beq.w	7440 <MTPD::loop()+0x404>
    7330:	movw	r2, #38916	; 0x9804
    7334:	cmp	r0, r2
    7336:	bne.n	72ea <MTPD::loop()+0x2ae>
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    {
      receive_buffer();
    7338:	mov	r0, r5
    733a:	str	r3, [sp, #12]
    733c:	bl	6d18 <MTPD::receive_buffer()>
      if(p2==0xDC07)
    7340:	movw	r2, #56327	; 0xdc07
    7344:	cmp	r9, r2
    7346:	ldr	r3, [sp, #12]
    7348:	bne.n	72ea <MTPD::loop()+0x2ae>
    734a:	mov	r1, r3
    734c:	mov	r0, r5
    734e:	bl	6e64 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>
          }
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
    7352:	cmp	r0, #0
    7354:	beq.w	70f2 <MTPD::loop()+0xb6>
    7358:	uxth	r0, r0
    735a:	b.n	709c <MTPD::loop()+0x60>
    735c:	.word	0x00014574
    7360:	.word	0x1fff8d50
    7364:	.word	0x000143e0
    7368:	.word	0x00014588
    736c:	.word	0x00014584
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7370:	movw	r3, #4109	; 0x100d
    7374:	cmp	r0, r3
    7376:	bne.n	72ea <MTPD::loop()+0x2ae>
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
              break;
            case 0x100D:  // SendObject
              SendObject();
    7378:	mov	r0, r5
    737a:	bl	6fc4 <MTPD::SendObject()>
              break;
    737e:	movw	r0, #8193	; 0x2001
    7382:	b.n	709c <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7384:	movw	r3, #4097	; 0x1001
    7388:	cmp	r0, r3
    738a:	bne.n	72ea <MTPD::loop()+0x2ae>
            case 0x1001: // GetDescription
              TRANSMIT(WriteDescriptor());
    738c:	mov.w	r9, #0
    7390:	strb	r1, [r5, #8]
    7392:	mov	r0, r5
    7394:	str.w	r9, [r5, #12]
    7398:	bl	5d20 <MTPD::WriteDescriptor()>
    739c:	ldr	r3, [r5, #12]
    739e:	strb.w	r9, [r5, #8]
    73a2:	adds	r3, #12
    73a4:	movs	r2, #2
    73a6:	strh.w	r2, [sp, #24]
    73aa:	str	r3, [sp, #20]
    73ac:	ldrh	r3, [r4, #14]
    73ae:	strh.w	r3, [sp, #26]
    73b2:	ldr	r3, [r4, #16]
    73b4:	str	r3, [sp, #28]
    73b6:	mov	r0, r5
    73b8:	mov	r2, sl
    73ba:	add	r1, sp, #20
    73bc:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    73c0:	mov	r0, r5
    73c2:	bl	5d20 <MTPD::WriteDescriptor()>
    73c6:	b.n	720c <MTPD::loop()+0x1d0>
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
      storage_->ResetIndex();
    73c8:	ldr	r0, [r5, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    73ca:	ldr	r2, [pc, #736]	; (76ac <MTPD::loop()+0x670>)
      storage_->ResetIndex();
    73cc:	ldr	r3, [r0, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    73ce:	str.w	r8, [r2]
      storage_->ResetIndex();
    73d2:	ldr	r3, [r3, #68]	; 0x44
    73d4:	blx	r3
    73d6:	movw	r0, #8193	; 0x2001
    73da:	b.n	709c <MTPD::loop()+0x60>
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
              break;
            case 0x1006:  // GetNumObjects
              if (p2) {
    73dc:	cmp.w	r9, #0
    73e0:	bne.w	7194 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                p1 = GetNumObjects(p1, p3);
    73e4:	mov	r2, fp
    73e6:	mov	r1, r3
    73e8:	mov	r0, r5
    73ea:	bl	5b18 <MTPD::GetNumObjects(unsigned long, unsigned long)>
    73ee:	mov	r8, r0
    73f0:	movw	r0, #8193	; 0x2001
    73f4:	b.n	709c <MTPD::loop()+0x60>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    73f6:	movw	r2, #54274	; 0xd402
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    73fa:	movs	r0, #0
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    73fc:	cmp	r3, r2
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    73fe:	strb	r1, [r5, #8]
    7400:	str	r0, [r5, #12]
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    7402:	beq.w	767c <MTPD::loop()+0x640>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    7406:	movs	r2, #12
    7408:	movs	r0, #0
    740a:	movs	r1, #2
    740c:	strb	r0, [r5, #8]
    740e:	str	r2, [sp, #20]
    7410:	strh.w	r1, [sp, #24]
    7414:	ldrh	r1, [r4, #14]
    7416:	strh.w	r1, [sp, #26]
    741a:	ldr	r1, [r4, #16]
    741c:	str	r1, [sp, #28]
    741e:	mov	r0, r5
    7420:	add	r1, sp, #20
    7422:	str	r3, [sp, #12]
    7424:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    7428:	ldr	r3, [sp, #12]
    742a:	movw	r2, #54274	; 0xd402
    742e:	cmp	r3, r2
    7430:	bne.w	72d2 <MTPD::loop()+0x296>
    7434:	movw	r1, #54274	; 0xd402
    7438:	mov	r0, r5
    743a:	bl	5c64 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
    743e:	b.n	72d2 <MTPD::loop()+0x296>
          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
            TRANSMIT(getObjectPropValue(p1,p2));
    7440:	mov.w	fp, #0
    7444:	strb	r1, [r5, #8]
    7446:	mov	r2, r9
    7448:	mov	r1, r3
    744a:	mov	r0, r5
    744c:	str.w	fp, [r5, #12]
    7450:	bl	6330 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    7454:	ldr	r3, [r5, #12]
    7456:	strb.w	fp, [r5, #8]
    745a:	adds	r3, #12
    745c:	movs	r2, #2
    745e:	strh.w	r2, [sp, #24]
    7462:	str	r3, [sp, #20]
    7464:	ldrh	r3, [r4, #14]
    7466:	strh.w	r3, [sp, #26]
    746a:	mov	r2, sl
    746c:	ldr	r3, [r4, #16]
    746e:	str	r3, [sp, #28]
    7470:	add	r1, sp, #20
    7472:	mov	r0, r5
    7474:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    7478:	mov	r2, r9
    747a:	mov	r1, r8
    747c:	mov	r0, r5
    747e:	bl	6330 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    7482:	mov	r0, r5
    7484:	bl	5b40 <MTPD::get_buffer()>
    7488:	ldr	r1, [r5, #4]
    748a:	movs	r0, #4
    748c:	bl	dafc <usb_tx>
    7490:	str.w	fp, [r5, #4]
    7494:	b.n	721e <MTPD::loop()+0x1e2>
                  return_code = 0x2012; // partial deletion
                }
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
    7496:	mov	r0, r5
    7498:	mov	r2, r9
    749a:	mov	r1, r3
    749c:	bl	6e90 <MTPD::SendObjectInfo(unsigned long, unsigned long)>
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    74a0:	movs	r7, #24
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
    74a2:	str	r0, [r4, #28]
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
    74a4:	str.w	r9, [r4, #24]
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    74a8:	strh	r7, [r4, #0]
              break;
    74aa:	movw	r0, #8193	; 0x2001
    74ae:	b.n	709c <MTPD::loop()+0x60>
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
    74b0:	mov.w	fp, #0
    74b4:	strb	r1, [r5, #8]
    74b6:	mov	r2, r9
    74b8:	mov	r1, r3
    74ba:	mov	r0, r5
    74bc:	str.w	fp, [r5, #12]
    74c0:	bl	6630 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    74c4:	ldr	r3, [r5, #12]
    74c6:	strb.w	fp, [r5, #8]
    74ca:	adds	r3, #12
    74cc:	movs	r2, #2
    74ce:	strh.w	r2, [sp, #24]
    74d2:	str	r3, [sp, #20]
    74d4:	ldrh	r3, [r4, #14]
    74d6:	strh.w	r3, [sp, #26]
    74da:	mov	r2, sl
    74dc:	ldr	r3, [r4, #16]
    74de:	str	r3, [sp, #28]
    74e0:	add	r1, sp, #20
    74e2:	mov	r0, r5
    74e4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    74e8:	mov	r2, r9
    74ea:	mov	r1, r8
    74ec:	mov	r0, r5
    74ee:	bl	6630 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    74f2:	b.n	7482 <MTPD::loop()+0x446>
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
    74f4:	mov.w	r9, #0
    74f8:	strb	r1, [r5, #8]
    74fa:	mov	r0, r5
    74fc:	mov	r1, r3
    74fe:	str.w	r9, [r5, #12]
    7502:	bl	6d34 <MTPD::GetObject(unsigned long)>
    7506:	ldr	r3, [r5, #12]
    7508:	strb.w	r9, [r5, #8]
    750c:	adds	r3, #12
    750e:	movs	r2, #2
    7510:	strh.w	r2, [sp, #24]
    7514:	str	r3, [sp, #20]
    7516:	ldrh	r3, [r4, #14]
    7518:	strh.w	r3, [sp, #26]
    751c:	ldr	r3, [r4, #16]
    751e:	str	r3, [sp, #28]
    7520:	add	r1, sp, #20
    7522:	mov	r0, r5
    7524:	mov	r2, sl
    7526:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    752a:	mov	r1, r8
    752c:	mov	r0, r5
    752e:	bl	6d34 <MTPD::GetObject(unsigned long)>
    7532:	b.n	720c <MTPD::loop()+0x1d0>
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    7534:	ldr	r0, [r5, #0]
    7536:	ldr	r1, [r0, #0]
    7538:	mov	r3, fp
    753a:	add.w	r2, r9, #4294967295
    753e:	ldr	r5, [r1, #76]	; 0x4c
    7540:	mov	r1, r8
    7542:	blx	r5
    7544:	movw	r3, #8197	; 0x2005
    7548:	movw	r2, #8193	; 0x2001
              return_code = 0x2005;
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
    754c:	strh.w	sl, [r4]
              break;
    7550:	mov	r7, sl
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    7552:	cmp	r0, #0
    7554:	ite	eq
    7556:	moveq	r0, r3
    7558:	movne	r0, r2
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
              break;
    755a:	b.n	709c <MTPD::loop()+0x60>
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
              }
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
    755c:	mov.w	r9, #0
    7560:	strb	r1, [r5, #8]
    7562:	mov	r0, r5
    7564:	mov	r1, r3
    7566:	str.w	r9, [r5, #12]
    756a:	bl	6070 <MTPD::GetObjectInfo(unsigned long)>
    756e:	ldr	r3, [r5, #12]
    7570:	strb.w	r9, [r5, #8]
    7574:	adds	r3, #12
    7576:	movs	r2, #2
    7578:	strh.w	r2, [sp, #24]
    757c:	str	r3, [sp, #20]
    757e:	ldrh	r3, [r4, #14]
    7580:	strh.w	r3, [sp, #26]
    7584:	ldr	r3, [r4, #16]
    7586:	str	r3, [sp, #28]
    7588:	add	r1, sp, #20
    758a:	mov	r0, r5
    758c:	mov	r2, sl
    758e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    7592:	mov	r1, r8
    7594:	mov	r0, r5
    7596:	bl	6070 <MTPD::GetObjectInfo(unsigned long)>
    759a:	b.n	720c <MTPD::loop()+0x1d0>
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
    759c:	mov.w	r9, #0
    75a0:	strb	r1, [r5, #8]
    75a2:	mov	r0, r5
    75a4:	mov	r1, r3
    75a6:	str.w	r9, [r5, #12]
    75aa:	bl	64ec <MTPD::GetStorageInfo(unsigned long)>
    75ae:	ldr	r3, [r5, #12]
    75b0:	strb.w	r9, [r5, #8]
    75b4:	adds	r3, #12
    75b6:	movs	r2, #2
    75b8:	strh.w	r2, [sp, #24]
    75bc:	str	r3, [sp, #20]
    75be:	ldrh	r3, [r4, #14]
    75c0:	strh.w	r3, [sp, #26]
    75c4:	ldr	r3, [r4, #16]
    75c6:	str	r3, [sp, #28]
    75c8:	add	r1, sp, #20
    75ca:	mov	r0, r5
    75cc:	mov	r2, sl
    75ce:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    75d2:	mov	r1, r8
    75d4:	mov	r0, r5
    75d6:	bl	64ec <MTPD::GetStorageInfo(unsigned long)>
    75da:	b.n	720c <MTPD::loop()+0x1d0>
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    }
    
    uint32_t MTPD::copyObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      return storage_->copy(handle,store1,newHandle);
    75dc:	ldr	r0, [r5, #0]
    75de:	ldr	r1, [r0, #0]
    75e0:	mov	r3, fp
    75e2:	ldr	r5, [r1, #80]	; 0x50
    75e4:	add.w	r2, r9, #4294967295
    75e8:	mov	r1, r8
    75ea:	blx	r5
              len  = receive_buffer->len = 12;
              break;

          case 0x101A:  // CopyObject
              return_code = copyObject(p1,p2,p3);
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
    75ec:	cbnz	r0, 75f8 <MTPD::loop()+0x5bc>
    75ee:	movs	r7, #12
    75f0:	strh	r7, [r4, #0]
    75f2:	movw	r0, #8197	; 0x2005
    75f6:	b.n	709c <MTPD::loop()+0x60>
              else {p1 = return_code; return_code=0x2001;}
    75f8:	mov	r8, r0
    75fa:	movw	r0, #8193	; 0x2001
    75fe:	b.n	709c <MTPD::loop()+0x60>
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
                return_code = 0x2014; // spec by format unsupported
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
    7600:	movs	r2, #1
    7602:	mov	r1, r3
    7604:	strb	r2, [r5, #8]
    7606:	mov	r0, r5
    7608:	mov	r2, fp
    760a:	str.w	r9, [r5, #12]
    760e:	str	r3, [sp, #12]
    7610:	bl	6000 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    7614:	ldr	r2, [r5, #12]
    7616:	strb.w	r9, [r5, #8]
    761a:	adds	r2, #12
    761c:	movs	r1, #2
    761e:	strh.w	r1, [sp, #24]
    7622:	str	r2, [sp, #20]
    7624:	ldrh	r2, [r4, #14]
    7626:	strh.w	r2, [sp, #26]
    762a:	ldr	r2, [r4, #16]
    762c:	str	r2, [sp, #28]
    762e:	add	r1, sp, #20
    7630:	mov	r0, r5
    7632:	movs	r2, #12
    7634:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    7638:	ldr	r3, [sp, #12]
    763a:	mov	r2, fp
    763c:	mov	r1, r3
    763e:	mov	r0, r5
    7640:	bl	6000 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    7644:	b.n	720c <MTPD::loop()+0x1d0>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    7646:	mov	r0, r5
    7648:	ldr	r1, [pc, #100]	; (76b0 <MTPD::loop()+0x674>)
    764a:	bl	5bbc <MTPD::writestring(char const*)>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    764e:	ldr	r3, [r5, #12]
    7650:	strb.w	r9, [r5, #8]
    7654:	adds	r3, #12
    7656:	movs	r2, #2
    7658:	strh.w	r2, [sp, #24]
    765c:	str	r3, [sp, #20]
    765e:	ldrh	r3, [r4, #14]
    7660:	strh.w	r3, [sp, #26]
    7664:	ldr	r3, [r4, #16]
    7666:	str	r3, [sp, #28]
    7668:	add	r1, sp, #20
    766a:	mov	r0, r5
    766c:	movs	r2, #12
    766e:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    7672:	ldr	r1, [pc, #60]	; (76b0 <MTPD::loop()+0x674>)
    7674:	mov	r0, r5
    7676:	bl	5bbc <MTPD::writestring(char const*)>
    767a:	b.n	72d2 <MTPD::loop()+0x296>
    767c:	mov	r1, r2
    767e:	mov	r0, r5
    7680:	bl	5c64 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    7684:	ldr	r3, [r5, #12]
    7686:	movs	r1, #0
    7688:	adds	r3, #12
    768a:	movs	r2, #2
    768c:	strb	r1, [r5, #8]
    768e:	strh.w	r2, [sp, #24]
    7692:	str	r3, [sp, #20]
    7694:	ldrh	r3, [r4, #14]
    7696:	strh.w	r3, [sp, #26]
    769a:	ldr	r3, [r4, #16]
    769c:	str	r3, [sp, #28]
    769e:	movs	r2, #12
    76a0:	add	r1, sp, #20
    76a2:	mov	r0, r5
    76a4:	bl	5b58 <MTPD::write(char const*, int) [clone .part.2]>
    76a8:	b.n	7434 <MTPD::loop()+0x3f8>
    76aa:	nop
    76ac:	.word	0x20002b24
    76b0:	.word	0x00014544

000076b4 <usb_init_events>:
  extern "C"
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
    76b4:	push	{r3, lr}
      tx_event_packet = usb_malloc();
    76b6:	bl	d984 <usb_malloc>
    76ba:	ldr	r2, [pc, #12]	; (76c8 <usb_init_events+0x14>)
    76bc:	mov	r3, r0
      if(tx_event_packet) return 1; else return 0; 
    }
    76be:	adds	r0, #0
    76c0:	it	ne
    76c2:	movne	r0, #1
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
      tx_event_packet = usb_malloc();
    76c4:	str	r3, [r2, #0]
      if(tx_event_packet) return 1; else return 0; 
    }
    76c6:	pop	{r3, pc}
    76c8:	.word	0x20002b28

000076cc <usb_mtp_sendEvent>:


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
    76cc:	push	{r3, r4, r5, lr}
      if (!usb_configuration) return -1;
    76ce:	ldr	r3, [pc, #44]	; (76fc <usb_mtp_sendEvent+0x30>)
    76d0:	ldrb	r3, [r3, #0]
    76d2:	cbz	r3, 76f4 <usb_mtp_sendEvent+0x28>
      memcpy(tx_event_packet->buf, buffer, len);
    76d4:	ldr	r3, [pc, #40]	; (7700 <usb_mtp_sendEvent+0x34>)
    76d6:	ldr	r5, [r3, #0]
    76d8:	mov	r4, r1
    76da:	mov	r2, r4
    76dc:	mov	r1, r0
    76de:	add.w	r0, r5, #8
    76e2:	bl	cb10 <memcpy>
      tx_event_packet->len = len;
    76e6:	strh	r4, [r5, #0]
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
    76e8:	mov	r1, r5
    76ea:	movs	r0, #6
    76ec:	bl	dafc <usb_tx>
      return len;
    76f0:	mov	r0, r4
    76f2:	pop	{r3, r4, r5, pc}
    }


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
      if (!usb_configuration) return -1;
    76f4:	mov.w	r0, #4294967295
      memcpy(tx_event_packet->buf, buffer, len);
      tx_event_packet->len = len;
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
      return len;
    }
    76f8:	pop	{r3, r4, r5, pc}
    76fa:	nop
    76fc:	.word	0x200031a8
    7700:	.word	0x20002b28

00007704 <MTPD::send_Event(unsigned short)>:

  #endif
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    7704:	push	{r4, r5, lr}
    7706:	sub	sp, #36	; 0x24
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    7708:	ldr	r3, [r0, #16]

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    770a:	strh.w	r1, [sp, #6]
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    770e:	movs	r4, #12
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    7710:	str	r3, [sp, #8]
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    7712:	mov	r1, r4
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    event.params[0]=0;
    7714:	movs	r3, #0
  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    7716:	movs	r5, #4
    event.transaction_id=TID;
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    7718:	movs	r2, #60	; 0x3c
    771a:	mov	r0, sp
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    771c:	str	r4, [sp, #0]
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    771e:	strh.w	r5, [sp, #4]
    event.transaction_id=TID;
    event.params[0]=0;
    7722:	str	r3, [sp, #12]
    event.params[1]=0;
    7724:	str	r3, [sp, #16]
    event.params[2]=0;
    7726:	str	r3, [sp, #20]
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    7728:	bl	76cc <usb_mtp_sendEvent>
  }
    772c:	add	sp, #36	; 0x24
    772e:	pop	{r4, r5, pc}

00007730 <MTPD::send_DeviceResetEvent()>:
    event.params[2]=p3;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
  }

  int MTPD::send_DeviceResetEvent(void) 
  { return send_Event(MTP_EVENT_DEVICE_RESET); } 
    7730:	movw	r1, #16395	; 0x400b
    7734:	b.w	7704 <MTPD::send_Event(unsigned short)>

00007738 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    7738:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    773a:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    773c:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    773e:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    7740:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    7742:	beq.n	774a <EventResponder::triggerEvent(int, void*)+0x12>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    7744:	pop	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    7746:	b.w	e690 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    774a:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    774c:	pop	{r4}
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    774e:	bx	r3

00007750 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    7750:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7754:	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    7756:	ldr	r5, [r4, #12]
    7758:	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    775c:	ldr	r5, [pc, #484]	; (7944 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    775e:	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    7760:	bne.n	7808 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    7762:	lsls	r7, r3, #31
    7764:	bpl.w	78ce <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    7768:	cmp	r1, #0
    776a:	beq.w	7934 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    776e:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    7770:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7772:	it	ne
    7774:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    7778:	str	r5, [r4, #52]	; 0x34
    777a:	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    777c:	ldrb.w	r8, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    7780:	add.w	ip, r3, #4294967295
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    7784:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    7788:	cmp.w	ip, #0
    778c:	beq.w	78e0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    7790:	cbz	r1, 779c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    7792:	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    7794:	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    7798:	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    779c:	ldr	r5, [r0, #4]
    779e:	ldrb	r6, [r5, #8]
			if (count == 2)
    77a0:	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    77a4:	add.w	r6, r6, #4294967295
    77a8:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    77ac:	ite	eq
    77ae:	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    77b2:	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    77b6:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    77b8:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    77ba:	sub.w	ip, ip, #2
    77be:	b.n	77d2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    77c0:	cbz	r2, 77c6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    77c2:	strb	r4, [r2, #0]
    77c4:	adds	r2, #1
						} 
						count_read--;
    77c6:	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    77c8:	and.w	r5, r5, #61440	; 0xf000
    77cc:	cmp	r5, r6
    77ce:	bls.n	77fe <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    77d0:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    77d2:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    77d4:	tst.w	r5, #240	; 0xf0
    77d8:	beq.n	77c8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    77da:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    77dc:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    77e0:	mov	r7, r2
    77e2:	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    77e6:	bne.n	77c0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    77e8:	cbz	r2, 77f2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    77ea:	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    77ee:	strb	r4, [r2, #1]
    77f0:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    77f2:	and.w	r5, r5, #61440	; 0xf000
    77f6:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    77f8:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    77fc:	bhi.n	77d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    77fe:	cmp.w	ip, #0
    7802:	beq.n	78e0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    7804:	ldr	r4, [r0, #0]
    7806:	b.n	7790 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    7808:	lsls	r5, r3, #31
    780a:	bpl.n	78a6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    780c:	cmp	r1, #0
    780e:	beq.w	7924 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7812:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    7814:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7816:	it	ne
    7818:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    781c:	str	r5, [r4, #52]	; 0x34
    781e:	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    7820:	add.w	lr, r3, #4294967295
		}

	    uint16_t w = _transferWriteFill;
    7824:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    7828:	cmp.w	lr, #0
    782c:	beq.n	78b2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    782e:	cbz	r1, 783c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    7830:	ldrb.w	ip, [r1, #1]
    7834:	ldrb	r5, [r1, #0]
    7836:	adds	r1, #2
    7838:	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    783c:	ldr	r5, [r0, #4]
    783e:	ldrb	r6, [r5, #8]
			if (count == 2)
    7840:	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    7844:	add.w	r6, r6, #4294967295
    7848:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    784c:	ite	eq
    784e:	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    7852:	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    7856:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    7858:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    785a:	sub.w	lr, lr, #2
    785e:	b.n	7872 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    7860:	cbz	r2, 7866 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    7862:	strb	r4, [r2, #0]
    7864:	adds	r2, #1
						} 
						count_read--;
    7866:	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    7868:	and.w	r5, r5, #61440	; 0xf000
    786c:	cmp	r5, r6
    786e:	bls.n	789c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    7870:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    7872:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    7874:	tst.w	r5, #240	; 0xf0
    7878:	beq.n	7868 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    787a:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    787e:	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    7880:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    7882:	bne.n	7860 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    7884:	cbz	r2, 7890 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    7886:	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    788a:	asrs	r4, r4, #8
    788c:	strb	r4, [r2, #1]
    788e:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    7890:	and.w	r5, r5, #61440	; 0xf000
    7894:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    7896:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    789a:	bhi.n	7870 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    789c:	cmp.w	lr, #0
    78a0:	beq.n	78b2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    78a2:	ldr	r4, [r0, #0]
    78a4:	b.n	782e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    78a6:	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    78a8:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    78ac:	cmp.w	lr, #0
    78b0:	bne.n	782e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    78b2:	cbz	r3, 78fc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    78b4:	ldr	r4, [r0, #0]
			sr = port().SR;
    78b6:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    78b8:	tst.w	r1, #240	; 0xf0
    78bc:	beq.n	78b6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    78be:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    78c0:	lsls	r4, r3, #31
    78c2:	bpl.n	7900 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    78c4:	cbz	r2, 78ca <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    78c6:	strb	r1, [r2, #0]
    78c8:	adds	r2, #1
					count_read--;
    78ca:	subs	r3, #1
    78cc:	b.n	78b2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    78ce:	ldrb.w	r8, [r0, #36]	; 0x24
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    78d2:	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    78d4:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    78d8:	cmp.w	ip, #0
    78dc:	bne.w	7790 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    78e0:	cbz	r3, 78fc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    78e2:	ldr	r4, [r0, #0]
			sr = port().SR;
    78e4:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    78e6:	tst.w	r1, #240	; 0xf0
    78ea:	beq.n	78e4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    78ec:	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    78ee:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    78f0:	bpl.n	7912 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    78f2:	cbz	r2, 78f8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    78f4:	strb	r1, [r2, #0]
    78f6:	adds	r2, #1
					count_read--;
    78f8:	subs	r3, #1
    78fa:	b.n	78e0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    78fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    7900:	cbz	r2, 790e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    7902:	mov	r4, r2
						*p_read++ = w >> 8;
    7904:	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    7906:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    790a:	strb	r5, [r2, #1]
    790c:	mov	r2, r4
					}
					count_read -= 2;
    790e:	subs	r3, #2
    7910:	b.n	78b2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    7912:	cbz	r2, 7920 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    7914:	mov	r4, r2
    7916:	asrs	r5, r1, #8
    7918:	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    791c:	strb	r1, [r2, #1]
    791e:	mov	r2, r4
					}
					count_read -= 2;
    7920:	subs	r3, #2
    7922:	b.n	78e0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7924:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    7928:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    792a:	it	ne
    792c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    7930:	str	r5, [r4, #52]	; 0x34
    7932:	b.n	7820 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7934:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    7938:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    793a:	it	ne
    793c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    7940:	str	r5, [r4, #52]	; 0x34
    7942:	b.n	777c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    7944:	.word	0x801f0400

00007948 <_spi_dma_rxISR0()>:
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7948:	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    794a:	ldr	r3, [pc, #280]	; (7a64 <_spi_dma_rxISR0()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    794c:	ldr	r2, [pc, #280]	; (7a68 <_spi_dma_rxISR0()+0x120>)
    794e:	ldr	r0, [r3, #48]	; 0x30
    7950:	ldr	r4, [r3, #44]	; 0x2c
    7952:	ldrb	r1, [r0, #4]
    7954:	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    7956:	ldr	r1, [pc, #276]	; (7a6c <_spi_dma_rxISR0()+0x124>)
    7958:	ldrb	r2, [r4, #4]
    795a:	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    795c:	ldr	r2, [r3, #40]	; 0x28
    795e:	ldrb	r0, [r0, #4]
    7960:	strb	r0, [r1, #0]
    7962:	cmp	r2, #0
    7964:	beq.n	79f4 <_spi_dma_rxISR0()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    7966:	ldr	r1, [r3, #4]
    7968:	ldr	r1, [r1, #12]
    796a:	cmp	r2, r1
    796c:	bhi.n	79ec <_spi_dma_rxISR0()+0xa4>
    796e:	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    7970:	ldrh	r4, [r1, #30]
    7972:	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    7974:	add.w	r0, r2, #4294967295

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    7978:	bmi.n	7a46 <_spi_dma_rxISR0()+0xfe>
		tcd->BITER = len & 0x7fff;
    797a:	ubfx	r0, r0, #0, #15
    797e:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7980:	ldrh	r0, [r1, #30]
    7982:	uxth	r0, r0
    7984:	strh	r0, [r1, #22]
    7986:	ldr	r1, [r3, #48]	; 0x30
    7988:	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    798a:	ldrh	r0, [r1, #30]
    798c:	lsls	r0, r0, #16
    798e:	bmi.n	7a36 <_spi_dma_rxISR0()+0xee>
		tcd->BITER = len & 0x7fff;
    7990:	ubfx	r0, r2, #0, #15
    7994:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7996:	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    7998:	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    799a:	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    799c:	adds.w	r2, r2, #4294967295
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    79a0:	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    79a2:	it	ne
    79a4:	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    79a6:	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    79a8:	ldr	r1, [r3, #44]	; 0x2c
    79aa:	ldr	r0, [pc, #184]	; (7a64 <_spi_dma_rxISR0()+0x11c>)
    79ac:	ldr	r1, [r1, #0]
    79ae:	ldr	r5, [r1, #0]
    79b0:	add.w	r4, r0, #36	; 0x24
    79b4:	cmp	r5, r4
    79b6:	beq.n	7a26 <_spi_dma_rxISR0()+0xde>
    79b8:	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    79ba:	ldr	r4, [r0, #12]
    79bc:	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    79c0:	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    79c2:	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    79c4:	itete	ne
    79c6:	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    79c8:	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    79ca:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    79cc:	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    79ce:	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    79d2:	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    79d4:	str	r4, [r0, #52]	; 0x34
    79d6:	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    79d8:	ldr	r3, [pc, #148]	; (7a70 <_spi_dma_rxISR0()+0x128>)
    79da:	ldrb	r1, [r1, #4]
    79dc:	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    79de:	ldr	r1, [pc, #132]	; (7a64 <_spi_dma_rxISR0()+0x11c>)
		if (should_reenable_tx)
    79e0:	cbz	r2, 79e8 <_spi_dma_rxISR0()+0xa0>
    79e2:	ldr	r2, [r1, #44]	; 0x2c
    79e4:	ldrb	r2, [r2, #4]
    79e6:	strb	r2, [r3, #0]
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    79e8:	pop	{r4, r5, r6, r7}
    79ea:	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    79ec:	subs	r2, r2, r1
    79ee:	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    79f0:	movs	r2, #1
    79f2:	b.n	79a8 <_spi_dma_rxISR0()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    79f4:	ldr	r0, [r3, #52]	; 0x34
    79f6:	ldr	r1, [r3, #0]
    79f8:	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    79fa:	ldr	r4, [pc, #120]	; (7a74 <_spi_dma_rxISR0()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    79fc:	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    79fe:	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a00:	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a02:	ldr	r5, [r5, #0]
    7a04:	ldr	r6, [pc, #112]	; (7a78 <_spi_dma_rxISR0()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a06:	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7a0a:	movs	r7, #3
    7a0c:	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a0e:	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7a10:	strb.w	r7, [r3, #37]	; 0x25
    7a14:	bne.n	7a56 <_spi_dma_rxISR0()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    7a16:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    7a18:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    7a1a:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    7a1c:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    7a1e:	beq.n	7a5e <_spi_dma_rxISR0()+0x116>
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7a20:	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    7a22:	b.w	e690 <EventResponder::triggerEventNotImmediate()>
    7a26:	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7a28:	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7a2c:	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7a2e:	orr.w	r0, r0, #2147483648	; 0x80000000
    7a32:	str	r0, [r1, #52]	; 0x34
    7a34:	b.n	79d6 <_spi_dma_rxISR0()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    7a36:	ldrh	r4, [r1, #30]
    7a38:	ubfx	r0, r2, #0, #9
    7a3c:	and.w	r4, r4, #65024	; 0xfe00
    7a40:	orrs	r0, r4
    7a42:	strh	r0, [r1, #30]
    7a44:	b.n	7996 <_spi_dma_rxISR0()+0x4e>
    7a46:	ldrh	r4, [r1, #30]
    7a48:	ubfx	r0, r0, #0, #9
    7a4c:	and.w	r4, r4, #65024	; 0xfe00
    7a50:	orrs	r0, r4
    7a52:	strh	r0, [r1, #30]
    7a54:	b.n	7980 <_spi_dma_rxISR0()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a56:	mov	r3, r5
    7a58:	mov	r1, r2
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7a5a:	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a5c:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    7a5e:	ldr	r3, [r0, #8]
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7a60:	pop	{r4, r5, r6, r7}
    7a62:	bx	r3
    7a64:	.word	0x1fff8a60
    7a68:	.word	0x4000801f
    7a6c:	.word	0x4000801c
    7a70:	.word	0x4000801b
    7a74:	.word	0xff0f0000
    7a78:	.word	0x00007739

00007a7c <SPIClass::begin()>:
    7a7c:	ldmia.w	r0, {r2, r3}
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    7a80:	push	{r4, r5, r6, r7}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    7a82:	ldr	r4, [r3, #0]
    7a84:	ldr	r1, [r3, #4]
    7a86:	ldr	r5, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    7a88:	ldr	r7, [pc, #88]	; (7ae4 <SPIClass::begin()+0x68>)
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7a8a:	ldr	r6, [pc, #92]	; (7ae8 <SPIClass::begin()+0x6c>)

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    7a8c:	orrs	r1, r5
    7a8e:	str	r1, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7a90:	ldr	r5, [pc, #88]	; (7aec <SPIClass::begin()+0x70>)
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    7a92:	ldr	r1, [pc, #92]	; (7af0 <SPIClass::begin()+0x74>)
void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    7a94:	str	r7, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7a96:	str	r6, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7a98:	str	r5, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    7a9a:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7a9c:	ldrb	r1, [r0, #9]
    7a9e:	ldr	r2, [pc, #84]	; (7af4 <SPIClass::begin()+0x78>)
    7aa0:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    7aa2:	adds	r1, #10
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7aa4:	ldrb.w	r4, [r4, #36]	; 0x24
	*reg = hardware().mosi_mux[mosi_pin_index];
    7aa8:	ldr.w	r5, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7aac:	add.w	r1, r2, r4, lsl #3
    7ab0:	ldr	r1, [r1, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    7ab2:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7ab4:	ldrb	r1, [r0, #8]
    7ab6:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    7ab8:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7abc:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    7abe:	ldr	r5, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7ac0:	add.w	r1, r2, r4, lsl #3
    7ac4:	ldr	r1, [r1, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    7ac6:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7ac8:	ldrb	r1, [r0, #10]
    7aca:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    7acc:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7ad0:	ldrb.w	r0, [r0, #48]	; 0x30
	*reg = hardware().sck_mux[sck_pin_index];
    7ad4:	ldr	r1, [r3, #52]	; 0x34
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7ad6:	add.w	r2, r2, r0, lsl #3
	*reg = hardware().sck_mux[sck_pin_index];
}
    7ada:	pop	{r4, r5, r6, r7}
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7adc:	ldr	r3, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    7ade:	str	r1, [r3, #0]
}
    7ae0:	bx	lr
    7ae2:	nop
    7ae4:	.word	0x001f4001
    7ae8:	.word	0x38001001
    7aec:	.word	0x78001001
    7af0:	.word	0x801f0000
    7af4:	.word	0x000147a0

00007af8 <SPIClass::setMOSI(unsigned char)>:
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7af8:	ldr	r2, [pc, #128]	; (7b7c <SPIClass::setMOSI(unsigned char)+0x84>)
    7afa:	ldr	r3, [r0, #4]
    7afc:	cmp	r2, r3
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    7afe:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7b00:	beq.n	7b22 <SPIClass::setMOSI(unsigned char)+0x2a>
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    7b02:	ldrb	r2, [r0, #9]
    7b04:	add	r2, r3
    7b06:	ldrb.w	r2, [r2, #36]	; 0x24
    7b0a:	cmp	r1, r2
    7b0c:	beq.n	7b1e <SPIClass::setMOSI(unsigned char)+0x26>
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    7b0e:	ldrb.w	r4, [r3, #36]	; 0x24
    7b12:	cmp	r4, r1
    7b14:	beq.n	7b42 <SPIClass::setMOSI(unsigned char)+0x4a>
    7b16:	ldrb.w	r4, [r3, #37]	; 0x25
    7b1a:	cmp	r4, r1
    7b1c:	beq.n	7b74 <SPIClass::setMOSI(unsigned char)+0x7c>
				mosi_pin_index = i;
				return;
			}
		}
	}
}
    7b1e:	pop	{r4, r5, r6, r7}
    7b20:	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
#else
		if (pin == 11) pinout &= ~1;
    7b22:	cmp	r1, #11
    7b24:	beq.n	7b36 <SPIClass::setMOSI(unsigned char)+0x3e>
		if (pin == 7)  pinout |= 1;
    7b26:	cmp	r1, #7
    7b28:	bne.n	7b02 <SPIClass::setMOSI(unsigned char)+0xa>
    7b2a:	ldr	r4, [pc, #84]	; (7b80 <SPIClass::setMOSI(unsigned char)+0x88>)
    7b2c:	ldrb	r2, [r4, #0]
    7b2e:	orr.w	r2, r2, #1
    7b32:	strb	r2, [r4, #0]
    7b34:	b.n	7b02 <SPIClass::setMOSI(unsigned char)+0xa>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
#else
		if (pin == 11) pinout &= ~1;
    7b36:	ldr	r4, [pc, #72]	; (7b80 <SPIClass::setMOSI(unsigned char)+0x88>)
    7b38:	ldrb	r2, [r4, #0]
    7b3a:	bic.w	r2, r2, #1
    7b3e:	strb	r2, [r4, #0]
    7b40:	b.n	7b02 <SPIClass::setMOSI(unsigned char)+0xa>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    7b42:	movs	r4, #0
    7b44:	mov	r1, r4
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7b46:	ldr	r6, [r3, #0]
    7b48:	ldr	r5, [r3, #4]
    7b4a:	ldr	r6, [r6, #0]
    7b4c:	tst	r6, r5
    7b4e:	beq.n	7b70 <SPIClass::setMOSI(unsigned char)+0x78>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7b50:	ldr	r5, [pc, #48]	; (7b84 <SPIClass::setMOSI(unsigned char)+0x8c>)
    7b52:	add.w	r2, r5, r2, lsl #3
					*reg = 0;
    7b56:	movs	r7, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7b58:	ldr	r6, [r2, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7b5a:	adds	r2, r3, r1
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
    7b5c:	str	r7, [r6, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7b5e:	ldrb.w	r2, [r2, #36]	; 0x24
    7b62:	add.w	r5, r5, r2, lsl #3
					*reg = hardware().mosi_mux[i];
    7b66:	adds	r1, #10
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7b68:	ldr	r2, [r5, #4]
					*reg = hardware().mosi_mux[i];
    7b6a:	ldr.w	r3, [r3, r1, lsl #2]
    7b6e:	str	r3, [r2, #0]
				}	
				mosi_pin_index = i;
    7b70:	strb	r4, [r0, #9]
				return;
    7b72:	b.n	7b1e <SPIClass::setMOSI(unsigned char)+0x26>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    7b74:	movs	r4, #1
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    7b76:	mov	r1, r4
    7b78:	b.n	7b46 <SPIClass::setMOSI(unsigned char)+0x4e>
    7b7a:	nop
    7b7c:	.word	0x00014624
    7b80:	.word	0x200031c9
    7b84:	.word	0x000147a0

00007b88 <SPIClass::setMISO(unsigned char)>:
	}
}

void SPIClass::setMISO(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7b88:	ldr	r2, [pc, #120]	; (7c04 <SPIClass::setMISO(unsigned char)+0x7c>)
    7b8a:	ldr	r3, [r0, #4]
    7b8c:	cmp	r2, r3
		}
	}
}

void SPIClass::setMISO(uint8_t pin)
{
    7b8e:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7b90:	beq.n	7bac <SPIClass::setMISO(unsigned char)+0x24>
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    7b92:	ldrb	r2, [r0, #8]
    7b94:	add	r2, r3
    7b96:	ldrb	r2, [r2, #24]
    7b98:	cmp	r1, r2
    7b9a:	beq.n	7ba8 <SPIClass::setMISO(unsigned char)+0x20>
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    7b9c:	ldrb	r4, [r3, #24]
    7b9e:	cmp	r4, r1
    7ba0:	beq.n	7bcc <SPIClass::setMISO(unsigned char)+0x44>
    7ba2:	ldrb	r4, [r3, #25]
    7ba4:	cmp	r4, r1
    7ba6:	beq.n	7bfe <SPIClass::setMISO(unsigned char)+0x76>
				miso_pin_index = i;
				return;
			}
		}
	}
}
    7ba8:	pop	{r4, r5, r6, r7}
    7baa:	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
#else
		if (pin == 12) pinout &= ~2;
    7bac:	cmp	r1, #12
    7bae:	beq.n	7bc0 <SPIClass::setMISO(unsigned char)+0x38>
		if (pin == 8)  pinout |= 2;
    7bb0:	cmp	r1, #8
    7bb2:	bne.n	7b92 <SPIClass::setMISO(unsigned char)+0xa>
    7bb4:	ldr	r4, [pc, #80]	; (7c08 <SPIClass::setMISO(unsigned char)+0x80>)
    7bb6:	ldrb	r2, [r4, #0]
    7bb8:	orr.w	r2, r2, #2
    7bbc:	strb	r2, [r4, #0]
    7bbe:	b.n	7b92 <SPIClass::setMISO(unsigned char)+0xa>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
#else
		if (pin == 12) pinout &= ~2;
    7bc0:	ldr	r4, [pc, #68]	; (7c08 <SPIClass::setMISO(unsigned char)+0x80>)
    7bc2:	ldrb	r2, [r4, #0]
    7bc4:	bic.w	r2, r2, #2
    7bc8:	strb	r2, [r4, #0]
    7bca:	b.n	7b92 <SPIClass::setMISO(unsigned char)+0xa>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    7bcc:	movs	r4, #0
    7bce:	mov	r1, r4
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7bd0:	ldr	r6, [r3, #0]
    7bd2:	ldr	r5, [r3, #4]
    7bd4:	ldr	r6, [r6, #0]
    7bd6:	tst	r6, r5
    7bd8:	beq.n	7bfa <SPIClass::setMISO(unsigned char)+0x72>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7bda:	ldr	r5, [pc, #48]	; (7c0c <SPIClass::setMISO(unsigned char)+0x84>)
    7bdc:	add.w	r2, r5, r2, lsl #3
					*reg = 0;
    7be0:	movs	r7, #0
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7be2:	ldr	r6, [r2, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7be4:	adds	r2, r3, r1
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
    7be6:	str	r7, [r6, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    7be8:	ldrb	r2, [r2, #24]
					*reg = hardware().miso_mux[i];
    7bea:	adds	r1, #6
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7bec:	add.w	r5, r5, r2, lsl #3
					*reg = hardware().miso_mux[i];
    7bf0:	add.w	r3, r3, r1, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7bf4:	ldr	r2, [r5, #4]
					*reg = hardware().miso_mux[i];
    7bf6:	ldr	r3, [r3, #4]
    7bf8:	str	r3, [r2, #0]
				}	
				miso_pin_index = i;
    7bfa:	strb	r4, [r0, #8]
				return;
    7bfc:	b.n	7ba8 <SPIClass::setMISO(unsigned char)+0x20>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    7bfe:	movs	r4, #1
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    7c00:	mov	r1, r4
    7c02:	b.n	7bd0 <SPIClass::setMISO(unsigned char)+0x48>
    7c04:	.word	0x00014624
    7c08:	.word	0x200031c9
    7c0c:	.word	0x000147a0

00007c10 <SPIClass::setSCK(unsigned char)>:
	}
}

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7c10:	ldr	r2, [pc, #128]	; (7c94 <SPIClass::setSCK(unsigned char)+0x84>)
    7c12:	ldr	r3, [r0, #4]
    7c14:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    7c16:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7c18:	beq.n	7c3a <SPIClass::setSCK(unsigned char)+0x2a>
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    7c1a:	ldrb	r2, [r0, #10]
    7c1c:	add	r2, r3
    7c1e:	ldrb.w	r2, [r2, #48]	; 0x30
    7c22:	cmp	r1, r2
    7c24:	beq.n	7c36 <SPIClass::setSCK(unsigned char)+0x26>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7c26:	ldrb.w	r4, [r3, #48]	; 0x30
    7c2a:	cmp	r4, r1
    7c2c:	beq.n	7c5a <SPIClass::setSCK(unsigned char)+0x4a>
    7c2e:	ldrb.w	r4, [r3, #49]	; 0x31
    7c32:	cmp	r4, r1
    7c34:	beq.n	7c8e <SPIClass::setSCK(unsigned char)+0x7e>
				sck_pin_index = i;
				return;
			}
		}
	}
}
    7c36:	pop	{r4, r5, r6, r7}
    7c38:	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
#else
		if (pin == 13) pinout &= ~4;
    7c3a:	cmp	r1, #13
    7c3c:	beq.n	7c4e <SPIClass::setSCK(unsigned char)+0x3e>
		if (pin == 14) pinout |= 4;
    7c3e:	cmp	r1, #14
    7c40:	bne.n	7c1a <SPIClass::setSCK(unsigned char)+0xa>
    7c42:	ldr	r4, [pc, #84]	; (7c98 <SPIClass::setSCK(unsigned char)+0x88>)
    7c44:	ldrb	r2, [r4, #0]
    7c46:	orr.w	r2, r2, #4
    7c4a:	strb	r2, [r4, #0]
    7c4c:	b.n	7c1a <SPIClass::setSCK(unsigned char)+0xa>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
#else
		if (pin == 13) pinout &= ~4;
    7c4e:	ldr	r4, [pc, #72]	; (7c98 <SPIClass::setSCK(unsigned char)+0x88>)
    7c50:	ldrb	r2, [r4, #0]
    7c52:	bic.w	r2, r2, #4
    7c56:	strb	r2, [r4, #0]
    7c58:	b.n	7c1a <SPIClass::setSCK(unsigned char)+0xa>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7c5a:	movs	r4, #0
    7c5c:	mov	r1, r4
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7c5e:	ldr	r6, [r3, #0]
    7c60:	ldr	r5, [r3, #4]
    7c62:	ldr	r6, [r6, #0]
    7c64:	tst	r6, r5
    7c66:	beq.n	7c8a <SPIClass::setSCK(unsigned char)+0x7a>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c68:	ldr	r5, [pc, #48]	; (7c9c <SPIClass::setSCK(unsigned char)+0x8c>)
    7c6a:	add.w	r2, r5, r2, lsl #3
					*reg = 0;
    7c6e:	movs	r7, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c70:	ldr	r6, [r2, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7c72:	adds	r2, r3, r1
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
    7c74:	str	r7, [r6, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    7c76:	ldrb.w	r2, [r2, #48]	; 0x30
					*reg = hardware().sck_mux[i];
    7c7a:	adds	r1, #12
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7c7c:	add.w	r5, r5, r2, lsl #3
					*reg = hardware().sck_mux[i];
    7c80:	add.w	r3, r3, r1, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7c84:	ldr	r2, [r5, #4]
					*reg = hardware().sck_mux[i];
    7c86:	ldr	r3, [r3, #4]
    7c88:	str	r3, [r2, #0]
				}	
				sck_pin_index = i;
    7c8a:	strb	r4, [r0, #10]
				return;
    7c8c:	b.n	7c36 <SPIClass::setSCK(unsigned char)+0x26>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7c8e:	movs	r4, #1
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    7c90:	mov	r1, r4
    7c92:	b.n	7c5e <SPIClass::setSCK(unsigned char)+0x4e>
    7c94:	.word	0x00014624
    7c98:	.word	0x200031c9
    7c9c:	.word	0x000147a0

00007ca0 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    7ca0:	cbz	r3, 7ca6 <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    7ca2:	b.w	7750 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    7ca6:	bx	lr

00007ca8 <breakTime(long, tmElements_t&)>:
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7ca8:	ldr	r2, [pc, #400]	; (7e3c <breakTime(long, tmElements_t&)+0x194>)
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7caa:	ldr	r3, [pc, #404]	; (7e40 <breakTime(long, tmElements_t&)+0x198>)
// leap year calculator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    7cac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cb0:	ldr	r6, [pc, #400]	; (7e44 <breakTime(long, tmElements_t&)+0x19c>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cb2:	ldr.w	sl, [pc, #416]	; 7e54 <breakTime(long, tmElements_t&)+0x1ac>
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cb6:	ldr	r4, [pc, #400]	; (7e48 <breakTime(long, tmElements_t&)+0x1a0>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7cb8:	ldr.w	r9, [pc, #400]	; 7e4c <breakTime(long, tmElements_t&)+0x1a4>
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7cbc:	umull	r5, r2, r2, r0
    7cc0:	mov.w	ip, r2, lsr #16
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cc4:	add.w	r7, ip, #4
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7cc8:	umull	r2, r5, r3, r0
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7ccc:	umull	r6, r2, r6, r0
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cd0:	umull	sl, fp, r7, sl
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7cd4:	lsrs	r5, r5, #5
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cd6:	lsrs	r2, r2, #11
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7cd8:	umull	r6, r3, r3, r5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cdc:	umull	r6, r4, r4, r2
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7ce0:	rsb	r6, fp, r7
    7ce4:	add.w	r6, fp, r6, lsr #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7ce8:	lsrs	r3, r3, #5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cea:	lsrs	r6, r6, #2
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cec:	lsrs	r4, r4, #4
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cee:	rsb	r6, r6, r6, lsl #3
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7cf2:	rsb	r3, r3, r3, lsl #4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7cf6:	add.w	r4, r4, r4, lsl #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7cfa:	sub.w	r3, r5, r3, lsl #2
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7cfe:	subs	r6, r7, r6
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7d00:	rsb	r5, r5, r5, lsl #4
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7d04:	sub.w	r2, r2, r4, lsl #3
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7d08:	sub.w	r0, r0, r5, lsl #2
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7d0c:	adds	r6, #1
    7d0e:	movs	r4, #0
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7d10:	strb	r2, [r1, #2]
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7d12:	strb	r0, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7d14:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7d16:	strb	r6, [r1, #3]
  
  year = 0;  
  days = 0;
    7d18:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7d1a:	movw	fp, #365	; 0x16d
    7d1e:	mov.w	r8, #100	; 0x64
    7d22:	mov.w	sl, #400	; 0x190
    7d26:	b.n	7d46 <breakTime(long, tmElements_t&)+0x9e>
    7d28:	rsb	r5, r6, r5, asr #7
    7d2c:	mls	r5, sl, r5, r3
    7d30:	cbnz	r0, 7d90 <breakTime(long, tmElements_t&)+0xe8>
    7d32:	cmp	r5, #0
    7d34:	ite	ne
    7d36:	movne	r0, fp
    7d38:	moveq.w	r0, #366	; 0x16e
    7d3c:	add	r2, r0
    7d3e:	cmp	ip, r2
    7d40:	add.w	r4, r4, #1
    7d44:	bcc.n	7d6e <breakTime(long, tmElements_t&)+0xc6>
    7d46:	uxtb	r7, r4
    7d48:	addw	r3, r7, #1970	; 0x7b2
    7d4c:	smull	r0, r5, r9, r3
    7d50:	asrs	r6, r3, #31
    7d52:	rsb	r0, r6, r5, asr #5
    7d56:	ands.w	lr, r3, #3
    7d5a:	mls	r0, r8, r0, r3
    7d5e:	beq.n	7d28 <breakTime(long, tmElements_t&)+0x80>
    7d60:	movw	r0, #365	; 0x16d
    7d64:	add	r2, r0
    7d66:	cmp	ip, r2
    7d68:	add.w	r4, r4, #1
    7d6c:	bcs.n	7d46 <breakTime(long, tmElements_t&)+0x9e>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    7d6e:	strb	r7, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7d70:	cmp.w	lr, #0
    7d74:	bne.n	7d96 <breakTime(long, tmElements_t&)+0xee>
    7d76:	ldr	r0, [pc, #212]	; (7e4c <breakTime(long, tmElements_t&)+0x1a4>)
    7d78:	asrs	r6, r3, #31
    7d7a:	smull	r4, r0, r0, r3
    7d7e:	rsb	r4, r6, r0, asr #5
    7d82:	movs	r5, #100	; 0x64
    7d84:	mls	r4, r5, r4, r3
    7d88:	cbz	r4, 7dfa <breakTime(long, tmElements_t&)+0x152>
    7d8a:	mov.w	r4, #366	; 0x16e
    7d8e:	b.n	7d9c <breakTime(long, tmElements_t&)+0xf4>
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7d90:	mov.w	r0, #366	; 0x16e
    7d94:	b.n	7d3c <breakTime(long, tmElements_t&)+0x94>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7d96:	movw	r4, #365	; 0x16d
    7d9a:	asrs	r6, r3, #31
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7d9c:	ldr	r0, [pc, #172]	; (7e4c <breakTime(long, tmElements_t&)+0x1a4>)
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    7d9e:	ldr	r5, [pc, #176]	; (7e50 <breakTime(long, tmElements_t&)+0x1a8>)
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7da0:	smull	r7, r0, r0, r3
    7da4:	rsb	r8, r6, r0, asr #5
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7da8:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7daa:	rsb	r6, r6, r0, asr #7
    7dae:	movs	r4, #100	; 0x64
    7db0:	mov.w	r0, #400	; 0x190
    7db4:	mls	r6, r0, r6, r3
    7db8:	mls	r8, r4, r8, r3
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7dbc:	rsb	r2, r2, ip
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7dc0:	movs	r0, #1
    7dc2:	movs	r3, #0
    7dc4:	b.n	7dcc <breakTime(long, tmElements_t&)+0x124>
    7dc6:	adds	r0, #1
    7dc8:	uxtb	r0, r0
    7dca:	adds	r3, #1
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    7dcc:	cmp	r3, #1
    7dce:	uxtb	r7, r3
    7dd0:	beq.n	7e14 <breakTime(long, tmElements_t&)+0x16c>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7dd2:	ldrb	r4, [r3, r5]
    7dd4:	cmp	r4, r2
    7dd6:	bhi.n	7dec <breakTime(long, tmElements_t&)+0x144>
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7dd8:	cmp	r0, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    7dda:	sub.w	r2, r2, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7dde:	bne.n	7dc6 <breakTime(long, tmElements_t&)+0x11e>
    7de0:	movs	r7, #13
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    7de2:	adds	r2, #1
    7de4:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    7de6:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    7de8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dec:	adds	r7, #1
    7dee:	uxtb	r7, r7
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    7df0:	adds	r2, #1
    7df2:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    7df4:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    7df6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7dfa:	mov.w	r4, #400	; 0x190
    7dfe:	rsb	r0, r6, r0, asr #7
    7e02:	mls	r0, r4, r0, r3
    7e06:	cmp	r0, #0
    7e08:	movw	r4, #365	; 0x16d
    7e0c:	it	eq
    7e0e:	moveq.w	r4, #366	; 0x16e
    7e12:	b.n	7d9c <breakTime(long, tmElements_t&)+0xf4>
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7e14:	cmp.w	lr, #0
    7e18:	bne.n	7e30 <breakTime(long, tmElements_t&)+0x188>
    7e1a:	cmp.w	r8, #0
    7e1e:	bne.n	7e38 <breakTime(long, tmElements_t&)+0x190>
    7e20:	cmp	r6, #0
    7e22:	ite	ne
    7e24:	movne	r4, #28
    7e26:	moveq	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7e28:	cmp	r2, r4
    7e2a:	bcc.n	7e34 <breakTime(long, tmElements_t&)+0x18c>
      time -= monthLength;
    7e2c:	subs	r2, r2, r4
    7e2e:	b.n	7dc6 <breakTime(long, tmElements_t&)+0x11e>
    7e30:	movs	r4, #28
    7e32:	b.n	7e28 <breakTime(long, tmElements_t&)+0x180>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7e34:	movs	r7, #2
    7e36:	b.n	7de2 <breakTime(long, tmElements_t&)+0x13a>
    7e38:	movs	r4, #29
    7e3a:	b.n	7e28 <breakTime(long, tmElements_t&)+0x180>
    7e3c:	.word	0xc22e4507
    7e40:	.word	0x88888889
    7e44:	.word	0x91a2b3c5
    7e48:	.word	0xaaaaaaab
    7e4c:	.word	0x51eb851f
    7e50:	.word	0x0001469c
    7e54:	.word	0x24924925

00007e58 <refreshCache(long) [clone .part.0]>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    7e58:	push	{r4, lr}
  if (t != cacheTime) {
    breakTime(t, tm); 
    7e5a:	ldr	r1, [pc, #12]	; (7e68 <refreshCache(long) [clone .part.0]+0x10>)

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    7e5c:	mov	r4, r0
  if (t != cacheTime) {
    breakTime(t, tm); 
    7e5e:	bl	7ca8 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    7e62:	ldr	r3, [pc, #8]	; (7e6c <refreshCache(long) [clone .part.0]+0x14>)
    7e64:	str	r4, [r3, #0]
    7e66:	pop	{r4, pc}
    7e68:	.word	0x20002b30
    7e6c:	.word	0x20002b2c

00007e70 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    7e70:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7e72:	ldr	r4, [pc, #128]	; (7ef4 <now()+0x84>)
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    7e74:	ldr	r6, [pc, #128]	; (7ef8 <now()+0x88>)
    7e76:	ldr	r3, [r4, #0]
    7e78:	ldr	r2, [r6, #0]
    7e7a:	ldr	r5, [pc, #128]	; (7efc <now()+0x8c>)
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    7e7c:	sub	sp, #12
    7e7e:	ldr	r0, [r5, #0]
    7e80:	str	r3, [sp, #0]
	return ret;
    7e82:	ldr	r3, [sp, #0]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    7e84:	subs	r3, r3, r2
    7e86:	cmp.w	r3, #1000	; 0x3e8
    7e8a:	bcc.n	7eac <now()+0x3c>
    7e8c:	adds	r0, #1
    7e8e:	b.n	7e92 <now()+0x22>
    7e90:	mov	r0, r1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7e92:	ldr	r3, [r4, #0]
    7e94:	str	r3, [sp, #0]
	return ret;
    7e96:	ldr	r3, [sp, #0]
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    7e98:	add.w	r2, r2, #1000	; 0x3e8
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    7e9c:	subs	r3, r3, r2
    7e9e:	cmp.w	r3, #1000	; 0x3e8
    7ea2:	add.w	r1, r0, #1
    7ea6:	bcs.n	7e90 <now()+0x20>
    7ea8:	str	r0, [r5, #0]
    7eaa:	str	r2, [r6, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    7eac:	ldr	r7, [pc, #80]	; (7f00 <now()+0x90>)
    7eae:	ldr	r3, [r7, #0]
    7eb0:	cmp	r0, r3
    7eb2:	bcc.n	7ed4 <now()+0x64>
    if (getTimePtr != 0) {
    7eb4:	ldr	r3, [pc, #76]	; (7f04 <now()+0x94>)
    7eb6:	ldr	r3, [r3, #0]
    7eb8:	cbz	r3, 7ed4 <now()+0x64>
      time_t t = getTimePtr();
    7eba:	blx	r3
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    7ebc:	ldr	r3, [pc, #72]	; (7f08 <now()+0x98>)
#endif
  }
  if (nextSyncTime <= sysTime) {
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
    7ebe:	cbnz	r0, 7ed8 <now()+0x68>
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7ec0:	ldr	r1, [pc, #72]	; (7f0c <now()+0x9c>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7ec2:	ldr	r2, [r3, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7ec4:	ldrb	r3, [r1, #0]
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7ec6:	ldr	r0, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7ec8:	adds	r3, #0
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7eca:	add	r2, r0
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7ecc:	it	ne
    7ece:	movne	r3, #1
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7ed0:	str	r2, [r7, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7ed2:	strb	r3, [r1, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    7ed4:	add	sp, #12
    7ed6:	pop	{r4, r5, r6, r7, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7ed8:	ldr	r2, [r4, #0]
    7eda:	str	r2, [sp, #4]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    7edc:	ldr	r3, [r3, #0]
  Status = timeSet;
    7ede:	ldr	r2, [pc, #44]	; (7f0c <now()+0x9c>)
	return ret;
    7ee0:	ldr	r4, [sp, #4]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    7ee2:	str	r0, [r5, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    7ee4:	add	r3, r0
  Status = timeSet;
    7ee6:	movs	r1, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    7ee8:	str	r4, [r6, #0]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    7eea:	str	r3, [r7, #0]
  Status = timeSet;
    7eec:	strb	r1, [r2, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
      }
    }
  }  
  return (time_t)sysTime;
}
    7eee:	add	sp, #12
    7ef0:	pop	{r4, r5, r6, r7, pc}
    7ef2:	nop
    7ef4:	.word	0x200030a4
    7ef8:	.word	0x20002b44
    7efc:	.word	0x20002b38
    7f00:	.word	0x20002b48
    7f04:	.word	0x20002b40
    7f08:	.word	0x1fff8a98
    7f0c:	.word	0x20002b3c

00007f10 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    7f10:	push	{r3, lr}
  return hour(now()); 
    7f12:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7f16:	ldr	r3, [pc, #16]	; (7f28 <hour()+0x18>)
    7f18:	ldr	r3, [r3, #0]
    7f1a:	cmp	r0, r3
    7f1c:	beq.n	7f22 <hour()+0x12>
    7f1e:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
    7f22:	ldr	r3, [pc, #8]	; (7f2c <hour()+0x1c>)
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    7f24:	ldrb	r0, [r3, #2]
    7f26:	pop	{r3, pc}
    7f28:	.word	0x20002b2c
    7f2c:	.word	0x20002b30

00007f30 <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    7f30:	push	{r3, lr}
  return minute(now()); 
    7f32:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7f36:	ldr	r3, [pc, #16]	; (7f48 <minute()+0x18>)
    7f38:	ldr	r3, [r3, #0]
    7f3a:	cmp	r0, r3
    7f3c:	beq.n	7f42 <minute()+0x12>
    7f3e:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
    7f42:	ldr	r3, [pc, #8]	; (7f4c <minute()+0x1c>)
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    7f44:	ldrb	r0, [r3, #1]
    7f46:	pop	{r3, pc}
    7f48:	.word	0x20002b2c
    7f4c:	.word	0x20002b30

00007f50 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    7f50:	push	{r3, lr}
  return second(now()); 
    7f52:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7f56:	ldr	r3, [pc, #16]	; (7f68 <second()+0x18>)
    7f58:	ldr	r3, [r3, #0]
    7f5a:	cmp	r0, r3
    7f5c:	beq.n	7f62 <second()+0x12>
    7f5e:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
    7f62:	ldr	r3, [pc, #8]	; (7f6c <second()+0x1c>)
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    7f64:	ldrb	r0, [r3, #0]
    7f66:	pop	{r3, pc}
    7f68:	.word	0x20002b2c
    7f6c:	.word	0x20002b30

00007f70 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    7f70:	push	{r3, lr}
  return(day(now())); 
    7f72:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7f76:	ldr	r3, [pc, #16]	; (7f88 <day()+0x18>)
    7f78:	ldr	r3, [r3, #0]
    7f7a:	cmp	r0, r3
    7f7c:	beq.n	7f82 <day()+0x12>
    7f7e:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
    7f82:	ldr	r3, [pc, #8]	; (7f8c <day()+0x1c>)
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    7f84:	ldrb	r0, [r3, #4]
    7f86:	pop	{r3, pc}
    7f88:	.word	0x20002b2c
    7f8c:	.word	0x20002b30

00007f90 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    7f90:	push	{r3, lr}
  return month(now()); 
    7f92:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7f96:	ldr	r3, [pc, #16]	; (7fa8 <month()+0x18>)
    7f98:	ldr	r3, [r3, #0]
    7f9a:	cmp	r0, r3
    7f9c:	beq.n	7fa2 <month()+0x12>
    7f9e:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
    7fa2:	ldr	r3, [pc, #8]	; (7fac <month()+0x1c>)
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    7fa4:	ldrb	r0, [r3, #5]
    7fa6:	pop	{r3, pc}
    7fa8:	.word	0x20002b2c
    7fac:	.word	0x20002b30

00007fb0 <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    7fb0:	push	{r3, lr}
  return year(now()); 
    7fb2:	bl	7e70 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    7fb6:	ldr	r3, [pc, #20]	; (7fcc <year()+0x1c>)
    7fb8:	ldr	r3, [r3, #0]
    7fba:	cmp	r0, r3
    7fbc:	beq.n	7fc2 <year()+0x12>
    7fbe:	bl	7e58 <refreshCache(long) [clone .part.0]>
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
    7fc2:	ldr	r3, [pc, #12]	; (7fd0 <year()+0x20>)
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    7fc4:	ldrb	r0, [r3, #6]
}
    7fc6:	addw	r0, r0, #1970	; 0x7b2
    7fca:	pop	{r3, pc}
    7fcc:	.word	0x20002b2c
    7fd0:	.word	0x20002b30

00007fd4 <setSyncProvider(long (*)())>:
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
  nextSyncTime = sysTime;
    7fd4:	ldr	r1, [pc, #12]	; (7fe4 <setSyncProvider(long (*)())+0x10>)
    7fd6:	ldr	r2, [pc, #16]	; (7fe8 <setSyncProvider(long (*)())+0x14>)
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    7fd8:	ldr	r3, [pc, #16]	; (7fec <setSyncProvider(long (*)())+0x18>)
  nextSyncTime = sysTime;
    7fda:	ldr	r1, [r1, #0]
    7fdc:	str	r1, [r2, #0]
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    7fde:	str	r0, [r3, #0]
  nextSyncTime = sysTime;
  now(); // this will sync the clock
    7fe0:	b.w	7e70 <now()>
    7fe4:	.word	0x20002b38
    7fe8:	.word	0x20002b48
    7fec:	.word	0x20002b40

00007ff0 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE>:
audio_block_t * AudioOutputPWM::block_2nd = NULL;
uint32_t  AudioOutputPWM::block_offset = 0;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    7ff0:	ldr	r2, [pc, #8]	; (7ffc <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0xc>)
    7ff2:	ldr	r1, [pc, #12]	; (8000 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x10>)
    7ff4:	ldr	r0, [pc, #12]	; (8004 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x14>)
    7ff6:	b.w	eb28 <__aeabi_atexit>
    7ffa:	nop
    7ffc:	.word	0x1fff8a3c
    8000:	.word	0x0000077d
    8004:	.word	0x20002b4c

00008008 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    8008:	ldr	r2, [pc, #8]	; (8014 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    800a:	ldr	r1, [pc, #12]	; (8018 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    800c:	ldr	r0, [pc, #12]	; (801c <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    800e:	b.w	eb28 <__aeabi_atexit>
    8012:	nop
    8014:	.word	0x1fff8a3c
    8018:	.word	0x0000077d
    801c:	.word	0x20002b54

00008020 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    8020:	ldr	r2, [pc, #8]	; (802c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    8022:	ldr	r1, [pc, #12]	; (8030 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    8024:	ldr	r0, [pc, #12]	; (8034 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    8026:	b.w	eb28 <__aeabi_atexit>
    802a:	nop
    802c:	.word	0x1fff8a3c
    8030:	.word	0x0000077d
    8034:	.word	0x20002b5c

00008038 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM __attribute__((aligned(32))) static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    8038:	ldr	r2, [pc, #8]	; (8044 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    803a:	ldr	r1, [pc, #12]	; (8048 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    803c:	ldr	r0, [pc, #12]	; (804c <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    803e:	b.w	eb28 <__aeabi_atexit>
    8042:	nop
    8044:	.word	0x1fff8a3c
    8048:	.word	0x0000077d
    804c:	.word	0x20002b64

00008050 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    8050:	ldr	r2, [pc, #8]	; (805c <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    8052:	ldr	r1, [pc, #12]	; (8060 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    8054:	ldr	r0, [pc, #12]	; (8064 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    8056:	b.w	eb28 <__aeabi_atexit>
    805a:	nop
    805c:	.word	0x1fff8a3c
    8060:	.word	0x0000077d
    8064:	.word	0x20002b6c

00008068 <AudioControlSGTL5000::disable()>:
public:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
	void setAddress(uint8_t level);
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
    8068:	movs	r0, #0
    806a:	bx	lr

0000806c <AudioControlSGTL5000::inputLevel(float)>:
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
    806c:	movs	r0, #0
    806e:	bx	lr

00008070 <AudioControlSGTL5000::read(unsigned int)>:
	return true;
}


unsigned int AudioControlSGTL5000::read(unsigned int reg)
{
    8070:	push	{r3, r4, r5, r6, r7, lr}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    8072:	ldr	r4, [pc, #124]	; (80f0 <AudioControlSGTL5000::read(unsigned int)+0x80>)
    8074:	ldrb	r2, [r0, #8]
    8076:	mov	r6, r1
    8078:	lsls	r2, r2, #1
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    807a:	ubfx	r1, r1, #8, #8
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    807e:	movs	r5, #1
    8080:	mov	r7, r0
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    8082:	mov	r0, r4
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    8084:	strb.w	r2, [r4, #59]	; 0x3b
		transmitting = 1;
    8088:	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    808c:	strb.w	r5, [r4, #93]	; 0x5d
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    8090:	bl	8654 <TwoWire::write(unsigned char)>
    8094:	uxtb	r1, r6
    8096:	mov	r0, r4
    8098:	bl	8654 <TwoWire::write(unsigned char)>
	unsigned int val;
	Wire.beginTransmission(i2c_addr);
	Wire.write(reg >> 8);
	Wire.write(reg);
	if (Wire.endTransmission(false) != 0) return 0;
    809c:	mov	r0, r4
    809e:	movs	r1, #0
    80a0:	bl	899c <TwoWire::endTransmission(unsigned char)>
    80a4:	cbz	r0, 80aa <AudioControlSGTL5000::read(unsigned int)+0x3a>
    80a6:	movs	r0, #0
    80a8:	pop	{r3, r4, r5, r6, r7, pc}
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    80aa:	mov	r3, r5
    80ac:	ldrb	r1, [r7, #8]
    80ae:	movs	r2, #2
    80b0:	mov	r0, r4
    80b2:	bl	8ab0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
	if (Wire.requestFrom((int)i2c_addr, 2) < 2) return 0;
    80b6:	cmp	r0, #1
    80b8:	bls.n	80a6 <AudioControlSGTL5000::read(unsigned int)+0x36>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    80ba:	ldrb.w	r1, [r4, #56]	; 0x38
    80be:	ldrb.w	r5, [r4, #57]	; 0x39
    80c2:	cmp	r1, r5
    80c4:	bcs.n	80e8 <AudioControlSGTL5000::read(unsigned int)+0x78>
		return rxBuffer[rxBufferIndex++];
    80c6:	adds	r3, r4, r1
    80c8:	adds	r2, r1, #1
    80ca:	uxtb	r2, r2
	val = Wire.read() << 8;
    80cc:	ldrb	r0, [r3, #24]
    80ce:	strb.w	r2, [r4, #56]	; 0x38
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    80d2:	cmp	r5, r2
    80d4:	mov.w	r3, r0, lsl #8
    80d8:	bls.n	80e8 <AudioControlSGTL5000::read(unsigned int)+0x78>
		return rxBuffer[rxBufferIndex++];
    80da:	add	r2, r4
    80dc:	adds	r1, #2
    80de:	ldrb	r0, [r2, #24]
    80e0:	strb.w	r1, [r4, #56]	; 0x38
    80e4:	orrs	r0, r3
    80e6:	pop	{r3, r4, r5, r6, r7, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    80e8:	mov.w	r0, #4294967295
	val |= Wire.read();
	return val;
}
    80ec:	pop	{r3, r4, r5, r6, r7, pc}
    80ee:	nop
    80f0:	.word	0x1fff8a9c

000080f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>:

bool AudioControlSGTL5000::write(unsigned int reg, unsigned int val)
{
    80f4:	push	{r3, r4, r5, r6, r7, lr}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    80f6:	ldr	r4, [pc, #80]	; (8148 <AudioControlSGTL5000::write(unsigned int, unsigned int)+0x54>)
    80f8:	ldrb	r3, [r0, #8]
	if (reg == CHIP_ANA_CTRL) ana_ctrl = val;
    80fa:	cmp	r1, #36	; 0x24
    80fc:	it	eq
    80fe:	strheq	r2, [r0, #6]
    8100:	lsls	r3, r3, #1
		transmitting = 1;
    8102:	movs	r5, #1
	val |= Wire.read();
	return val;
}

bool AudioControlSGTL5000::write(unsigned int reg, unsigned int val)
{
    8104:	mov	r6, r1
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    8106:	mov	r0, r4
    8108:	ubfx	r1, r1, #8, #8
    810c:	mov	r7, r2
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    810e:	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    8112:	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    8116:	strb.w	r5, [r4, #93]	; 0x5d
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    811a:	bl	8654 <TwoWire::write(unsigned char)>
    811e:	uxtb	r1, r6
    8120:	mov	r0, r4
    8122:	bl	8654 <TwoWire::write(unsigned char)>
    8126:	ubfx	r1, r7, #8, #8
    812a:	mov	r0, r4
    812c:	bl	8654 <TwoWire::write(unsigned char)>
    8130:	uxtb	r1, r7
    8132:	mov	r0, r4
    8134:	bl	8654 <TwoWire::write(unsigned char)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    8138:	mov	r1, r5
    813a:	mov	r0, r4
    813c:	bl	899c <TwoWire::endTransmission(unsigned char)>
	Wire.write(reg);
	Wire.write(val >> 8);
	Wire.write(val);
	if (Wire.endTransmission() == 0) return true;
	return false;
}
    8140:	clz	r0, r0
    8144:	lsrs	r0, r0, #5
    8146:	pop	{r3, r4, r5, r6, r7, pc}
    8148:	.word	0x1fff8a9c

0000814c <AudioControlSGTL5000::micGain(unsigned int)>:

bool AudioControlSGTL5000::micGain(unsigned int dB)
{
	unsigned int preamp_gain, input_gain;

	if (dB >= 40) {
    814c:	cmp	r1, #39	; 0x27
	unsigned short m=((0x7F-calcVol(right,0x7F))<<8)|(0x7F-calcVol(left,0x7F));
	return write(CHIP_ANA_HP_CTRL, m);
}

bool AudioControlSGTL5000::micGain(unsigned int dB)
{
    814e:	push	{r3, r4, r5, lr}
    8150:	mov	r4, r1
    8152:	mov	r5, r0
	unsigned int preamp_gain, input_gain;

	if (dB >= 40) {
    8154:	bls.n	816a <AudioControlSGTL5000::micGain(unsigned int)+0x1e>
		preamp_gain = 3;
		dB -= 40;
    8156:	sub.w	r4, r1, #40	; 0x28
    815a:	movw	r2, #371	; 0x173
		preamp_gain = 0;
	}
	input_gain = (dB * 2) / 3;
	if (input_gain > 15) input_gain = 15;

	return write(CHIP_MIC_CTRL, 0x0170 | preamp_gain)
    815e:	movs	r1, #42	; 0x2a
    8160:	mov	r0, r5
    8162:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	    && write(CHIP_ANA_ADC_CTRL, (input_gain << 4) | input_gain);
    8166:	cbnz	r0, 8182 <AudioControlSGTL5000::micGain(unsigned int)+0x36>
}
    8168:	pop	{r3, r4, r5, pc}
	unsigned int preamp_gain, input_gain;

	if (dB >= 40) {
		preamp_gain = 3;
		dB -= 40;
	} else if (dB >= 30) {
    816a:	cmp	r1, #29
    816c:	bls.n	81a2 <AudioControlSGTL5000::micGain(unsigned int)+0x56>
		preamp_gain = 2;
		dB -= 30;
    816e:	sub.w	r4, r1, #30
    8172:	mov.w	r2, #370	; 0x172
		preamp_gain = 0;
	}
	input_gain = (dB * 2) / 3;
	if (input_gain > 15) input_gain = 15;

	return write(CHIP_MIC_CTRL, 0x0170 | preamp_gain)
    8176:	movs	r1, #42	; 0x2a
    8178:	mov	r0, r5
    817a:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	    && write(CHIP_ANA_ADC_CTRL, (input_gain << 4) | input_gain);
    817e:	cmp	r0, #0
    8180:	beq.n	8168 <AudioControlSGTL5000::micGain(unsigned int)+0x1c>
		preamp_gain = 1;
		dB -= 20;
	} else {
		preamp_gain = 0;
	}
	input_gain = (dB * 2) / 3;
    8182:	ldr	r2, [pc, #48]	; (81b4 <AudioControlSGTL5000::micGain(unsigned int)+0x68>)
    8184:	lsls	r4, r4, #1
    8186:	umull	r3, r2, r2, r4
    818a:	lsrs	r2, r2, #1
    818c:	cmp	r2, #15
    818e:	it	cs
    8190:	movcs	r2, #15
	if (input_gain > 15) input_gain = 15;

	return write(CHIP_MIC_CTRL, 0x0170 | preamp_gain)
	    && write(CHIP_ANA_ADC_CTRL, (input_gain << 4) | input_gain);
    8192:	mov	r0, r5
    8194:	orr.w	r2, r2, r2, lsl #4
    8198:	movs	r1, #32
}
    819a:	ldmia.w	sp!, {r3, r4, r5, lr}
	}
	input_gain = (dB * 2) / 3;
	if (input_gain > 15) input_gain = 15;

	return write(CHIP_MIC_CTRL, 0x0170 | preamp_gain)
	    && write(CHIP_ANA_ADC_CTRL, (input_gain << 4) | input_gain);
    819e:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		preamp_gain = 3;
		dB -= 40;
	} else if (dB >= 30) {
		preamp_gain = 2;
		dB -= 30;
	} else if (dB >= 20) {
    81a2:	cmp	r1, #19
		preamp_gain = 1;
		dB -= 20;
    81a4:	itte	hi
    81a6:	subhi.w	r4, r1, #20
    81aa:	movwhi	r2, #369	; 0x171
    81ae:	movls.w	r2, #368	; 0x170
    81b2:	b.n	815e <AudioControlSGTL5000::micGain(unsigned int)+0x12>
    81b4:	.word	0xaaaaaaab

000081b8 <AudioControlSGTL5000::enable(unsigned int, unsigned long)>:
	return enable(0);
#endif	
}

bool AudioControlSGTL5000::enable(const unsigned extMCLK, const uint32_t pllFreq)
{
    81b8:	push	{r3, r4, r5, r6, r7, lr}
    81ba:	mov	r4, r0

	Wire.begin();
    81bc:	ldr	r0, [pc, #492]	; (83ac <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1f4>)
	return enable(0);
#endif	
}

bool AudioControlSGTL5000::enable(const unsigned extMCLK, const uint32_t pllFreq)
{
    81be:	mov	r5, r1
    81c0:	mov	r6, r2

	Wire.begin();
    81c2:	bl	867c <TwoWire::begin()>
	delay(5);
    81c6:	movs	r0, #5
    81c8:	bl	d808 <delay>
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
    81cc:	mov	r0, r4
    81ce:	movs	r1, #6
    81d0:	bl	8070 <AudioControlSGTL5000::read(unsigned int)>
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
    81d4:	cmp	r5, #0
    81d6:	beq.w	8306 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x14e>
    81da:	cmp	r0, #176	; 0xb0
    81dc:	beq.w	83a2 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1ea>
	//Serial.print("chip ID = ");
	//delay(5);
	//unsigned int n = read(CHIP_ID);
	//Serial.println(n, HEX);

        muted = true;
    81e0:	movs	r7, #1
    81e2:	strb	r7, [r4, #4]

	int r = write(CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    81e4:	movw	r2, #16480	; 0x4060
    81e8:	movs	r1, #48	; 0x30
    81ea:	mov	r0, r4
    81ec:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	if (!r) return false;
    81f0:	cbnz	r0, 81f6 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x3e>
    81f2:	movs	r0, #0
    81f4:	pop	{r3, r4, r5, r6, r7, pc}
	write(CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    81f6:	movs	r2, #108	; 0x6c
    81f8:	movs	r1, #38	; 0x26
    81fa:	mov	r0, r4
    81fc:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    8200:	mov.w	r2, #498	; 0x1f2
    8204:	movs	r1, #40	; 0x28
    8206:	mov	r0, r4
    8208:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    820c:	movw	r2, #3874	; 0xf22
    8210:	movs	r1, #44	; 0x2c
    8212:	mov	r0, r4
    8214:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    8218:	movw	r2, #17478	; 0x4446
    821c:	movs	r1, #60	; 0x3c
    821e:	mov	r0, r4
    8220:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    8224:	movw	r2, #311	; 0x137
    8228:	movs	r1, #36	; 0x24
    822a:	mov	r0, r4
    822c:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		
	if (extMCLK > 0) {
		//SGTL is I2S Master
		//Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
		if (extMCLK > 17000000) {
    8230:	ldr	r3, [pc, #380]	; (83b0 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1f8>)
    8232:	cmp	r5, r3
    8234:	bhi.w	8396 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1de>
			write(CHIP_CLK_TOP_CTRL, 1);
		} else {
			write(CHIP_CLK_TOP_CTRL, 0);
    8238:	movs	r2, #0
    823a:	movs	r1, #52	; 0x34
    823c:	mov	r0, r4
    823e:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		}

		uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    8242:	udiv	r3, r6, r5
		uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    8246:	mov	r0, r6
			write(CHIP_CLK_TOP_CTRL, 1);
		} else {
			write(CHIP_CLK_TOP_CTRL, 0);
		}

		uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    8248:	and.w	r6, r3, #31
		uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    824c:	bl	f660 <__aeabi_ui2f>
    8250:	mov	r7, r0
    8252:	mov	r0, r5
    8254:	bl	f660 <__aeabi_ui2f>
    8258:	mov	r1, r0
    825a:	mov	r0, r7
    825c:	bl	f878 <__aeabi_fdiv>
    8260:	mov	r5, r0
    8262:	mov	r0, r6
    8264:	bl	f660 <__aeabi_ui2f>
    8268:	mov	r1, r0
    826a:	mov	r0, r5
    826c:	bl	f4fc <__aeabi_fsub>
    8270:	mov.w	r1, #1157627904	; 0x45000000
    8274:	bl	f710 <__aeabi_fmul>
    8278:	bl	fb14 <__aeabi_f2uiz>
    827c:	ubfx	r2, r0, #0, #11
    8280:	orr.w	r2, r2, r6, lsl #11
    8284:	movs	r1, #50	; 0x32
    8286:	mov	r0, r4
    8288:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
    828c:	movw	r2, #17919	; 0x45ff
    8290:	movs	r1, #48	; 0x30
    8292:	mov	r0, r4
    8294:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	} else {
		//SGTL is I2S Slave
		write(CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
	}

	write(CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    8298:	movs	r2, #115	; 0x73
    829a:	movs	r1, #2
    829c:	mov	r0, r4
    829e:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	delay(400);
    82a2:	mov.w	r0, #400	; 0x190
    82a6:	bl	d808 <delay>
	write(CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    82aa:	movw	r2, #7453	; 0x1d1d
    82ae:	movs	r1, #46	; 0x2e
    82b0:	mov	r0, r4
    82b2:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	
	if (extMCLK > 0) { 
		//SGTL is I2S Master
		write(CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
    82b6:	movs	r2, #7
    82b8:	movs	r1, #4
    82ba:	mov	r0, r4
    82bc:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
    82c0:	movs	r2, #176	; 0xb0
    82c2:	movs	r1, #6
    82c4:	mov	r0, r4
    82c6:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
		write(CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
	}

	// default signal routing is ok?
	write(CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    82ca:	movs	r2, #16
    82cc:	movs	r1, #10
    82ce:	mov	r0, r4
    82d0:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    82d4:	movs	r2, #0
    82d6:	movs	r1, #14
    82d8:	mov	r0, r4
    82da:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    82de:	movw	r2, #15420	; 0x3c3c
    82e2:	movs	r1, #16
    82e4:	mov	r0, r4
    82e6:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    82ea:	movw	r2, #32639	; 0x7f7f
    82ee:	movs	r1, #34	; 0x22
    82f0:	mov	r0, r4
    82f2:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    82f6:	movs	r2, #54	; 0x36
    82f8:	movs	r1, #36	; 0x24
    82fa:	mov	r0, r4
    82fc:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>

	semi_automated = true;
    8300:	movs	r0, #1
    8302:	strb	r0, [r4, #9]
    8304:	pop	{r3, r4, r5, r6, r7, pc}
	//Serial.print("chip ID = ");
	//delay(5);
	//unsigned int n = read(CHIP_ID);
	//Serial.println(n, HEX);

        muted = true;
    8306:	movs	r3, #1
    8308:	strb	r3, [r4, #4]

	int r = write(CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    830a:	movw	r2, #16480	; 0x4060
    830e:	movs	r1, #48	; 0x30
    8310:	mov	r0, r4
    8312:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	if (!r) return false;
    8316:	cmp	r0, #0
    8318:	beq.w	81f2 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x3a>
	write(CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    831c:	movs	r2, #108	; 0x6c
    831e:	movs	r1, #38	; 0x26
    8320:	mov	r0, r4
    8322:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    8326:	mov.w	r2, #498	; 0x1f2
    832a:	movs	r1, #40	; 0x28
    832c:	mov	r0, r4
    832e:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    8332:	movw	r2, #3874	; 0xf22
    8336:	movs	r1, #44	; 0x2c
    8338:	mov	r0, r4
    833a:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    833e:	movw	r2, #17478	; 0x4446
    8342:	movs	r1, #60	; 0x3c
    8344:	mov	r0, r4
    8346:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    834a:	movw	r2, #311	; 0x137
    834e:	movs	r1, #36	; 0x24
    8350:	mov	r0, r4
    8352:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
		write(CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
	} else {
		//SGTL is I2S Slave
		write(CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    8356:	movw	r2, #16639	; 0x40ff
    835a:	movs	r1, #48	; 0x30
    835c:	mov	r0, r4
    835e:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	}

	write(CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    8362:	movs	r2, #115	; 0x73
    8364:	movs	r1, #2
    8366:	mov	r0, r4
    8368:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	delay(400);
    836c:	mov.w	r0, #400	; 0x190
    8370:	bl	d808 <delay>
	write(CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    8374:	movw	r2, #7453	; 0x1d1d
    8378:	movs	r1, #46	; 0x2e
    837a:	mov	r0, r4
    837c:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		//SGTL is I2S Master
		write(CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
		write(CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
	} else {
		//SGTL is I2S Slave
		write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
    8380:	movs	r2, #4
    8382:	mov	r1, r2
    8384:	mov	r0, r4
    8386:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
    838a:	movs	r2, #48	; 0x30
    838c:	movs	r1, #6
    838e:	mov	r0, r4
    8390:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    8394:	b.n	82ca <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x112>
		
	if (extMCLK > 0) {
		//SGTL is I2S Master
		//Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
		if (extMCLK > 17000000) {
			write(CHIP_CLK_TOP_CTRL, 1);
    8396:	mov	r2, r7
    8398:	movs	r1, #52	; 0x34
    839a:	mov	r0, r4
    839c:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    83a0:	b.n	8242 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x8a>
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
		//Yes. Do not initialize.
		muted = false;
    83a2:	movs	r3, #0
		semi_automated = true;
    83a4:	movs	r0, #1
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
		//Yes. Do not initialize.
		muted = false;
    83a6:	strb	r3, [r4, #4]
		semi_automated = true;
    83a8:	strb	r0, [r4, #9]
		return true;
    83aa:	pop	{r3, r4, r5, r6, r7, pc}
    83ac:	.word	0x1fff8a9c
    83b0:	.word	0x01036640

000083b4 <AudioControlSGTL5000::enable()>:

bool AudioControlSGTL5000::enable(void) {
#if defined(KINETISL)
	return enable(16000000); // SGTL as Master with 16MHz MCLK from Teensy LC
#else	
	return enable(0);
    83b4:	ldr	r2, [pc, #4]	; (83bc <AudioControlSGTL5000::enable()+0x8>)
    83b6:	movs	r1, #0
    83b8:	b.w	81b8 <AudioControlSGTL5000::enable(unsigned int, unsigned long)>
    83bc:	.word	0x0ac55a5a

000083c0 <AudioControlSGTL5000::inputSelect(int)>:
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
    83c0:	push	{r4, lr}
    83c2:	mov	r4, r0
		if (n == AUDIO_INPUT_LINEIN) {
    83c4:	cbz	r1, 83ce <AudioControlSGTL5000::inputSelect(int)+0xe>
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
    83c6:	cmp	r1, #1
    83c8:	beq.n	83ee <AudioControlSGTL5000::inputSelect(int)+0x2e>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
		} else {
			return false;
		}
	}
    83ca:	movs	r0, #0
    83cc:	pop	{r4, pc}
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
    83ce:	movs	r2, #85	; 0x55
    83d0:	movs	r1, #32
    83d2:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
    83d6:	cmp	r0, #0
    83d8:	beq.n	83ca <AudioControlSGTL5000::inputSelect(int)+0xa>
    83da:	ldrh	r2, [r4, #6]
    83dc:	orr.w	r2, r2, #4
    83e0:	mov	r0, r4
    83e2:	uxth	r2, r2
    83e4:	movs	r1, #36	; 0x24
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
		} else {
			return false;
		}
	}
    83e6:	ldmia.w	sp!, {r4, lr}
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
    83ea:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
    83ee:	movw	r2, #371	; 0x173
    83f2:	movs	r1, #42	; 0x2a
    83f4:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    83f8:	cmp	r0, #0
    83fa:	beq.n	83ca <AudioControlSGTL5000::inputSelect(int)+0xa>
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
    83fc:	movs	r2, #136	; 0x88
    83fe:	movs	r1, #32
    8400:	mov	r0, r4
    8402:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    8406:	cmp	r0, #0
    8408:	beq.n	83ca <AudioControlSGTL5000::inputSelect(int)+0xa>
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    840a:	ldrh	r2, [r4, #6]
    840c:	mov	r0, r4
    840e:	bic.w	r2, r2, #4
    8412:	movs	r1, #36	; 0x24
		} else {
			return false;
		}
	}
    8414:	ldmia.w	sp!, {r4, lr}
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    8418:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>

0000841c <AudioControlSGTL5000::volumeInteger(unsigned int)>:
	if(!write(reg,val1)) return 0;
	return val1;
}

bool AudioControlSGTL5000::volumeInteger(unsigned int n)
{
    841c:	push	{r3, r4, r5, lr}
    841e:	mov	r5, r0
	if (n == 0) {
    8420:	cbz	r1, 8460 <AudioControlSGTL5000::volumeInteger(unsigned int)+0x44>
		muted = true;
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
		return muteHeadphone();
	} else if (n > 0x80) {
    8422:	cmp	r1, #128	; 0x80
		n = 0;
	} else {
		n = 0x80 - n;
	}
	if (muted) {
    8424:	ldrb	r3, [r0, #4]
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
		return muteHeadphone();
	} else if (n > 0x80) {
		n = 0;
	} else {
		n = 0x80 - n;
    8426:	itte	ls
    8428:	rsbls	r4, r1, #128	; 0x80
    842c:	orrls.w	r4, r4, r4, lsl #8
    8430:	movhi	r4, #0
	}
	if (muted) {
    8432:	cbnz	r3, 8442 <AudioControlSGTL5000::volumeInteger(unsigned int)+0x26>
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    8434:	mov	r2, r4
    8436:	mov	r0, r5
    8438:	movs	r1, #34	; 0x22
}
    843a:	ldmia.w	sp!, {r3, r4, r5, lr}
	if (muted) {
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    843e:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
    8442:	ldrh	r2, [r0, #6]
		n = 0;
	} else {
		n = 0x80 - n;
	}
	if (muted) {
		muted = false;
    8444:	movs	r3, #0
    8446:	bic.w	r2, r2, #16
    844a:	strb	r3, [r0, #4]
    844c:	movs	r1, #36	; 0x24
    844e:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    8452:	mov	r2, r4
    8454:	mov	r0, r5
    8456:	movs	r1, #34	; 0x22
}
    8458:	ldmia.w	sp!, {r3, r4, r5, lr}
	if (muted) {
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    845c:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
}

bool AudioControlSGTL5000::volumeInteger(unsigned int n)
{
	if (n == 0) {
		muted = true;
    8460:	movs	r3, #1
    8462:	strb	r3, [r0, #4]
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
    8464:	movw	r2, #32639	; 0x7f7f
    8468:	movs	r1, #34	; 0x22
    846a:	bl	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
    846e:	ldrh	r2, [r5, #6]
    8470:	orr.w	r2, r2, #16
    8474:	mov	r0, r5
    8476:	uxth	r2, r2
    8478:	movs	r1, #36	; 0x24
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
}
    847a:	ldmia.w	sp!, {r3, r4, r5, lr}
    847e:	b.w	80f4 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    8482:	nop

00008484 <AudioControlSGTL5000::volume(float)>:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
	void setAddress(uint8_t level);
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
    8484:	mov	r3, r1
    8486:	push	{r4, lr}
    8488:	ldr	r1, [pc, #28]	; (84a8 <AudioControlSGTL5000::volume(float)+0x24>)
    848a:	mov	r4, r0
    848c:	mov	r0, r3
    848e:	bl	f710 <__aeabi_fmul>
    8492:	ldr	r1, [pc, #24]	; (84ac <AudioControlSGTL5000::volume(float)+0x28>)
    8494:	bl	f500 <__addsf3>
    8498:	bl	fb14 <__aeabi_f2uiz>
    849c:	mov	r1, r0
    849e:	mov	r0, r4
    84a0:	ldmia.w	sp!, {r4, lr}
    84a4:	b.w	841c <AudioControlSGTL5000::volumeInteger(unsigned int)>
    84a8:	.word	0x43010000
    84ac:	.word	0x3eff7cee

000084b0 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM __attribute__((aligned(32))) static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    84b0:	ldr	r2, [pc, #8]	; (84bc <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    84b2:	ldr	r1, [pc, #12]	; (84c0 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    84b4:	ldr	r0, [pc, #12]	; (84c4 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    84b6:	b.w	eb28 <__aeabi_atexit>
    84ba:	nop
    84bc:	.word	0x1fff8a3c
    84c0:	.word	0x0000077d
    84c4:	.word	0x20002b74

000084c8 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    84c8:	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    84ca:	ldr	r5, [pc, #28]	; (84e8 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    84cc:	ldr	r4, [pc, #28]	; (84ec <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    84ce:	ldr	r0, [pc, #32]	; (84f0 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    84d0:	mov	r2, r5
    84d2:	mov	r1, r4
    84d4:	bl	eb28 <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    84d8:	mov	r2, r5
    84da:	mov	r1, r4
    84dc:	ldr	r0, [pc, #20]	; (84f4 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    84de:	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    84e2:	b.w	eb28 <__aeabi_atexit>
    84e6:	nop
    84e8:	.word	0x1fff8a3c
    84ec:	.word	0x0000077d
    84f0:	.word	0x20002b7c
    84f4:	.word	0x20002b84

000084f8 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    84f8:	ldr	r2, [pc, #8]	; (8504 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    84fa:	ldr	r1, [pc, #12]	; (8508 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    84fc:	ldr	r0, [pc, #12]	; (850c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    84fe:	b.w	eb28 <__aeabi_atexit>
    8502:	nop
    8504:	.word	0x1fff8a3c
    8508:	.word	0x0000077d
    850c:	.word	0x20002b8c

00008510 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    8510:	ldr	r2, [pc, #8]	; (851c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    8512:	ldr	r1, [pc, #12]	; (8520 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    8514:	ldr	r0, [pc, #12]	; (8524 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    8516:	b.w	eb28 <__aeabi_atexit>
    851a:	nop
    851c:	.word	0x1fff8a3c
    8520:	.word	0x0000077d
    8524:	.word	0x20002b94

00008528 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
    8528:	ldr	r2, [pc, #8]	; (8534 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
    852a:	ldr	r1, [pc, #12]	; (8538 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
    852c:	ldr	r0, [pc, #12]	; (853c <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
    852e:	b.w	eb28 <__aeabi_atexit>
    8532:	nop
    8534:	.word	0x1fff8a3c
    8538:	.word	0x0000077d
    853c:	.word	0x20002b9c

00008540 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    8540:	ldr	r2, [pc, #8]	; (854c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    8542:	ldr	r1, [pc, #12]	; (8550 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    8544:	ldr	r0, [pc, #12]	; (8554 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    8546:	b.w	eb28 <__aeabi_atexit>
    854a:	nop
    854c:	.word	0x1fff8a3c
    8550:	.word	0x0000077d
    8554:	.word	0x20002ba4

00008558 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    8558:	ldr	r2, [pc, #8]	; (8564 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    855a:	ldr	r1, [pc, #12]	; (8568 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    855c:	ldr	r0, [pc, #12]	; (856c <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    855e:	b.w	eb28 <__aeabi_atexit>
    8562:	nop
    8564:	.word	0x1fff8a3c
    8568:	.word	0x0000077d
    856c:	.word	0x20002bac

00008570 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
    8570:	ldr	r2, [pc, #8]	; (857c <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
    8572:	ldr	r1, [pc, #12]	; (8580 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
    8574:	ldr	r0, [pc, #12]	; (8584 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
    8576:	b.w	eb28 <__aeabi_atexit>
    857a:	nop
    857c:	.word	0x1fff8a3c
    8580:	.word	0x0000077d
    8584:	.word	0x20002bb4

00008588 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:

DMAMEM __attribute__((aligned(32))) static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    8588:	ldr	r2, [pc, #8]	; (8594 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    858a:	ldr	r1, [pc, #12]	; (8598 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    858c:	ldr	r0, [pc, #12]	; (859c <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    858e:	b.w	eb28 <__aeabi_atexit>
    8592:	nop
    8594:	.word	0x1fff8a3c
    8598:	.word	0x0000077d
    859c:	.word	0x20002bbc

000085a0 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    85a0:	ldr	r2, [pc, #8]	; (85ac <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    85a2:	ldr	r1, [pc, #12]	; (85b0 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    85a4:	ldr	r0, [pc, #12]	; (85b4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    85a6:	b.w	eb28 <__aeabi_atexit>
    85aa:	nop
    85ac:	.word	0x1fff8a3c
    85b0:	.word	0x0000077d
    85b4:	.word	0x20002bc4

000085b8 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    85b8:	ldr	r2, [pc, #8]	; (85c4 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    85ba:	ldr	r1, [pc, #12]	; (85c8 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    85bc:	ldr	r0, [pc, #12]	; (85cc <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    85be:	b.w	eb28 <__aeabi_atexit>
    85c2:	nop
    85c4:	.word	0x1fff8a3c
    85c8:	.word	0x0000077d
    85cc:	.word	0x20002bcc

000085d0 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    85d0:	ldrb.w	r2, [r0, #57]	; 0x39
    85d4:	ldrb.w	r0, [r0, #56]	; 0x38
	}
    85d8:	subs	r0, r2, r0
    85da:	bx	lr

000085dc <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    85dc:	ldrb.w	r3, [r0, #56]	; 0x38
    85e0:	ldrb.w	r2, [r0, #57]	; 0x39
    85e4:	cmp	r2, r3
    85e6:	bls.n	85f4 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    85e8:	adds	r2, r3, #1
    85ea:	add	r3, r0
    85ec:	strb.w	r2, [r0, #56]	; 0x38
    85f0:	ldrb	r0, [r3, #24]
    85f2:	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    85f4:	mov.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    85f8:	bx	lr
    85fa:	nop

000085fc <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    85fc:	ldrb.w	r3, [r0, #56]	; 0x38
    8600:	ldrb.w	r2, [r0, #57]	; 0x39
    8604:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    8606:	itte	hi
    8608:	addhi	r3, r3, r0
    860a:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    860c:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    8610:	bx	lr
    8612:	nop

00008614 <TwoWire::flush()>:
	virtual void flush(void) {
    8614:	bx	lr
    8616:	nop

00008618 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    8618:	push	{r3, r4, r5, lr}
    861a:	mov	r5, r0
	if (transmitting || slave_mode) {
    861c:	ldrh.w	r0, [r0, #94]	; 0x5e
    8620:	cbz	r0, 8648 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    8622:	ldrb.w	r3, [r5, #93]	; 0x5d
    8626:	mov	r4, r2
    8628:	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    862c:	cmp	r4, r2
    862e:	bhi.n	864a <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    8630:	add.w	r0, r5, #59	; 0x3b
    8634:	add	r0, r3
    8636:	mov	r2, r4
    8638:	bl	cb10 <memcpy>
		txBufferLength += quantity;
    863c:	ldrb.w	r3, [r5, #93]	; 0x5d
    8640:	add	r3, r4
    8642:	strb.w	r3, [r5, #93]	; 0x5d
    8646:	mov	r0, r4
		return quantity;
	}
	return 0;
}
    8648:	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    864a:	movs	r0, #1
    864c:	mov	r4, r2
    864e:	strb	r0, [r5, #4]
    8650:	b.n	8630 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    8652:	nop

00008654 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    8654:	ldrh.w	r3, [r0, #94]	; 0x5e
    8658:	cbz	r3, 8676 <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    865a:	ldrb.w	r3, [r0, #93]	; 0x5d
    865e:	cmp	r3, #32
    8660:	bhi.n	8672 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    8662:	adds	r2, r0, r3
    8664:	adds	r3, #1
    8666:	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    866a:	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    866c:	strb.w	r1, [r2, #59]	; 0x3b
    8670:	bx	lr
    8672:	movs	r3, #1
    8674:	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    8676:	movs	r0, #0
    8678:	bx	lr
    867a:	nop

0000867c <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    867c:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    867e:	ldr	r2, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    8680:	strb.w	r3, [r0, #56]	; 0x38
	rxBufferLength = 0;
    8684:	strb.w	r3, [r0, #57]	; 0x39
	txBufferIndex = 0;
    8688:	strb.w	r3, [r0, #92]	; 0x5c
	txBufferLength = 0;
    868c:	strb.w	r3, [r0, #93]	; 0x5d
	transmitting = 0;
    8690:	strb.w	r3, [r0, #94]	; 0x5e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    8694:	strb.w	r3, [r0, #95]	; 0x5f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    8698:	ldmia	r2, {r1, r2}

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    869a:	push	{r4, r5}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    869c:	ldr	r5, [r1, #0]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    869e:	ldr	r4, [r0, #16]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    86a0:	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    86a2:	orrs	r2, r5
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    86a4:	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    86a6:	str	r2, [r1, #0]
	port().C1 = 0;
    86a8:	strb	r3, [r4, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    86aa:	ldr	r2, [r0, #20]
    86ac:	ldrb.w	r3, [r0, #97]	; 0x61
    86b0:	ldr	r1, [pc, #88]	; (870c <TwoWire::begin()+0x90>)
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    86b2:	ldr	r4, [r2, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    86b4:	add	r3, r2
    86b6:	ldrb	r5, [r3, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86b8:	ldrb	r3, [r3, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    86ba:	add.w	r5, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86be:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    86c0:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86c2:	and.w	r3, r3, #1792	; 0x700
    86c6:	orr.w	r3, r3, #100	; 0x64
    86ca:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    86cc:	ldrb.w	r3, [r0, #98]	; 0x62
    86d0:	add	r3, r2
    86d2:	ldrb	r5, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86d4:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    86d6:	add.w	r1, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86da:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    86dc:	ldr	r1, [r1, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    86de:	and.w	r3, r3, #1792	; 0x700
    86e2:	orr.w	r3, r3, #100	; 0x64
    86e6:	str	r3, [r1, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    86e8:	ldr	r1, [r4, #0]
    86ea:	ldr	r3, [r2, #4]
    86ec:	tst	r1, r3
    86ee:	beq.n	86fc <TwoWire::begin()+0x80>
    86f0:	ldr	r3, [r0, #16]
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
		port().F = 0x27;	// 100 kHz
    86f2:	movs	r2, #39	; 0x27
    86f4:	strb	r2, [r3, #1]
    86f6:	ldr	r3, [r0, #16]
	} else if (frequency < 1000000) {
		port().F = 0x1A; // 400 kHz
	} else {
		port().F = 0x0D; // 1 MHz
	}
	port().FLT = 4;
    86f8:	movs	r2, #4
    86fa:	strb	r2, [r3, #6]
    86fc:	ldr	r3, [r0, #16]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
    86fe:	movs	r2, #32
    8700:	strb	r2, [r3, #5]
    8702:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    8704:	movs	r2, #128	; 0x80
    8706:	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
    8708:	pop	{r4, r5}
    870a:	bx	lr
    870c:	.word	0x000147a0

00008710 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    8710:	push	{r4, lr}
    8712:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    8714:	ldrb	r3, [r2, #3]
    8716:	uxtb	r3, r3
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    8718:	lsls	r1, r3, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    871a:	mov	r4, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    871c:	bpl.n	879a <TwoWire::isr()+0x8a>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    871e:	movs	r1, #16
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    8720:	lsls	r0, r3, #25

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    8722:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    8724:	bpl.n	8798 <TwoWire::isr()+0x88>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    8726:	and.w	r3, r3, #4
    872a:	and.w	r2, r3, #255	; 0xff
    872e:	cmp	r3, #0
    8730:	beq.n	87d6 <TwoWire::isr()+0xc6>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    8732:	ldr	r1, [pc, #244]	; (8828 <TwoWire::isr()+0x118>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    8734:	ldr	r2, [r4, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    8736:	movs	r3, #0
    8738:	strb	r3, [r1, #0]
			txBufferLength = 0;
    873a:	strb.w	r3, [r4, #93]	; 0x5d
			if (user_onRequest != NULL) {
    873e:	cmp	r2, #0
    8740:	beq.n	87fa <TwoWire::isr()+0xea>
				user_onRequest();
    8742:	blx	r2
			}
			if (txBufferLength == 0) {
    8744:	ldrb.w	r3, [r4, #93]	; 0x5d
    8748:	cmp	r3, #0
    874a:	beq.n	87fa <TwoWire::isr()+0xea>
    874c:	ldr	r3, [r4, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    874e:	movs	r2, #208	; 0xd0
    8750:	strb	r2, [r3, #2]
    8752:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    8754:	ldrb.w	r2, [r4, #59]	; 0x3b
    8758:	strb	r2, [r3, #4]
    875a:	ldr	r3, [r4, #16]
			txBufferIndex = 1;
    875c:	movs	r2, #1
    875e:	strb.w	r2, [r4, #92]	; 0x5c
			receiving = 1;
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
		port().S = I2C_S_IICIF;
    8762:	movs	r2, #2
    8764:	strb	r2, [r3, #3]
		return;
    8766:	pop	{r4, pc}
		#if defined(WIRE_IMPLEMENT_WIRE) && !defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
    8768:	ldr	r3, [pc, #192]	; (882c <TwoWire::isr()+0x11c>)
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    876a:	strb.w	r0, [r4, #96]	; 0x60
		#if defined(WIRE_IMPLEMENT_WIRE) && !defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
    876e:	cmp	r4, r3
    8770:	beq.n	8808 <TwoWire::isr()+0xf8>
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		} else if (this == &Wire1) {
    8772:	ldr	r3, [pc, #188]	; (8830 <TwoWire::isr()+0x120>)
    8774:	cmp	r4, r3
    8776:	beq.n	881e <TwoWire::isr()+0x10e>
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    8778:	ldrb.w	r1, [r4, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    877c:	ldrb	r3, [r2, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    877e:	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    8780:	uxtb	r3, r3
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    8782:	bhi.n	8794 <TwoWire::isr()+0x84>
    8784:	ldr	r0, [pc, #160]	; (8828 <TwoWire::isr()+0x118>)
    8786:	ldrb	r0, [r0, #0]
    8788:	cbz	r0, 8794 <TwoWire::isr()+0x84>
			rxBuffer[rxBufferLength++] = data;
    878a:	adds	r0, r4, r1
    878c:	adds	r1, #1
    878e:	strb.w	r1, [r4, #57]	; 0x39
    8792:	strb	r3, [r0, #24]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    8794:	movs	r3, #2
    8796:	strb	r3, [r2, #3]
    8798:	pop	{r4, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    879a:	lsls	r1, r3, #25
    879c:	bmi.n	8726 <TwoWire::isr()+0x16>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    879e:	ldrb	r1, [r2, #2]
	if (c1 & I2C_C1_TX) {
    87a0:	and.w	r1, r1, #16
    87a4:	and.w	r0, r1, #255	; 0xff
    87a8:	cmp	r1, #0
    87aa:	beq.n	8768 <TwoWire::isr()+0x58>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    87ac:	ands.w	r3, r3, #1
    87b0:	bne.n	87f0 <TwoWire::isr()+0xe0>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    87b2:	ldrb.w	r1, [r4, #92]	; 0x5c
    87b6:	ldrb.w	r0, [r4, #93]	; 0x5d
    87ba:	cmp	r0, r1
				port().D = txBuffer[txBufferIndex++];
    87bc:	itttt	hi
    87be:	addhi	r3, r1, #1
    87c0:	addhi	r1, r1, r4
    87c2:	strbhi.w	r3, [r4, #92]	; 0x5c
    87c6:	ldrbhi.w	r3, [r1, #59]	; 0x3b
			} else {
				port().D = 0;
    87ca:	strb	r3, [r2, #4]
    87cc:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    87ce:	movs	r2, #208	; 0xd0
    87d0:	strb	r2, [r3, #2]
    87d2:	ldr	r2, [r4, #16]
    87d4:	b.n	8794 <TwoWire::isr()+0x84>
    87d6:	ldr	r3, [r4, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    87d8:	strb.w	r2, [r4, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    87dc:	movs	r2, #192	; 0xc0
    87de:	strb	r2, [r3, #2]
    87e0:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    87e2:	ldr	r2, [pc, #68]	; (8828 <TwoWire::isr()+0x118>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    87e4:	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    87e6:	movs	r1, #1
    87e8:	strb	r1, [r2, #0]
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
		port().S = I2C_S_IICIF;
    87ea:	movs	r2, #2
    87ec:	strb	r2, [r3, #3]
		return;
    87ee:	pop	{r4, pc}
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    87f0:	movs	r3, #192	; 0xc0
    87f2:	strb	r3, [r2, #2]
    87f4:	ldr	r2, [r4, #16]
			data = port().D;
    87f6:	ldrb	r3, [r2, #4]
    87f8:	b.n	8794 <TwoWire::isr()+0x84>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    87fa:	movs	r2, #1
				txBuffer[0] = 0;
    87fc:	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    87fe:	strb.w	r2, [r4, #93]	; 0x5d
				txBuffer[0] = 0;
    8802:	strb.w	r3, [r4, #59]	; 0x3b
    8806:	b.n	874c <TwoWire::isr()+0x3c>
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
    8808:	ldr	r2, [r4, #20]
    880a:	ldrb.w	r3, [r4, #97]	; 0x61
    880e:	ldr	r1, [pc, #36]	; (8834 <TwoWire::isr()+0x124>)
		} else if (this == &Wire1) {
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
    8810:	add	r3, r2
    8812:	movs	r2, #3
    8814:	ldrb	r0, [r3, #8]
    8816:	bl	d5fc <attachInterrupt>
    881a:	ldr	r2, [r4, #16]
    881c:	b.n	8778 <TwoWire::isr()+0x68>
    881e:	ldr	r2, [r4, #20]
    8820:	ldrb.w	r3, [r4, #97]	; 0x61
    8824:	ldr	r1, [pc, #16]	; (8838 <TwoWire::isr()+0x128>)
    8826:	b.n	8810 <TwoWire::isr()+0x100>
    8828:	.word	0x20002bd4
    882c:	.word	0x1fff8a9c
    8830:	.word	0x1fff8b08
    8834:	.word	0x00008899
    8838:	.word	0x000088a5

0000883c <TwoWire::sda_rising_isr()>:
    883c:	ldr	r3, [r0, #16]
#endif

void TwoWire::sda_rising_isr(void)
{
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
    883e:	ldrb	r3, [r3, #3]
    8840:	and.w	r3, r3, #32
    8844:	cbz	r3, 8864 <TwoWire::sda_rising_isr()+0x28>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
		//delayMicroseconds(100);
	} else {
		if (++irqcount >= 2 || !slave_mode) {
    8846:	ldrb.w	r3, [r0, #96]	; 0x60
    884a:	adds	r3, #1
    884c:	uxtb	r3, r3
    884e:	cmp	r3, #1
    8850:	strb.w	r3, [r0, #96]	; 0x60
    8854:	bls.n	888c <TwoWire::sda_rising_isr()+0x50>
			detachInterrupt(hardware.sda_pin[sda_pin_index]);
    8856:	ldr	r2, [r0, #20]
    8858:	ldrb.w	r3, [r0, #97]	; 0x61
    885c:	add	r3, r2
    885e:	ldrb	r0, [r3, #8]
    8860:	b.w	d6f4 <detachInterrupt>
	Wire1.sda_rising_isr();
}
#endif

void TwoWire::sda_rising_isr(void)
{
    8864:	push	{r4, r5, r6, lr}
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
		detachInterrupt(hardware.sda_pin[sda_pin_index]);
    8866:	ldr	r2, [r0, #20]
    8868:	and.w	r5, r3, #255	; 0xff
    886c:	ldrb.w	r3, [r0, #97]	; 0x61
    8870:	add	r3, r2
    8872:	mov	r4, r0
    8874:	ldrb	r0, [r3, #8]
    8876:	bl	d6f4 <detachInterrupt>
		if (user_onReceive != NULL) {
    887a:	ldr	r3, [r4, #104]	; 0x68
    887c:	cbz	r3, 8896 <TwoWire::sda_rising_isr()+0x5a>
			rxBufferIndex = 0;
    887e:	strb.w	r5, [r4, #56]	; 0x38
			user_onReceive(rxBufferLength);
    8882:	ldrb.w	r0, [r4, #57]	; 0x39
		if (++irqcount >= 2 || !slave_mode) {
			detachInterrupt(hardware.sda_pin[sda_pin_index]);
		}
	}
	//digitalWrite(3, LOW);
}
    8886:	ldmia.w	sp!, {r4, r5, r6, lr}
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
		detachInterrupt(hardware.sda_pin[sda_pin_index]);
		if (user_onReceive != NULL) {
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
    888a:	bx	r3
		}
		//delayMicroseconds(100);
	} else {
		if (++irqcount >= 2 || !slave_mode) {
    888c:	ldrb.w	r3, [r0, #95]	; 0x5f
    8890:	cmp	r3, #0
    8892:	beq.n	8856 <TwoWire::sda_rising_isr()+0x1a>
    8894:	bx	lr
    8896:	pop	{r4, r5, r6, pc}

00008898 <sda_rising_isr0()>:
#if !defined(WIRE_HAS_STOP_INTERRUPT)

#if defined(WIRE_IMPLEMENT_WIRE)
void sda_rising_isr0(void)
{
	Wire.sda_rising_isr();
    8898:	ldr	r0, [pc, #4]	; (88a0 <sda_rising_isr0()+0x8>)
    889a:	b.w	883c <TwoWire::sda_rising_isr()>
    889e:	nop
    88a0:	.word	0x1fff8a9c

000088a4 <sda_rising_isr1()>:
}
#endif
#if defined(WIRE_IMPLEMENT_WIRE1)
void sda_rising_isr1(void)
{
	Wire1.sda_rising_isr();
    88a4:	ldr	r0, [pc, #4]	; (88ac <sda_rising_isr1()+0x8>)
    88a6:	b.w	883c <TwoWire::sda_rising_isr()>
    88aa:	nop
    88ac:	.word	0x1fff8b08

000088b0 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    88b0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    88b4:	ldr	r7, [pc, #220]	; (8994 <L_1545_delayMicroseconds+0x1a>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    88b6:	ldr.w	r9, [pc, #224]	; 8998 <L_1545_delayMicroseconds+0x1e>
    88ba:	ldr	r3, [r7, #0]
    88bc:	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    88be:	sub	sp, #8
    88c0:	mov	r6, r0
    88c2:	str	r3, [sp, #0]
	return ret;
    88c4:	ldr.w	r8, [sp]
	bool reset=false;
    88c8:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    88ca:	movs	r5, #160	; 0xa0
	uint8_t i2c_status(void) {
		return port().S;
    88cc:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    88ce:	lsls	r3, r3, #26
    88d0:	bpl.n	898a <L_1545_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    88d2:	ldr	r3, [r7, #0]
    88d4:	str	r3, [sp, #4]
	return ret;
    88d6:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    88d8:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    88dc:	cmp	r3, #15
    88de:	bls.n	88cc <TwoWire::wait_idle()+0x1c>
    88e0:	cbz	r1, 88f6 <TwoWire::wait_idle()+0x46>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    88e2:	cmp	r3, #16
    88e4:	beq.n	88cc <TwoWire::wait_idle()+0x1c>
			// bus stuck busy too long
			port().C1 = 0;
    88e6:	movs	r0, #0
    88e8:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    88ea:	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    88ec:	movs	r2, #128	; 0x80
    88ee:	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    88f0:	add	sp, #8
    88f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    88f6:	ldr	r2, [r6, #20]
    88f8:	ldrb.w	r3, [r6, #97]	; 0x61
    88fc:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    88fe:	movs	r1, #5
    8900:	ldrb	r0, [r3, #8]
    8902:	bl	d7b8 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    8906:	ldr	r2, [r6, #20]
    8908:	ldrb.w	r3, [r6, #97]	; 0x61
    890c:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    890e:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    8910:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    8914:	mov	r0, sl
    8916:	bl	d7b8 <pinMode>
    891a:	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    891c:	movs	r1, #0
    891e:	mov	r0, sl
    8920:	bl	d7ac <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    8924:	mov	r3, r5

00008926 <L_1480_delayMicroseconds>:
    8926:	subs	r3, #1
    8928:	bne.n	8926 <L_1480_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    892a:	movs	r1, #1
    892c:	mov	r0, sl
    892e:	bl	d7ac <digitalWrite>
    8932:	mov	r3, r5

00008934 <L_1494_delayMicroseconds>:
    8934:	subs	r3, #1
    8936:	bne.n	8934 <L_1494_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    8938:	subs	r4, #1
    893a:	bne.n	891c <TwoWire::wait_idle()+0x6c>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    893c:	ldr	r0, [r6, #20]
    893e:	ldrb.w	r1, [r6, #97]	; 0x61
    8942:	add	r1, r0
    8944:	mov.w	r2, #320	; 0x140
    8948:	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    894a:	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    894c:	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8950:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    8952:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8954:	and.w	r3, r3, #1792	; 0x700
    8958:	orr.w	r3, r3, #100	; 0x64
    895c:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    895e:	ldrb.w	r3, [r6, #98]	; 0x62
    8962:	add	r3, r0
    8964:	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8966:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    8968:	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    896c:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    896e:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8970:	and.w	r3, r3, #1792	; 0x700
    8974:	orr.w	r3, r3, #100	; 0x64
    8978:	str	r3, [r1, #0]

0000897a <L_1545_delayMicroseconds>:
    897a:	subs	r2, #1
    897c:	bne.n	897a <L_1545_delayMicroseconds>
    897e:	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    8980:	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    8982:	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    8984:	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    8988:	bmi.n	88d2 <TwoWire::wait_idle()+0x22>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    898a:	movs	r0, #1
}
    898c:	add	sp, #8
    898e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8992:	nop
    8994:	.word	0x200030a4
    8998:	.word	0x000147a0

0000899c <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    899c:	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    899e:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    89a0:	movs	r2, #18
    89a2:	strb	r2, [r3, #3]
    89a4:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    89a6:	ldrb	r3, [r2, #2]
    89a8:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    89ac:	sub	sp, #20
    89ae:	mov	r4, r0
    89b0:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    89b2:	cmp	r3, #0
    89b4:	beq.n	8a74 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    89b6:	movs	r3, #180	; 0xb4
    89b8:	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    89ba:	ldr	r1, [pc, #240]	; (8aac <TwoWire::endTransmission(unsigned char)+0x110>)
    89bc:	ldr	r2, [r4, #16]
    89be:	ldr	r3, [r1, #0]
    89c0:	str	r3, [sp, #0]
	return ret;
    89c2:	ldr	r6, [sp, #0]
    89c4:	b.n	89d2 <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    89c6:	ldr	r3, [r1, #0]
    89c8:	str	r3, [sp, #4]
	return ret;
    89ca:	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    89cc:	subs	r3, r3, r6
    89ce:	cmp	r3, #4
    89d0:	bhi.n	8a58 <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    89d2:	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    89d4:	and.w	r3, r3, #32
    89d8:	and.w	r0, r3, #255	; 0xff
    89dc:	cmp	r3, #0
    89de:	beq.n	89c6 <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    89e0:	ldrb.w	r3, [r4, #93]	; 0x5d
    89e4:	cmp	r3, #0
    89e6:	beq.n	8a4c <TwoWire::endTransmission(unsigned char)+0xb0>
    89e8:	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    89ec:	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    89f0:	add.w	r3, r4, lr
    89f4:	ldrb.w	r3, [r3, #59]	; 0x3b
    89f8:	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    89fa:	ldr	r3, [r1, #0]
    89fc:	str	r3, [sp, #12]
	return ret;
    89fe:	ldr	r7, [sp, #12]
    8a00:	ldr	r0, [r4, #16]
    8a02:	b.n	8a14 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    8a04:	lsls	r3, r3, #26
    8a06:	bpl.n	8a24 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8a08:	ldr	r3, [r1, #0]
    8a0a:	str	r3, [sp, #8]
	return ret;
    8a0c:	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    8a0e:	subs	r3, r3, r7
    8a10:	cmp	r3, #5
    8a12:	bhi.n	8a66 <TwoWire::endTransmission(unsigned char)+0xca>
    8a14:	ldrb	r3, [r0, #3]
    8a16:	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    8a18:	and.w	r2, r3, #2
    8a1c:	and.w	r6, r2, #255	; 0xff
    8a20:	cmp	r2, #0
    8a22:	beq.n	8a04 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    8a24:	strb.w	ip, [r0, #3]
    8a28:	ldr	r6, [r4, #16]
    8a2a:	ldrb	r3, [r6, #3]
    8a2c:	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    8a2e:	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    8a30:	mov	r2, r6
    8a32:	bmi.n	8a90 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    8a34:	lsls	r7, r3, #26
    8a36:	bpl.n	8a90 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    8a38:	lsls	r3, r3, #31
    8a3a:	bmi.n	8aa0 <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    8a3c:	add.w	lr, lr, #1
    8a40:	ldrb.w	r3, [r4, #93]	; 0x5d
    8a44:	uxtb.w	lr, lr
    8a48:	cmp	r3, lr
    8a4a:	bhi.n	89f0 <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    8a4c:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    8a4e:	cbnz	r5, 8a98 <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    8a50:	movs	r3, #0
    8a52:	strb.w	r3, [r4, #94]	; 0x5e
    8a56:	b.n	8a62 <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    8a58:	strb	r0, [r2, #2]
    8a5a:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    8a5c:	movs	r2, #128	; 0x80
    8a5e:	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    8a60:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8a62:	add	sp, #20
    8a64:	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    8a66:	strb	r6, [r0, #2]
    8a68:	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    8a6a:	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    8a6c:	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    8a6e:	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8a70:	add	sp, #20
    8a72:	pop	{r4, r5, r6, r7, pc}
    8a74:	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    8a78:	bl	88b0 <TwoWire::wait_idle()>
    8a7c:	cbnz	r0, 8a84 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    8a7e:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8a80:	add	sp, #20
    8a82:	pop	{r4, r5, r6, r7, pc}
    8a84:	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    8a86:	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    8a8a:	movs	r2, #176	; 0xb0
    8a8c:	strb	r2, [r3, #2]
    8a8e:	b.n	89ba <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    8a90:	movs	r3, #128	; 0x80
    8a92:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    8a94:	movs	r0, #4
    8a96:	b.n	8a4e <TwoWire::endTransmission(unsigned char)+0xb2>
    8a98:	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    8a9a:	movs	r3, #128	; 0x80
    8a9c:	strb	r3, [r6, #2]
    8a9e:	b.n	8a50 <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    8aa0:	cmp.w	lr, #0
    8aa4:	ite	eq
    8aa6:	moveq	r0, #2
    8aa8:	movne	r0, #3
    8aaa:	b.n	8a9a <TwoWire::endTransmission(unsigned char)+0xfe>
    8aac:	.word	0x200030a4

00008ab0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    8ab0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8ab4:	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    8ab6:	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    8ab8:	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    8aba:	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    8abe:	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    8ac2:	strb	r7, [r6, #3]
    8ac4:	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    8ac8:	ldrb.w	lr, [ip, #2]
    8acc:	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    8ad0:	sub	sp, #32
    8ad2:	mov	r4, r0
    8ad4:	mov	r8, r1
    8ad6:	mov	r5, r2
    8ad8:	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    8ada:	cmp.w	lr, #0
    8ade:	beq.n	8b74 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    8ae0:	movs	r3, #180	; 0xb4
    8ae2:	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8ae6:	ldr	r3, [pc, #480]	; (8cc8 <L_3073_delayMicroseconds+0x1a>)
    8ae8:	ldr	r1, [r4, #16]
    8aea:	ldr	r2, [r3, #0]
    8aec:	str	r2, [sp, #0]
	return ret;
    8aee:	ldr.w	lr, [sp]
    8af2:	b.n	8b02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8af4:	ldr	r2, [r3, #0]
    8af6:	str	r2, [sp, #4]
	return ret;
    8af8:	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    8afa:	rsb	r0, lr, r0
    8afe:	cmp	r0, #4
    8b00:	bhi.n	8b64 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    8b02:	ldrb	r0, [r1, #3]
    8b04:	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    8b08:	and.w	r7, r0, #255	; 0xff
    8b0c:	cmp	r0, #0
    8b0e:	beq.n	8af4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    8b10:	mov.w	r2, r8, lsl #1
    8b14:	orr.w	r2, r2, #1
    8b18:	uxtb	r2, r2
    8b1a:	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8b1c:	ldr	r2, [r3, #0]
    8b1e:	str	r2, [sp, #8]
	return ret;
    8b20:	ldr.w	lr, [sp, #8]
    8b24:	ldr	r0, [r4, #16]
    8b26:	b.n	8b36 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8b28:	ldr	r2, [r3, #0]
    8b2a:	str	r2, [sp, #12]
	return ret;
    8b2c:	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    8b2e:	rsb	r1, lr, r1
    8b32:	cmp	r1, #5
    8b34:	bhi.n	8b8c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    8b36:	ldrb	r1, [r0, #3]
    8b38:	and.w	r1, r1, #2
    8b3c:	and.w	r7, r1, #255	; 0xff
    8b40:	cmp	r1, #0
    8b42:	beq.n	8b28 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    8b44:	mov.w	ip, #2
    8b48:	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    8b4c:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    8b4e:	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    8b50:	ands.w	r7, r1, #17
    8b54:	bne.n	8b9c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    8b56:	cbnz	r5, 8ba4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    8b58:	cmp	r6, #0
    8b5a:	ite	eq
    8b5c:	moveq	r3, #160	; 0xa0
    8b5e:	movne	r3, #128	; 0x80
    8b60:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    8b62:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    8b64:	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    8b66:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    8b68:	movs	r2, #128	; 0x80
    8b6a:	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    8b6c:	mov	r0, r7
    8b6e:	add	sp, #32
    8b70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8b74:	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    8b78:	bl	88b0 <TwoWire::wait_idle()>
    8b7c:	cmp	r0, #0
    8b7e:	beq.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    8b80:	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    8b82:	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    8b86:	movs	r2, #176	; 0xb0
    8b88:	strb	r2, [r3, #2]
    8b8a:	b.n	8ae6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    8b8c:	strb	r7, [r0, #2]
    8b8e:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    8b90:	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    8b92:	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    8b94:	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    8b96:	add	sp, #32
    8b98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    8b9c:	movs	r3, #128	; 0x80
    8b9e:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    8ba0:	movs	r7, #0
    8ba2:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    8ba4:	cmp	r5, #1
    8ba6:	beq.n	8c94 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e4>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    8ba8:	movs	r1, #160	; 0xa0
    8baa:	strb	r1, [r2, #2]
    8bac:	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    8bae:	ldrb	r2, [r1, #4]
    8bb0:	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    8bb2:	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8bb4:	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8bb8:	ldr	r2, [r3, #0]
    8bba:	str	r2, [sp, #16]
	return ret;
    8bbc:	ldr	r0, [sp, #16]
    8bbe:	b.n	8bcc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8bc0:	ldr	r2, [r3, #0]
    8bc2:	str	r2, [sp, #20]
	return ret;
    8bc4:	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    8bc6:	subs	r2, r2, r0
    8bc8:	cmp	r2, #5
    8bca:	bhi.n	8c62 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b2>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    8bcc:	ldrb	r2, [r1, #3]
    8bce:	and.w	r2, r2, #2
    8bd2:	and.w	r8, r2, #255	; 0xff
    8bd6:	cmp	r2, #0
    8bd8:	beq.n	8bc0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    8bda:	strb	r7, [r1, #3]
    8bdc:	ldr	r1, [r4, #16]
		status = port().S;
    8bde:	ldrb	r2, [r1, #3]
    8be0:	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    8be2:	tst.w	r2, #16
    8be6:	mov	r0, r1
    8be8:	bne.n	8ca0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    8bea:	lsls	r2, r2, #26
    8bec:	bpl.n	8ca0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    8bee:	subs	r5, #1
    8bf0:	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8bf2:	cmp	r5, #1
    8bf4:	beq.n	8c8a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1da>
		if (count < BUFFER_LENGTH) {
    8bf6:	cmp.w	lr, #31
    8bfa:	bls.n	8c74 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1c4>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    8bfc:	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    8bfe:	cmp	r5, #1
    8c00:	bne.n	8bb8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8c02:	ldr	r2, [r3, #0]
    8c04:	str	r2, [sp, #24]
	return ret;
    8c06:	ldr	r5, [sp, #24]
    8c08:	b.n	8c16 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8c0a:	ldr	r2, [r3, #0]
    8c0c:	str	r2, [sp, #28]
	return ret;
    8c0e:	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    8c10:	subs	r2, r2, r5
    8c12:	cmp	r2, #5
    8c14:	bhi.n	8ca4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f4>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    8c16:	ldrb	r2, [r0, #3]
    8c18:	and.w	r2, r2, #2
    8c1c:	and.w	r1, r2, #255	; 0xff
    8c20:	cmp	r2, #0
    8c22:	beq.n	8c0a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    8c24:	movs	r3, #2
    8c26:	strb	r3, [r0, #3]
    8c28:	ldr	r2, [r4, #16]
	status = port().S;
    8c2a:	ldrb	r3, [r2, #3]
    8c2c:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    8c2e:	lsls	r1, r3, #27
    8c30:	bmi.n	8ca8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f8>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    8c32:	lsls	r3, r3, #26
    8c34:	bpl.n	8ca0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    8c36:	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    8c38:	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    8c3c:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    8c3e:	bhi.n	8cc0 <L_3073_delayMicroseconds+0x12>
    8c40:	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    8c42:	add.w	r3, r4, lr
    8c46:	ldrb	r2, [r2, #4]
    8c48:	strb	r2, [r3, #24]
    8c4a:	add.w	lr, lr, #1
    8c4e:	uxtb.w	lr, lr
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    8c52:	cbz	r6, 8c5a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1aa>
    8c54:	ldr	r3, [r4, #16]
    8c56:	movs	r2, #128	; 0x80
    8c58:	strb	r2, [r3, #2]
	rxBufferLength = count;
    8c5a:	strb.w	lr, [r4, #57]	; 0x39
	return count;
    8c5e:	mov	r7, lr
    8c60:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    8c62:	strb.w	r8, [r1, #2]
    8c66:	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    8c68:	movs	r2, #128	; 0x80
    8c6a:	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    8c6c:	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    8c6e:	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    8c72:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    8c74:	add.w	r2, r4, lr
    8c78:	ldrb.w	r8, [r1, #4]
    8c7c:	strb.w	r8, [r2, #24]
    8c80:	add.w	lr, lr, #1
    8c84:	uxtb.w	lr, lr
    8c88:	b.n	8bfe <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8c8a:	strb.w	ip, [r1, #2]
    8c8e:	ldr	r1, [r4, #16]
    8c90:	mov	r0, r1
    8c92:	b.n	8bf6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8c94:	movs	r1, #168	; 0xa8
    8c96:	strb	r1, [r2, #2]
    8c98:	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    8c9a:	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    8c9c:	ldrb	r2, [r0, #4]
    8c9e:	b.n	8c02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    8ca0:	mov	r7, lr
    8ca2:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    8ca4:	strb	r1, [r0, #2]
    8ca6:	b.n	8c66 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b6>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    8ca8:	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    8caa:	movs	r3, #160	; 0xa0
    8cac:	strb	r1, [r2, #3]

00008cae <L_3073_delayMicroseconds>:
    8cae:	subs	r3, #1
    8cb0:	bne.n	8cae <L_3073_delayMicroseconds>
    8cb2:	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    8cb4:	ldrb	r3, [r2, #2]
    8cb6:	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    8cba:	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    8cbc:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    8cbe:	b.n	8b6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    8cc0:	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    8cc2:	ldrb	r3, [r3, #4]
    8cc4:	b.n	8c52 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    8cc6:	nop
    8cc8:	.word	0x200030a4

00008ccc <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    8ccc:	ldr	r0, [pc, #4]	; (8cd4 <i2c0_isr+0x8>)
    8cce:	b.w	8710 <TwoWire::isr()>
    8cd2:	nop
    8cd4:	.word	0x1fff8a9c

00008cd8 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    8cd8:	ldr	r0, [pc, #4]	; (8ce0 <i2c1_isr+0x8>)
    8cda:	b.w	8710 <TwoWire::isr()>
    8cde:	nop
    8ce0:	.word	0x1fff8b08

00008ce4 <FsCache::sync() [clone .part.0]>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    8ce4:	push	{r4, r5, r6, lr}
    8ce6:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    8ce8:	add.w	r6, r0, #16
    8cec:	ldr	r0, [r0, #4]
    8cee:	ldr	r1, [r4, #12]
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    8cf0:	ldrb	r3, [r0, #13]
    8cf2:	cbnz	r3, 8d16 <FsCache::sync() [clone .part.0]+0x32>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    8cf4:	movs	r3, #1
    8cf6:	mov	r2, r6
    8cf8:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
    8cfc:	mov	r5, r0
    8cfe:	cbz	r5, 8d10 <FsCache::sync() [clone .part.0]+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    8d00:	ldrb	r3, [r4, #0]
    8d02:	lsls	r2, r3, #30
    8d04:	bmi.n	8d20 <FsCache::sync() [clone .part.0]+0x3c>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    8d06:	bic.w	r3, r3, #1
    8d0a:	strb	r3, [r4, #0]
  }
  return true;

 fail:
  return false;
}
    8d0c:	mov	r0, r5
    8d0e:	pop	{r4, r5, r6, pc}
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    8d10:	movs	r5, #0
}
    8d12:	mov	r0, r5
    8d14:	pop	{r4, r5, r6, pc}
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    8d16:	mov	r2, r6
    8d18:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    8d1c:	mov	r5, r0
    8d1e:	b.n	8cfe <FsCache::sync() [clone .part.0]+0x1a>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    8d20:	ldr	r0, [r4, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
    8d22:	ldr	r1, [r4, #12]
    8d24:	ldr	r3, [r4, #8]
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    8d26:	ldrb	r2, [r0, #13]
    8d28:	add	r1, r3
    8d2a:	cbnz	r2, 8d3c <FsCache::sync() [clone .part.0]+0x58>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    8d2c:	mov	r2, r6
    8d2e:	movs	r3, #1
    8d30:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    8d34:	cmp	r0, #0
    8d36:	beq.n	8d10 <FsCache::sync() [clone .part.0]+0x2c>
    8d38:	ldrb	r3, [r4, #0]
    8d3a:	b.n	8d06 <FsCache::sync() [clone .part.0]+0x22>
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    8d3c:	mov	r2, r6
    8d3e:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    8d42:	b.n	8d34 <FsCache::sync() [clone .part.0]+0x50>

00008d44 <FsCache::get(unsigned long, unsigned char)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    8d44:	push	{r3, r4, r5, r6, r7, lr}
  if (!m_blockDev) {
    8d46:	ldr	r5, [r0, #4]
    8d48:	cbz	r5, 8d8a <FsCache::get(unsigned long, unsigned char)+0x46>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    8d4a:	ldr	r3, [r0, #12]
    8d4c:	cmp	r3, r1
    8d4e:	mov	r4, r0
    8d50:	mov	r7, r2
    8d52:	mov	r6, r1
    8d54:	beq.n	8d74 <FsCache::get(unsigned long, unsigned char)+0x30>
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    8d56:	ldrb	r3, [r0, #0]
    8d58:	lsls	r2, r3, #31
    8d5a:	bmi.n	8d82 <FsCache::get(unsigned long, unsigned char)+0x3e>
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    8d5c:	lsls	r3, r7, #29
      if (!m_blockDev->readSector(sector, m_buffer)) {
    8d5e:	add.w	r5, r4, #16
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    8d62:	bpl.n	8d8e <FsCache::get(unsigned long, unsigned char)+0x4a>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    8d64:	and.w	r2, r7, #3
    8d68:	movs	r3, #0
    8d6a:	orrs	r3, r2
    8d6c:	strb	r3, [r4, #0]
    8d6e:	mov	r0, r5
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_sector = sector;
    8d70:	str	r6, [r4, #12]
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
}
    8d72:	pop	{r3, r4, r5, r6, r7, pc}
    8d74:	ldrsb.w	r3, [r0], #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    8d78:	and.w	r2, r7, #3
    8d7c:	orrs	r3, r2
    8d7e:	strb	r3, [r4, #0]
  return m_buffer;

 fail:
  return nullptr;
}
    8d80:	pop	{r3, r4, r5, r6, r7, pc}
    8d82:	bl	8ce4 <FsCache::sync() [clone .part.0]>
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
    8d86:	cmp	r0, #0
    8d88:	bne.n	8d5c <FsCache::get(unsigned long, unsigned char)+0x18>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    8d8a:	movs	r0, #0
    8d8c:	pop	{r3, r4, r5, r6, r7, pc}
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    8d8e:	mov	r2, r5
    8d90:	movs	r3, #1
    8d92:	mov	r1, r6
    8d94:	ldr	r0, [r4, #4]
    8d96:	bl	c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    8d9a:	cmp	r0, #0
    8d9c:	bne.n	8d64 <FsCache::get(unsigned long, unsigned char)+0x20>
    8d9e:	b.n	8d8a <FsCache::get(unsigned long, unsigned char)+0x46>

00008da0 <FsCache::sync()>:
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    8da0:	ldrb	r3, [r0, #0]
    8da2:	lsls	r3, r3, #31
    8da4:	bmi.n	8daa <FsCache::sync()+0xa>
  }
  return true;

 fail:
  return false;
}
    8da6:	movs	r0, #1
    8da8:	bx	lr
    8daa:	b.w	8ce4 <FsCache::sync() [clone .part.0]>
    8dae:	nop

00008db0 <ExFatFile::close()>:
#include "../common/DebugMacros.h"
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    8db0:	push	{r4, lr}
    8db2:	mov	r4, r0
  bool rtn = sync();
    8db4:	bl	9f94 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    8db8:	movs	r3, #0
    8dba:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    8dbe:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    8dc2:	pop	{r4, pc}

00008dc4 <ExFatFile::getName(char*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    8dc4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8dc8:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    8dcc:	mov	r9, r0
    8dce:	mov	r7, r1
    8dd0:	mov	r5, r2
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8dd2:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    8dd6:	sub	sp, #20
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
    8dd8:	ldrb.w	r3, [r9, #49]	; 0x31
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8ddc:	add	r6, sp, #4
    8dde:	stmia.w	r6, {r0, r1, r2}
  size_t n = 0;
  if (!isOpen()) {
    8de2:	cmp	r3, #0
    8de4:	beq.n	8e64 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8de6:	ldrb.w	r3, [r9, #48]	; 0x30
    8dea:	cmp	r3, #1
    8dec:	bls.n	8e6e <ExFatFile::getName(char*, unsigned int)+0xaa>
    8dee:	mov.w	r8, #1
    8df2:	movs	r4, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
    8df4:	cmp.w	r8, #1
    8df8:	ite	ne
    8dfa:	movne	r2, #32
    8dfc:	moveq	r2, #64	; 0x40
    8dfe:	mov	r1, r6
    8e00:	ldr.w	r0, [r9, #32]
    8e04:	bl	9990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    8e08:	cmp	r0, #1
    8e0a:	bne.n	8e64 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    8e0c:	movs	r2, #0
    8e0e:	mov	r1, r6
    8e10:	ldr.w	r0, [r9, #32]
    8e14:	bl	995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    8e18:	cbz	r0, 8e64 <ExFatFile::getName(char*, unsigned int)+0xa0>
    8e1a:	ldrb	r3, [r0, #0]
    8e1c:	cmp	r3, #193	; 0xc1
    8e1e:	bne.n	8e64 <ExFatFile::getName(char*, unsigned int)+0xa0>
    8e20:	adds	r1, r7, r4
    8e22:	add.w	lr, r4, #15
    8e26:	b.n	8e2a <ExFatFile::getName(char*, unsigned int)+0x66>
    8e28:	mov	r4, r2
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    8e2a:	ldrh.w	r3, [r0, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
    8e2e:	adds	r2, r4, #1
    8e30:	cbz	r3, 8e58 <ExFatFile::getName(char*, unsigned int)+0x94>
    8e32:	cmp	r2, r5
    8e34:	bcs.n	8e58 <ExFatFile::getName(char*, unsigned int)+0x94>
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    8e36:	cmp	r3, #126	; 0x7e
    8e38:	ite	ls
    8e3a:	uxtbls	r3, r3
    8e3c:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    8e3e:	cmp	r2, lr
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    8e40:	strb.w	r3, [r1], #1
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    8e44:	bne.n	8e28 <ExFatFile::getName(char*, unsigned int)+0x64>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8e46:	add.w	r8, r8, #1
    8e4a:	ldrb.w	r3, [r9, #48]	; 0x30
    8e4e:	uxtb.w	r8, r8
    8e52:	cmp	r3, r8
    8e54:	mov	r4, r2
    8e56:	bhi.n	8df4 <ExFatFile::getName(char*, unsigned int)+0x30>
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    8e58:	movs	r3, #0
  return n;
    8e5a:	mov	r0, r4
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    8e5c:	strb	r3, [r7, r4]
  return n;

 fail:
  *name = 0;
  return 0;
}
    8e5e:	add	sp, #20
    8e60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 done:
  name[n] = 0;
  return n;

 fail:
  *name = 0;
    8e64:	movs	r0, #0
    8e66:	strb	r0, [r7, #0]
  return 0;
}
    8e68:	add	sp, #20
    8e6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8e6e:	movs	r4, #0
    8e70:	b.n	8e58 <ExFatFile::getName(char*, unsigned int)+0x94>
    8e72:	nop

00008e74 <ExFatFile::openRoot(ExFatVolume*)>:
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    8e74:	ldrb.w	r2, [r0, #49]	; 0x31
    8e78:	cbz	r2, 8e7e <ExFatFile::openRoot(ExFatVolume*)+0xa>
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    8e7a:	movs	r0, #0
    8e7c:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    8e7e:	push	{r3, r4, r5, lr}
    8e80:	mov	r4, r0
    8e82:	mov	r5, r1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8e84:	mov	r1, r2
    8e86:	movs	r2, #56	; 0x38
    8e88:	bl	106dc <memset>
  m_attributes = FILE_ATTR_ROOT;
    8e8c:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8e8e:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8e90:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8e94:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8e98:	str	r5, [r4, #32]
    8e9a:	pop	{r3, r4, r5, pc}

00008e9c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const ExChar_t* path,
                            ExName_t* fname, const ExChar_t** ptr) {
    8e9c:	push	{r4, r5, r6, r7, lr}
  ExChar_t c;
  int end;
  int len = 0;

  // Skip leading spaces.
  while (*path == ' ') {
    8e9e:	ldrb	r0, [r1, #0]
    8ea0:	cmp	r0, #32
    8ea2:	bne.n	8eac <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    8ea4:	ldrb.w	r0, [r1, #1]!
    8ea8:	cmp	r0, #32
    8eaa:	beq.n	8ea4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x8>
    path++;
  }
  fname->lfn = path;
    8eac:	str	r1, [r2, #4]

  for (len = 0; ; len++) {
    c = path[len];
    8eae:	ldrb	r0, [r1, #0]
    if (c == 0 || isDirSeparator(c)) {
    8eb0:	cmp	r0, #0
    8eb2:	beq.n	8f58 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xbc>
    8eb4:	cmp	r0, #47	; 0x2f
    8eb6:	beq.n	8f10 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x74>
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    8eb8:	cmp	r0, #92	; 0x5c
    8eba:	beq.n	8efe <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    8ebc:	sub.w	r4, r0, #34	; 0x22
    8ec0:	uxtb	r4, r4
    8ec2:	cmp	r4, #29
    8ec4:	bls.n	8f02 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
    8ec6:	ldr.w	lr, [pc, #148]	; 8f5c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>
    8eca:	adds	r6, r1, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    8ecc:	movs	r4, #0
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    8ece:	cmp	r0, #124	; 0x7c
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    8ed0:	sub.w	r5, r0, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    8ed4:	mov	r7, r6
    8ed6:	beq.n	8efe <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    8ed8:	cmp	r5, #94	; 0x5e
    8eda:	bhi.n	8efe <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    8edc:	ldrb.w	r0, [r6], #1
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    8ee0:	sub.w	r5, r0, #34	; 0x22
    8ee4:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    8ee6:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    8ee8:	cbz	r0, 8f4a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xae>
    8eea:	cmp	r0, #47	; 0x2f
    8eec:	beq.n	8f12 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x76>
    8eee:	cmp	r0, #92	; 0x5c
    8ef0:	lsr.w	r7, lr, r5
    8ef4:	beq.n	8efe <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    8ef6:	cmp	r5, #29
    8ef8:	bhi.n	8ece <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
    8efa:	lsls	r5, r7, #31
    8efc:	bpl.n	8ece <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    8efe:	movs	r0, #0
    8f00:	pop	{r4, r5, r6, r7, pc}
    8f02:	ldr	r5, [pc, #88]	; (8f5c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>)
    8f04:	lsr.w	r4, r5, r4
    8f08:	lsls	r6, r4, #31
    8f0a:	bpl.n	8ec6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2a>
    8f0c:	movs	r0, #0
    8f0e:	pop	{r4, r5, r6, r7, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    8f10:	movs	r4, #0
    8f12:	adds	r7, r1, r4
    8f14:	mov	r6, r7
    8f16:	mov	r5, r4
    8f18:	movs	r0, #47	; 0x2f
    8f1a:	b.n	8f22 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x86>
    8f1c:	ldrb.w	r0, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    8f20:	adds	r5, #1
    8f22:	cmp	r0, #32
    8f24:	beq.n	8f1c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
    8f26:	cmp	r0, #47	; 0x2f
    8f28:	beq.n	8f1c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
  *ptr = &path[end];
    8f2a:	add	r1, r5
    8f2c:	str	r1, [r3, #0]

  // Back over spaces and dots.
  while (len) {
    8f2e:	cbz	r4, 8f42 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    8f30:	mov	r1, r7
    c = path[len - 1];
    8f32:	ldrb.w	r3, [r1, #-1]!
    if (c != '.' && c != ' ') {
    8f36:	cmp	r3, #46	; 0x2e
    8f38:	beq.n	8f3e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa2>
    8f3a:	cmp	r3, #32
    8f3c:	bne.n	8f50 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xb4>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    8f3e:	subs	r4, #1
    8f40:	bne.n	8f32 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x96>
    8f42:	mov	r0, r4
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    return false;
  }
  fname->len = len;
    8f44:	str	r0, [r2, #0]
  return true;
    8f46:	movs	r0, #1
    8f48:	pop	{r4, r5, r6, r7, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    8f4a:	str	r7, [r3, #0]
    8f4c:	adds	r7, r1, r4
    8f4e:	b.n	8f30 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x94>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    8f50:	cmp	r4, #255	; 0xff
    8f52:	ble.n	8f42 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    8f54:	movs	r0, #0
    8f56:	pop	{r4, r5, r6, r7, pc}
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    8f58:	str	r1, [r3, #0]
    8f5a:	b.n	8f44 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa8>
    8f5c:	.word	0x35000101

00008f60 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    8f60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f64:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    8f68:	lsls	r6, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    8f6a:	sub	sp, #12
    8f6c:	mov	r4, r0
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    8f6e:	bpl.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    8f70:	lsls	r5, r3, #25
    8f72:	mov	r6, r1
    8f74:	mov	fp, r2
    8f76:	bpl.w	90e8 <ExFatFile::read(void*, unsigned int)+0x188>
    if ((m_curPosition + count) > m_validLength) {
    8f7a:	ldrd	r0, r1, [r4]
    8f7e:	ldrd	r2, r3, [r4, #16]
    8f82:	adds.w	r8, r0, fp
    8f86:	adc.w	r9, r1, #0
    8f8a:	cmp	r3, r9
    8f8c:	it	eq
    8f8e:	cmpeq	r2, r8
    8f90:	bcc.w	90f4 <ExFatFile::read(void*, unsigned int)+0x194>
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    8f94:	cmp.w	fp, #0
    8f98:	beq.n	9078 <ExFatFile::read(void*, unsigned int)+0x118>
    8f9a:	mov	r9, r4
    8f9c:	ldrd	r0, r1, [r9], #24
    8fa0:	mov	r5, fp
    clusterOffset = m_curPosition & m_vol->clusterMask();
    8fa2:	ldr	r7, [r4, #32]
    8fa4:	ldr.w	r3, [r7, #1080]	; 0x438
    8fa8:	ands	r3, r0
    sectorOffset = clusterOffset & m_vol->sectorMask();
    8faa:	ubfx	sl, r3, #0, #9
    if (clusterOffset == 0) {
    8fae:	cmp	r3, #0
    8fb0:	bne.n	9084 <ExFatFile::read(void*, unsigned int)+0x124>
      if (m_curPosition == 0) {
    8fb2:	orrs.w	r2, r0, r1
    8fb6:	bne.n	90a2 <ExFatFile::read(void*, unsigned int)+0x142>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    8fb8:	ldrb.w	r2, [r4, #49]	; 0x31
    8fbc:	lsls	r1, r2, #25
    8fbe:	ite	mi
    8fc0:	ldrmi.w	r2, [r7, #1076]	; 0x434
    8fc4:	ldrpl	r2, [r4, #28]
      } else if (isContiguous()) {
        m_curCluster++;
    8fc6:	str	r2, [r4, #24]
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    8fc8:	ldr.w	r0, [r7, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    8fcc:	ldrb.w	lr, [r7, #1093]	; 0x445
    8fd0:	lsrs	r3, r3, #9
    8fd2:	subs	r2, #2
    8fd4:	adds	r1, r3, r0
    8fd6:	lsl.w	r2, r2, lr
    8fda:	add	r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    8fdc:	cmp.w	sl, #0
    8fe0:	bne.n	903c <ExFatFile::read(void*, unsigned int)+0xdc>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    8fe2:	cmp.w	r5, #512	; 0x200
    8fe6:	bcc.n	903c <ExFatFile::read(void*, unsigned int)+0xdc>
    8fe8:	ldr.w	r2, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    8fec:	cmp	r1, r2
    8fee:	beq.n	903c <ExFatFile::read(void*, unsigned int)+0xdc>
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    8ff0:	cmp.w	r5, #1024	; 0x400
    8ff4:	bcc.n	90b0 <ExFatFile::read(void*, unsigned int)+0x150>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    8ff6:	mov.w	r8, #1
    8ffa:	lsl.w	r8, r8, lr
    8ffe:	rsb	r3, r3, r8
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    9002:	mov.w	r8, r5, lsr #9
    9006:	cmp	r8, r3
    9008:	it	cs
    900a:	movcs	r8, r3
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    900c:	cmp	r1, r2
    900e:	bhi.n	9088 <ExFatFile::read(void*, unsigned int)+0x128>
    9010:	add.w	r3, r8, r1
    9014:	cmp	r2, r3
    9016:	bcs.n	9088 <ExFatFile::read(void*, unsigned int)+0x128>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    9018:	add.w	r0, r7, #528	; 0x210
    901c:	str	r1, [sp, #4]
    901e:	bl	8da0 <FsCache::sync()>
    9022:	ldr	r1, [sp, #4]
    9024:	cbnz	r0, 9088 <ExFatFile::read(void*, unsigned int)+0x128>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    9026:	ldrb.w	r3, [r4, #50]	; 0x32
  return -1;
    902a:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    902e:	orr.w	r3, r3, #2
    9032:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
}
    9036:	add	sp, #12
    9038:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    903c:	add.w	r0, r7, #528	; 0x210
    9040:	movs	r2, #0
    9042:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    9046:	cmp	r0, #0
    9048:	beq.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    904a:	rsb	r8, sl, #512	; 0x200
    904e:	cmp	r8, r5
    9050:	it	cs
    9052:	movcs	r8, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    9054:	add.w	r1, r0, sl
    9058:	mov	r2, r8
    905a:	mov	r0, r6
    905c:	bl	cb10 <memcpy>
    9060:	mov	r2, r8
    9062:	movs	r3, #0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    9064:	ldrd	r0, r1, [r4]
    9068:	adds	r0, r0, r2
    906a:	adcs	r1, r3
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    906c:	subs.w	r5, r5, r8
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    9070:	add	r6, r8
    m_curPosition += n;
    9072:	strd	r0, r1, [r4]
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    9076:	bne.n	8fa2 <ExFatFile::read(void*, unsigned int)+0x42>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    9078:	movs	r5, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    907a:	rsb	r0, r5, fp

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    907e:	add	sp, #12
    9080:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9084:	ldr	r2, [r4, #24]
    9086:	b.n	8fc8 <ExFatFile::read(void*, unsigned int)+0x68>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    9088:	ldr.w	r0, [r7, #532]	; 0x214
    908c:	mov	r3, r8
    908e:	mov	r2, r6
    9090:	bl	c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    9094:	cmp	r0, #0
    9096:	beq.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    9098:	mov.w	r8, r8, lsl #9
    909c:	mov	r2, r8
    909e:	movs	r3, #0
    90a0:	b.n	9064 <ExFatFile::read(void*, unsigned int)+0x104>
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
    90a2:	ldrb.w	r2, [r4, #51]	; 0x33
    90a6:	lsls	r2, r2, #25
    90a8:	bpl.n	90cc <ExFatFile::read(void*, unsigned int)+0x16c>
        m_curCluster++;
    90aa:	ldr	r2, [r4, #24]
    90ac:	adds	r2, #1
    90ae:	b.n	8fc6 <ExFatFile::read(void*, unsigned int)+0x66>
    90b0:	ldr.w	r0, [r7, #532]	; 0x214
    90b4:	movs	r3, #1
    90b6:	mov	r2, r6
    90b8:	bl	c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    90bc:	cmp	r0, #0
    90be:	beq.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
    90c0:	mov.w	r2, #512	; 0x200
    90c4:	movs	r3, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    90c6:	mov.w	r8, #512	; 0x200
    90ca:	b.n	9064 <ExFatFile::read(void*, unsigned int)+0x104>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    90cc:	mov	r0, r7
    90ce:	mov	r2, r9
    90d0:	ldr	r1, [r4, #24]
    90d2:	str	r3, [sp, #4]
    90d4:	bl	99e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    90d8:	sxtb	r0, r0
        if (fg < 0) {
    90da:	cmp	r0, #0
    90dc:	blt.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    90de:	beq.n	90fa <ExFatFile::read(void*, unsigned int)+0x19a>
    90e0:	ldr	r7, [r4, #32]
    90e2:	ldr	r2, [r4, #24]
    90e4:	ldr	r3, [sp, #4]
    90e6:	b.n	8fc8 <ExFatFile::read(void*, unsigned int)+0x68>

  if (!isReadable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    90e8:	ldrb.w	r3, [r0, #49]	; 0x31
    90ec:	lsls	r0, r3, #28
    90ee:	bmi.w	8f7a <ExFatFile::read(void*, unsigned int)+0x1a>
    90f2:	b.n	8f94 <ExFatFile::read(void*, unsigned int)+0x34>
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    90f4:	rsb	fp, r0, r2
    90f8:	b.n	8f94 <ExFatFile::read(void*, unsigned int)+0x34>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
          // EOF if directory.
          if (isDir()) {
    90fa:	ldrb.w	r3, [r4, #49]	; 0x31
    90fe:	tst.w	r3, #80	; 0x50
    9102:	bne.n	907a <ExFatFile::read(void*, unsigned int)+0x11a>
    9104:	b.n	9026 <ExFatFile::read(void*, unsigned int)+0xc6>
    9106:	nop

00009108 <ExFatFile::peek()>:
  }
  fname->len = len;
  return true;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    9108:	push	{r4, r5, r6, r7, lr}
    910a:	sub	sp, #12
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    910c:	movs	r2, #1
    910e:	add.w	r1, sp, #7
    9112:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    9114:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    9118:	ldr	r5, [r0, #24]
    911a:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
    911e:	cmp	r0, #1
    9120:	it	eq
    9122:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    9126:	str	r5, [r4, #24]
    9128:	it	ne
    912a:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    912e:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    9132:	add	sp, #12
    9134:	pop	{r4, r5, r6, r7, pc}
    9136:	nop

00009138 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    9138:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    913c:	ldrb.w	lr, [r0, #49]	; 0x31
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    9140:	ldr	r5, [r0, #24]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    9142:	sub	sp, #12
    9144:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    9146:	cmp.w	lr, #0
    914a:	beq.n	9184 <ExFatFile::seekSet(unsigned long long)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    914c:	ldrd	r0, r1, [r0]
    9150:	cmp	r1, r3
    9152:	it	eq
    9154:	cmpeq	r0, r2
    9156:	mov	r6, r2
    9158:	mov	r7, r3
    915a:	beq.n	91d4 <ExFatFile::seekSet(unsigned long long)+0x9c>
    return true;
  }
  if (pos == 0) {
    915c:	orrs.w	r3, r6, r7
    9160:	bne.n	9172 <ExFatFile::seekSet(unsigned long long)+0x3a>
    // set position to start of file
    m_curCluster = 0;
    9162:	movs	r3, #0
    9164:	str	r3, [r4, #24]
    }
  }

 done:
  m_curPosition = pos;
  return true;
    9166:	movs	r0, #1
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    9168:	strd	r6, r7, [r4]
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    916c:	add	sp, #12
    916e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    9172:	tst.w	lr, #8
    9176:	beq.n	918e <ExFatFile::seekSet(unsigned long long)+0x56>
    if (pos > m_validLength) {
    9178:	ldrd	r2, r3, [r4, #16]
    917c:	cmp	r3, r7
    917e:	it	eq
    9180:	cmpeq	r2, r6
    9182:	bcs.n	918e <ExFatFile::seekSet(unsigned long long)+0x56>
 done:
  m_curPosition = pos;
  return true;

 fail:
  m_curCluster = tmp;
    9184:	str	r5, [r4, #24]
  return false;
    9186:	movs	r0, #0
}
    9188:	add	sp, #12
    918a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    918e:	ldr	r3, [r4, #32]
    9190:	str	r3, [sp, #4]
    9192:	ldrb.w	ip, [r3, #1093]	; 0x445
  if (isContiguous()) {
    9196:	ldrb.w	sl, [r4, #51]	; 0x33
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    919a:	add.w	ip, ip, #9
    919e:	uxtb.w	ip, ip
    91a2:	adds.w	r2, r6, #4294967295
    91a6:	adc.w	r3, r7, #4294967295
    91aa:	rsb	r8, ip, #32
    91ae:	lsl.w	fp, r3, r8
    91b2:	lsr.w	r2, r2, ip
    91b6:	orr.w	r2, r2, fp
    91ba:	sub.w	fp, ip, #32
    91be:	lsr.w	r3, r3, fp
  if (isContiguous()) {
    91c2:	tst.w	sl, #64	; 0x40
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    91c6:	orr.w	r2, r2, r3
  if (isContiguous()) {
    91ca:	beq.n	91d8 <ExFatFile::seekSet(unsigned long long)+0xa0>
    m_curCluster = m_firstCluster + nNew;
    91cc:	ldr	r3, [r4, #28]
    91ce:	add	r2, r3
    91d0:	str	r2, [r4, #24]
    goto done;
    91d2:	b.n	9166 <ExFatFile::seekSet(unsigned long long)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    91d4:	movs	r0, #1
    91d6:	b.n	9188 <ExFatFile::seekSet(unsigned long long)+0x50>
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    91d8:	adds.w	r9, r0, #4294967295
    91dc:	adc.w	sl, r1, #4294967295
    91e0:	lsr.w	ip, r9, ip
    91e4:	lsl.w	r8, sl, r8
    91e8:	orr.w	ip, ip, r8
    91ec:	lsr.w	fp, sl, fp
    91f0:	orr.w	ip, ip, fp
  if (nNew < nCur || m_curPosition == 0) {
    91f4:	cmp	r2, ip
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    91f6:	mov	r3, sl
  if (nNew < nCur || m_curPosition == 0) {
    91f8:	bcs.n	922a <ExFatFile::seekSet(unsigned long long)+0xf2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    91fa:	tst.w	lr, #64	; 0x40
    91fe:	itet	ne
    9200:	ldrne	r3, [sp, #4]
    9202:	ldreq	r3, [r4, #28]
    9204:	ldrne.w	r3, [r3, #1076]	; 0x434
    9208:	str	r3, [r4, #24]
    920a:	mov	r8, r2
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    920c:	add.w	r9, r4, #24
    9210:	mov	r2, r9
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    9212:	cmp.w	r8, #0
    9216:	beq.n	9166 <ExFatFile::seekSet(unsigned long long)+0x2e>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    9218:	ldr	r1, [r4, #24]
    921a:	ldr	r0, [r4, #32]
    921c:	bl	99e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    9220:	add.w	r8, r8, #4294967295
    9224:	cmp	r0, #0
    9226:	bne.n	9210 <ExFatFile::seekSet(unsigned long long)+0xd8>
    9228:	b.n	9184 <ExFatFile::seekSet(unsigned long long)+0x4c>
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
  if (nNew < nCur || m_curPosition == 0) {
    922a:	orrs.w	r3, r0, r1
    922e:	beq.n	91fa <ExFatFile::seekSet(unsigned long long)+0xc2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    9230:	rsb	r2, ip, r2
    9234:	b.n	920a <ExFatFile::seekSet(unsigned long long)+0xd2>
    9236:	nop

00009238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    9238:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    923c:	mov	r6, r1
    923e:	sub	sp, #76	; 0x4c
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    9240:	ldrb.w	r1, [r0, #49]	; 0x31
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    9244:	str	r2, [sp, #0]
    9246:	mov	r5, r0
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    9248:	cbnz	r1, 9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    924a:	mov	sl, r3
    924c:	ldrb.w	r3, [r6, #49]	; 0x31
    9250:	tst.w	r3, #80	; 0x50
    9254:	bne.n	9266 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
  return sync();
#endif  // READ_ONLY
 fail:

  // close file
  m_attributes = FILE_ATTR_CLOSED;
    9256:	movs	r0, #0
    9258:	strb.w	r0, [r5, #49]	; 0x31
  m_flags = 0;
    925c:	strb.w	r0, [r5, #51]	; 0x33
  return false;
}
    9260:	add	sp, #76	; 0x4c
    9262:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    9266:	ldr	r3, [sp, #112]	; 0x70
    9268:	and.w	r3, r3, #3
    926c:	cmp	r3, #1
    926e:	beq.n	927e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x46>
    9270:	cmp	r3, #2
    9272:	beq.w	9488 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x250>
    9276:	cmp	r3, #0
    9278:	bne.n	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    927a:	movs	r3, #1
    927c:	b.n	9280 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
    927e:	movs	r3, #2
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    9280:	ldr	r2, [sp, #112]	; 0x70
    9282:	and.w	r2, r2, #8
    9286:	orrs	r3, r2
    9288:	str	r3, [sp, #4]
  if (name) {
    928a:	ldr	r3, [sp, #0]
    928c:	cmp	r3, #0
    928e:	beq.w	948c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x254>
    nameHash = exFatHashName(name, nameLength, 0);
    9292:	mov	r0, r3
    9294:	movs	r2, #0
    9296:	mov	r1, sl
    9298:	bl	9c60 <exFatHashName(char const*, unsigned int, unsigned short)>
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    929c:	ldrb.w	r3, [r6, #49]	; 0x31
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    92a0:	str	r0, [sp, #8]
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    92a2:	cbz	r3, 92b8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    92a4:	ldrd	r2, r3, [r6]
    92a8:	orrs	r3, r2
    92aa:	beq.n	92b8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    92ac:	movs	r2, #0
    92ae:	movs	r3, #0
    92b0:	strd	r2, r3, [r6]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    92b4:	movs	r1, #0
    92b6:	str	r1, [r6, #24]
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    92b8:	ldr	r2, [pc, #736]	; (959c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x364>)
    92ba:	add.w	r3, sl, #14
    92be:	smull	r1, r2, r2, r3
    92c2:	add	r2, r3
    92c4:	asrs	r3, r3, #31
    92c6:	rsb	r3, r3, r2, asr #3
    92ca:	uxtb	r3, r3
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;
    92cc:	mov.w	r9, #0
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    92d0:	str	r3, [sp, #12]
    92d2:	adds	r3, #2
    92d4:	uxtb.w	fp, r3

  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
    92d8:	mov	r4, r9
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
    92da:	mov	r7, r9
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    92dc:	movs	r2, #32
    92de:	add	r1, sp, #40	; 0x28
    92e0:	mov	r0, r6
    92e2:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    92e6:	cmp	r0, #0
    92e8:	beq.n	9366 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      goto create;
    }
    if (n != 32) {
    92ea:	cmp	r0, #32
    92ec:	bne.n	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    92ee:	ldrb.w	r3, [sp, #40]	; 0x28
    92f2:	lsls	r2, r3, #24
    92f4:	bmi.n	93c4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x18c>
      if (freeCount == 0) {
    92f6:	cmp	r4, #0
    92f8:	bne.n	93be <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x186>
        freePos.position = dir->curPosition() - 32;
    92fa:	ldr	r2, [r6, #0]
        freePos.cluster = dir->curCluster();
    92fc:	ldr	r1, [r6, #24]
    92fe:	str	r1, [sp, #28]
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
    9300:	subs	r2, #32
    9302:	str	r2, [sp, #32]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
        freeCount++;
    9304:	adds	r4, #1
    9306:	uxtb	r4, r4
      }
      if (!buf[0]) {
    9308:	cbz	r3, 9366 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    }
    switch (buf[0]) {
    930a:	cmp	r3, #192	; 0xc0
    930c:	beq.w	9436 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fe>
    9310:	cmp	r3, #193	; 0xc1
    9312:	beq.n	93da <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1a2>
    9314:	cmp	r3, #133	; 0x85
    9316:	bne.n	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
    9318:	movs	r2, #56	; 0x38
    931a:	movs	r1, #0
    931c:	mov	r0, r5
    931e:	bl	106dc <memset>
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    9322:	ldrb.w	r3, [sp, #44]	; 0x2c
    }
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
    9326:	ldrb.w	r2, [sp, #41]	; 0x29
    932a:	strb.w	r2, [r5, #48]	; 0x30
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    932e:	lsls	r0, r3, #27
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    9330:	and.w	r2, r3, #55	; 0x37
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
    9334:	it	pl
    9336:	orrpl.w	r2, r2, #8
    933a:	strb.w	r2, [r5, #49]	; 0x31
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    933e:	ldr	r3, [r6, #0]
    9340:	ldr	r1, [r6, #32]
    9342:	ldr	r2, [r6, #24]
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
    9344:	str	r2, [r5, #36]	; 0x24
        m_dirPos.position = dir->curPosition() - 32;
    9346:	subs	r3, #32
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();
    9348:	str	r1, [r5, #32]

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    934a:	str	r3, [r5, #40]	; 0x28
        m_dirPos.isContiguous = dir->isContiguous();
    934c:	ldrb.w	r3, [r6, #51]	; 0x33
    9350:	ubfx	r3, r3, #6, #1
    9354:	strb.w	r3, [r5, #44]	; 0x2c
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    9358:	movs	r2, #32
    935a:	add	r1, sp, #40	; 0x28
    935c:	mov	r0, r6
    935e:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    9362:	cmp	r0, #0
    9364:	bne.n	92ea <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xb2>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    9366:	ldr	r3, [sp, #112]	; 0x70
    9368:	lsls	r1, r3, #22
    936a:	bpl.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    936e:	ldr	r3, [sp, #4]
    9370:	lsls	r2, r3, #30
    9372:	bpl.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    9376:	ldr	r3, [sp, #0]
    9378:	cmp	r3, #0
    937a:	beq.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    937e:	cmp	r4, fp
    9380:	bcc.n	939c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x164>
    9382:	b.n	9492 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
        goto fail;
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
    9384:	cmp	r0, #32
    9386:	bne.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    938a:	cbnz	r4, 9396 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x15e>
      freePos.position = dir->curPosition() - 32;
    938c:	ldr	r2, [r6, #0]
      freePos.cluster = dir->curCluster();
    938e:	ldr	r1, [r6, #24]
    9390:	str	r1, [sp, #28]
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
    9392:	subs	r2, #32
    9394:	str	r2, [sp, #32]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    9396:	uxtb	r4, r3
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    9398:	cmp	fp, r4
    939a:	bls.n	9492 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
    n = dir->read(buf, 32);
    939c:	movs	r2, #32
    939e:	add	r1, sp, #40	; 0x28
    93a0:	mov	r0, r6
    93a2:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    93a6:	adds	r3, r4, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
    93a8:	cmp	r0, #0
    93aa:	bne.n	9384 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x14c>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    93ac:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    93ae:	ldr	r7, [r6, #24]
      if (!dir->addDirCluster()) {
    93b0:	bl	9ff0 <ExFatFile::addDirCluster()>
    93b4:	cmp	r0, #0
    93b6:	beq.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    93ba:	str	r7, [r6, #24]
      continue;
    93bc:	b.n	9398 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x160>
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    93be:	cmp	r4, fp
    93c0:	bcs.n	9308 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd0>
    93c2:	b.n	9304 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xcc>
        freeCount++;
      }
      if (!buf[0]) {
        goto create;
      }
    } else if (!inSet) {
    93c4:	cmp.w	r9, #0
    93c8:	bne.n	930a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd2>
      if (freeCount < freeNeed) {
        freeCount = 0;
    93ca:	cmp	r4, fp
    93cc:	it	cc
    93ce:	movcc	r4, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    93d0:	cmp	r3, #133	; 0x85
    93d2:	bne.n	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        continue;
      }
      inSet = true;
    93d4:	mov.w	r9, #1
    93d8:	b.n	9318 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xe0>
        }
        break;

      case EXFAT_TYPE_NAME:
        dirName = reinterpret_cast<DirName_t*>(buf);
        nCmp = nameLength - nameOffset;
    93da:	rsb	r8, r7, sl
    93de:	uxtb.w	r8, r8
    93e2:	cmp.w	r8, #15
    93e6:	it	cs
    93e8:	movcs.w	r8, #15
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
    93ec:	mov	r3, r8
    93ee:	mov	r2, r7
    93f0:	ldr	r1, [sp, #0]
    93f2:	add	r0, sp, #40	; 0x28
    93f4:	bl	9c08 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>
    93f8:	cmp	r0, #0
    93fa:	beq.n	9476 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x23e>
          inSet = false;
          break;
        }
        nameOffset += nCmp;
    93fc:	add	r7, r8
    93fe:	uxtb	r7, r7

        if (nameOffset == nameLength) {
    9400:	cmp	sl, r7
    9402:	bne.w	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    9406:	ldr	r3, [sp, #112]	; 0x70
    9408:	lsls	r3, r3, #20
    940a:	bmi.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    940e:	ldr	r3, [sp, #112]	; 0x70
    9410:	tst.w	r3, #17408	; 0x4400
    9414:	bne.w	9558 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
    9418:	ldrb.w	r3, [r5, #51]	; 0x33
    941c:	lsls	r7, r3, #30
    941e:	bmi.w	9558 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    9422:	ldr	r3, [sp, #112]	; 0x70
    9424:	lsls	r3, r3, #21
    9426:	bmi.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    942a:	ldr	r3, [sp, #112]	; 0x70
    942c:	lsls	r0, r3, #17
    942e:	bmi.w	95a0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x368>
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // READ_ONLY
  return true;
    9432:	movs	r0, #1
    9434:	b.n	9260 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    9436:	ldrb.w	r3, [sp, #41]	; 0x29
        m_dirPos.isContiguous = dir->isContiguous();
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
    943a:	ldr	r2, [sp, #4]
    943c:	strb.w	r2, [r5, #51]	; 0x33
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    9440:	lsls	r1, r3, #30
    9442:	bpl.n	944c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x214>
          m_flags |= FILE_FLAG_CONTIGUOUS;
    9444:	orr.w	r3, r2, #64	; 0x40
    9448:	strb.w	r3, [r5, #51]	; 0x33
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    944c:	ldrd	r2, r3, [sp, #48]	; 0x30
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    9450:	ldrd	r0, r1, [sp, #64]	; 0x40
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    9454:	strd	r2, r3, [r5, #16]
        m_firstCluster = getLe32(dirStream->firstCluster);
    9458:	ldr	r3, [sp, #60]	; 0x3c
    945a:	str	r3, [r5, #28]
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
    945c:	ldr	r3, [sp, #0]
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    945e:	strd	r0, r1, [r5, #8]
        if (!name) {
    9462:	cmp	r3, #0
    9464:	beq.n	9406 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1ce>
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    9466:	ldrb.w	r3, [sp, #43]	; 0x2b
    946a:	cmp	r3, sl
    946c:	beq.n	947a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x242>
            nameHash != getLe16(dirStream->nameHash)) {
          inSet = false;
    946e:	mov.w	r9, #0
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    9472:	mov	r7, r9
    9474:	b.n	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        nCmp = nameLength - nameOffset;
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
          inSet = false;
    9476:	mov	r9, r0
    9478:	b.n	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    947a:	ldrh.w	r3, [sp, #44]	; 0x2c
    947e:	ldr	r2, [sp, #8]
    9480:	cmp	r3, r2
    9482:	bne.n	946e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x236>
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    9484:	movs	r7, #0
    9486:	b.n	92dc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    9488:	movs	r3, #3
    948a:	b.n	9280 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
  uint8_t nCmp;
  uint8_t modeFlags;
  uint16_t nameHash = 0;
    948c:	ldr	r3, [sp, #0]
    948e:	str	r3, [sp, #8]
    9490:	b.n	92b8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    9492:	ldrb.w	r3, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    9496:	movs	r2, #56	; 0x38
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    9498:	ubfx	r3, r3, #6, #1
  memset(this, 0, sizeof(ExFatFile));
    949c:	movs	r1, #0
    949e:	mov	r0, r5
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    94a0:	add.w	r8, sp, #28
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    94a4:	strb.w	r3, [sp, #36]	; 0x24
  memset(this, 0, sizeof(ExFatFile));
    94a8:	bl	106dc <memset>
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    94ac:	ldr	r4, [sp, #12]
    94ae:	ldr	r3, [r6, #32]
    94b0:	str.w	sl, [sp, #12]

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    94b4:	ldmia.w	r8, {r0, r1, r2}
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    94b8:	add.w	r9, r4, #1
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
    94bc:	movs	r4, #8
    94be:	strb.w	r4, [r5, #49]	; 0x31
    94c2:	add.w	r7, sl, #30
  m_dirPos = freePos;
    94c6:	add.w	r4, r5, #36	; 0x24
    94ca:	ldr.w	sl, [sp]
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
    94ce:	str	r3, [r5, #32]
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    94d0:	uxtb.w	r9, r9

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    94d4:	stmia.w	r4, {r0, r1, r2}
    94d8:	uxtb	r7, r7
  for (uint8_t i = 0; i < freeNeed; i++) {
    94da:	movs	r6, #0
    94dc:	mov	r0, r3
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
    94de:	movs	r2, #1
    94e0:	mov	r1, r8
    94e2:	bl	995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    94e6:	mov	r4, r0
    94e8:	cmp	r0, #0
    94ea:	beq.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    94ee:	ldrsb.w	r3, [r0]
    94f2:	cmp	r3, #0
    94f4:	blt.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    94f8:	movs	r2, #32
    94fa:	movs	r1, #0
    94fc:	bl	106dc <memset>
    if (i == 0) {
    9500:	cmp	r6, #0
    9502:	beq.n	95d2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x39a>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    9504:	cmp	r6, #1
    9506:	beq.n	95b2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x37a>
    9508:	rsb	r3, r6, r6, lsl #4
    950c:	cmp	r7, #15
    950e:	sub.w	r3, r3, #30

      dirStream->nameLength = nameLength;
      setLe16(dirStream->nameHash, nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    9512:	mov.w	r2, #193	; 0xc1
    9516:	mov	r1, r7
    9518:	it	cs
    951a:	movcs	r1, #15
    951c:	uxtb	r3, r3
    951e:	strb	r2, [r4, #0]
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    9520:	cbz	r1, 9538 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    9522:	adds	r4, #2
    9524:	sxth	r1, r1
    9526:	add.w	r1, r4, r1, lsl #1
    952a:	add	r3, sl
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
    952c:	ldrb.w	r2, [r3], #1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    9530:	strh.w	r2, [r4], #2
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    9534:	cmp	r1, r4
    9536:	bne.n	952c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2f4>
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
    9538:	adds	r6, #1
    953a:	uxtb	r6, r6
    953c:	cmp	fp, r6
    953e:	bls.n	9594 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x35c>
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
    9540:	movs	r2, #32
    9542:	mov	r1, r8
    9544:	ldr	r0, [r5, #32]
    9546:	bl	9990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    954a:	cmp	r0, #1
    954c:	bne.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    9550:	subs	r7, #15
    9552:	uxtb	r7, r7
    9554:	ldr	r0, [r5, #32]
    9556:	b.n	94de <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2a6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    9558:	ldrb.w	r3, [r5, #49]	; 0x31
    955c:	tst.w	r3, #17
    9560:	bne.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    9564:	ldr	r3, [sp, #112]	; 0x70
    9566:	lsls	r6, r3, #21
    9568:	bpl.w	942a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1f2>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    956c:	ldrb.w	r3, [r5, #51]	; 0x33
    9570:	lsls	r4, r3, #30
    9572:	bpl.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    9576:	movs	r2, #0
    9578:	movs	r3, #0
    957a:	mov	r0, r5
    957c:	bl	9138 <ExFatFile::seekSet(unsigned long long)>
    9580:	cmp	r0, #0
    9582:	beq.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    9586:	mov	r0, r5
    9588:	bl	a2c8 <ExFatFile::truncate()>
    958c:	cmp	r0, #0
    958e:	beq.w	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    9592:	b.n	9432 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
      for (size_t k = 0; k < nCmp; k++) {
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
      }
    }
  }
  return sync();
    9594:	mov	r0, r5
    9596:	bl	9f94 <ExFatFile::sync()>
    959a:	b.n	9260 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
    959c:	.word	0x88888889
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    95a0:	ldrd	r2, r3, [r5, #16]
    95a4:	mov	r0, r5
    95a6:	bl	9138 <ExFatFile::seekSet(unsigned long long)>
    95aa:	cmp	r0, #0
    95ac:	bne.w	9432 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
    95b0:	b.n	9256 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    95b2:	movs	r3, #192	; 0xc0
    95b4:	strb	r3, [r4, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    95b6:	ldr	r3, [sp, #4]
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    95b8:	movs	r2, #3
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    95ba:	orn	r3, r3, #63	; 0x3f
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    95be:	strb	r2, [r4, #1]
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    95c0:	strb.w	r3, [r5, #51]	; 0x33

      dirStream->nameLength = nameLength;
    95c4:	ldrb.w	r3, [sp, #12]
    95c8:	strb	r3, [r4, #3]
    95ca:	ldrh.w	r3, [sp, #8]
    95ce:	strh	r3, [r4, #4]
    95d0:	b.n	9538 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
      goto fail;
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    95d2:	movs	r3, #133	; 0x85
    95d4:	strb	r3, [r4, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    95d6:	ldr	r3, [pc, #56]	; (9610 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3d8>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    95d8:	strb.w	r9, [r5, #48]	; 0x30
      dirFile->setCount = m_setCount;
    95dc:	strb.w	r9, [r4, #1]

      if (FsDateTime::callback) {
    95e0:	ldr	r3, [r3, #0]
    95e2:	cbz	r3, 9604 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3cc>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    95e4:	add.w	r2, sp, #23
    95e8:	add.w	r1, sp, #26
    95ec:	add	r0, sp, #24
    95ee:	blx	r3
    95f0:	ldrh.w	r1, [sp, #24]
    95f4:	ldrh.w	r2, [sp, #26]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    95f8:	ldrb.w	r3, [sp, #23]
    95fc:	strh	r1, [r4, #10]
    95fe:	strh	r2, [r4, #8]
    9600:	strb	r3, [r4, #20]
    9602:	b.n	9538 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    9604:	movw	r3, #21025	; 0x5221
    9608:	strh	r3, [r4, #10]
    960a:	strh	r3, [r4, #14]
    960c:	strh	r3, [r4, #18]
    960e:	b.n	9538 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    9610:	.word	0x20002bd8

00009614 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    9614:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9618:	mov	r6, r0
    961a:	sub	sp, #84	; 0x54
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    961c:	ldrb.w	r4, [r6, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    9620:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    9622:	movs	r0, #0
    9624:	strb.w	r0, [sp, #73]	; 0x49
    9628:	strb.w	r0, [sp, #74]	; 0x4a
    962c:	strb.w	r0, [sp, #75]	; 0x4b
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    9630:	cbnz	r4, 9640 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
    9632:	mov	r9, r3
    9634:	ldrb.w	r3, [r1, #49]	; 0x31
    9638:	tst.w	r3, #80	; 0x50
    963c:	mov	r5, r1
    963e:	bne.n	9648 <ExFatFile::open(ExFatFile*, char const*, int)+0x34>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    9640:	movs	r0, #0
}
    9642:	add	sp, #84	; 0x54
    9644:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    9648:	ldrb	r3, [r2, #0]
    964a:	cmp	r3, #47	; 0x2f
    964c:	mov	r4, r2
    964e:	beq.n	96b6 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    9650:	mov.w	r8, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9654:	mov	r1, r4
    9656:	add	r3, sp, #12
    9658:	add	r2, sp, #16
    965a:	mov	r0, r6
    965c:	bl	8e9c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    9660:	cmp	r0, #0
    9662:	beq.n	9640 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    9664:	ldr	r3, [sp, #12]
    9666:	ldrb	r3, [r3, #0]
    9668:	cmp	r3, #0
    966a:	beq.n	96e0 <ExFatFile::open(ExFatFile*, char const*, int)+0xcc>
    966c:	ldrb.w	r3, [sp, #16]
    9670:	ldr	r2, [sp, #20]
    9672:	str.w	r8, [sp]
    9676:	mov	r1, r5
    9678:	mov	r0, r6
    967a:	bl	9238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    967e:	cmp	r0, #0
    9680:	beq.n	9640 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    9682:	mov	r4, r6
    9684:	add	r7, sp, #24
    9686:	add.w	lr, r6, #48	; 0x30
    968a:	ldr	r0, [r4, #0]
    968c:	ldr	r1, [r4, #4]
    968e:	ldr	r2, [r4, #8]
    9690:	ldr	r3, [r4, #12]
    9692:	mov	r5, r7
    9694:	stmia	r5!, {r0, r1, r2, r3}
    9696:	adds	r4, #16
    9698:	cmp	r4, lr
    969a:	mov	r7, r5
    969c:	bne.n	968a <ExFatFile::open(ExFatFile*, char const*, int)+0x76>
    969e:	ldr	r0, [r4, #0]
    96a0:	str	r0, [r5, #0]
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
    96a2:	mov	r0, r6
    96a4:	bl	9f94 <ExFatFile::sync()>
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    96a8:	add	r5, sp, #24
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    96aa:	strb.w	r8, [r6, #49]	; 0x31
  m_flags = 0;
    96ae:	strb.w	r8, [r6, #51]	; 0x33
    96b2:	ldr	r4, [sp, #12]
    96b4:	b.n	9654 <ExFatFile::open(ExFatFile*, char const*, int)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    96b6:	adds	r4, #1
    96b8:	str	r4, [sp, #12]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    96ba:	ldrb	r1, [r4, #0]
    96bc:	cmp	r1, #47	; 0x2f
    96be:	beq.n	96b6 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
      path++;
    }
    if (*path == 0) {
    96c0:	cbz	r1, 96f8 <ExFatFile::open(ExFatFile*, char const*, int)+0xe4>
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    96c2:	movs	r2, #56	; 0x38
    96c4:	add	r0, sp, #24
    96c6:	movs	r1, #0
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    96c8:	ldr	r7, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    96ca:	bl	106dc <memset>
  m_attributes = FILE_ATTR_ROOT;
    96ce:	movs	r2, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    96d0:	movs	r3, #1
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    96d2:	add	r5, sp, #24
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    96d4:	str	r7, [sp, #56]	; 0x38
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    96d6:	strb.w	r2, [sp, #73]	; 0x49
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    96da:	strb.w	r3, [sp, #75]	; 0x4b
    96de:	b.n	9650 <ExFatFile::open(ExFatFile*, char const*, int)+0x3c>
    96e0:	ldrb.w	r3, [sp, #16]
    96e4:	ldr	r2, [sp, #20]
    96e6:	str.w	r9, [sp]
    96ea:	mov	r1, r5
    96ec:	mov	r0, r6
    96ee:	bl	9238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
}
    96f2:	add	sp, #84	; 0x54
    96f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    96f8:	movs	r2, #56	; 0x38
    96fa:	mov	r0, r6
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    96fc:	ldr	r4, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    96fe:	bl	106dc <memset>
  m_attributes = FILE_ATTR_ROOT;
    9702:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    9704:	movs	r0, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    9706:	str	r4, [r6, #32]
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    9708:	strb.w	r3, [r6, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    970c:	strb.w	r0, [r6, #51]	; 0x33
    9710:	b.n	9642 <ExFatFile::open(ExFatFile*, char const*, int)+0x2e>
    9712:	nop

00009714 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const ExChar_t* path, int oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
    9714:	cbz	r1, 971e <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    9716:	add.w	r1, r1, #1096	; 0x448
    971a:	b.w	9614 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    971e:	mov	r0, r1
    9720:	bx	lr
    9722:	nop

00009724 <ExFatFile::openNext(ExFatFile*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    9724:	ldrb.w	r3, [r0, #49]	; 0x31
    9728:	cbnz	r3, 9740 <ExFatFile::openNext(ExFatFile*, int)+0x1c>
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    972a:	push	{r4, r5, lr}
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    972c:	ldrb.w	r4, [r1, #49]	; 0x31
    9730:	ands.w	r4, r4, #80	; 0x50
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    9734:	sub	sp, #12
    9736:	mov	r5, r1
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    9738:	bne.n	9744 <ExFatFile::openNext(ExFatFile*, int)+0x20>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    973a:	mov	r0, r4
}
    973c:	add	sp, #12
    973e:	pop	{r4, r5, pc}
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    9740:	movs	r0, #0
}
    9742:	bx	lr
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    9744:	ldrd	r4, r5, [r5]
    9748:	movs	r5, #0
    974a:	and.w	r4, r4, #31
    974e:	orrs	r4, r5
    9750:	beq.n	9758 <ExFatFile::openNext(ExFatFile*, int)+0x34>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    9752:	mov	r0, r3
}
    9754:	add	sp, #12
    9756:	pop	{r4, r5, pc}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);
    9758:	str	r2, [sp, #0]
    975a:	mov	r2, r3
    975c:	bl	9238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>

 fail:
  return false;
}
    9760:	add	sp, #12
    9762:	pop	{r4, r5, pc}

00009764 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>:
    }
  }
  return 1;
}
//------------------------------------------------------------------------------
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    9764:	push	{r3, r4, r5, lr}
    9766:	mov	r4, r1
    9768:	ldr.w	r1, [r0, #1060]	; 0x424
    976c:	mov	r5, r2
    976e:	add.w	r1, r1, r4, lsr #7
    9772:	add.w	r0, r0, #528	; 0x210
    9776:	movs	r2, #0
    9778:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    return -1;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    977c:	cbz	r0, 9790 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x2c>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    977e:	lsls	r4, r4, #2
    9780:	ubfx	r4, r4, #0, #9
    9784:	ldr	r3, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    9786:	adds	r2, r3, #1
    9788:	beq.n	9794 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x30>
    return 0;
  }
  *value = next;
    978a:	str	r3, [r5, #0]
  return 1;
    978c:	movs	r0, #1
    978e:	pop	{r3, r4, r5, pc}
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    return -1;
    9790:	movs	r0, #255	; 0xff
    9792:	pop	{r3, r4, r5, pc}
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    return 0;
    9794:	movs	r0, #0
  }
  *value = next;
  return 1;
}
    9796:	pop	{r3, r4, r5, pc}

00009798 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    9798:	push	{r3, r4, r5, lr}
    979a:	mov	r4, r1
    979c:	ldr.w	r1, [r0, #1060]	; 0x424
    97a0:	mov	r5, r2
    97a2:	add.w	r1, r1, r4, lsr #7
    97a6:	add.w	r0, r0, #528	; 0x210
    97aa:	movs	r2, #1
    97ac:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    97b0:	mov	r3, r0
    97b2:	cbz	r0, 97c0 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]+0x28>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    97b4:	lsls	r4, r4, #2
    97b6:	ubfx	r4, r4, #0, #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    97ba:	movs	r0, #1
    97bc:	str	r5, [r3, r4]
    97be:	pop	{r3, r4, r5, pc}

 fail:
  return false;
}
    97c0:	pop	{r3, r4, r5, pc}
    97c2:	nop

000097c4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    97c4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    97c8:	mov	r8, r0
    97ca:	mov	r9, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    97cc:	mov	fp, r1
    97ce:	cmp	r1, #0
    97d0:	beq.n	985c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x98>
    97d2:	subs	r7, r1, #2
  if (start >= m_clusterCount) {
    97d4:	ldr.w	r3, [r8, #1072]	; 0x430
    97d8:	cmp	r7, r3
    97da:	bcs.n	9854 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x90>
    97dc:	and.w	r5, r7, #7
    97e0:	movs	r3, #1
    97e2:	lsl.w	r5, r3, r5
    97e6:	uxtb	r5, r5
    97e8:	ubfx	sl, r7, #3, #9
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    97ec:	mov	r6, r7
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    97ee:	mov	r4, r7
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    97f0:	ldr.w	r1, [r8, #1068]	; 0x42c
    97f4:	movs	r2, #0
    97f6:	add.w	r1, r1, r4, lsr #12
    97fa:	mov	r0, r8
    97fc:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    9800:	cbz	r0, 9834 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
    9802:	ldrb.w	r1, [r0, sl]
    9806:	b.n	981e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x5a>
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    9808:	cmp	r2, r9
    980a:	beq.n	9862 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x9e>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    980c:	cmp	r7, r4
    980e:	beq.n	9832 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    9810:	ldr.w	r2, [r8, #1072]	; 0x430
    9814:	cmp	r4, r2
    9816:	bcs.n	9848 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x84>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    9818:	ands.w	r5, r3, #255	; 0xff
    981c:	beq.n	9838 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x74>
        endAlloc++;
    981e:	adds	r4, #1
        if (!(mask & cache[i])) {
    9820:	tst	r5, r1
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    9822:	mov.w	r3, r5, lsl #1
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    9826:	sub.w	r2, r4, r6
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    982a:	beq.n	9808 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x44>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    982c:	cmp	r7, r4
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    982e:	mov	r6, r4
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    9830:	bne.n	9810 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4c>
          return 1;
    9832:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    9834:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9838:	add.w	sl, sl, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    983c:	cmp.w	sl, #512	; 0x200
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    9840:	mov.w	r5, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    9844:	bne.n	9802 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x3e>
    9846:	b.n	984c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x88>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    9848:	movs	r6, #0
    984a:	mov	r4, r6
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    984c:	mov.w	sl, #0
    9850:	movs	r5, #1
    9852:	b.n	97f0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x2c>
    9854:	movs	r7, #0
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
    9856:	mov	sl, r7
    9858:	movs	r5, #1
    985a:	b.n	97ec <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x28>
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    985c:	ldr.w	r7, [r0, #1056]	; 0x420
    9860:	b.n	97d4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
            if (cluster == 0 && count == 1) {
    9862:	cmp.w	fp, #0
    9866:	bne.n	9872 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xae>
    9868:	cmp.w	r9, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    986c:	it	eq
    986e:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    9872:	adds	r0, r6, #2
    9874:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00009878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    9878:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector;
  uint32_t start = cluster - 2;
    987c:	subs	r1, #2
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    987e:	mov	r8, r0
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    9880:	ldr.w	r0, [r0, #1072]	; 0x430
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    9884:	mov	r5, r2
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    9886:	adds	r2, r1, r2
    9888:	cmp	r2, r0
    988a:	bhi.n	98fe <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    988c:	mov	sl, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    988e:	ldr.w	r3, [r8, #1056]	; 0x420
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    9892:	cmp.w	sl, #0
    9896:	bne.n	9904 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x8c>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    }
  } else {
    if (start < m_bitmapStart) {
    9898:	cmp	r1, r3
      m_bitmapStart = start;
    989a:	it	cc
    989c:	strcc.w	r1, [r8, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    98a0:	and.w	r4, r1, #7
    98a4:	movs	r2, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    98a6:	ldr.w	r3, [r8, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    98aa:	lsl.w	r4, r2, r4
    98ae:	uxtb	r4, r4
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    98b0:	add.w	r9, r3, r1, lsr #12
  i = (start >> 3) & m_sectorMask;
    98b4:	ubfx	r6, r1, #3, #9
    98b8:	movs	r2, #1
    98ba:	mov	r1, r9
    98bc:	mov	r0, r8
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    98be:	add	r9, r2
    98c0:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    98c4:	cbz	r0, 98fe <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    98c6:	adds	r7, r0, r6
    98c8:	add.w	r0, r0, #512	; 0x200
    98cc:	ldrb.w	r2, [r7], #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    98d0:	tst	r2, r4
    98d2:	ite	ne
    98d4:	movne	r6, #1
    98d6:	moveq	r6, #0
    98d8:	cmp	r6, sl
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    98da:	eor.w	r2, r2, r4
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    98de:	mov.w	r4, r4, lsl #1
        if (value == static_cast<bool>(cache[i] & mask)) {
    98e2:	beq.n	98fe <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
    98e4:	subs	r5, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    98e6:	strb.w	r2, [r7, #-1]
        if (--count == 0) {
    98ea:	beq.n	9918 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    98ec:	ands.w	r4, r4, #255	; 0xff
    98f0:	bne.n	98d0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x58>
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    98f2:	cmp	r0, r7
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    98f4:	mov	r6, r4
    98f6:	mov.w	r4, #1
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    98fa:	bne.n	98cc <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    98fc:	b.n	98b8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x40>
    }
    i = 0;
  }

 fail:
  return false;
    98fe:	movs	r0, #0
    9900:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    9904:	cmp	r1, r3
    9906:	bhi.n	98a0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
    9908:	cmp	r2, r3
    990a:	bls.n	98a0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    990c:	cmp	r2, r0
    990e:	it	cs
    9910:	movcs	r2, #0
    9912:	str.w	r2, [r8, #1056]	; 0x420
    9916:	b.n	98a0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    9918:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    991a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    991e:	nop

00009920 <ExFatPartition::chainSize(unsigned long)>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    9920:	push	{r4, r5, r6, lr}
    9922:	sub	sp, #8
    9924:	add	r6, sp, #8
    9926:	mov	r5, r0
    9928:	str.w	r1, [r6, #-4]!
  uint32_t n = 0;
    992c:	movs	r4, #0
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    992e:	ldr.w	r3, [r5, #1072]	; 0x430
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    9932:	ldr	r1, [sp, #4]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    9934:	adds	r3, #1
    9936:	cmp	r1, r3
    9938:	bls.n	9940 <ExFatPartition::chainSize(unsigned long)+0x20>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    993a:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    993c:	add	sp, #8
    993e:	pop	{r4, r5, r6, pc}
    9940:	mov	r2, r6
    9942:	mov	r0, r5
    9944:	bl	9764 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    9948:	sxtb	r0, r0
    if (status < 0) return 0;
    994a:	cmp	r0, #0
    994c:	blt.n	993a <ExFatPartition::chainSize(unsigned long)+0x1a>
    n++;
    994e:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    9952:	bne.n	992e <ExFatPartition::chainSize(unsigned long)+0xe>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    9954:	mov	r0, r4
  } while (status);
  return n;
}
    9956:	add	sp, #8
    9958:	pop	{r4, r5, r6, pc}
    995a:	nop

0000995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    995c:	push	{r3, r4, r5, r6, r7, lr}
    995e:	mov	r6, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    9960:	ldmia.w	r6, {r3, r5}
    9964:	ldr.w	r1, [r0, #1080]	; 0x438
    9968:	ldr.w	r4, [r0, #1068]	; 0x42c
    996c:	ldrb.w	r7, [r0, #1093]	; 0x445
    9970:	ands	r1, r5
    9972:	subs	r3, #2
    9974:	add.w	r1, r4, r1, lsr #9
    9978:	lsls	r3, r7
    997a:	add	r1, r3
    997c:	add.w	r0, r0, #528	; 0x210
    9980:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    9984:	cbz	r0, 998e <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x32>
    9986:	ldr	r3, [r6, #4]
    9988:	ubfx	r3, r3, #0, #9
    998c:	add	r0, r3
}
    998e:	pop	{r3, r4, r5, r6, r7, pc}

00009990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    9990:	push	{r4, r5, r6, lr}
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    9992:	ldr	r4, [r1, #4]
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    9994:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
    9996:	adds	r3, r4, r2
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    9998:	ldr.w	r1, [r0, #1080]	; 0x438
  pos->position += offset;
    999c:	str	r3, [r5, #4]
  tmp >>= bytesPerClusterShift();
    999e:	ldrb.w	r3, [r0, #1093]	; 0x445
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    99a2:	ands	r4, r1
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    99a4:	adds	r3, #9
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    99a6:	add	r2, r4
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    99a8:	uxtb	r3, r3
    99aa:	lsr.w	r4, r2, r3
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    99ae:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    99b0:	cbz	r4, 99c2 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x32>
    if (pos->isContiguous) {
    99b2:	ldrb	r3, [r5, #8]
    99b4:	cbz	r3, 99c6 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x36>
      pos->cluster++;
    99b6:	ldr	r3, [r5, #0]
    99b8:	adds	r3, #1
    99ba:	str	r3, [r5, #0]
    99bc:	subs	r4, #1
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    99be:	cmp	r4, #0
    99c0:	bne.n	99b2 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x22>
      if (status != 1) {
        return status;
      }
    }
  }
  return 1;
    99c2:	movs	r0, #1
    99c4:	pop	{r4, r5, r6, pc}
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    99c6:	ldr.w	r3, [r6, #1072]	; 0x430
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    99ca:	ldr	r1, [r5, #0]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    99cc:	adds	r3, #1
    99ce:	cmp	r1, r3
    99d0:	bls.n	99d8 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x48>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    99d2:	mov.w	r0, #4294967295
        return status;
      }
    }
  }
  return 1;
}
    99d6:	pop	{r4, r5, r6, pc}
    99d8:	mov	r2, r5
    99da:	mov	r0, r6
    99dc:	bl	9764 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    99e0:	sxtb	r0, r0
      if (status != 1) {
    99e2:	cmp	r0, #1
    99e4:	beq.n	99bc <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    99e6:	pop	{r4, r5, r6, pc}

000099e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    99e8:	ldr.w	r3, [r0, #1072]	; 0x430
    99ec:	adds	r3, #1
    99ee:	cmp	r3, r1
    99f0:	bcs.n	99f6 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0xe>
  if (next == EXFAT_EOC) {
    return 0;
  }
  *value = next;
  return 1;
}
    99f2:	movs	r0, #255	; 0xff
    99f4:	bx	lr
    99f6:	b.w	9764 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
    99fa:	nop

000099fc <ExFatPartition::fatPut(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    99fc:	cmp	r1, #1
    99fe:	bls.n	9a18 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x1c>
    9a00:	ldr.w	r3, [r0, #1072]	; 0x430
    9a04:	adds	r3, #1
    9a06:	cmp	r1, r3
  }
  *value = next;
  return 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    9a08:	push	{r4}
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    9a0a:	bls.n	9a12 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x16>
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
}
    9a0c:	movs	r0, #0
    9a0e:	pop	{r4}
    9a10:	bx	lr
    9a12:	pop	{r4}
    9a14:	b.w	9798 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    9a18:	movs	r0, #0
    9a1a:	bx	lr

00009a1c <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    9a1c:	push	{r4, r5, r6, r7, lr}
    9a1e:	mov	r4, r1
    9a20:	sub	sp, #12
    9a22:	mov	r5, r0
  uint32_t next;
  uint32_t start = cluster;
    9a24:	mov	r6, r1
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    9a26:	ldr.w	r3, [r5, #1072]	; 0x430
    9a2a:	adds	r3, #1
    9a2c:	cmp	r4, r3
    9a2e:	bls.n	9a36 <ExFatPartition::freeChain(unsigned long)+0x1a>
  } while (status);

  return true;

 fail:
  return false;
    9a30:	movs	r0, #0
}
    9a32:	add	sp, #12
    9a34:	pop	{r4, r5, r6, r7, pc}
    9a36:	add	r2, sp, #4
    9a38:	mov	r1, r4
    9a3a:	mov	r0, r5
    9a3c:	bl	9764 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    9a40:	sxtb	r7, r0
    if (status < 0) {
    9a42:	cmp	r7, #0
    9a44:	blt.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    9a46:	cmp	r4, #1
    9a48:	bls.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>
    9a4a:	ldr.w	r3, [r5, #1072]	; 0x430
    9a4e:	adds	r3, #1
    9a50:	cmp	r4, r3
    9a52:	bhi.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>
    9a54:	movs	r2, #0
    9a56:	mov	r1, r4
    9a58:	mov	r0, r5
    9a5a:	bl	9798 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    9a5e:	cmp	r0, #0
    9a60:	beq.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    9a62:	ldr	r3, [sp, #4]
    9a64:	adds	r4, #1
    9a66:	cmp	r4, r3
    9a68:	bne.n	9a82 <ExFatPartition::freeChain(unsigned long)+0x66>
    9a6a:	cmp	r7, #0
    9a6c:	bne.n	9a26 <ExFatPartition::freeChain(unsigned long)+0xa>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    9a6e:	mov	r3, r7
    9a70:	subs	r2, r4, r6
    9a72:	mov	r1, r6
    9a74:	mov	r0, r5
    9a76:	bl	9878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    9a7a:	cmp	r0, #0
    9a7c:	beq.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>

  return true;

 fail:
  return false;
}
    9a7e:	add	sp, #12
    9a80:	pop	{r4, r5, r6, r7, pc}
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    9a82:	subs	r2, r4, r6
    9a84:	mov	r1, r6
    9a86:	movs	r3, #0
    9a88:	mov	r0, r5
    9a8a:	bl	9878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    9a8e:	cmp	r0, #0
    9a90:	beq.n	9a30 <ExFatPartition::freeChain(unsigned long)+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    9a92:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    9a94:	cmp	r7, #0
    9a96:	beq.n	9a32 <ExFatPartition::freeChain(unsigned long)+0x16>
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    9a98:	mov	r6, r4
    9a9a:	b.n	9a26 <ExFatPartition::freeChain(unsigned long)+0xa>

00009a9c <ExFatPartition::freeClusterCount()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    9a9c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
    9aa0:	movs	r4, #0
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    9aa2:	ldr.w	r6, [r0, #1068]	; 0x42c

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    9aa6:	mov	r8, r0
    9aa8:	add.w	r7, r0, #528	; 0x210
  uint32_t nc = 0;
    9aac:	mov	r5, r4
    9aae:	mov	r1, r6
    9ab0:	movs	r2, #0
    9ab2:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    9ab4:	adds	r6, #1
    9ab6:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    9aba:	cbz	r0, 9b0a <ExFatPartition::freeClusterCount()+0x6e>
    9abc:	add.w	lr, r0, #4294967295
    9ac0:	ldr.w	ip, [r8, #1072]	; 0x430
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    9ac4:	ldrb.w	r0, [lr, #1]!
    9ac8:	cmp	r0, #255	; 0xff
    9aca:	add.w	r9, r5, #4096	; 0x1000
    9ace:	beq.n	9af8 <ExFatPartition::freeClusterCount()+0x5c>
        usedCount+= 8;
      } else if (cache[i]) {
    9ad0:	cbz	r0, 9ae6 <ExFatPartition::freeClusterCount()+0x4a>
    9ad2:	movs	r2, #8
    9ad4:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    9ad6:	tst	r0, r3
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    9ad8:	mov.w	r1, r3, lsl #1
          if ((mask & cache[i])) {
            usedCount++;
    9adc:	it	ne
    9ade:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    9ae0:	subs	r2, #1
    9ae2:	uxtb	r3, r1
    9ae4:	bne.n	9ad6 <ExFatPartition::freeClusterCount()+0x3a>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    9ae6:	adds	r5, #8
      if (nc >= m_clusterCount) {
    9ae8:	cmp	ip, r5
    9aea:	bls.n	9b02 <ExFatPartition::freeClusterCount()+0x66>
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    9aec:	cmp	r5, r9
    9aee:	beq.n	9aae <ExFatPartition::freeClusterCount()+0x12>
      if (cache[i] == 0XFF) {
    9af0:	ldrb.w	r0, [lr, #1]!
    9af4:	cmp	r0, #255	; 0xff
    9af6:	bne.n	9ad0 <ExFatPartition::freeClusterCount()+0x34>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    9af8:	adds	r5, #8
      if (nc >= m_clusterCount) {
    9afa:	cmp	ip, r5
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
    9afc:	add.w	r4, r4, #8
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    9b00:	bhi.n	9aec <ExFatPartition::freeClusterCount()+0x50>
        return m_clusterCount - usedCount;
    9b02:	rsb	r0, r4, ip
    9b06:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }
}
    9b0a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9b0e:	nop

00009b10 <ExFatPartition::init(SdSpiCard*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    9b10:	push	{r3, r4, r5, r6, r7, lr}
    9b12:	mov	r4, r0
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    9b14:	movs	r3, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    9b16:	mov.w	r6, #4294967295
    9b1a:	add.w	r7, r0, #528	; 0x210
  m_blockDev = dev;
    9b1e:	str.w	r1, [r0, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    9b22:	str	r1, [r0, #4]
    9b24:	str.w	r1, [r0, #532]	; 0x214
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    9b28:	mov	r5, r2
    9b2a:	mov	r0, r7
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    9b2c:	strb.w	r3, [r4, #1092]	; 0x444
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    9b30:	strb	r3, [r4, #0]
    9b32:	strb.w	r3, [r4, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    9b36:	str	r6, [r4, #12]
    9b38:	str.w	r6, [r4, #540]	; 0x21c
    9b3c:	mov	r2, r3
    9b3e:	mov	r1, r3
    9b40:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    9b44:	cmp	r5, #4
    9b46:	bhi.n	9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
    9b48:	mov	r6, r0
    9b4a:	cbz	r0, 9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    9b4c:	cbnz	r5, 9b66 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    9b4e:	movs	r2, #5
    9b50:	ldr	r1, [pc, #152]	; (9bec <ExFatPartition::init(SdSpiCard*, unsigned char)+0xdc>)
    9b52:	adds	r0, r6, #3
    9b54:	bl	10e1c <strncmp>
    9b58:	cbnz	r0, 9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    9b5a:	ldrb.w	r3, [r6, #108]	; 0x6c
    9b5e:	cmp	r3, #9
    9b60:	beq.n	9b96 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x86>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    9b62:	movs	r0, #0
    9b64:	pop	{r3, r4, r5, r6, r7, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    9b66:	subs	r3, r5, #1
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    9b68:	add.w	r3, r0, r3, lsl #4
    9b6c:	ldrb.w	r2, [r3, #446]	; 0x1be
    9b70:	ands.w	r2, r2, #127	; 0x7f
    9b74:	bne.n	9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
    9b76:	ldrb.w	r3, [r3, #450]	; 0x1c2
    9b7a:	cmp	r3, #0
    9b7c:	beq.n	9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    9b7e:	add.w	r5, r0, r5, lsl #4
    9b82:	mov	r0, r7
    9b84:	ldr.w	r5, [r5, #438]	; 0x1b6
    9b88:	mov	r1, r5
    9b8a:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
    9b8e:	mov	r6, r0
    9b90:	cmp	r0, #0
    9b92:	bne.n	9b4e <ExFatPartition::init(SdSpiCard*, unsigned char)+0x3e>
    9b94:	b.n	9b62 <ExFatPartition::init(SdSpiCard*, unsigned char)+0x52>
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    9b96:	ldr	r3, [r6, #80]	; 0x50
    9b98:	add	r3, r5
    9b9a:	str.w	r3, [r4, #1060]	; 0x424
    9b9e:	ldr	r3, [r6, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    9ba0:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    9ba4:	ldr	r3, [r6, #88]	; 0x58
    9ba6:	add	r5, r3
    9ba8:	str.w	r5, [r4, #1068]	; 0x42c
    9bac:	ldr	r3, [r6, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    9bae:	str.w	r3, [r4, #1072]	; 0x430
    9bb2:	ldr	r3, [r6, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    9bb4:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    9bb8:	ldrb.w	r3, [r6, #109]	; 0x6d
    9bbc:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    9bc0:	movs	r5, #1
    9bc2:	adds	r3, #9
    9bc4:	lsl.w	r3, r5, r3
  m_clusterMask = m_bytesPerCluster - 1;
    9bc8:	subs	r2, r3, #1
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    9bca:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    9bce:	mov	r1, r0
  m_fatLength = getLe32(bpb->fatLength);
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
  m_clusterCount = getLe32(bpb->clusterCount);
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    9bd0:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    9bd4:	str.w	r2, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
  bitmapFind(0, 1);
    9bd8:	mov	r0, r4
    9bda:	mov	r2, r5
    9bdc:	bl	97c4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    9be0:	movs	r3, #64	; 0x40
    9be2:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    9be6:	mov	r0, r5

 fail:
  return false;
}
    9be8:	pop	{r3, r4, r5, r6, r7, pc}
    9bea:	nop
    9bec:	.word	0x00014728

00009bf0 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    9bf0:	push	{r4, lr}
    9bf2:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    9bf4:	ldr.w	r1, [r0, #1076]	; 0x434
    9bf8:	bl	9920 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    9bfc:	ldrb.w	r3, [r4, #1093]	; 0x445
    9c00:	adds	r3, #9
    9c02:	uxtb	r3, r3
}
    9c04:	lsls	r0, r3
    9c06:	pop	{r4, pc}

00009c08 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>:
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    9c08:	cbz	r3, 9c5c <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x54>
  }
  return true;
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
    9c0a:	push	{r4, r5, r6}
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    9c0c:	ldrh	r4, [r0, #2]
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    9c0e:	cmp	r4, #126	; 0x7e
    9c10:	bhi.n	9c50 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
    9c12:	add	r3, r2
    9c14:	adds	r5, r1, r3
    9c16:	add	r2, r1
    9c18:	adds	r0, #2
    9c1a:	ldrb.w	r3, [r2], #1
    9c1e:	uxtb	r4, r4
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    9c20:	sub.w	r1, r3, #97	; 0x61
    9c24:	cmp	r1, #25
    9c26:	sub.w	r1, r4, #97	; 0x61
    9c2a:	ite	ls
    9c2c:	movls	r6, #32
    9c2e:	movhi	r6, #0
    9c30:	cmp	r1, #25
    9c32:	ite	ls
    9c34:	movls	r1, #32
    9c36:	movhi	r1, #0
    9c38:	subs	r3, r3, r6
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    9c3a:	subs	r4, r4, r1
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    9c3c:	uxtb	r3, r3
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    9c3e:	uxtb	r4, r4
    9c40:	cmp	r4, r3
    9c42:	bne.n	9c50 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    9c44:	cmp	r2, r5
    9c46:	beq.n	9c56 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x4e>
    9c48:	ldrh.w	r4, [r0, #2]!
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    9c4c:	cmp	r4, #126	; 0x7e
    9c4e:	bls.n	9c1a <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x12>
      return false;
    9c50:	movs	r0, #0
    }
  }
  return true;
}
    9c52:	pop	{r4, r5, r6}
    9c54:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    9c56:	movs	r0, #1
}
    9c58:	pop	{r4, r5, r6}
    9c5a:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    9c5c:	movs	r0, #1
}
    9c5e:	bx	lr

00009c60 <exFatHashName(char const*, unsigned int, unsigned short)>:
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    9c60:	cbz	r1, 9c94 <exFatHashName(char const*, unsigned int, unsigned short)+0x34>
    hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
    9c62:	push	{r4}
    9c64:	add	r1, r0
    9c66:	lsls	r3, r2, #15
    9c68:	orr.w	r3, r3, r2, lsr #1
  for (size_t i = 0; i < n; i++) {
    uint8_t c = name[i];
    9c6c:	ldrb.w	r2, [r0], #1
    if ('a' <= c && c <= 'z') {
    9c70:	sub.w	r4, r2, #97	; 0x61
    9c74:	cmp	r4, #25
      c -= 'a' - 'A';
    9c76:	itt	ls
    9c78:	subls	r2, #32
    9c7a:	uxtbls	r2, r2
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    9c7c:	uxtah	r2, r2, r3
    9c80:	uxth	r2, r2
    9c82:	lsls	r3, r2, #15
    9c84:	orr.w	r2, r3, r2, lsr #1
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    9c88:	cmp	r1, r0
    9c8a:	uxth	r2, r2
    9c8c:	bne.n	9c66 <exFatHashName(char const*, unsigned int, unsigned short)+0x6>
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    hash = ((hash << 15) | (hash >> 1));
  }
  return hash;
}
    9c8e:	mov	r0, r2
    9c90:	pop	{r4}
    9c92:	bx	lr
    9c94:	mov	r0, r2
    9c96:	bx	lr

00009c98 <ExFatFile::addCluster()>:
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    9c98:	ldr	r1, [r0, #24]
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    9c9a:	push	{r3, r4, r5, r6, r7, lr}
    9c9c:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    9c9e:	ldr	r0, [r0, #32]
    9ca0:	cbz	r1, 9ca4 <ExFatFile::addCluster()+0xc>
    9ca2:	adds	r1, #1
    9ca4:	movs	r2, #1
    9ca6:	bl	97c4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    9caa:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    9cac:	mov	r6, r0
  if (find < 2) {
    9cae:	bls.n	9d10 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    9cb0:	movs	r3, #1
    9cb2:	mov	r1, r0
    9cb4:	mov	r2, r3
    9cb6:	ldr	r0, [r4, #32]
    9cb8:	bl	9878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    9cbc:	mov	r7, r0
    9cbe:	cbz	r0, 9d10 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    9cc0:	ldr	r0, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    9cc2:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    9cc6:	cbz	r0, 9d16 <ExFatFile::addCluster()+0x7e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    goto done;
  }
  if (isContiguous()) {
    9cc8:	lsls	r2, r3, #25
    9cca:	bpl.n	9cf4 <ExFatFile::addCluster()+0x5c>
    if (find == (m_curCluster + 1)) {
    9ccc:	adds	r2, r0, #1
    9cce:	cmp	r6, r2
    9cd0:	beq.n	9d1e <ExFatFile::addCluster()+0x86>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    9cd2:	bic.w	r2, r3, #64	; 0x40
    9cd6:	strb.w	r2, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    9cda:	ldr	r3, [r4, #28]
    9cdc:	b.n	9cea <ExFatFile::addCluster()+0x52>
      if (!m_vol->fatPut(c, c + 1)) {
    9cde:	ldr	r0, [r4, #32]
    9ce0:	bl	99fc <ExFatPartition::fatPut(unsigned long, unsigned long)>
    9ce4:	cbz	r0, 9d10 <ExFatFile::addCluster()+0x78>
    9ce6:	ldr	r0, [r4, #24]
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    9ce8:	mov	r3, r5
      if (!m_vol->fatPut(c, c + 1)) {
    9cea:	adds	r5, r3, #1
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    9cec:	cmp	r3, r0
      if (!m_vol->fatPut(c, c + 1)) {
    9cee:	mov	r1, r3
    9cf0:	mov	r2, r5
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    9cf2:	bcc.n	9cde <ExFatFile::addCluster()+0x46>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    9cf4:	mov.w	r2, #4294967295
    9cf8:	mov	r1, r6
    9cfa:	ldr	r0, [r4, #32]
    9cfc:	bl	99fc <ExFatPartition::fatPut(unsigned long, unsigned long)>
    9d00:	cbz	r0, 9d10 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    9d02:	ldr	r1, [r4, #24]
    9d04:	cbz	r1, 9d1e <ExFatFile::addCluster()+0x86>
    if (!m_vol->fatPut(m_curCluster, find)) {
    9d06:	mov	r2, r6
    9d08:	ldr	r0, [r4, #32]
    9d0a:	bl	99fc <ExFatPartition::fatPut(unsigned long, unsigned long)>
    9d0e:	cbnz	r0, 9d1e <ExFatFile::addCluster()+0x86>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    9d10:	movs	r7, #0
}
    9d12:	mov	r0, r7
    9d14:	pop	{r3, r4, r5, r6, r7, pc}
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    9d16:	orr.w	r3, r3, #64	; 0x40
    9d1a:	strb.w	r3, [r4, #51]	; 0x33
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    9d1e:	str	r6, [r4, #24]
  return true;

 fail:
  return false;
}
    9d20:	mov	r0, r7
    9d22:	pop	{r3, r4, r5, r6, r7, pc}

00009d24 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    9d24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirPos_t pos = m_dirPos;
    9d28:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    9d2c:	mov	r5, r0
  DirPos_t pos = m_dirPos;
    9d2e:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    9d32:	sub	sp, #20
    9d34:	ldrb.w	r3, [r5, #51]	; 0x33
  DirPos_t pos = m_dirPos;
    9d38:	add	r6, sp, #4
    9d3a:	stmia.w	r6, {r0, r1, r2}
  uint8_t* cache;
  if (!isWritable()) {
    9d3e:	lsls	r2, r3, #30
    9d40:	bpl.n	9d7a <ExFatFile::remove()+0x56>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    9d42:	ldr	r1, [r5, #28]
    9d44:	cbnz	r1, 9d82 <ExFatFile::remove()+0x5e>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    9d46:	movs	r4, #0
  for (uint8_t i = 0; i <= m_setCount; i++) {
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    9d48:	movs	r2, #1
    9d4a:	mov	r1, r6
    9d4c:	ldr	r0, [r5, #32]
    9d4e:	bl	995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    9d52:	adds	r4, #1
    9d54:	uxtb	r4, r4
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    9d56:	cbz	r0, 9d7a <ExFatFile::remove()+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    9d58:	ldrb	r3, [r0, #0]
    9d5a:	and.w	r3, r3, #127	; 0x7f
    9d5e:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    9d60:	ldrb.w	r3, [r5, #48]	; 0x30
    9d64:	cmp	r3, r4
    9d66:	bcc.n	9dcc <ExFatFile::remove()+0xa8>
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
    9d68:	cmp	r4, #0
    9d6a:	beq.n	9d48 <ExFatFile::remove()+0x24>
    9d6c:	movs	r2, #32
    9d6e:	mov	r1, r6
    9d70:	ldr	r0, [r5, #32]
    9d72:	bl	9990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    9d76:	cmp	r0, #1
    9d78:	beq.n	9d48 <ExFatFile::remove()+0x24>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    9d7a:	movs	r0, #0
}
    9d7c:	add	sp, #20
    9d7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    9d82:	lsls	r3, r3, #25
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    9d84:	ldr	r0, [r5, #32]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    9d86:	bpl.n	9dc2 <ExFatFile::remove()+0x9e>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    9d88:	ldrd	r2, r3, [r5, #8]
    9d8c:	ldrb.w	r4, [r0, #1093]	; 0x445
    9d90:	adds	r4, #9
    9d92:	uxtb	r4, r4
    9d94:	adds.w	r8, r2, #4294967295
    9d98:	adc.w	r9, r3, #4294967295
    9d9c:	rsb	r7, r4, #32
    9da0:	lsl.w	r7, r9, r7
    9da4:	lsr.w	r2, r8, r4
    9da8:	sub.w	r3, r4, #32
    9dac:	lsr.w	r3, r9, r3
    9db0:	orrs	r2, r7
    9db2:	orrs	r2, r3
    9db4:	adds	r2, #1
    9db6:	movs	r3, #0
    9db8:	bl	9878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    9dbc:	cmp	r0, #0
    9dbe:	bne.n	9d46 <ExFatFile::remove()+0x22>
    9dc0:	b.n	9d7a <ExFatFile::remove()+0x56>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    9dc2:	bl	9a1c <ExFatPartition::freeChain(unsigned long)>
    9dc6:	cmp	r0, #0
    9dc8:	bne.n	9d46 <ExFatFile::remove()+0x22>
    9dca:	b.n	9d7a <ExFatFile::remove()+0x56>
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  return m_vol->cacheSync();
    9dcc:	ldr	r4, [r5, #32]
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    9dce:	movs	r3, #0
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9dd0:	mov	r0, r4
    9dd2:	strb.w	r3, [r5, #49]	; 0x31
  m_flags = 0;
    9dd6:	strb.w	r3, [r5, #51]	; 0x33
    9dda:	bl	8da0 <FsCache::sync()>
    9dde:	cmp	r0, #0
    9de0:	beq.n	9d7a <ExFatFile::remove()+0x56>
    9de2:	add.w	r0, r4, #528	; 0x210
    9de6:	bl	8da0 <FsCache::sync()>
    9dea:	cmp	r0, #0
    9dec:	beq.n	9d7a <ExFatFile::remove()+0x56>
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9dee:	ldr.w	r0, [r4, #1088]	; 0x440
    9df2:	bl	c4f8 <SdSpiCard::syncDevice()>
    9df6:	b.n	9d7c <ExFatFile::remove()+0x58>

00009df8 <ExFatFile::rmdir()>:
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    9df8:	ldrb.w	r3, [r0, #49]	; 0x31
    9dfc:	lsls	r1, r3, #27
    9dfe:	bmi.n	9e04 <ExFatFile::rmdir()+0xc>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    9e00:	movs	r0, #0
}
    9e02:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    9e04:	push	{r4, lr}
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    9e06:	movs	r2, #0
    9e08:	sub	sp, #32
    9e0a:	movs	r3, #0
    9e0c:	mov	r4, r0
    9e0e:	bl	9138 <ExFatFile::seekSet(unsigned long long)>
    9e12:	b.n	9e22 <ExFatFile::rmdir()+0x2a>
  while (1) {
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    9e14:	cmp	r0, #32
    9e16:	bne.n	9e4c <ExFatFile::rmdir()+0x54>
    9e18:	ldrb.w	r3, [sp]
    9e1c:	lsls	r2, r3, #24
    9e1e:	bmi.n	9e4c <ExFatFile::rmdir()+0x54>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    9e20:	cbz	r3, 9e30 <ExFatFile::rmdir()+0x38>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    9e22:	movs	r2, #32
    9e24:	mov	r1, sp
    9e26:	mov	r0, r4
    9e28:	bl	8f60 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    9e2c:	cmp	r0, #0
    9e2e:	bne.n	9e14 <ExFatFile::rmdir()+0x1c>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    9e30:	ldrb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    9e34:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    9e36:	orr.w	r3, r3, #2
    9e3a:	strb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    9e3e:	strb.w	r2, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    9e42:	mov	r0, r4
    9e44:	bl	9d24 <ExFatFile::remove()>

 fail:
  return false;
}
    9e48:	add	sp, #32
    9e4a:	pop	{r4, pc}
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    9e4c:	movs	r0, #0
}
    9e4e:	add	sp, #32
    9e50:	pop	{r4, pc}
    9e52:	nop

00009e54 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9e54:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    9e58:	add.w	fp, r0, #36	; 0x24
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9e5c:	mov	r6, r0
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    9e5e:	ldmia.w	fp, {r0, r1, r2}
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9e62:	sub	sp, #28
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    9e64:	add.w	r8, sp, #12
    9e68:	stmia.w	r8, {r0, r1, r2}
    9e6c:	movs	r7, #0
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;
    9e6e:	mov	sl, r7
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    9e70:	mov	r4, r7
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    9e72:	movs	r2, #0
    9e74:	mov	r1, r8
    9e76:	ldr	r0, [r6, #32]
    9e78:	bl	995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    9e7c:	uxtb.w	r9, r7
    if (!cache) {
    9e80:	mov	r5, r0
    9e82:	cbz	r0, 9e92 <ExFatFile::syncDir()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    9e84:	ldrb	r3, [r0, #0]
    9e86:	cmp	r3, #192	; 0xc0
    9e88:	beq.n	9f2e <ExFatFile::syncDir()+0xda>
    9e8a:	cmp	r3, #193	; 0xc1
    9e8c:	beq.n	9f2a <ExFatFile::syncDir()+0xd6>
    9e8e:	cmp	r3, #133	; 0x85
    9e90:	beq.n	9ea6 <ExFatFile::syncDir()+0x52>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    9e92:	ldrb.w	r3, [r6, #50]	; 0x32
    9e96:	orr.w	r3, r3, #1
    9e9a:	strb.w	r3, [r6, #50]	; 0x32
  return false;
    9e9e:	movs	r0, #0
}
    9ea0:	add	sp, #28
    9ea2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    9ea6:	ldr	r3, [pc, #232]	; (9f90 <ExFatFile::syncDir()+0x13c>)
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    9ea8:	ldrb.w	r2, [r6, #49]	; 0x31
    9eac:	ldr	r3, [r3, #0]
      goto fail;
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
    9eae:	ldrb.w	sl, [r0, #1]
    9eb2:	and.w	r2, r2, #55	; 0x37
    9eb6:	strh	r2, [r0, #4]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    9eb8:	cbz	r3, 9edc <ExFatFile::syncDir()+0x88>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    9eba:	add.w	r2, sp, #7
    9ebe:	add.w	r1, sp, #10
    9ec2:	add	r0, sp, #8
    9ec4:	blx	r3
          df->modifyTimeMs = ms10;
          setLe16(df->modifyTime, time);
    9ec6:	ldrh.w	r2, [sp, #10]
          setLe16(df->modifyDate, date);
    9eca:	ldrh.w	r3, [sp, #8]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    9ece:	ldrb.w	r1, [sp, #7]
    9ed2:	strb	r1, [r5, #21]
    9ed4:	strh	r2, [r5, #12]
    9ed6:	strh	r2, [r5, #16]
    9ed8:	strh	r3, [r5, #14]
    9eda:	strh	r3, [r5, #18]
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
        m_vol->dataCacheDirty();
    9edc:	ldr	r2, [r6, #32]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    9ede:	ldrb.w	r3, [r2, #528]	; 0x210
    9ee2:	orr.w	r3, r3, #1
    9ee6:	strb.w	r3, [r2, #528]	; 0x210
    9eea:	ldrb	r0, [r5, #0]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    9eec:	movs	r1, #0
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    9eee:	ldrb	r2, [r5, r1]
    9ef0:	lsls	r3, r4, #15
    9ef2:	orr.w	r4, r3, r4, lsr #1
    9ef6:	uxtah	r4, r2, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    9efa:	cmp	r1, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    9efc:	uxth	r4, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    9efe:	add.w	r1, r1, #1
    9f02:	beq.n	9f20 <ExFatFile::syncDir()+0xcc>
    9f04:	cmp	r1, #31
    9f06:	bls.n	9eee <ExFatFile::syncDir()+0x9a>
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    if (i == setCount) break;
    9f08:	cmp	sl, r9
    9f0a:	beq.n	9f5a <ExFatFile::syncDir()+0x106>
    if (m_vol->dirSeek(&pos, 32) != 1) {
    9f0c:	movs	r2, #32
    9f0e:	mov	r1, r8
    9f10:	ldr	r0, [r6, #32]
    9f12:	bl	9990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    9f16:	cmp	r0, #1
    9f18:	add.w	r7, r7, #1
    9f1c:	beq.n	9e72 <ExFatFile::syncDir()+0x1e>
    9f1e:	b.n	9e92 <ExFatFile::syncDir()+0x3e>
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    9f20:	cmp	r0, #133	; 0x85
    9f22:	ite	eq
    9f24:	moveq	r1, #4
    9f26:	movne	r1, #2
    9f28:	b.n	9eee <ExFatFile::syncDir()+0x9a>
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    9f2a:	mov	r0, r3
    9f2c:	b.n	9eec <ExFatFile::syncDir()+0x98>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    9f2e:	ldrb.w	r3, [r6, #51]	; 0x33
    9f32:	tst.w	r3, #64	; 0x40
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    9f36:	ldrb	r3, [r0, #1]
    9f38:	ite	ne
    9f3a:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    9f3e:	biceq.w	r3, r3, #2
    9f42:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    9f44:	ldrd	r2, r3, [r6, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    9f48:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
    9f4c:	ldrd	r2, r3, [r6, #8]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
    9f50:	ldr	r1, [r6, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    9f52:	str	r1, [r0, #20]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    9f54:	strd	r2, r3, [r0, #24]
    9f58:	b.n	9edc <ExFatFile::syncDir()+0x88>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    9f5a:	mov	r1, fp
    9f5c:	movs	r2, #1
    9f5e:	ldr	r0, [r6, #32]
    9f60:	bl	995c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    9f64:	cmp	r0, #0
    9f66:	beq.n	9e92 <ExFatFile::syncDir()+0x3e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    9f68:	ldr	r5, [r6, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    9f6a:	strh	r4, [r0, #2]
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9f6c:	mov	r0, r5
    9f6e:	bl	8da0 <FsCache::sync()>
    9f72:	cmp	r0, #0
    9f74:	beq.n	9e92 <ExFatFile::syncDir()+0x3e>
    9f76:	add.w	r0, r5, #528	; 0x210
    9f7a:	bl	8da0 <FsCache::sync()>
    9f7e:	cmp	r0, #0
    9f80:	beq.n	9e92 <ExFatFile::syncDir()+0x3e>
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9f82:	ldr.w	r0, [r5, #1088]	; 0x440
    9f86:	bl	c4f8 <SdSpiCard::syncDevice()>
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9f8a:	cmp	r0, #0
    9f8c:	beq.n	9e92 <ExFatFile::syncDir()+0x3e>
    9f8e:	b.n	9ea0 <ExFatFile::syncDir()+0x4c>
    9f90:	.word	0x20002bd8

00009f94 <ExFatFile::sync()>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    9f94:	ldrb.w	r2, [r0, #49]	; 0x31
    9f98:	cbz	r2, 9fc0 <ExFatFile::sync()+0x2c>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    9f9a:	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    9f9c:	ldrb.w	r2, [r0, #51]	; 0x33
    9fa0:	lsls	r1, r2, #24
    9fa2:	bmi.n	9fc4 <ExFatFile::sync()+0x30>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
  }
  if (!m_vol->cacheSync()) {
    9fa4:	ldr	r5, [r0, #32]
    9fa6:	mov	r4, r0
    9fa8:	mov	r0, r5
    9faa:	bl	8da0 <FsCache::sync()>
    9fae:	cbnz	r0, 9fd4 <ExFatFile::sync()+0x40>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    9fb0:	ldrb.w	r3, [r4, #50]	; 0x32
    9fb4:	orr.w	r3, r3, #1
    9fb8:	strb.w	r3, [r4, #50]	; 0x32
  return false;
    9fbc:	movs	r0, #0
}
    9fbe:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    9fc0:	movs	r0, #1
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    9fc2:	bx	lr
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    9fc4:	and.w	r2, r2, #127	; 0x7f
    9fc8:	strb.w	r2, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    9fcc:	ldmia.w	sp!, {r3, r4, r5, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    9fd0:	b.w	9e54 <ExFatFile::syncDir()>
    9fd4:	add.w	r0, r5, #528	; 0x210
    9fd8:	bl	8da0 <FsCache::sync()>
    9fdc:	cmp	r0, #0
    9fde:	beq.n	9fb0 <ExFatFile::sync()+0x1c>
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9fe0:	ldr.w	r0, [r5, #1088]	; 0x440
    9fe4:	bl	c4f8 <SdSpiCard::syncDevice()>
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9fe8:	cmp	r0, #0
    9fea:	beq.n	9fb0 <ExFatFile::sync()+0x1c>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    9fec:	movs	r0, #1
    9fee:	pop	{r3, r4, r5, pc}

00009ff0 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    9ff0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    9ff4:	ldrb.w	r3, [r0, #49]	; 0x31
    9ff8:	lsls	r1, r3, #25

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    9ffa:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    9ffc:	bmi.n	a092 <ExFatFile::addDirCluster()+0xa2>
    9ffe:	ldr	r0, [r0, #8]
    a000:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    a002:	ldr.w	r3, [r3, #1084]	; 0x43c
    a006:	add	r0, r3
    a008:	cmp.w	r0, #67108864	; 0x4000000
    a00c:	bcc.n	a014 <ExFatFile::addDirCluster()+0x24>
  }
  return sync();

 fail:
  return false;
}
    a00e:	movs	r0, #0
    a010:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    a014:	mov	r0, r4
    a016:	bl	9c98 <ExFatFile::addCluster()>
    a01a:	cmp	r0, #0
    a01c:	beq.n	a00e <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    a01e:	ldr	r6, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    a020:	ldrb.w	r3, [r6, #528]	; 0x210
    a024:	lsls	r2, r3, #31
    a026:	bmi.n	a0d8 <ExFatFile::addDirCluster()+0xe8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    a028:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a02c:	movs	r5, #0
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    a02e:	add.w	r8, r6, #544	; 0x220
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    a032:	str.w	r3, [r6, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a036:	strb.w	r5, [r6, #528]	; 0x210
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    a03a:	mov	r1, r5
    a03c:	mov.w	r2, #512	; 0x200
    a040:	mov	r0, r8
    a042:	bl	106dc <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    a046:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    a048:	ldr	r3, [r4, #24]
    a04a:	ldrb.w	r0, [r2, #1093]	; 0x445
    a04e:	ldr.w	r1, [r2, #1068]	; 0x42c
    a052:	subs	r3, #2
    a054:	lsls	r3, r0
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    a056:	movs	r6, #1
    a058:	adds	r7, r3, r1
    a05a:	lsls.w	r3, r6, r0
    a05e:	bne.n	a07e <ExFatFile::addDirCluster()+0x8e>
    a060:	b.n	a09a <ExFatFile::addDirCluster()+0xaa>
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    a062:	movs	r3, #1
    a064:	mov	r2, r8
    a066:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
    a06a:	adds	r5, #1
    if (!m_vol->writeSector(sector + i, cache)) {
    a06c:	cmp	r0, #0
    a06e:	beq.n	a00e <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    a070:	ldr	r2, [r4, #32]
    a072:	ldrb.w	r3, [r2, #1093]	; 0x445
    a076:	lsl.w	r3, r6, r3
    a07a:	cmp	r3, r5
    a07c:	bls.n	a09a <ExFatFile::addDirCluster()+0xaa>
    a07e:	ldr.w	r0, [r2, #1088]	; 0x440
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    a082:	ldrb	r3, [r0, #13]
    if (!m_vol->writeSector(sector + i, cache)) {
    a084:	adds	r1, r7, r5
    a086:	cmp	r3, #0
    a088:	beq.n	a062 <ExFatFile::addDirCluster()+0x72>
      return writeSingle(sector, src);
    a08a:	mov	r2, r8
    a08c:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    a090:	b.n	a06a <ExFatFile::addDirCluster()+0x7a>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    a092:	ldr	r0, [r0, #32]
    a094:	bl	9bf0 <ExFatPartition::rootLength()>
    a098:	b.n	a000 <ExFatFile::addDirCluster()+0x10>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    a09a:	ldrb.w	r3, [r4, #49]	; 0x31
    a09e:	lsls	r3, r3, #25
    a0a0:	bmi.n	a0ce <ExFatFile::addDirCluster()+0xde>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a0a2:	ldrb.w	r3, [r4, #51]	; 0x33
    a0a6:	orn	r3, r3, #127	; 0x7f
    a0aa:	strb.w	r3, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    a0ae:	ldr.w	r6, [r2, #1084]	; 0x43c
    a0b2:	ldrd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    a0b6:	ldrd	r0, r1, [r4, #16]
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    a0ba:	adds	r2, r2, r6
    a0bc:	mov.w	r7, #0
    a0c0:	adcs	r3, r7
    m_validLength += m_vol->bytesPerCluster();
    a0c2:	adds	r0, r0, r6
    a0c4:	adcs	r1, r7
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    a0c6:	strd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    a0ca:	strd	r0, r1, [r4, #16]
  }
  return sync();
    a0ce:	mov	r0, r4

 fail:
  return false;
}
    a0d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    a0d4:	b.w	9f94 <ExFatFile::sync()>
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    a0d8:	add.w	r0, r6, #528	; 0x210
    a0dc:	bl	8da0 <FsCache::sync()>
    a0e0:	cmp	r0, #0
    a0e2:	bne.n	a028 <ExFatFile::addDirCluster()+0x38>
    a0e4:	b.n	a00e <ExFatFile::addDirCluster()+0x1e>
    a0e6:	nop

0000a0e8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
  if (!parent->isDir()) {
    a0e8:	ldrb.w	r3, [r1, #49]	; 0x31
    a0ec:	tst.w	r3, #80	; 0x50
    a0f0:	bne.n	a0f6 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0xe>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    a0f2:	movs	r0, #0
    a0f4:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    a0f6:	push	{r4, r5, lr}
    a0f8:	sub	sp, #12
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    a0fa:	movw	r5, #2562	; 0xa02
    a0fe:	ldrb	r3, [r2, #0]
    a100:	ldr	r2, [r2, #4]
    a102:	str	r5, [sp, #0]
    a104:	mov	r4, r0
    a106:	bl	9238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    a10a:	cbnz	r0, a112 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x2a>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    a10c:	movs	r0, #0
    a10e:	add	sp, #12
    a110:	pop	{r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory

  m_attributes = FILE_ATTR_SUBDIR;
    a112:	movs	r3, #16
    a114:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    a118:	mov	r0, r4
    a11a:	bl	9ff0 <ExFatFile::addDirCluster()>
    a11e:	cmp	r0, #0
    a120:	beq.n	a10c <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    a122:	ldr	r3, [r4, #24]
    a124:	str	r3, [r4, #28]
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    a126:	movs	r2, #0
    a128:	movs	r3, #0
    a12a:	mov	r0, r4
    a12c:	bl	9138 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    a130:	movs	r3, #193	; 0xc1
  return sync();
    a132:	mov	r0, r4
  }
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    a134:	strb.w	r3, [r4, #51]	; 0x33
  return sync();

 fail:
  return false;
}
    a138:	add	sp, #12
    a13a:	ldmia.w	sp!, {r4, r5, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    a13e:	b.w	9f94 <ExFatFile::sync()>
    a142:	nop

0000a144 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    a144:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a148:	mov	r6, r0
    a14a:	sub	sp, #84	; 0x54
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    a14c:	ldrb.w	r5, [r6, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    a150:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    a152:	movs	r0, #0
    a154:	strb.w	r0, [sp, #73]	; 0x49
    a158:	strb.w	r0, [sp, #74]	; 0x4a
    a15c:	strb.w	r0, [sp, #75]	; 0x4b
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    a160:	cbnz	r5, a170 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    a162:	mov	r9, r3
    a164:	ldrb.w	r3, [r1, #49]	; 0x31
    a168:	tst.w	r3, #80	; 0x50
    a16c:	mov	r4, r1
    a16e:	bne.n	a178 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x34>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    a170:	movs	r0, #0
}
    a172:	add	sp, #84	; 0x54
    a174:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    a178:	ldrb	r3, [r2, #0]
    a17a:	cmp	r3, #47	; 0x2f
    a17c:	mov	r1, r2
    a17e:	beq.n	a1ee <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    a180:	mov.w	r8, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    a184:	add	r3, sp, #12
    a186:	add	r2, sp, #16
    a188:	mov	r0, r6
    a18a:	bl	8e9c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    a18e:	cmp	r0, #0
    a190:	beq.n	a170 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    a192:	ldr	r3, [sp, #12]
    a194:	ldrb	r3, [r3, #0]
    a196:	cmp	r3, #0
    a198:	beq.n	a20a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xc6>
    a19a:	ldrb.w	r3, [sp, #16]
    a19e:	ldr	r2, [sp, #20]
    a1a0:	str.w	r8, [sp]
    a1a4:	mov	r1, r4
    a1a6:	mov	r0, r6
    a1a8:	bl	9238 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    a1ac:	cbnz	r0, a1c2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
      if (!pFlag || !mkdir(parent, &fname)) {
    a1ae:	cmp.w	r9, #0
    a1b2:	beq.n	a170 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    a1b4:	mov	r1, r4
    a1b6:	add	r2, sp, #16
    a1b8:	mov	r0, r6
    a1ba:	bl	a0e8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    a1be:	cmp	r0, #0
    a1c0:	beq.n	a170 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    a1c2:	mov	r4, r6
    a1c4:	add	r7, sp, #24
    a1c6:	add.w	lr, r6, #48	; 0x30
    a1ca:	ldr	r0, [r4, #0]
    a1cc:	ldr	r1, [r4, #4]
    a1ce:	ldr	r2, [r4, #8]
    a1d0:	ldr	r3, [r4, #12]
    a1d2:	mov	r5, r7
    a1d4:	stmia	r5!, {r0, r1, r2, r3}
    a1d6:	adds	r4, #16
    a1d8:	cmp	r4, lr
    a1da:	mov	r7, r5
    a1dc:	bne.n	a1ca <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x86>
    a1de:	ldr	r0, [r4, #0]
    a1e0:	str	r0, [r5, #0]
    parent = &tmpDir;
    close();
    a1e2:	mov	r0, r6
    a1e4:	bl	8db0 <ExFatFile::close()>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    a1e8:	add	r4, sp, #24
    a1ea:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    a1ec:	b.n	a184 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    a1ee:	adds	r1, #1
    a1f0:	str	r1, [sp, #12]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    a1f2:	ldrb	r3, [r1, #0]
    a1f4:	cmp	r3, #47	; 0x2f
    a1f6:	beq.n	a1ee <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    a1f8:	ldr	r1, [r4, #32]
    a1fa:	add	r0, sp, #24
    a1fc:	bl	8e74 <ExFatFile::openRoot(ExFatVolume*)>
    a200:	cmp	r0, #0
    a202:	beq.n	a170 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    a204:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    a206:	add	r4, sp, #24
    a208:	b.n	a180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x3c>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    a20a:	add	r2, sp, #16
    a20c:	mov	r1, r4
    a20e:	mov	r0, r6
    a210:	bl	a0e8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>

 fail:
  return false;
}
    a214:	add	sp, #84	; 0x54
    a216:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a21a:	nop

0000a21c <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    a21c:	push	{r4, r5, r6, r7, lr}
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    a21e:	ldrb.w	r4, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    a222:	sub	sp, #116	; 0x74
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    a224:	movs	r3, #0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    a226:	tst.w	r4, #24
    a22a:	strb.w	r3, [sp, #49]	; 0x31
    a22e:	strb.w	r3, [sp, #50]	; 0x32
    a232:	strb.w	r3, [sp, #51]	; 0x33
    a236:	strb.w	r3, [sp, #105]	; 0x69
    a23a:	strb.w	r3, [sp, #106]	; 0x6a
    a23e:	strb.w	r3, [sp, #107]	; 0x6b
    a242:	beq.n	a24c <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    a244:	ldr	r3, [r1, #32]
    a246:	ldr	r4, [r0, #32]
    a248:	cmp	r4, r3
    a24a:	beq.n	a252 <ExFatFile::rename(ExFatFile*, char const*)+0x36>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    a24c:	movs	r0, #0
}
    a24e:	add	sp, #116	; 0x74
    a250:	pop	{r4, r5, r6, r7, pc}
    a252:	mov	r4, r0
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    a254:	movw	r3, #2561	; 0xa01
    a258:	mov	r0, sp
    a25a:	bl	9614 <ExFatFile::open(ExFatFile*, char const*, int)>
    a25e:	cmp	r0, #0
    a260:	beq.n	a24c <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    a262:	add	r7, sp, #56	; 0x38
    a264:	mov	r5, r4
    a266:	add.w	lr, r4, #48	; 0x30
    a26a:	ldr	r0, [r5, #0]
    a26c:	ldr	r1, [r5, #4]
    a26e:	ldr	r2, [r5, #8]
    a270:	ldr	r3, [r5, #12]
    a272:	mov	r6, r7
    a274:	stmia	r6!, {r0, r1, r2, r3}
    a276:	adds	r5, #16
    a278:	cmp	r5, lr
    a27a:	mov	r7, r6
    a27c:	bne.n	a26a <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    a27e:	ldr	r0, [r5, #0]
    a280:	str	r0, [r6, #0]
  m_dirPos = file.m_dirPos;
    a282:	add	r3, sp, #36	; 0x24
    a284:	ldmia.w	r3, {r0, r1, r2}
    a288:	add.w	r3, r4, #36	; 0x24
    a28c:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a290:	ldrb.w	r3, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
    a294:	ldrb.w	r2, [sp, #48]	; 0x30
    a298:	strb.w	r2, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a29c:	orn	r3, r3, #127	; 0x7f
    a2a0:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    a2a4:	mov	r0, r4
    a2a6:	bl	9f94 <ExFatFile::sync()>
    a2aa:	cmp	r0, #0
    a2ac:	beq.n	a24c <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    a2ae:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    a2b0:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    a2b2:	movs	r3, #8
  return oldFile.remove();
    a2b4:	add	r0, sp, #56	; 0x38
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    a2b6:	str	r1, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    a2b8:	strb.w	r2, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
    a2bc:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    a2c0:	bl	9d24 <ExFatFile::remove()>
    a2c4:	b.n	a24e <ExFatFile::rename(ExFatFile*, char const*)+0x32>
    a2c6:	nop

0000a2c8 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    a2c8:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    a2cc:	lsls	r2, r3, #30
    a2ce:	bpl.n	a302 <ExFatFile::truncate()+0x3a>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    a2d0:	push	{r4, r5, r6, r7, lr}
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    a2d2:	ldr	r5, [r0, #28]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    a2d4:	sub	sp, #12
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    a2d6:	cbz	r5, a2fc <ExFatFile::truncate()+0x34>
      return true;
  }
  if (isContiguous()) {
    a2d8:	and.w	r3, r3, #64	; 0x40
    a2dc:	mov	r4, r0
    a2de:	and.w	r0, r3, #255	; 0xff
    a2e2:	cbnz	r3, a306 <ExFatFile::truncate()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    a2e4:	ldr	r1, [r4, #24]
    a2e6:	cmp	r1, #0
    a2e8:	bne.n	a36e <ExFatFile::truncate()+0xa6>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    a2ea:	str	r5, [sp, #4]
      m_firstCluster = 0;
    a2ec:	str	r1, [r4, #28]
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
    a2ee:	mov	r1, r5
    a2f0:	ldr	r0, [r4, #32]
    a2f2:	bl	9a1c <ExFatPartition::freeChain(unsigned long)>
    a2f6:	cbnz	r0, a346 <ExFatFile::truncate()+0x7e>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    a2f8:	movs	r0, #0
    a2fa:	b.n	a2fe <ExFatFile::truncate()+0x36>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    a2fc:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    a2fe:	add	sp, #12
    a300:	pop	{r4, r5, r6, r7, pc}
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    a302:	movs	r0, #0
}
    a304:	bx	lr
    a306:	ldr	r0, [r4, #32]
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
    a308:	ldr	r1, [r4, #24]
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    a30a:	ldrb.w	r3, [r0, #1093]	; 0x445
    a30e:	ldrd	r6, r7, [r4, #8]
    a312:	adds	r3, #9
    a314:	uxtb	r3, r3
    a316:	adds.w	r6, r6, #4294967295
    a31a:	rsb	lr, r3, #32
    a31e:	adc.w	r7, r7, #4294967295
    a322:	lsr.w	r2, r6, r3
    a326:	lsl.w	lr, r7, lr
    a32a:	subs	r3, #32
    a32c:	orr.w	r2, r2, lr
    a330:	lsr.w	r3, r7, r3
    a334:	orrs	r2, r3
    a336:	adds	r2, #1
    if (m_curCluster) {
    a338:	cbz	r1, a368 <ExFatFile::truncate()+0xa0>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    a33a:	subs	r5, #1
    a33c:	subs	r5, r5, r1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    a33e:	adds	r1, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    a340:	add	r2, r5
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    a342:	str	r1, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    a344:	cbnz	r2, a38a <ExFatFile::truncate()+0xc2>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    a346:	ldrd	r0, r1, [r4]
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a34a:	ldrb.w	r3, [r4, #51]	; 0x33
    a34e:	orn	r3, r3, #127	; 0x7f
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    a352:	strd	r0, r1, [r4, #8]
  m_validLength = m_curPosition;
    a356:	strd	r0, r1, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a35a:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    a35e:	mov	r0, r4
    a360:	bl	9f94 <ExFatFile::sync()>

 fail:
  return false;
}
    a364:	add	sp, #12
    a366:	pop	{r4, r5, r6, r7, pc}
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
    a368:	str	r5, [sp, #4]
      m_firstCluster = 0;
    a36a:	str	r1, [r4, #28]
    a36c:	b.n	a344 <ExFatFile::truncate()+0x7c>
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    a36e:	add	r2, sp, #8
    a370:	str.w	r0, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    a374:	ldr	r0, [r4, #32]
    a376:	bl	99e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    a37a:	sxtb	r0, r0
      if (fg < 0) {
    a37c:	cmp	r0, #0
    a37e:	blt.n	a2f8 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    a380:	bne.n	a398 <ExFatFile::truncate()+0xd0>
      }
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
    a382:	ldr	r5, [sp, #4]
    a384:	cmp	r5, #0
    a386:	beq.n	a346 <ExFatFile::truncate()+0x7e>
    a388:	b.n	a2ee <ExFatFile::truncate()+0x26>
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    a38a:	movs	r3, #0
    a38c:	ldr	r1, [sp, #4]
    a38e:	bl	9878 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    a392:	cmp	r0, #0
    a394:	bne.n	a346 <ExFatFile::truncate()+0x7e>
    a396:	b.n	a2f8 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    a398:	mov.w	r2, #4294967295
    a39c:	ldr	r1, [r4, #24]
    a39e:	ldr	r0, [r4, #32]
    a3a0:	bl	99fc <ExFatPartition::fatPut(unsigned long, unsigned long)>
    a3a4:	cmp	r0, #0
    a3a6:	bne.n	a382 <ExFatFile::truncate()+0xba>
    a3a8:	b.n	a2f8 <ExFatFile::truncate()+0x30>
    a3aa:	nop

0000a3ac <ExFatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    a3ac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a3b0:	ldrb.w	r3, [r0, #51]	; 0x33
    a3b4:	sub	sp, #12

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    a3b6:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    a3b8:	mov	r4, r0
    a3ba:	str	r2, [sp, #0]

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    a3bc:	bmi.n	a3d4 <ExFatFile::write(void const*, unsigned int)+0x28>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    a3be:	ldrb.w	r3, [r4, #50]	; 0x32
    a3c2:	orr.w	r3, r3, #1
    a3c6:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    a3ca:	mov.w	r0, #4294967295
}
    a3ce:	add	sp, #12
    a3d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    a3d4:	lsls	r2, r3, #28
    a3d6:	mov	r9, r1
    a3d8:	bmi.w	a5e8 <ExFatFile::write(void const*, unsigned int)+0x23c>
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    a3dc:	ldr	r3, [sp, #0]
    a3de:	cmp	r3, #0
    a3e0:	beq.w	a610 <ExFatFile::write(void const*, unsigned int)+0x264>
    a3e4:	mov	r1, r4
    a3e6:	ldrd	r2, r3, [r1], #24
    a3ea:	ldr.w	r8, [sp]
    a3ee:	str	r1, [sp, #4]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    a3f0:	mov.w	fp, #1
    a3f4:	mov	sl, r9
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    a3f6:	ldr	r0, [r4, #32]
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    a3f8:	ldr	r1, [r4, #24]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    a3fa:	ldr.w	r5, [r0, #1080]	; 0x438
    a3fe:	ands	r5, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    a400:	ubfx	r9, r5, #0, #9
    if (clusterOffset == 0) {
    a404:	cbnz	r5, a458 <ExFatFile::write(void const*, unsigned int)+0xac>
      // start of new cluster
      if (m_curCluster != 0) {
    a406:	cmp	r1, #0
    a408:	beq.w	a566 <ExFatFile::write(void const*, unsigned int)+0x1ba>
        int fg;

        if (isContiguous()) {
    a40c:	ldrb.w	r3, [r4, #51]	; 0x33
    a410:	lsls	r3, r3, #25
    a412:	bpl.w	a5a6 <ExFatFile::write(void const*, unsigned int)+0x1fa>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    a416:	ldrd	r6, r7, [r4, #8]
    a41a:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    a41e:	ldr	r3, [r4, #28]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    a420:	adds	r2, #9
    a422:	uxtb	r2, r2
    a424:	adds.w	r6, r6, #4294967295
    a428:	adc.w	r7, r7, #4294967295
    a42c:	rsb	lr, r2, #32
    a430:	lsrs	r6, r2
    a432:	lsl.w	lr, r7, lr
    a436:	subs	r2, #32
    a438:	orr.w	r6, r6, lr
    a43c:	lsr.w	r2, r7, r2
    a440:	orrs	r6, r2
    a442:	add	r3, r6
    a444:	cmp	r1, r3
    a446:	bcc.w	a5a0 <ExFatFile::write(void const*, unsigned int)+0x1f4>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    a44a:	mov	r0, r4
    a44c:	bl	9c98 <ExFatFile::addCluster()>
    a450:	cmp	r0, #0
    a452:	beq.n	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
    a454:	ldr	r0, [r4, #32]
    a456:	ldr	r1, [r4, #24]
    a458:	ldrb.w	r7, [r0, #1093]	; 0x445
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    a45c:	ldr.w	r6, [r0, #1068]	; 0x42c
    a460:	lsrs	r5, r5, #9
    a462:	subs	r1, #2
    a464:	lsls	r1, r7
    a466:	add	r6, r5
    a468:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    a46a:	cmp.w	r9, #0
    a46e:	bne.n	a558 <ExFatFile::write(void const*, unsigned int)+0x1ac>
    a470:	cmp.w	r8, #512	; 0x200
    a474:	bcs.n	a514 <ExFatFile::write(void const*, unsigned int)+0x168>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    a476:	ldrd	r2, r3, [r4, #16]
    a47a:	ldrd	r6, r7, [r4]
    a47e:	cmp.w	r8, #512	; 0x200
    a482:	mov	r5, r8
    a484:	it	cs
    a486:	movcs.w	r5, #512	; 0x200
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    a48a:	cmp	r7, r3
    a48c:	it	eq
    a48e:	cmpeq	r6, r2
    a490:	ite	cc
    a492:	movcc	r2, #1
    a494:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    a496:	add.w	r0, r0, #528	; 0x210
    a49a:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    a49e:	cmp	r0, #0
    a4a0:	beq.n	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    a4a2:	add	r0, r9
    a4a4:	mov	r2, r5
    a4a6:	mov	r1, sl
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a4a8:	add	r9, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    a4aa:	bl	cb10 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a4ae:	cmp.w	r9, #512	; 0x200
    a4b2:	beq.w	a5d6 <ExFatFile::write(void const*, unsigned int)+0x22a>
    a4b6:	mov	r0, r5
    a4b8:	movs	r1, #0
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a4ba:	ldrd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    a4be:	ldrd	r6, r7, [r4, #16]
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a4c2:	adds	r2, r2, r0
    a4c4:	adcs	r3, r1
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    a4c6:	cmp	r7, r3
    a4c8:	it	eq
    a4ca:	cmpeq	r6, r2
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    a4cc:	add	sl, r5
    toWrite -= n;
    a4ce:	rsb	r8, r5, r8
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a4d2:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    a4d6:	bcs.n	a4e8 <ExFatFile::write(void const*, unsigned int)+0x13c>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    a4d8:	ldrb.w	r1, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    a4dc:	strd	r2, r3, [r4, #16]
    }
    m_curPosition += n;
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
    a4e0:	orn	r1, r1, #127	; 0x7f
    a4e4:	strb.w	r1, [r4, #51]	; 0x33
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    a4e8:	cmp.w	r8, #0
    a4ec:	bne.n	a3f6 <ExFatFile::write(void const*, unsigned int)+0x4a>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    a4ee:	ldrd	r0, r1, [r4, #8]
    a4f2:	cmp	r1, r3
    a4f4:	it	eq
    a4f6:	cmpeq	r0, r2
    a4f8:	bcc.n	a5f8 <ExFatFile::write(void const*, unsigned int)+0x24c>
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    a4fa:	ldr	r3, [pc, #284]	; (a618 <ExFatFile::write(void const*, unsigned int)+0x26c>)
    a4fc:	ldr	r3, [r3, #0]
    a4fe:	cmp	r3, #0
    a500:	beq.w	a60c <ExFatFile::write(void const*, unsigned int)+0x260>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a504:	ldrb.w	r3, [r4, #51]	; 0x33
    a508:	ldr	r0, [sp, #0]
    a50a:	orn	r3, r3, #127	; 0x7f
    a50e:	strb.w	r3, [r4, #51]	; 0x33
    a512:	b.n	a3ce <ExFatFile::write(void const*, unsigned int)+0x22>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    a514:	cmp.w	r8, #1024	; 0x400
    a518:	bcc.n	a56e <ExFatFile::write(void const*, unsigned int)+0x1c2>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    a51a:	lsl.w	r3, fp, r7
    a51e:	subs	r5, r3, r5
    a520:	ldr.w	r2, [r0, #540]	; 0x21c
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    a524:	mov.w	r3, r8, lsr #9
    a528:	cmp	r3, r5
    a52a:	it	cs
    a52c:	movcs	r3, r5
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    a52e:	cmp	r1, r2
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    a530:	mov.w	r5, r3, lsl #9
    a534:	bhi.n	a548 <ExFatFile::write(void const*, unsigned int)+0x19c>
    a536:	adds	r6, r1, r3
    a538:	cmp	r2, r6
    a53a:	bcs.n	a548 <ExFatFile::write(void const*, unsigned int)+0x19c>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    a53c:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a540:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    a544:	str.w	r2, [r0, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    a548:	ldr.w	r0, [r0, #532]	; 0x214
    a54c:	mov	r2, sl
    a54e:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    a552:	cmp	r0, #0
    a554:	bne.n	a4b6 <ExFatFile::write(void const*, unsigned int)+0x10a>
    a556:	b.n	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    a558:	rsb	r5, r9, #512	; 0x200
    a55c:	cmp	r5, r8
    a55e:	it	cs
    a560:	movcs	r5, r8
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    a562:	movs	r2, #1
    a564:	b.n	a496 <ExFatFile::write(void const*, unsigned int)+0xea>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    a566:	ldr	r1, [r4, #28]
    a568:	cbz	r1, a5b4 <ExFatFile::write(void const*, unsigned int)+0x208>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    a56a:	str	r1, [r4, #24]
    a56c:	b.n	a458 <ExFatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    a56e:	ldr.w	r3, [r0, #540]	; 0x21c
    a572:	cmp	r1, r3
    a574:	beq.n	a5c8 <ExFatFile::write(void const*, unsigned int)+0x21c>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    a576:	ldr.w	r0, [r0, #532]	; 0x214
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    a57a:	ldrb	r3, [r0, #13]
    a57c:	cbnz	r3, a598 <ExFatFile::write(void const*, unsigned int)+0x1ec>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    a57e:	movs	r3, #1
    a580:	mov	r2, sl
    a582:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    a586:	cmp	r0, #0
    a588:	beq.w	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
    a58c:	mov.w	r0, #512	; 0x200
    a590:	movs	r1, #0
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    a592:	mov.w	r5, #512	; 0x200
    a596:	b.n	a4ba <ExFatFile::write(void const*, unsigned int)+0x10e>
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    a598:	mov	r2, sl
    a59a:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    a59e:	b.n	a586 <ExFatFile::write(void const*, unsigned int)+0x1da>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    a5a0:	adds	r1, #1
    a5a2:	str	r1, [r4, #24]
    a5a4:	b.n	a458 <ExFatFile::write(void const*, unsigned int)+0xac>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    a5a6:	ldr	r2, [sp, #4]
    a5a8:	bl	99e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    a5ac:	cmp	r0, #0
    a5ae:	bne.w	a454 <ExFatFile::write(void const*, unsigned int)+0xa8>
    a5b2:	b.n	a44a <ExFatFile::write(void const*, unsigned int)+0x9e>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    a5b4:	mov	r0, r4
    a5b6:	bl	9c98 <ExFatFile::addCluster()>
    a5ba:	cmp	r0, #0
    a5bc:	beq.w	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    a5c0:	ldr	r1, [r4, #24]
    a5c2:	str	r1, [r4, #28]
    a5c4:	ldr	r0, [r4, #32]
    a5c6:	b.n	a458 <ExFatFile::write(void const*, unsigned int)+0xac>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    a5c8:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a5cc:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    a5d0:	str.w	r3, [r0, #540]	; 0x21c
    a5d4:	b.n	a576 <ExFatFile::write(void const*, unsigned int)+0x1ca>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    a5d6:	ldr	r0, [r4, #32]
    a5d8:	add.w	r0, r0, #528	; 0x210
    a5dc:	bl	8da0 <FsCache::sync()>
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->dataCacheSync()) {
    a5e0:	cmp	r0, #0
    a5e2:	bne.w	a4b6 <ExFatFile::write(void const*, unsigned int)+0x10a>
    a5e6:	b.n	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    a5e8:	ldrd	r2, r3, [r0, #16]
    a5ec:	bl	9138 <ExFatFile::seekSet(unsigned long long)>
    a5f0:	cmp	r0, #0
    a5f2:	beq.w	a3be <ExFatFile::write(void const*, unsigned int)+0x12>
    a5f6:	b.n	a3dc <ExFatFile::write(void const*, unsigned int)+0x30>
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a5f8:	ldrb.w	r1, [r4, #51]	; 0x33
    a5fc:	ldr	r0, [sp, #0]
    a5fe:	orn	r1, r1, #127	; 0x7f
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    a602:	strd	r2, r3, [r4, #8]
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a606:	strb.w	r1, [r4, #51]	; 0x33
    a60a:	b.n	a3ce <ExFatFile::write(void const*, unsigned int)+0x22>
    a60c:	ldr	r0, [sp, #0]
    a60e:	b.n	a3ce <ExFatFile::write(void const*, unsigned int)+0x22>
    a610:	ldrd	r2, r3, [r4]
    a614:	b.n	a4ee <ExFatFile::write(void const*, unsigned int)+0x142>
    a616:	nop
    a618:	.word	0x20002bd8

0000a61c <FatFile::openRoot(FatVolume*) [clone .part.37]>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    a61c:	push	{r3, r4, r5, lr}
    a61e:	mov	r4, r0
    a620:	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    a622:	movs	r2, #36	; 0x24
    a624:	movs	r1, #0
    a626:	bl	106dc <memset>

  m_vol = vol;
    a62a:	str	r5, [r4, #8]
  switch (vol->fatType()) {
    a62c:	ldrb	r3, [r5, #7]
    a62e:	cmp	r3, #16
    a630:	beq.n	a644 <FatFile::openRoot(FatVolume*) [clone .part.37]+0x28>
    a632:	cmp	r3, #32
    a634:	bne.n	a640 <FatFile::openRoot(FatVolume*) [clone .part.37]+0x24>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    a636:	movs	r3, #64	; 0x40
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    a638:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    a63a:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    a63c:	strb	r0, [r4, #2]
    a63e:	pop	{r3, r4, r5, pc}
  return true;

 fail:
  return false;
    a640:	movs	r0, #0
}
    a642:	pop	{r3, r4, r5, pc}
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    a644:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    a646:	movs	r0, #1
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    a648:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    a64a:	strb	r0, [r4, #2]
    a64c:	pop	{r3, r4, r5, pc}
    a64e:	nop

0000a650 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    a650:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    a652:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    a654:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    a658:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    a65a:	mov	r1, r5
    a65c:	ldr	r0, [r0, #8]
    a65e:	bl	b49c <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    a662:	cbz	r0, a67a <FatFile::addCluster()+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    a664:	cbz	r5, a67c <FatFile::addCluster()+0x2c>
    m_flags |= FILE_FLAG_CONTIGUOUS;
  } else if (m_curCluster != (cc + 1)) {
    a666:	ldr	r3, [r4, #16]
    a668:	adds	r5, #1
    a66a:	cmp	r3, r5
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    a66c:	ldrb	r3, [r4, #2]
    a66e:	it	ne
    a670:	andne.w	r3, r3, #191	; 0xbf
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a674:	orn	r3, r3, #127	; 0x7f
    a678:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    a67a:	pop	{r3, r4, r5, pc}
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    a67c:	ldrb	r3, [r4, #2]
    a67e:	orr.w	r3, r3, #64	; 0x40
    a682:	b.n	a674 <FatFile::addCluster()+0x24>

0000a684 <FatFile::addDirCluster()>:
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    a684:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    a688:	ldrb	r3, [r0, #0]
    a68a:	and.w	r3, r3, #32
    a68e:	cbnz	r3, a69c <FatFile::addDirCluster()+0x18>
    a690:	and.w	r4, r3, #255	; 0xff
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    a694:	ldr	r1, [r0, #20]
    a696:	ldr	r3, [pc, #140]	; (a724 <FatFile::addDirCluster()+0xa0>)
    a698:	cmp	r1, r3
    a69a:	bls.n	a6a4 <FatFile::addDirCluster()+0x20>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    a69c:	movs	r6, #0
}
    a69e:	mov	r0, r6
    a6a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a6a4:	mov	r5, r0
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    a6a6:	bl	a650 <FatFile::addCluster()>
    a6aa:	mov	r6, r0
    a6ac:	cmp	r0, #0
    a6ae:	beq.n	a69c <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    a6b0:	ldr	r0, [r5, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    a6b2:	ldr	r3, [r5, #16]
    a6b4:	ldrb	r7, [r0, #6]
    a6b6:	ldr	r2, [r0, #20]
    a6b8:	subs	r3, #2
    a6ba:	lsls	r3, r7
    a6bc:	adds	r7, r3, r2
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a6be:	adds	r0, #36	; 0x24
    a6c0:	mov	r1, r7
    a6c2:	movs	r2, #5
    a6c4:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    a6c8:	mov	r8, r0
    a6ca:	cmp	r0, #0
    a6cc:	beq.n	a69c <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    a6ce:	mov.w	r2, #512	; 0x200
    a6d2:	mov	r1, r4
    a6d4:	bl	106dc <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    a6d8:	ldr	r3, [r5, #8]
    a6da:	ldrb	r2, [r3, #4]
    a6dc:	cmp	r2, #1
    a6de:	bls.n	a70e <FatFile::addDirCluster()+0x8a>
    a6e0:	movs	r4, #1
    a6e2:	b.n	a6fc <FatFile::addDirCluster()+0x78>
    } else {
      return writeSectors(sector, src, 1);
    a6e4:	movs	r3, #1
    a6e6:	mov	r2, r8
    a6e8:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
    a6ec:	adds	r4, #1
    a6ee:	uxtb	r4, r4
    if (!m_vol->writeSector(sector + i, pc->data)) {
    a6f0:	cmp	r0, #0
    a6f2:	beq.n	a69c <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    a6f4:	ldr	r3, [r5, #8]
    a6f6:	ldrb	r2, [r3, #4]
    a6f8:	cmp	r2, r4
    a6fa:	bls.n	a70e <FatFile::addDirCluster()+0x8a>
    a6fc:	ldr	r0, [r3, #0]
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    a6fe:	ldrb	r3, [r0, #13]
    if (!m_vol->writeSector(sector + i, pc->data)) {
    a700:	adds	r1, r4, r7
    a702:	cmp	r3, #0
    a704:	beq.n	a6e4 <FatFile::addDirCluster()+0x60>
      return writeSingle(sector, src);
    a706:	mov	r2, r8
    a708:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    a70c:	b.n	a6ec <FatFile::addDirCluster()+0x68>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    a70e:	ldrb	r3, [r3, #6]
    a710:	ldr	r1, [r5, #20]
    a712:	mov.w	r2, #512	; 0x200
    a716:	lsl.w	r3, r2, r3
    a71a:	uxtah	r3, r1, r3
    a71e:	str	r3, [r5, #20]
    a720:	b.n	a69e <FatFile::addDirCluster()+0x1a>
    a722:	nop
    a724:	.word	0x001ffdff

0000a728 <FatFile::cacheDirEntry(unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    a728:	push	{r4, lr}
    a72a:	mov	r4, r0
    a72c:	ldr	r0, [r0, #8]
    a72e:	mov	r2, r1
    a730:	adds	r0, #36	; 0x24
    a732:	ldr	r1, [r4, #24]
    a734:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    a738:	cbz	r0, a744 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    a73a:	ldrh	r3, [r4, #4]
    a73c:	and.w	r3, r3, #15
    a740:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    a744:	pop	{r4, pc}
    a746:	nop

0000a748 <FatFile::sync() [clone .part.41]>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    a748:	push	{r4, r5, r6, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    a74a:	ldrsb.w	r3, [r0, #2]
    a74e:	cmp	r3, #0
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    a750:	sub	sp, #8
    a752:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    a754:	blt.n	a788 <FatFile::sync() [clone .part.41]+0x40>
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
  }
  if (m_vol->cacheSync()) {
    a756:	ldr	r5, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    a758:	add.w	r0, r5, #36	; 0x24
    a75c:	bl	8da0 <FsCache::sync()>
    a760:	cbnz	r0, a770 <FatFile::sync() [clone .part.41]+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    a762:	ldrb	r3, [r4, #1]
    a764:	orr.w	r3, r3, #1
    a768:	strb	r3, [r4, #1]
  return false;
    a76a:	movs	r0, #0
}
    a76c:	add	sp, #8
    a76e:	pop	{r4, r5, r6, pc}
    a770:	add.w	r0, r5, #564	; 0x234
    a774:	bl	8da0 <FsCache::sync()>
    a778:	cmp	r0, #0
    a77a:	beq.n	a762 <FatFile::sync() [clone .part.41]+0x1a>
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    a77c:	ldr	r0, [r5, #0]
    a77e:	bl	c4f8 <SdSpiCard::syncDevice()>
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    a782:	cmp	r0, #0
    a784:	beq.n	a762 <FatFile::sync() [clone .part.41]+0x1a>
    a786:	b.n	a76c <FatFile::sync() [clone .part.41]+0x24>
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    a788:	movs	r1, #1
    a78a:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    a78e:	mov	r5, r0
    a790:	cmp	r0, #0
    a792:	beq.n	a762 <FatFile::sync() [clone .part.41]+0x1a>
    a794:	ldrb	r3, [r0, #0]
    a796:	cmp	r3, #229	; 0xe5
    a798:	beq.n	a762 <FatFile::sync() [clone .part.41]+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    a79a:	ldrb	r3, [r4, #0]
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    a79c:	ldr	r2, [pc, #56]	; (a7d8 <FatFile::sync() [clone .part.41]+0x90>)
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    a79e:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    a7a0:	itt	mi
    a7a2:	ldrmi	r3, [r4, #28]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    a7a4:	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    a7a6:	ldr	r3, [r4, #32]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    a7a8:	ldr	r6, [r2, #0]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    a7aa:	strh	r3, [r0, #26]
    a7ac:	lsrs	r3, r3, #16
    a7ae:	strh	r3, [r0, #20]
    a7b0:	cbz	r6, a7cc <FatFile::sync() [clone .part.41]+0x84>
      FsDateTime::callback(&date, &time, &ms10);
    a7b2:	add.w	r2, sp, #3
    a7b6:	add.w	r1, sp, #6
    a7ba:	add	r0, sp, #4
    a7bc:	blx	r6
      setLe16(dir->modifyDate, date);
    a7be:	ldrh.w	r3, [sp, #4]
    a7c2:	ldrh.w	r2, [sp, #6]
    a7c6:	strh	r3, [r5, #24]
    a7c8:	strh	r3, [r5, #18]
    a7ca:	strh	r2, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    a7cc:	ldrb	r3, [r4, #2]
    a7ce:	and.w	r3, r3, #127	; 0x7f
    a7d2:	strb	r3, [r4, #2]
    a7d4:	b.n	a756 <FatFile::sync() [clone .part.41]+0xe>
    a7d6:	nop
    a7d8:	.word	0x20002bd8

0000a7dc <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    a7dc:	push	{r4, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a7de:	ldrb	r3, [r0, #0]

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    a7e0:	mov	r4, r0
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a7e2:	cbnz	r3, a7ee <FatFile::close()+0x12>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    a7e4:	movs	r3, #0
    a7e6:	strb	r3, [r4, #0]
  m_flags = 0;
    a7e8:	strb	r3, [r4, #2]
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    a7ea:	movs	r0, #1
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return rtn;
}
    a7ec:	pop	{r4, pc}
    a7ee:	bl	a748 <FatFile::sync() [clone .part.41]>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    a7f2:	movs	r3, #0
    a7f4:	strb	r3, [r4, #0]
  m_flags = 0;
    a7f6:	strb	r3, [r4, #2]
  return rtn;
}
    a7f8:	pop	{r4, pc}
    a7fa:	nop

0000a7fc <FatFile::mkdir(FatFile*, fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    a7fc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    a800:	ldrb	r4, [r1, #0]
    a802:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    a806:	sub	sp, #36	; 0x24
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    a808:	bne.n	a812 <FatFile::mkdir(FatFile*, fname_t*)+0x16>
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
}
    a80a:	movs	r0, #0
    a80c:	add	sp, #36	; 0x24
    a80e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    a812:	movw	r3, #2562	; 0xa02
    a816:	mov	r5, r0
    a818:	mov	r4, r1
    a81a:	bl	bcb8 <FatFile::open(FatFile*, fname_t*, int)>
    a81e:	cmp	r0, #0
    a820:	beq.n	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    a822:	movs	r2, #1
  m_attributes = FILE_ATTR_SUBDIR;
    a824:	movs	r3, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    a826:	strb	r2, [r5, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    a828:	strb	r3, [r5, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    a82a:	mov	r0, r5
    a82c:	bl	a684 <FatFile::addDirCluster()>
    a830:	cmp	r0, #0
    a832:	beq.n	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    a834:	ldrb	r3, [r5, #0]
  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    a836:	ldr	r2, [r5, #16]
    a838:	str	r2, [r5, #32]
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    a83a:	cmp	r3, #0
    a83c:	bne.n	a928 <FatFile::mkdir(FatFile*, fname_t*)+0x12c>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    a83e:	movs	r1, #1
    a840:	mov	r0, r5
    a842:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    a846:	mov	r6, r0
    a848:	cmp	r0, #0
    a84a:	beq.n	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    a84c:	movs	r3, #16
    a84e:	strb	r3, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    a850:	ldr	r2, [r0, #8]
    a852:	ldr	r1, [r6, #4]
    a854:	ldr	r3, [r6, #12]
    a856:	ldr	r0, [r0, #0]
    a858:	ldrh.w	r8, [r6, #20]
    a85c:	ldrh.w	r9, [r6, #26]
    a860:	mov	r7, sp
    a862:	stmia	r7!, {r0, r1, r2, r3}
    a864:	ldr	r1, [r6, #20]
    a866:	ldr	r2, [r6, #24]
    a868:	ldr	r3, [r6, #28]
    a86a:	ldr	r0, [r6, #16]
  dot.name[0] = '.';
    a86c:	add	r6, sp, #32
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    a86e:	stmia	r7!, {r0, r1, r2, r3}
  dot.name[0] = '.';
    a870:	movs	r3, #46	; 0x2e
    a872:	strb.w	r3, [r6, #-32]!
    a876:	add.w	r1, sp, #10
    a87a:	mov	r3, r6
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    a87c:	movs	r2, #32
    a87e:	strb.w	r2, [r3, #1]!
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    a882:	cmp	r3, r1
    a884:	bne.n	a87e <FatFile::mkdir(FatFile*, fname_t*)+0x82>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    a886:	ldr	r0, [r5, #8]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a888:	ldr	r3, [r5, #32]
    a88a:	ldrb	r2, [r0, #6]
    a88c:	ldr	r1, [r0, #20]
    a88e:	subs	r3, #2
    a890:	lsls	r3, r2
    a892:	add	r1, r3
    a894:	adds	r0, #36	; 0x24
    a896:	movs	r2, #1
    a898:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    a89c:	mov	lr, r0
    a89e:	cmp	r0, #0
    a8a0:	beq.n	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    a8a2:	mov	r7, r6
    a8a4:	strh.w	r8, [sp, #20]
    a8a8:	strh.w	r9, [sp, #26]
    a8ac:	ldmia	r7!, {r0, r1, r2, r3}
    a8ae:	str.w	r0, [lr]
    a8b2:	str.w	r1, [lr, #4]
    a8b6:	str.w	r2, [lr, #8]
    a8ba:	str.w	r3, [lr, #12]
    a8be:	ldmia	r7!, {r0, r1, r2, r3}
    a8c0:	str.w	r0, [lr, #16]
    a8c4:	str.w	r1, [lr, #20]
    a8c8:	str.w	r2, [lr, #24]
    a8cc:	str.w	r3, [lr, #28]
  // make entry for '..'
  dot.name[1] = '.';
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    a8d0:	ldr	r3, [r4, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    a8d2:	strh.w	r3, [sp, #26]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    a8d6:	movs	r2, #46	; 0x2e
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    a8d8:	lsrs	r3, r3, #16
    a8da:	mov	r4, r6
    a8dc:	strh.w	r3, [sp, #20]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    a8e0:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    a8e4:	ldmia	r4!, {r0, r1, r2, r3}
    a8e6:	add.w	r6, lr, #32
    a8ea:	str.w	r0, [lr, #32]
    a8ee:	str	r1, [r6, #4]
    a8f0:	str	r2, [r6, #8]
    a8f2:	str	r3, [r6, #12]
    a8f4:	ldmia	r4!, {r0, r1, r2, r3}
    a8f6:	str	r0, [r6, #16]
    a8f8:	str	r1, [r6, #20]
    a8fa:	str	r2, [r6, #24]
    a8fc:	str	r3, [r6, #28]
  // write first sector
  return m_vol->cacheSync();
    a8fe:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    a900:	add.w	r0, r4, #36	; 0x24
    a904:	bl	8da0 <FsCache::sync()>
    a908:	cmp	r0, #0
    a90a:	beq.w	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    a90e:	add.w	r0, r4, #564	; 0x234
    a912:	bl	8da0 <FsCache::sync()>
    a916:	cmp	r0, #0
    a918:	beq.w	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    a91c:	ldr	r0, [r4, #0]

 fail:
  return false;
}
    a91e:	add	sp, #36	; 0x24
    a920:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a924:	b.w	c4f8 <SdSpiCard::syncDevice()>
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    a928:	ldr	r3, [r5, #20]
    a92a:	cbz	r3, a93a <FatFile::mkdir(FatFile*, fname_t*)+0x13e>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    a92c:	ldrb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    a92e:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    a930:	bic.w	r3, r3, #32
    a934:	strb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    a936:	str	r2, [r5, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    a938:	str	r2, [r5, #20]
    a93a:	mov	r0, r5
    a93c:	bl	a748 <FatFile::sync() [clone .part.41]>
  }
  m_firstCluster = m_curCluster;
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    a940:	cmp	r0, #0
    a942:	beq.w	a80a <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    a946:	b.n	a83e <FatFile::mkdir(FatFile*, fname_t*)+0x42>

0000a948 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    a948:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a94c:	mov	r6, r0
    a94e:	sub	sp, #72	; 0x48
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    a950:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    a952:	str	r2, [sp, #4]
    a954:	movs	r0, #0
    a956:	strb.w	r0, [sp, #36]	; 0x24
    a95a:	strb.w	r0, [sp, #37]	; 0x25
    a95e:	strb.w	r0, [sp, #38]	; 0x26
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    a962:	cbnz	r5, a970 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    a964:	mov	r8, r3
    a966:	ldrb	r3, [r1, #0]
    a968:	tst.w	r3, #112	; 0x70
    a96c:	mov	r4, r1
    a96e:	bne.n	a978 <FatFile::mkdir(FatFile*, char const*, bool)+0x30>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    a970:	movs	r0, #0
}
    a972:	add	sp, #72	; 0x48
    a974:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    a978:	ldrb	r3, [r2, #0]
    a97a:	cmp	r3, #47	; 0x2f
    a97c:	mov	r0, r2
    a97e:	beq.n	a9d6 <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    a980:	movs	r7, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    a982:	add	r2, sp, #4
    a984:	add	r1, sp, #12
    a986:	bl	b890 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    a98a:	add	r2, sp, #12
    a98c:	mov	r1, r4
    a98e:	movs	r3, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    a990:	cmp	r0, #0
    a992:	beq.n	a970 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    a994:	ldr	r5, [sp, #4]
    a996:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    a998:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    a99a:	cmp	r5, #0
    a99c:	beq.n	a9fa <FatFile::mkdir(FatFile*, char const*, bool)+0xb2>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    a99e:	bl	bcb8 <FatFile::open(FatFile*, fname_t*, int)>
    a9a2:	cbnz	r0, a9b8 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      if (!pFlag || !mkdir(parent, &fname)) {
    a9a4:	cmp.w	r8, #0
    a9a8:	beq.n	a970 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    a9aa:	mov	r1, r4
    a9ac:	add	r2, sp, #12
    a9ae:	mov	r0, r6
    a9b0:	bl	a7fc <FatFile::mkdir(FatFile*, fname_t*)>
    a9b4:	cmp	r0, #0
    a9b6:	beq.n	a970 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    a9b8:	mov	r5, r6
    a9ba:	ldmia	r5!, {r0, r1, r2, r3}
    a9bc:	add	r4, sp, #36	; 0x24
    a9be:	stmia	r4!, {r0, r1, r2, r3}
    a9c0:	ldmia	r5!, {r0, r1, r2, r3}
    a9c2:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a9c4:	ldrb	r3, [r6, #0]
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    a9c6:	ldr	r2, [r5, #0]
    a9c8:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a9ca:	cbnz	r3, a9f2 <FatFile::mkdir(FatFile*, char const*, bool)+0xaa>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    a9cc:	strb	r7, [r6, #0]
  m_flags = 0;
    a9ce:	strb	r7, [r6, #2]
    a9d0:	ldr	r0, [sp, #4]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    a9d2:	add	r4, sp, #36	; 0x24
    a9d4:	b.n	a982 <FatFile::mkdir(FatFile*, char const*, bool)+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    a9d6:	adds	r0, #1
    a9d8:	str	r0, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    a9da:	ldrb	r3, [r0, #0]
    a9dc:	cmp	r3, #47	; 0x2f
    a9de:	beq.n	a9d6 <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    a9e0:	ldr	r1, [r4, #8]
    a9e2:	add	r0, sp, #36	; 0x24
    a9e4:	bl	a61c <FatFile::openRoot(FatVolume*) [clone .part.37]>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    a9e8:	cmp	r0, #0
    a9ea:	beq.n	a970 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    a9ec:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    a9ee:	add	r4, sp, #36	; 0x24
    a9f0:	b.n	a980 <FatFile::mkdir(FatFile*, char const*, bool)+0x38>
    a9f2:	mov	r0, r6
    a9f4:	bl	a748 <FatFile::sync() [clone .part.41]>
    a9f8:	b.n	a9cc <FatFile::mkdir(FatFile*, char const*, bool)+0x84>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    a9fa:	add	r2, sp, #12
    a9fc:	mov	r1, r4
    a9fe:	mov	r0, r6
    aa00:	bl	a7fc <FatFile::mkdir(FatFile*, fname_t*)>

 fail:
  return false;
}
    aa04:	add	sp, #72	; 0x48
    aa06:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    aa0a:	nop

0000aa0c <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    aa0c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aa10:	mov	r6, r0
    aa12:	sub	sp, #72	; 0x48
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    aa14:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    aa16:	str	r2, [sp, #4]
    aa18:	movs	r0, #0
    aa1a:	strb.w	r0, [sp, #36]	; 0x24
    aa1e:	strb.w	r0, [sp, #37]	; 0x25
    aa22:	strb.w	r0, [sp, #38]	; 0x26
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    aa26:	cbnz	r5, aa34 <FatFile::open(FatFile*, char const*, int)+0x28>
    aa28:	mov	r8, r3
    aa2a:	ldrb	r3, [r1, #0]
    aa2c:	tst.w	r3, #112	; 0x70
    aa30:	mov	r4, r1
    aa32:	bne.n	aa3c <FatFile::open(FatFile*, char const*, int)+0x30>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    aa34:	movs	r0, #0
}
    aa36:	add	sp, #72	; 0x48
    aa38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    aa3c:	ldrb	r3, [r2, #0]
    aa3e:	cmp	r3, #47	; 0x2f
    aa40:	mov	r0, r2
    aa42:	beq.n	aa90 <FatFile::open(FatFile*, char const*, int)+0x84>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    aa44:	movs	r7, #0
    aa46:	b.n	aa50 <FatFile::open(FatFile*, char const*, int)+0x44>
    aa48:	ldr	r0, [sp, #4]
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    aa4a:	strb	r7, [r6, #0]
  m_flags = 0;
    aa4c:	strb	r7, [r6, #2]
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    aa4e:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    aa50:	add	r2, sp, #4
    aa52:	add	r1, sp, #12
    aa54:	bl	b890 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    aa58:	add	r2, sp, #12
    aa5a:	mov	r1, r4
    aa5c:	movs	r3, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    aa5e:	cmp	r0, #0
    aa60:	beq.n	aa34 <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    aa62:	ldr	r5, [sp, #4]
    aa64:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    aa66:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    aa68:	cbz	r5, aaae <FatFile::open(FatFile*, char const*, int)+0xa2>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    aa6a:	bl	bcb8 <FatFile::open(FatFile*, fname_t*, int)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    aa6e:	mov	r5, r6
    aa70:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    aa72:	cmp	r0, #0
    aa74:	beq.n	aa34 <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    aa76:	ldmia	r5!, {r0, r1, r2, r3}
    aa78:	stmia	r4!, {r0, r1, r2, r3}
    aa7a:	ldmia	r5!, {r0, r1, r2, r3}
    aa7c:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    aa7e:	ldrb	r3, [r6, #0]
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    aa80:	ldr	r2, [r5, #0]
    aa82:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    aa84:	cmp	r3, #0
    aa86:	beq.n	aa48 <FatFile::open(FatFile*, char const*, int)+0x3c>
    aa88:	mov	r0, r6
    aa8a:	bl	a748 <FatFile::sync() [clone .part.41]>
    aa8e:	b.n	aa48 <FatFile::open(FatFile*, char const*, int)+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    aa90:	adds	r0, #1
    aa92:	str	r0, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    aa94:	ldrb	r3, [r0, #0]
    aa96:	cmp	r3, #47	; 0x2f
    aa98:	beq.n	aa90 <FatFile::open(FatFile*, char const*, int)+0x84>
      path++;
    }
    if (*path == 0) {
    aa9a:	cbz	r3, aac0 <FatFile::open(FatFile*, char const*, int)+0xb4>
    aa9c:	ldr	r1, [r4, #8]
    aa9e:	add	r0, sp, #36	; 0x24
    aaa0:	bl	a61c <FatFile::openRoot(FatVolume*) [clone .part.37]>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    aaa4:	cmp	r0, #0
    aaa6:	beq.n	aa34 <FatFile::open(FatFile*, char const*, int)+0x28>
    aaa8:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    aaaa:	add	r4, sp, #36	; 0x24
    aaac:	b.n	aa44 <FatFile::open(FatFile*, char const*, int)+0x38>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    aaae:	mov	r3, r8
    aab0:	add	r2, sp, #12
    aab2:	mov	r1, r4
    aab4:	mov	r0, r6
    aab6:	bl	bcb8 <FatFile::open(FatFile*, fname_t*, int)>

 fail:
  return false;
}
    aaba:	add	sp, #72	; 0x48
    aabc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    aac0:	ldr	r1, [r4, #8]
    aac2:	mov	r0, r6
    aac4:	bl	a61c <FatFile::openRoot(FatVolume*) [clone .part.37]>
    aac8:	b.n	aa36 <FatFile::open(FatFile*, char const*, int)+0x2a>
    aaca:	nop

0000aacc <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    aacc:	cbz	r1, aad6 <FatFile::open(FatVolume*, char const*, int)+0xa>
    aace:	addw	r1, r1, #1092	; 0x444
    aad2:	b.w	aa0c <FatFile::open(FatFile*, char const*, int)>
}
    aad6:	mov	r0, r1
    aad8:	bx	lr
    aada:	nop

0000aadc <FatFile::openRoot(FatVolume*)>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    aadc:	ldrb	r3, [r0, #0]
    aade:	cbz	r3, aae4 <FatFile::openRoot(FatVolume*)+0x8>
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
}
    aae0:	movs	r0, #0
    aae2:	bx	lr
    aae4:	b.w	a61c <FatFile::openRoot(FatVolume*) [clone .part.37]>

0000aae8 <FatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    aae8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    aaec:	ldrb	r3, [r0, #2]
    aaee:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    aaf0:	sub	sp, #20
    aaf2:	mov	r5, r0
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    aaf4:	bpl.w	ac16 <FatFile::read(void*, unsigned int)+0x12e>
    aaf8:	mov	r8, r1
    aafa:	ldrb	r1, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    aafc:	lsls	r6, r1, #28
    aafe:	mov	sl, r2
    ab00:	bmi.w	ac28 <FatFile::read(void*, unsigned int)+0x140>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    ab04:	lsls	r4, r1, #26
    ab06:	bpl.n	ab1a <FatFile::read(void*, unsigned int)+0x32>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    ab08:	ldr	r2, [r0, #8]
    if (nbyte > tmp16) {
    ab0a:	ldr	r3, [r0, #20]
    ab0c:	ldrh	r2, [r2, #8]
    ab0e:	rsb	r3, r3, r2, lsl #5
    ab12:	uxth	r3, r3
    ab14:	cmp	sl, r3
    ab16:	it	cs
    ab18:	movcs	sl, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    ab1a:	cmp.w	sl, #0
    ab1e:	beq.w	ac74 <FatFile::read(void*, unsigned int)+0x18c>
    ab22:	ldr	r2, [r5, #20]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    ab24:	ldr	r6, [r5, #8]
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    ab26:	add.w	r3, r5, #16
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    if (isRootFixed()) {
    ab2a:	lsls	r0, r1, #26
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    ab2c:	mov	r7, sl
    ab2e:	mov.w	r9, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    ab32:	str	r3, [sp, #12]
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    ab34:	ubfx	fp, r2, #0, #9
    if (isRootFixed()) {
    ab38:	bpl.n	abb4 <FatFile::read(void*, unsigned int)+0xcc>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    ab3a:	ldr	r1, [r6, #32]
    ab3c:	add.w	r1, r1, r2, lsr #9
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    ab40:	cmp.w	fp, #0
    ab44:	bne.n	abea <FatFile::read(void*, unsigned int)+0x102>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    ab46:	cmp.w	r7, #512	; 0x200
    ab4a:	bcc.n	abea <FatFile::read(void*, unsigned int)+0x102>
    ab4c:	ldr	r2, [r6, #48]	; 0x30
        || sector == m_vol->cacheSectorNumber()) {
    ab4e:	cmp	r1, r2
    ab50:	beq.n	abea <FatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    ab52:	cmp.w	r7, #1024	; 0x400
    ab56:	bcc.n	ac3a <FatFile::read(void*, unsigned int)+0x152>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    ab58:	ldrb	r0, [r5, #0]
    ab5a:	lsls	r0, r0, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    ab5c:	mov.w	r3, r7, lsr #9
      if (!isRootFixed()) {
    ab60:	bmi.n	ab6e <FatFile::read(void*, unsigned int)+0x86>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    ab62:	ldrb	r0, [r6, #4]
    ab64:	rsb	r0, r9, r0
    ab68:	cmp	r3, r0
    ab6a:	it	cs
    ab6c:	movcs	r3, r0
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    ab6e:	cmp	r1, r2
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    ab70:	mov.w	r4, r3, lsl #9
    ab74:	bhi.n	ab90 <FatFile::read(void*, unsigned int)+0xa8>
    ab76:	adds	r0, r1, r3
    ab78:	cmp	r2, r0
    ab7a:	bcs.n	ab90 <FatFile::read(void*, unsigned int)+0xa8>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    ab7c:	add.w	r0, r6, #36	; 0x24
    ab80:	str	r3, [sp, #8]
    ab82:	str	r1, [sp, #4]
    ab84:	bl	8da0 <FsCache::sync()>
    ab88:	ldr	r1, [sp, #4]
    ab8a:	ldr	r3, [sp, #8]
    ab8c:	cmp	r0, #0
    ab8e:	beq.n	ac16 <FatFile::read(void*, unsigned int)+0x12e>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    ab90:	ldr	r0, [r6, #40]	; 0x28
    ab92:	mov	r2, r8
    ab94:	bl	c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    ab98:	cmp	r0, #0
    ab9a:	beq.n	ac16 <FatFile::read(void*, unsigned int)+0x12e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    ab9c:	ldr	r2, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    ab9e:	subs	r7, r7, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    aba0:	add	r2, r4
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    aba2:	add	r8, r4
    m_curPosition += n;
    aba4:	str	r2, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    aba6:	beq.n	ac74 <FatFile::read(void*, unsigned int)+0x18c>
    aba8:	ldrb	r1, [r5, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    abaa:	ldr	r6, [r5, #8]
    if (isRootFixed()) {
    abac:	lsls	r0, r1, #26
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    abae:	ubfx	fp, r2, #0, #9
    if (isRootFixed()) {
    abb2:	bmi.n	ab3a <FatFile::read(void*, unsigned int)+0x52>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    abb4:	ldrb.w	r9, [r6, #5]
    abb8:	and.w	r9, r9, r2, lsr #9
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    abbc:	cmp.w	fp, #0
    abc0:	bne.n	ac36 <FatFile::read(void*, unsigned int)+0x14e>
    abc2:	cmp.w	r9, #0
    abc6:	bne.n	ac36 <FatFile::read(void*, unsigned int)+0x14e>
        // start of new cluster
        if (m_curPosition == 0) {
    abc8:	cmp	r2, #0
    abca:	bne.n	ac4e <FatFile::read(void*, unsigned int)+0x166>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    abcc:	lsls	r2, r1, #25
    abce:	ite	mi
    abd0:	ldrmi	r4, [r6, #32]
    abd2:	ldrpl	r4, [r5, #32]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    abd4:	str	r4, [r5, #16]
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    abd6:	ldrb	r1, [r6, #6]
    abd8:	ldr	r0, [r6, #20]
    abda:	subs	r4, #2
    abdc:	lsls	r4, r1
    abde:	add.w	r1, r9, r0
    abe2:	add	r1, r4
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    abe4:	cmp.w	fp, #0
    abe8:	beq.n	ab46 <FatFile::read(void*, unsigned int)+0x5e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    abea:	add.w	r0, r6, #36	; 0x24
    abee:	movs	r2, #0
    abf0:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    abf4:	cbz	r0, ac16 <FatFile::read(void*, unsigned int)+0x12e>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    abf6:	rsb	r4, fp, #512	; 0x200
    abfa:	cmp	r4, r7
    abfc:	it	cs
    abfe:	movcs	r4, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    ac00:	add.w	r1, r0, fp
    ac04:	mov	r2, r4
    ac06:	mov	r0, r8
    ac08:	bl	cb10 <memcpy>
    ac0c:	b.n	ab9c <FatFile::read(void*, unsigned int)+0xb4>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    ac0e:	ldrb	r3, [r5, #0]
    ac10:	tst.w	r3, #112	; 0x70
    ac14:	bne.n	ac76 <FatFile::read(void*, unsigned int)+0x18e>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    ac16:	ldrb	r3, [r5, #1]
  return -1;
    ac18:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    ac1c:	orr.w	r3, r3, #2
    ac20:	strb	r3, [r5, #1]
  return -1;
}
    ac22:	add	sp, #20
    ac24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    uint32_t tmp32 = m_fileSize - m_curPosition;
    ac28:	ldr	r3, [r0, #28]
    ac2a:	ldr	r2, [r0, #20]
    ac2c:	subs	r3, r3, r2
    ac2e:	cmp	sl, r3
    ac30:	it	cs
    ac32:	movcs	sl, r3
    ac34:	b.n	ab1a <FatFile::read(void*, unsigned int)+0x32>
    ac36:	ldr	r4, [r5, #16]
    ac38:	b.n	abd6 <FatFile::read(void*, unsigned int)+0xee>
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    ac3a:	ldr	r0, [r6, #40]	; 0x28
    ac3c:	movs	r3, #1
    ac3e:	mov	r2, r8
    ac40:	bl	c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    ac44:	cmp	r0, #0
    ac46:	beq.n	ac16 <FatFile::read(void*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    ac48:	mov.w	r4, #512	; 0x200
    ac4c:	b.n	ab9c <FatFile::read(void*, unsigned int)+0xb4>
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    ac4e:	lsls	r3, r1, #28
    ac50:	bpl.n	ac5e <FatFile::read(void*, unsigned int)+0x176>
    ac52:	ldrb	r2, [r5, #2]
    ac54:	lsls	r4, r2, #25
    ac56:	bpl.n	ac5e <FatFile::read(void*, unsigned int)+0x176>
          m_curCluster++;
    ac58:	ldr	r4, [r5, #16]
    ac5a:	adds	r4, #1
    ac5c:	b.n	abd4 <FatFile::read(void*, unsigned int)+0xec>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    ac5e:	mov	r0, r6
    ac60:	ldr	r2, [sp, #12]
    ac62:	ldr	r1, [r5, #16]
    ac64:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    ac68:	cmp	r0, #0
    ac6a:	blt.n	ac16 <FatFile::read(void*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    ac6c:	beq.n	ac0e <FatFile::read(void*, unsigned int)+0x126>
    ac6e:	ldr	r6, [r5, #8]
    ac70:	ldr	r4, [r5, #16]
    ac72:	b.n	abd6 <FatFile::read(void*, unsigned int)+0xee>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    ac74:	movs	r7, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    ac76:	rsb	r0, r7, sl

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    ac7a:	add	sp, #20
    ac7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000ac80 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    ac80:	push	{r4, r5, r6, lr}
    ac82:	sub	sp, #8
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    ac84:	movs	r2, #1
    ac86:	add.w	r1, sp, #7
    ac8a:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    ac8c:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    ac8e:	ldr	r5, [r0, #16]
    ac90:	bl	aae8 <FatFile::read(void*, unsigned int)>
    ac94:	cmp	r0, #1
    ac96:	it	eq
    ac98:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    ac9c:	str	r6, [r4, #20]
    ac9e:	it	ne
    aca0:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    aca4:	str	r5, [r4, #16]
  return c;
}
    aca6:	add	sp, #8
    aca8:	pop	{r4, r5, r6, pc}
    acaa:	nop

0000acac <FatFile::readDirCache(bool)>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    acac:	push	{r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
    acae:	ldr	r3, [r0, #20]
    acb0:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    acb4:	sub	sp, #12
    acb6:	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    acb8:	cbz	r5, acbc <FatFile::readDirCache(bool)+0x10>
    acba:	cbnz	r1, ace0 <FatFile::readDirCache(bool)+0x34>
    int8_t n = read(&n, 1);
    acbc:	movs	r2, #1
    acbe:	add.w	r1, sp, #7
    acc2:	mov	r0, r4
    acc4:	bl	aae8 <FatFile::read(void*, unsigned int)>
    acc8:	sxtb	r0, r0
    if  (n != 1) {
    acca:	cmp	r0, #1
    accc:	bne.n	ace6 <FatFile::readDirCache(bool)+0x3a>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    acce:	ldr	r3, [r4, #20]
    acd0:	adds	r3, #31
    acd2:	str	r3, [r4, #20]
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    acd4:	ldr	r0, [r4, #8]
    acd6:	adds	r0, #52	; 0x34
  } else {
    m_curPosition += 32;
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    acd8:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    acdc:	add	sp, #12
    acde:	pop	{r4, r5, pc}
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    ace0:	adds	r3, #32
    ace2:	str	r3, [r0, #20]
    ace4:	b.n	acd4 <FatFile::readDirCache(bool)+0x28>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    ace6:	movs	r0, #0
}
    ace8:	add	sp, #12
    acea:	pop	{r4, r5, pc}

0000acec <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    acec:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    acf0:	ldrb	r5, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    acf2:	sub	sp, #104	; 0x68
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    acf4:	movs	r4, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    acf6:	tst.w	r5, #24
    acfa:	strb.w	r4, [sp, #32]
    acfe:	strb.w	r4, [sp, #33]	; 0x21
    ad02:	strb.w	r4, [sp, #34]	; 0x22
    ad06:	strb.w	r4, [sp, #68]	; 0x44
    ad0a:	strb.w	r4, [sp, #69]	; 0x45
    ad0e:	strb.w	r4, [sp, #70]	; 0x46
    ad12:	beq.n	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    ad14:	ldr	r6, [r0, #8]
    ad16:	ldr	r5, [r1, #8]
    ad18:	cmp	r6, r5
    ad1a:	mov	r3, r0
    ad1c:	beq.n	ad26 <FatFile::rename(FatFile*, char const*)+0x3a>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    ad1e:	movs	r0, #0
}
    ad20:	add	sp, #104	; 0x68
    ad22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ad26:	mov	r5, r3
    ad28:	mov	r8, r2
    ad2a:	mov	r6, r1
    ad2c:	bl	a748 <FatFile::sync() [clone .part.41]>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    ad30:	mov	lr, r5
    ad32:	ldmia.w	lr!, {r0, r1, r2, r3}
    ad36:	add	r7, sp, #68	; 0x44
    ad38:	stmia	r7!, {r0, r1, r2, r3}
    ad3a:	ldmia.w	lr!, {r0, r1, r2, r3}
    ad3e:	stmia	r7!, {r0, r1, r2, r3}
    ad40:	ldr.w	r3, [lr]
    ad44:	str	r3, [r7, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    ad46:	mov	r1, r4
    ad48:	mov	r0, r5
    ad4a:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    ad4e:	mov	lr, r0
    ad50:	cmp	r0, #0
    ad52:	beq.n	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    ad54:	ldr.w	r1, [lr, #4]
    ad58:	ldr.w	r2, [lr, #8]
    ad5c:	ldr.w	r3, [lr, #12]
    ad60:	ldr	r0, [r0, #0]
  // make directory entry for new path
  if (isFile()) {
    ad62:	ldrb.w	ip, [r5]
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    ad66:	mov	r7, sp
    ad68:	stmia	r7!, {r0, r1, r2, r3}
    ad6a:	ldr.w	r1, [lr, #20]
    ad6e:	ldr.w	r2, [lr, #24]
    ad72:	ldr.w	r3, [lr, #28]
    ad76:	ldr.w	r0, [lr, #16]
  // make directory entry for new path
  if (isFile()) {
    ad7a:	and.w	lr, ip, #8
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    ad7e:	stmia	r7!, {r0, r1, r2, r3}
  // make directory entry for new path
  if (isFile()) {
    ad80:	and.w	r3, lr, #255	; 0xff
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    ad84:	mov	r2, r8
    ad86:	mov	r1, r6
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    ad88:	cmp.w	lr, #0
    ad8c:	beq.w	aeae <FatFile::rename(FatFile*, char const*)+0x1c2>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    ad90:	movw	r3, #2561	; 0xa01
    ad94:	add	r0, sp, #32
    ad96:	bl	aa0c <FatFile::open(FatFile*, char const*, int)>
    ad9a:	cmp	r0, #0
    ad9c:	beq.n	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    ad9e:	ldr	r0, [sp, #56]	; 0x38
  m_dirIndex = file.m_dirIndex;
    ada0:	ldrh.w	r1, [sp, #36]	; 0x24
  m_lfnOrd = file.m_lfnOrd;
    ada4:	ldrb.w	r2, [sp, #35]	; 0x23
  m_dirCluster = file.m_dirCluster;
    ada8:	ldr	r3, [sp, #44]	; 0x2c
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    adaa:	str	r0, [r5, #24]
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    adac:	movs	r6, #0
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
    adae:	strh	r1, [r5, #4]
  m_lfnOrd = file.m_lfnOrd;
    adb0:	strb	r2, [r5, #3]
  m_dirCluster = file.m_dirCluster;
    adb2:	str	r3, [r5, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    adb4:	movs	r1, #1
    adb6:	mov	r0, r5
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    adb8:	strb.w	r6, [sp, #32]
  file.m_flags = 0;
    adbc:	strb.w	r6, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    adc0:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    adc4:	cmp	r0, #0
    adc6:	beq.n	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    adc8:	add	r3, sp, #104	; 0x68
  dir->attributes = entry.attributes;
    adca:	ldrb.w	r2, [sp, #11]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    adce:	ldr.w	r7, [r3, #-91]!
    add2:	str.w	r7, [r0, #13]
    add6:	ldr	r7, [r3, #4]
    add8:	str.w	r7, [r0, #17]
    addc:	ldr	r7, [r3, #8]
    adde:	str.w	r7, [r0, #21]
    ade2:	ldr	r7, [r3, #12]
    ade4:	str.w	r7, [r0, #25]
    ade8:	ldrh	r7, [r3, #16]
    adea:	ldrb	r3, [r3, #18]
    adec:	strh.w	r7, [r0, #29]
    adf0:	strb	r3, [r0, #31]
  dir->attributes = entry.attributes;
    adf2:	strb	r2, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    adf4:	cmp	r4, #0
    adf6:	beq.n	ae6c <FatFile::rename(FatFile*, char const*)+0x180>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    adf8:	ldr	r0, [r5, #8]
    adfa:	ldrb	r2, [r0, #6]
    adfc:	ldr	r1, [r0, #20]
    adfe:	subs	r3, r4, #2
    ae00:	lsls	r3, r2
    ae02:	add	r1, r3
    ae04:	mov	r2, r6
    ae06:	adds	r0, #36	; 0x24
    ae08:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    ae0c:	cmp	r0, #0
    ae0e:	beq.n	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    ae10:	mov	r6, r0
    ae12:	mov	r7, sp
    ae14:	ldr.w	r0, [r6, #32]!
    ae18:	ldr	r1, [r6, #4]
    ae1a:	ldr	r2, [r6, #8]
    ae1c:	ldr	r3, [r6, #12]
    ae1e:	stmia	r7!, {r0, r1, r2, r3}
    ae20:	ldr	r0, [r6, #16]
    ae22:	ldr	r1, [r6, #20]
    ae24:	ldr	r2, [r6, #24]
    ae26:	ldr	r3, [r6, #28]
    ae28:	stmia	r7!, {r0, r1, r2, r3}

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    ae2a:	mov	r1, r4
    ae2c:	ldr	r0, [r5, #8]
    ae2e:	bl	b520 <FatPartition::freeChain(unsigned long)>
    ae32:	cmp	r0, #0
    ae34:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    ae38:	ldr	r0, [r5, #8]
    ae3a:	ldr	r3, [r5, #32]
    ae3c:	ldrb	r2, [r0, #6]
    ae3e:	ldr	r1, [r0, #20]
    ae40:	subs	r3, #2
    ae42:	lsls	r3, r2
    ae44:	add	r1, r3
    ae46:	adds	r0, #36	; 0x24
    ae48:	movs	r2, #1
    ae4a:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    ae4e:	mov	r7, r0
    ae50:	cmp	r0, #0
    ae52:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    ae56:	mov	r4, sp
    ae58:	ldmia	r4!, {r0, r1, r2, r3}
    ae5a:	str	r0, [r7, #32]
    ae5c:	str	r1, [r7, #36]	; 0x24
    ae5e:	str	r2, [r7, #40]	; 0x28
    ae60:	str	r3, [r7, #44]	; 0x2c
    ae62:	ldmia	r4!, {r0, r1, r2, r3}
    ae64:	str	r0, [r7, #48]	; 0x30
    ae66:	str	r1, [r7, #52]	; 0x34
    ae68:	str	r2, [r7, #56]	; 0x38
    ae6a:	str	r3, [r7, #60]	; 0x3c
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    ae6c:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    ae6e:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    ae70:	movs	r3, #8
  if (!oldFile.remove()) {
    ae72:	add	r0, sp, #68	; 0x44
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    ae74:	str	r1, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    ae76:	strb.w	r2, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
    ae7a:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    ae7e:	bl	badc <FatFile::remove()>
    ae82:	cmp	r0, #0
    ae84:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    ae88:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    ae8a:	add.w	r0, r4, #36	; 0x24
    ae8e:	bl	8da0 <FsCache::sync()>
    ae92:	cmp	r0, #0
    ae94:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
    ae98:	add.w	r0, r4, #564	; 0x234
    ae9c:	bl	8da0 <FsCache::sync()>
    aea0:	cmp	r0, #0
    aea2:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    aea6:	ldr	r0, [r4, #0]
    aea8:	bl	c4f8 <SdSpiCard::syncDevice()>
    aeac:	b.n	ad20 <FatFile::rename(FatFile*, char const*)+0x34>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    aeae:	add	r0, sp, #32
    aeb0:	bl	a948 <FatFile::mkdir(FatFile*, char const*, bool)>
    aeb4:	cmp	r0, #0
    aeb6:	beq.w	ad1e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    aeba:	ldr	r4, [sp, #64]	; 0x40
    aebc:	b.n	ad9e <FatFile::rename(FatFile*, char const*)+0xb2>
    aebe:	nop

0000aec0 <FatFile::rmdir()>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    aec0:	ldrb	r3, [r0, #0]
    aec2:	lsls	r2, r3, #27
    aec4:	bpl.n	aefc <FatFile::rmdir()+0x3c>
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    aec6:	ldr	r3, [r0, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    aec8:	push	{r4, lr}
    aeca:	mov	r4, r0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    aecc:	cbz	r3, aedc <FatFile::rmdir()+0x1c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    aece:	ldrb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    aed0:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    aed2:	bic.w	r3, r3, #32
    aed6:	strb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    aed8:	str	r2, [r0, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    aeda:	str	r2, [r0, #20]
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    aedc:	movs	r1, #1
    aede:	mov	r0, r4
    aee0:	bl	acac <FatFile::readDirCache(bool)>
    if (!dir) {
    aee4:	cbz	r0, af00 <FatFile::rmdir()+0x40>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    aee6:	ldrb	r3, [r0, #0]
    aee8:	cbz	r3, af06 <FatFile::rmdir()+0x46>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    aeea:	cmp	r3, #229	; 0xe5
    aeec:	beq.n	aedc <FatFile::rmdir()+0x1c>
    aeee:	cmp	r3, #46	; 0x2e
    aef0:	beq.n	aedc <FatFile::rmdir()+0x1c>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    aef2:	ldrb	r3, [r0, #11]
    aef4:	lsls	r3, r3, #28
    aef6:	bmi.n	aedc <FatFile::rmdir()+0x1c>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
}
    aef8:	movs	r0, #0
    aefa:	pop	{r4, pc}
    aefc:	movs	r0, #0
    aefe:	bx	lr
  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
    af00:	ldrb	r3, [r4, #1]
    af02:	cmp	r3, #0
    af04:	bne.n	aef8 <FatFile::rmdir()+0x38>
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    af06:	ldrb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    af08:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    af0a:	orr.w	r3, r3, #2
    af0e:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    af10:	strb	r2, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    af12:	mov	r0, r4

 fail:
  return false;
}
    af14:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    af18:	b.w	badc <FatFile::remove()>

0000af1c <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    af1c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    af20:	ldrb	r3, [r0, #0]
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    af22:	ldr	r7, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    af24:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    af26:	cbz	r3, af56 <FatFile::seekSet(unsigned long)+0x3a>
    af28:	mov	r5, r1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    af2a:	ldr	r1, [r0, #20]
    af2c:	cmp	r1, r5
    af2e:	beq.n	af88 <FatFile::seekSet(unsigned long)+0x6c>
    return true;
  }
  if (pos == 0) {
    af30:	cbnz	r5, af44 <FatFile::seekSet(unsigned long)+0x28>
    af32:	ldrb	r3, [r0, #2]
    // set position to start of file
    m_curCluster = 0;
    af34:	str	r5, [r0, #16]
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    af36:	bic.w	r3, r3, #32
    af3a:	strb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    af3c:	str	r5, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;
    af3e:	movs	r0, #1
    af40:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    af44:	lsls	r0, r3, #28
    af46:	bmi.n	af5e <FatFile::seekSet(unsigned long)+0x42>
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    af48:	lsls	r2, r3, #26
    af4a:	bpl.n	af64 <FatFile::seekSet(unsigned long)+0x48>
    af4c:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    af4e:	ldrh	r3, [r3, #8]
    af50:	cmp.w	r5, r3, lsl #5
    af54:	bls.n	afc0 <FatFile::seekSet(unsigned long)+0xa4>
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;

 fail:
  m_curCluster = tmp;
    af56:	str	r7, [r4, #16]
  return false;
    af58:	movs	r0, #0
    af5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_fileSize) {
    af5e:	ldr	r2, [r4, #28]
    af60:	cmp	r5, r2
    af62:	bhi.n	af56 <FatFile::seekSet(unsigned long)+0x3a>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    af64:	ldr.w	lr, [r4, #8]
    af68:	ldrb	r2, [r4, #2]
    af6a:	ldrb.w	r0, [lr, #6]
    af6e:	adds	r0, #9
    af70:	uxtb	r0, r0
    af72:	subs	r6, r5, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    af74:	tst.w	r2, #64	; 0x40
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    af78:	lsr.w	r6, r6, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    af7c:	beq.n	af8e <FatFile::seekSet(unsigned long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    af7e:	ldr	r3, [r4, #32]
    af80:	add	r6, r3
    af82:	str	r6, [r4, #16]
    goto done;
    af84:	mov	r3, r2
    af86:	b.n	af36 <FatFile::seekSet(unsigned long)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    af88:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    af8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    af8e:	subs	r2, r1, #1
    af90:	lsr.w	r0, r2, r0

  if (nNew < nCur || m_curPosition == 0) {
    af94:	cmp	r6, r0
    af96:	bcs.n	afc4 <FatFile::seekSet(unsigned long)+0xa8>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    af98:	lsls	r3, r3, #25
    af9a:	ite	mi
    af9c:	ldrmi.w	r3, [lr, #32]
    afa0:	ldrpl	r3, [r4, #32]
    afa2:	str	r3, [r4, #16]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    afa4:	add.w	r8, r4, #16
    afa8:	b.n	afba <FatFile::seekSet(unsigned long)+0x9e>
    afaa:	ldr	r1, [r4, #16]
    afac:	ldr	r0, [r4, #8]
    afae:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
    afb2:	cmp	r0, #0
    afb4:	add.w	r6, r6, #4294967295
    afb8:	ble.n	af56 <FatFile::seekSet(unsigned long)+0x3a>
    afba:	mov	r2, r8
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    afbc:	cmp	r6, #0
    afbe:	bne.n	afaa <FatFile::seekSet(unsigned long)+0x8e>
    afc0:	ldrb	r3, [r4, #2]
    afc2:	b.n	af36 <FatFile::seekSet(unsigned long)+0x1a>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());

  if (nNew < nCur || m_curPosition == 0) {
    afc4:	cmp	r1, #0
    afc6:	beq.n	af98 <FatFile::seekSet(unsigned long)+0x7c>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    afc8:	subs	r6, r6, r0
    afca:	b.n	afa4 <FatFile::seekSet(unsigned long)+0x88>

0000afcc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    afcc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    afd0:	mov	r5, r1
    afd2:	mov	r8, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    afd4:	movs	r1, #0
    afd6:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    afd8:	mov	r4, r0
    afda:	mov	r7, r3
    afdc:	ldrb.w	r6, [sp, #24]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    afe0:	bl	106dc <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    afe4:	ldr	r0, [r5, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    afe6:	ldr	r3, [r5, #32]
    afe8:	str	r3, [r4, #12]
    afea:	add.w	r2, r0, #52	; 0x34
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    afee:	and.w	r3, r8, #15
    aff2:	add.w	r2, r2, r3, lsl #5
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    aff6:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
    aff8:	strh.w	r8, [r4, #4]
    affc:	ldrb	r1, [r2, #11]
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    affe:	lsls	r5, r1, #28
    b000:	bmi.n	b028 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    b002:	and.w	r1, r1, #23
    b006:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    b008:	ldrb	r3, [r2, #11]
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    b00a:	strb	r6, [r4, #3]
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    b00c:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
    b010:	it	eq
    b012:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    b016:	and.w	r3, r7, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    b01a:	it	eq
    b01c:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    b01e:	cmp	r3, #1
    b020:	beq.n	b032 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
    b022:	cmp	r3, #2
    b024:	beq.n	b07a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xae>
    b026:	cbz	r3, b070 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa4>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    b028:	movs	r0, #0
    b02a:	strb	r0, [r4, #0]
  m_flags = 0;
    b02c:	strb	r0, [r4, #2]
  return false;
    b02e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    b032:	movs	r3, #2
    b034:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    b036:	ldrb	r1, [r4, #0]
    b038:	tst.w	r1, #17
    b03c:	bne.n	b028 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    b03e:	sxtb	r1, r3
    b040:	and.w	r5, r7, #1024	; 0x400
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    b044:	and.w	r3, r7, #8
    b048:	orrs	r3, r1
    b04a:	uxtb	r3, r3
    b04c:	strb	r3, [r4, #2]

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    b04e:	ldrh.w	lr, [r2, #20]
    b052:	ldrh	r1, [r2, #26]
    b054:	ldr	r6, [r0, #48]	; 0x30
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);

  m_dirSector = m_vol->cacheSectorNumber();
    b056:	str	r6, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    b058:	orr.w	r1, r1, lr, lsl #16

  if (oflag & O_TRUNC) {
    b05c:	cbz	r5, b080 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    b05e:	cbnz	r1, b096 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xca>
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    b060:	orn	r3, r3, #127	; 0x7f
    b064:	strb	r3, [r4, #2]
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    b066:	lsls	r3, r7, #17
    b068:	bmi.n	b088 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    b06a:	movs	r0, #1
    b06c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    b070:	ands.w	r5, r7, #1024	; 0x400
    b074:	bne.n	b028 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    b076:	movs	r1, #1
    b078:	b.n	b044 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x78>
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    b07a:	movs	r3, #3
    b07c:	strb	r3, [r4, #2]
      break;
    b07e:	b.n	b036 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x6a>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    b080:	str	r1, [r4, #32]
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    b082:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    b084:	str	r3, [r4, #28]
    b086:	b.n	b066 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9a>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    b088:	ldr	r1, [r4, #28]
    b08a:	mov	r0, r4
    b08c:	bl	af1c <FatFile::seekSet(unsigned long)>
    b090:	cmp	r0, #0
    b092:	bne.n	b06a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
    b094:	b.n	b028 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);

  if (oflag & O_TRUNC) {
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    b096:	bl	b520 <FatPartition::freeChain(unsigned long)>
    b09a:	cmp	r0, #0
    b09c:	beq.n	b028 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    b09e:	ldrb	r3, [r4, #2]
    b0a0:	b.n	b060 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x94>
    b0a2:	nop

0000b0a4 <FatFile::openNext(FatFile*, int)>:
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    b0a4:	ldrb	r3, [r0, #0]
    b0a6:	cbnz	r3, b0b0 <FatFile::openNext(FatFile*, int)+0xc>
    b0a8:	ldrb	r3, [r1, #0]
    b0aa:	tst.w	r3, #112	; 0x70
    b0ae:	bne.n	b0b4 <FatFile::openNext(FatFile*, int)+0x10>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    b0b0:	movs	r0, #0
}
    b0b2:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    b0b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b0b8:	ldr	r6, [r1, #20]
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    b0ba:	ands.w	r7, r6, #31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    b0be:	sub	sp, #8
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    b0c0:	bne.n	b106 <FatFile::openNext(FatFile*, int)+0x62>
    b0c2:	mov	r9, r2
    b0c4:	mov	r5, r1
    b0c6:	mov	r8, r0
    b0c8:	mov	sl, r7
    b0ca:	b.n	b0d0 <FatFile::openNext(FatFile*, int)+0x2c>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    b0cc:	movs	r7, #0
    b0ce:	ldr	r6, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    b0d0:	movs	r1, #0
    b0d2:	mov	r0, r5
    b0d4:	bl	acac <FatFile::readDirCache(bool)>
    if (!dir) {
    b0d8:	cbz	r0, b106 <FatFile::openNext(FatFile*, int)+0x62>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    b0da:	ldrb	r3, [r0, #0]
    b0dc:	cbz	r3, b106 <FatFile::openNext(FatFile*, int)+0x62>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    b0de:	cmp	r3, #46	; 0x2e
    b0e0:	beq.n	b0cc <FatFile::openNext(FatFile*, int)+0x28>
    b0e2:	cmp	r3, #229	; 0xe5
    b0e4:	beq.n	b0cc <FatFile::openNext(FatFile*, int)+0x28>
    b0e6:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    b0e8:	lsls	r1, r2, #28
    b0ea:	bpl.n	b10e <FatFile::openNext(FatFile*, int)+0x6a>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    b0ec:	cmp	r2, #15
    b0ee:	bne.n	b0cc <FatFile::openNext(FatFile*, int)+0x28>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    b0f0:	lsls	r2, r3, #25
    b0f2:	bpl.n	b0ce <FatFile::openNext(FatFile*, int)+0x2a>
        lfnOrd = ldir->order & 0X1F;
    b0f4:	and.w	r7, r3, #31
        checksum = ldir->checksum;
    b0f8:	ldrb.w	sl, [r0, #13]
    b0fc:	b.n	b0ce <FatFile::openNext(FatFile*, int)+0x2a>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    b0fe:	bl	b750 <FatFile::lfnChecksum(unsigned char*)>
    b102:	cmp	r0, sl
    b104:	beq.n	b112 <FatFile::openNext(FatFile*, int)+0x6e>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    b106:	movs	r0, #0
}
    b108:	add	sp, #8
    b10a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    b10e:	cmp	r7, #0
    b110:	bne.n	b0fe <FatFile::openNext(FatFile*, int)+0x5a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    b112:	str	r7, [sp, #0]
    b114:	mov	r3, r9
    b116:	ubfx	r2, r6, #5, #16
    b11a:	mov	r1, r5
    b11c:	mov	r0, r8
    b11e:	bl	afcc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    b122:	b.n	b108 <FatFile::openNext(FatFile*, int)+0x64>

0000b124 <FatFile::sync()>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    b124:	ldrb	r3, [r0, #0]
    b126:	cbz	r3, b12c <FatFile::sync()+0x8>
    b128:	b.w	a748 <FatFile::sync() [clone .part.41]>
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    b12c:	movs	r0, #1
    b12e:	bx	lr

0000b130 <FatFile::truncate()>:
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    b130:	ldrb	r3, [r0, #2]
    b132:	lsls	r3, r3, #30
    b134:	bpl.n	b16c <FatFile::truncate()+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    b136:	ldr	r3, [r0, #32]
    b138:	cbz	r3, b168 <FatFile::truncate()+0x38>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    b13a:	push	{r4, lr}
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    b13c:	ldr	r1, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    b13e:	sub	sp, #8
    b140:	mov	r4, r0
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    b142:	cbnz	r1, b182 <FatFile::truncate()+0x52>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    b144:	str	r3, [sp, #4]
    m_firstCluster = 0;
    b146:	str	r1, [r0, #32]
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    b148:	mov	r1, r3
    b14a:	ldr	r0, [r4, #8]
    b14c:	bl	b520 <FatPartition::freeChain(unsigned long)>
    b150:	cbz	r0, b17e <FatFile::truncate()+0x4e>
    }
  }
  m_fileSize = m_curPosition;

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    b152:	ldrb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    b154:	ldrb	r2, [r4, #0]
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    b156:	ldr	r1, [r4, #20]
    b158:	str	r1, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    b15a:	orn	r3, r3, #127	; 0x7f
    b15e:	strb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    b160:	cbnz	r2, b19e <FatFile::truncate()+0x6e>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    b162:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    b164:	add	sp, #8
    b166:	pop	{r4, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    b168:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    b16a:	bx	lr
    goto fail;
  }
  return true;

 fail:
  return false;
    b16c:	movs	r0, #0
}
    b16e:	bx	lr
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    b170:	mvn.w	r2, #4026531840	; 0xf0000000
    b174:	ldr	r1, [r4, #16]
    b176:	ldr	r0, [r4, #8]
    b178:	bl	b434 <FatPartition::fatPut(unsigned long, unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    b17c:	cbnz	r0, b196 <FatFile::truncate()+0x66>
    goto fail;
  }
  return true;

 fail:
  return false;
    b17e:	movs	r0, #0
    b180:	b.n	b164 <FatFile::truncate()+0x34>
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    toFree = 0;
    b182:	add	r2, sp, #8
    b184:	movs	r3, #0
    b186:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    b18a:	ldr	r0, [r0, #8]
    b18c:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    b190:	cmp	r0, #0
    b192:	blt.n	b17e <FatFile::truncate()+0x4e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    b194:	bne.n	b170 <FatFile::truncate()+0x40>
    }
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    b196:	ldr	r3, [sp, #4]
    b198:	cmp	r3, #0
    b19a:	beq.n	b152 <FatFile::truncate()+0x22>
    b19c:	b.n	b148 <FatFile::truncate()+0x18>
    b19e:	mov	r0, r4
    b1a0:	bl	a748 <FatFile::sync() [clone .part.41]>
    b1a4:	b.n	b164 <FatFile::truncate()+0x34>
    b1a6:	nop

0000b1a8 <FatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    b1a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b1ac:	ldrb	r3, [r0, #2]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    b1ae:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    b1b0:	mov	r4, r0
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    b1b2:	bmi.n	b1c4 <FatFile::write(void const*, unsigned int)+0x1c>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    b1b4:	ldrb	r3, [r4, #1]
    b1b6:	orr.w	r3, r3, #1
    b1ba:	strb	r3, [r4, #1]
  return -1;
    b1bc:	mov.w	r0, #4294967295
    b1c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b1c4:	mov	r9, r2
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    b1c6:	lsls	r2, r3, #28
    b1c8:	mov	r8, r1
    b1ca:	bmi.w	b36c <FatFile::write(void const*, unsigned int)+0x1c4>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    b1ce:	ldr	r2, [r4, #20]
    b1d0:	mvns	r3, r2
    b1d2:	cmp	r9, r3
    b1d4:	bhi.n	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    b1d6:	cmp.w	r9, #0
    b1da:	beq.w	b38e <FatFile::write(void const*, unsigned int)+0x1e6>
    b1de:	mov	r5, r9
    b1e0:	b.n	b25c <FatFile::write(void const*, unsigned int)+0xb4>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    b1e2:	cmp	r7, #0
    b1e4:	bne.n	b298 <FatFile::write(void const*, unsigned int)+0xf0>
      // start of new cluster
      if (m_curCluster != 0) {
    b1e6:	ldr	r1, [r4, #16]
    b1e8:	cmp	r1, #0
    b1ea:	beq.w	b310 <FatFile::write(void const*, unsigned int)+0x168>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    b1ee:	ldrb	r3, [r4, #2]
    b1f0:	lsls	r3, r3, #25
    b1f2:	bpl.w	b32c <FatFile::write(void const*, unsigned int)+0x184>
    b1f6:	ldr	r3, [r4, #28]
    b1f8:	cmp	r3, r2
    b1fa:	bls.w	b32c <FatFile::write(void const*, unsigned int)+0x184>
          m_curCluster++;
    b1fe:	adds	r3, r1, #1
    b200:	str	r3, [r4, #16]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    b202:	ldrb	r3, [r0, #6]
    b204:	ldr	r2, [r0, #20]
    b206:	subs	r1, #1
    b208:	lsl.w	r3, r1, r3
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    b20c:	cmp.w	r5, #512	; 0x200
    b210:	add.w	r1, r3, r2
    b214:	bcs.n	b2b4 <FatFile::write(void const*, unsigned int)+0x10c>
    b216:	cmp.w	r5, #512	; 0x200
    b21a:	mov	sl, r5
    b21c:	it	cs
    b21e:	movcs.w	sl, #512	; 0x200
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    b222:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    b224:	tst.w	r3, #32
    b228:	ite	eq
    b22a:	moveq	r2, #1
    b22c:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    b22e:	adds	r0, #36	; 0x24
    b230:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    b234:	cmp	r0, #0
    b236:	beq.n	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    b238:	add	r0, r7
    b23a:	mov	r2, sl
    b23c:	mov	r1, r8
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    b23e:	add	r7, sl
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    b240:	bl	cb10 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    b244:	cmp.w	r7, #512	; 0x200
    b248:	beq.w	b35c <FatFile::write(void const*, unsigned int)+0x1b4>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    b24c:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    b24e:	subs.w	r5, r5, sl
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    b252:	add	r2, sl
    src += n;
    b254:	add	r8, sl
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    b256:	str	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    b258:	beq.w	b38e <FatFile::write(void const*, unsigned int)+0x1e6>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    b25c:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    b25e:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    b260:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    b264:	ubfx	r7, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    b268:	beq.n	b1e2 <FatFile::write(void const*, unsigned int)+0x3a>
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;
    b26a:	ldr	r3, [r4, #16]
    b26c:	ldrb	r1, [r0, #6]
    b26e:	ldr	r2, [r0, #20]
    b270:	subs	r3, #2
    b272:	lsls	r3, r1
    b274:	add	r3, r2
    b276:	adds	r1, r3, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    b278:	cbnz	r7, b2a6 <FatFile::write(void const*, unsigned int)+0xfe>
    b27a:	cmp.w	r5, #512	; 0x200
    b27e:	bcs.n	b2b4 <FatFile::write(void const*, unsigned int)+0x10c>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    b280:	ldr	r2, [r4, #20]
    b282:	ldr	r3, [r4, #28]
    b284:	cmp.w	r5, #512	; 0x200
    b288:	mov	sl, r5
    b28a:	it	cs
    b28c:	movcs.w	sl, #512	; 0x200
    b290:	cmp	r2, r3
    b292:	bcc.n	b222 <FatFile::write(void const*, unsigned int)+0x7a>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    b294:	movs	r2, #5
    b296:	b.n	b22e <FatFile::write(void const*, unsigned int)+0x86>
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    b298:	ldr	r6, [r4, #16]
    b29a:	ldrb	r3, [r0, #6]
    b29c:	ldr	r2, [r0, #20]
    b29e:	subs	r6, #2
    b2a0:	lsl.w	r3, r6, r3
    b2a4:	adds	r1, r3, r2
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    b2a6:	rsb	sl, r7, #512	; 0x200
    b2aa:	cmp	sl, r5
    b2ac:	it	cs
    b2ae:	movcs	sl, r5
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    b2b0:	movs	r2, #1
    b2b2:	b.n	b22e <FatFile::write(void const*, unsigned int)+0x86>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    b2b4:	cmp.w	r5, #1024	; 0x400
    b2b8:	bcc.n	b2f0 <FatFile::write(void const*, unsigned int)+0x148>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    b2ba:	ldrb	r3, [r0, #4]
    b2bc:	ldr	r7, [r0, #48]	; 0x30
    b2be:	subs	r3, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    b2c0:	lsrs	r2, r5, #9
    b2c2:	cmp	r3, r2
    b2c4:	it	cs
    b2c6:	movcs	r3, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    b2c8:	cmp	r7, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    b2ca:	mov.w	sl, r3, lsl #9
    b2ce:	bcc.n	b2e2 <FatFile::write(void const*, unsigned int)+0x13a>
    b2d0:	adds	r2, r3, r1
    b2d2:	cmp	r7, r2
    b2d4:	bcs.n	b2e2 <FatFile::write(void const*, unsigned int)+0x13a>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    b2d6:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    b2d8:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    b2dc:	strb.w	r6, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    b2e0:	str	r2, [r0, #48]	; 0x30
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    b2e2:	ldr	r0, [r0, #40]	; 0x28
    b2e4:	mov	r2, r8
    b2e6:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    b2ea:	cmp	r0, #0
    b2ec:	bne.n	b24c <FatFile::write(void const*, unsigned int)+0xa4>
    b2ee:	b.n	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    b2f0:	ldr	r3, [r0, #48]	; 0x30
    b2f2:	cmp	r3, r1
    b2f4:	beq.n	b34e <FatFile::write(void const*, unsigned int)+0x1a6>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    b2f6:	ldr	r0, [r0, #40]	; 0x28
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
    b2f8:	ldrb	r3, [r0, #13]
    b2fa:	cbnz	r3, b324 <FatFile::write(void const*, unsigned int)+0x17c>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    b2fc:	movs	r3, #1
    b2fe:	mov	r2, r8
    b300:	bl	c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    b304:	cmp	r0, #0
    b306:	beq.w	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    b30a:	mov.w	sl, #512	; 0x200
    b30e:	b.n	b24c <FatFile::write(void const*, unsigned int)+0xa4>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    b310:	ldr	r1, [r4, #32]
    b312:	cbz	r1, b37a <FatFile::write(void const*, unsigned int)+0x1d2>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    b314:	str	r1, [r4, #16]
    b316:	ldrb	r3, [r0, #6]
    b318:	ldr	r2, [r0, #20]
    b31a:	subs	r1, #2
    b31c:	lsl.w	r3, r1, r3
    b320:	adds	r1, r3, r2
    b322:	b.n	b27a <FatFile::write(void const*, unsigned int)+0xd2>
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    b324:	mov	r2, r8
    b326:	bl	c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    b32a:	b.n	b304 <FatFile::write(void const*, unsigned int)+0x15c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    b32c:	add.w	r2, r4, #16
    b330:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    b334:	cmp	r0, #0
    b336:	blt.w	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    b33a:	bne.n	b348 <FatFile::write(void const*, unsigned int)+0x1a0>
          // add cluster if at end of chain
          if (!addCluster()) {
    b33c:	mov	r0, r4
    b33e:	bl	a650 <FatFile::addCluster()>
    b342:	cmp	r0, #0
    b344:	beq.w	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
    b348:	ldr	r1, [r4, #16]
    b34a:	ldr	r0, [r4, #8]
    b34c:	b.n	b316 <FatFile::write(void const*, unsigned int)+0x16e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    b34e:	movs	r2, #0
    m_sector = 0XFFFFFFFF;
    b350:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    b354:	strb.w	r2, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    b358:	str	r3, [r0, #48]	; 0x30
    b35a:	b.n	b2f6 <FatFile::write(void const*, unsigned int)+0x14e>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    b35c:	ldr	r0, [r4, #8]
    b35e:	adds	r0, #36	; 0x24
    b360:	bl	8da0 <FsCache::sync()>
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->cacheSyncData()) {
    b364:	cmp	r0, #0
    b366:	bne.w	b24c <FatFile::write(void const*, unsigned int)+0xa4>
    b36a:	b.n	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    b36c:	ldr	r1, [r0, #28]
    b36e:	bl	af1c <FatFile::seekSet(unsigned long)>
    b372:	cmp	r0, #0
    b374:	beq.w	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
    b378:	b.n	b1ce <FatFile::write(void const*, unsigned int)+0x26>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    b37a:	mov	r0, r4
    b37c:	bl	a650 <FatFile::addCluster()>
    b380:	cmp	r0, #0
    b382:	beq.w	b1b4 <FatFile::write(void const*, unsigned int)+0xc>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    b386:	ldr	r1, [r4, #16]
    b388:	str	r1, [r4, #32]
    b38a:	ldr	r0, [r4, #8]
    b38c:	b.n	b316 <FatFile::write(void const*, unsigned int)+0x16e>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    b38e:	ldr	r3, [r4, #28]
    b390:	cmp	r3, r2
    b392:	bcc.n	b3a8 <FatFile::write(void const*, unsigned int)+0x200>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    b394:	ldr	r3, [pc, #40]	; (b3c0 <FatFile::write(void const*, unsigned int)+0x218>)
    b396:	ldr	r3, [r3, #0]
    b398:	cbz	r3, b3b8 <FatFile::write(void const*, unsigned int)+0x210>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    b39a:	ldrb	r3, [r4, #2]
    b39c:	orn	r3, r3, #127	; 0x7f
    b3a0:	strb	r3, [r4, #2]
    b3a2:	mov	r0, r9
    b3a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
    b3a8:	ldrb	r3, [r4, #2]
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    b3aa:	str	r2, [r4, #28]
    m_flags |= FILE_FLAG_DIR_DIRTY;
    b3ac:	orn	r3, r3, #127	; 0x7f
    b3b0:	strb	r3, [r4, #2]
    b3b2:	mov	r0, r9
    b3b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b3b8:	mov	r0, r9
    b3ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b3be:	nop
    b3c0:	.word	0x20002bd8

0000b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    b3c4:	cmp	r1, #1
    b3c6:	bls.n	b42c <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
    b3c8:	ldr	r3, [r0, #28]
    b3ca:	cmp	r1, r3
    b3cc:	bhi.n	b42c <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    b3ce:	push	{r4, r5, r6, lr}
    b3d0:	ldrb	r3, [r0, #7]
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    b3d2:	cmp	r3, #32
    b3d4:	mov	r6, r2
    b3d6:	mov	r5, r0
    b3d8:	mov	r4, r1
    b3da:	beq.n	b40e <FatPartition::fatGet(unsigned long, unsigned long*)+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    b3dc:	cmp	r3, #16
    b3de:	bne.n	b408 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    b3e0:	ldr	r3, [r0, #24]
    b3e2:	ubfx	r1, r1, #8, #8
    b3e6:	add	r1, r3
    b3e8:	movs	r2, #2
    b3ea:	add.w	r0, r0, #564	; 0x234
    b3ee:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    b3f2:	cbz	r0, b408 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    b3f4:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    b3f6:	ldrh.w	r3, [r0, r1, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    b3fa:	ldr	r2, [r5, #28]
    b3fc:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    b3fe:	itte	ls
    b400:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    b402:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    b404:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    b406:	pop	{r4, r5, r6, pc}
  }
  *value = next;
  return 1;

 fail:
  return -1;
    b408:	mov.w	r0, #4294967295
    b40c:	pop	{r4, r5, r6, pc}
    b40e:	ldr	r1, [r0, #24]
    b410:	movs	r2, #2
    b412:	add.w	r1, r1, r4, lsr #7
    b416:	add.w	r0, r0, #564	; 0x234
    b41a:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    b41e:	cmp	r0, #0
    b420:	beq.n	b408 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    b422:	and.w	r1, r4, #127	; 0x7f
    b426:	ldr.w	r3, [r0, r1, lsl #2]
    b42a:	b.n	b3fa <FatPartition::fatGet(unsigned long, unsigned long*)+0x36>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    b42c:	mov.w	r0, #4294967295
}
    b430:	bx	lr
    b432:	nop

0000b434 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    b434:	cmp	r1, #1
    b436:	bls.n	b474 <FatPartition::fatPut(unsigned long, unsigned long)+0x40>
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    b438:	push	{r3, r4, r5, lr}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    b43a:	ldr	r3, [r0, #28]
    b43c:	cmp	r1, r3
    b43e:	bhi.n	b44e <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
    b440:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    b442:	cmp	r3, #32
    b444:	mov	r5, r2
    b446:	mov	r4, r1
    b448:	beq.n	b478 <FatPartition::fatPut(unsigned long, unsigned long)+0x44>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    b44a:	cmp	r3, #16
    b44c:	beq.n	b452 <FatPartition::fatPut(unsigned long, unsigned long)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    b44e:	movs	r0, #0
    b450:	pop	{r3, r4, r5, pc}
    b452:	ldr	r3, [r0, #24]
    b454:	ubfx	r1, r1, #8, #8
    b458:	add	r1, r3
    b45a:	add.w	r0, r0, #564	; 0x234
    b45e:	movs	r2, #3
    b460:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>

  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    b464:	mov	r3, r0
    b466:	cmp	r0, #0
    b468:	beq.n	b44e <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    b46a:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    b46c:	movs	r0, #1
    b46e:	strh.w	r5, [r3, r1, lsl #1]
    goto fail;
  }

 fail:
  return false;
}
    b472:	pop	{r3, r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    b474:	movs	r0, #0
}
    b476:	bx	lr
    b478:	ldr	r1, [r0, #24]
    b47a:	movs	r2, #3
    b47c:	add.w	r0, r0, #564	; 0x234
    b480:	add.w	r1, r1, r4, lsr #7
    b484:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    b488:	mov	r3, r0
    b48a:	cmp	r0, #0
    b48c:	beq.n	b44e <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    b48e:	and.w	r1, r4, #127	; 0x7f
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
    b492:	movs	r0, #1
    b494:	str.w	r5, [r3, r1, lsl #2]
    b498:	pop	{r3, r4, r5, pc}
    b49a:	nop

0000b49c <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    b49c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    b4a0:	ldr	r4, [r0, #12]
    b4a2:	cmp	r4, r1
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    b4a4:	sub	sp, #8
    b4a6:	mov	r5, r0
    b4a8:	mov	r7, r1
    b4aa:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    b4ac:	itte	cc
    b4ae:	movcc	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    b4b0:	movcc	r6, #0
  } else {
    find = m_allocSearchStart;
    setStart = true;
    b4b2:	movcs	r6, #1
    b4b4:	ldr	r3, [r5, #28]
  }
  while (1) {
    find++;
    b4b6:	adds	r4, #1
    if (find > m_lastCluster) {
    b4b8:	cmp	r4, r3
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    b4ba:	add	r2, sp, #4
    b4bc:	mov	r0, r5
    b4be:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    b4c0:	bls.n	b4d6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x3a>
      if (setStart) {
    b4c2:	cbnz	r6, b514 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    b4c4:	ldr	r4, [r5, #12]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    b4c6:	adds	r4, #1
    if (find > m_lastCluster) {
    b4c8:	cmp	r4, r3
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
      setStart = true;
    b4ca:	mov.w	r6, #1
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    b4ce:	add	r2, sp, #4
    b4d0:	mov	r0, r5
    b4d2:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    b4d4:	bhi.n	b4c2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x26>
      }
      find = m_allocSearchStart;
      setStart = true;
      continue;
    }
    if (find == current) {
    b4d6:	cmp	r7, r4
    b4d8:	beq.n	b514 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    b4da:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    b4de:	cmp	r0, #0
    b4e0:	blt.n	b514 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    b4e2:	beq.n	b4b4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
    b4e4:	ldr	r3, [sp, #4]
    b4e6:	cmp	r3, #0
    b4e8:	bne.n	b4b4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
      break;
    }
  }
  if (setStart) {
    b4ea:	cbz	r6, b4ee <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
    m_allocSearchStart = find;
    b4ec:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    b4ee:	mvn.w	r2, #4026531840	; 0xf0000000
    b4f2:	mov	r1, r4
    b4f4:	mov	r0, r5
    b4f6:	bl	b434 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    b4fa:	mov	r6, r0
    b4fc:	cbz	r0, b514 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    b4fe:	cbnz	r7, b506 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x6a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    b500:	str.w	r4, [r8]
  return true;
    b504:	b.n	b516 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x7a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
    b506:	mov	r1, r7
    b508:	mov	r0, r5
    b50a:	mov	r2, r4
    b50c:	bl	b434 <FatPartition::fatPut(unsigned long, unsigned long)>
    b510:	cmp	r0, #0
    b512:	bne.n	b500 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    b514:	movs	r6, #0
}
    b516:	mov	r0, r6
    b518:	add	sp, #8
    b51a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b51e:	nop

0000b520 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    b520:	push	{r4, r5, r6, lr}
    b522:	mov	r5, r0
    b524:	sub	sp, #8
    b526:	mov	r4, r1
    b528:	b.n	b540 <FatPartition::freeChain(unsigned long)+0x20>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    b52a:	bl	b434 <FatPartition::fatPut(unsigned long, unsigned long)>
    b52e:	cbz	r0, b556 <FatPartition::freeChain(unsigned long)+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    b530:	ldr	r3, [r5, #12]
    b532:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    b534:	itt	cc
    b536:	addcc.w	r4, r4, #4294967295
    b53a:	strcc	r4, [r5, #12]
    }
    cluster = next;
    b53c:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    b53e:	cbz	r6, b558 <FatPartition::freeChain(unsigned long)+0x38>
    fg = fatGet(cluster, &next);
    b540:	add	r2, sp, #4
    b542:	mov	r1, r4
    b544:	mov	r0, r5
    b546:	bl	b3c4 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    b54a:	subs	r6, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    b54c:	mov	r1, r4
    b54e:	mov.w	r2, #0
    b552:	mov	r0, r5
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    if (fg < 0) {
    b554:	bge.n	b52a <FatPartition::freeChain(unsigned long)+0xa>
  } while (fg);

  return true;

 fail:
  return false;
    b556:	movs	r0, #0
}
    b558:	add	sp, #8
    b55a:	pop	{r4, r5, r6, pc}

0000b55c <FatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    b55c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b560:	ldrb	r3, [r0, #7]
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    b562:	ldr	r2, [r0, #28]
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    b564:	cmp	r3, #16
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    b566:	add.w	r8, r2, #1
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    b56a:	beq.n	b578 <FatPartition::freeClusterCount()+0x1c>
    b56c:	cmp	r3, #32
    b56e:	beq.n	b578 <FatPartition::freeClusterCount()+0x1c>
  }
  setFreeClusterCount(free);
  return free;

 fail:
  return -1;
    b570:	mov.w	r0, #4294967295
    b574:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    b578:	ldr	r5, [r0, #24]
    while (todo) {
    b57a:	cmp.w	r8, #0
    b57e:	beq.n	b5fe <FatPartition::freeClusterCount()+0xa2>
    b580:	mov	r6, r0
    b582:	add.w	r7, r0, #564	; 0x234
    b586:	movs	r4, #0
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    b588:	mov	r1, r5
    b58a:	movs	r2, #2
    b58c:	mov	r0, r7
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
    b58e:	adds	r5, #1
    b590:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      if (!pc) {
    b594:	cmp	r0, #0
    b596:	beq.n	b570 <FatPartition::freeClusterCount()+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    b598:	ldrb	r3, [r6, #7]
    b59a:	cmp	r3, #16
    b59c:	beq.n	b5cc <FatPartition::freeClusterCount()+0x70>
      if (todo < n) {
    b59e:	cmp.w	r8, #127	; 0x7f
    b5a2:	bhi.n	b5f6 <FatPartition::freeClusterCount()+0x9a>
        n = todo;
    b5a4:	uxth.w	r1, r8
    b5a8:	mov	lr, r8
    b5aa:	subs	r1, #1
    b5ac:	uxth	r1, r1
    b5ae:	add.w	r1, r0, r1, lsl #2
    b5b2:	subs	r3, r0, #4
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat32[i] == 0) {
    b5b4:	ldr.w	r2, [r3, #4]!
    b5b8:	cbnz	r2, b5bc <FatPartition::freeClusterCount()+0x60>
            free++;
    b5ba:	adds	r4, #1
          if (pc->fat16[i] == 0) {
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
    b5bc:	cmp	r3, r1
    b5be:	bne.n	b5b4 <FatPartition::freeClusterCount()+0x58>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    b5c0:	subs.w	r8, r8, lr
    b5c4:	bne.n	b588 <FatPartition::freeClusterCount()+0x2c>
    b5c6:	mov	r0, r4
    b5c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    b5cc:	cmp.w	r8, #255	; 0xff
    b5d0:	bls.n	b604 <FatPartition::freeClusterCount()+0xa8>
    b5d2:	mov.w	lr, #256	; 0x100
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    b5d6:	mov	r3, lr
    b5d8:	subs	r1, r3, #1
    b5da:	uxth	r1, r1
    b5dc:	add.w	r1, r0, r1, lsl #1
    b5e0:	subs	r3, r0, #2
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat16[i] == 0) {
    b5e2:	ldrh.w	r2, [r3, #2]!
    b5e6:	cbnz	r2, b5ea <FatPartition::freeClusterCount()+0x8e>
            free++;
    b5e8:	adds	r4, #1
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
    b5ea:	cmp	r1, r3
    b5ec:	bne.n	b5e2 <FatPartition::freeClusterCount()+0x86>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    b5ee:	subs.w	r8, r8, lr
    b5f2:	bne.n	b588 <FatPartition::freeClusterCount()+0x2c>
    b5f4:	b.n	b5c6 <FatPartition::freeClusterCount()+0x6a>
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    b5f6:	mov.w	lr, #128	; 0x80
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    b5fa:	mov	r1, lr
    b5fc:	b.n	b5aa <FatPartition::freeClusterCount()+0x4e>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    b5fe:	mov	r0, r8
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
  }
  setFreeClusterCount(free);
  return free;
    b600:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
    b604:	uxth.w	r3, r8
    b608:	mov	lr, r8
    b60a:	b.n	b5d8 <FatPartition::freeClusterCount()+0x7c>

0000b60c <FatPartition::init(SdSpiCard*, unsigned char)>:

 fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    b60c:	push	{r3, r4, r5, r6, r7, lr}
    b60e:	mov	r4, r0
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    b610:	movs	r3, #0
  m_allocSearchStart = 1;
    b612:	movs	r5, #1
    b614:	mov.w	r0, #4294967295
    b618:	str	r5, [r4, #12]
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    b61a:	str	r1, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    b61c:	str	r1, [r4, #40]	; 0x28
    b61e:	str.w	r1, [r4, #568]	; 0x238
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    b622:	strb	r3, [r4, #7]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    b624:	strb.w	r3, [r4, #36]	; 0x24
    b628:	strb.w	r3, [r4, #564]	; 0x234
    m_sector = 0XFFFFFFFF;
    b62c:	str	r0, [r4, #48]	; 0x30
    b62e:	str.w	r0, [r4, #576]	; 0x240
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    b632:	mov	r5, r2
    b634:	cbz	r2, b66e <FatPartition::init(SdSpiCard*, unsigned char)+0x62>
    if (part > 4) {
    b636:	cmp	r2, #4
    b638:	bls.n	b63e <FatPartition::init(SdSpiCard*, unsigned char)+0x32>
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    b63a:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    b63c:	pop	{r3, r4, r5, r6, r7, pc}
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    b63e:	add.w	r6, r4, #36	; 0x24
    b642:	mov	r2, r3
    b644:	mov	r1, r3
    b646:	mov	r0, r6
    b648:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    mbr = reinterpret_cast<MbrSector_t*>
          (cacheFetchData(0, FsCache::CACHE_FOR_READ));
    MbrPart_t* mp = mbr->part + part - 1;
    b64c:	add.w	r5, r5, #268435456	; 0x10000000
    b650:	subs	r5, #1
    b652:	lsls	r5, r5, #4
    b654:	add.w	r3, r0, #446	; 0x1be
    b658:	adds	r2, r3, r5

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
    b65a:	cmp	r0, #0
    b65c:	beq.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    b65e:	ldrb	r1, [r2, #4]
    b660:	cmp	r1, #0
    b662:	beq.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    b664:	ldrb	r3, [r3, r5]
    b666:	lsls	r3, r3, #25
    b668:	bne.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    b66a:	ldr	r5, [r2, #8]
    b66c:	b.n	b672 <FatPartition::init(SdSpiCard*, unsigned char)+0x66>
    b66e:	add.w	r6, r4, #36	; 0x24
    b672:	mov	r0, r6
    b674:	movs	r2, #0
    b676:	mov	r1, r5
    b678:	bl	8d44 <FsCache::get(unsigned long, unsigned char)>
    volumeStartSector = getLe32(mp->relativeSectors);
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    b67c:	cmp	r0, #0
    b67e:	beq.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    b680:	ldrb	r3, [r0, #16]
    b682:	cmp	r3, #2
    b684:	bne.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    b686:	ldrh.w	r3, [r0, #11]
    b68a:	cmp.w	r3, #512	; 0x200
    b68e:	bne.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    b690:	ldrb	r6, [r0, #13]
    b692:	strb	r6, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    b694:	subs	r3, r6, #1
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    b696:	movs	r2, #0
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    b698:	cmp	r6, #1
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    b69a:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    b69c:	strb	r2, [r4, #6]
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    b69e:	beq.n	b6c0 <FatPartition::init(SdSpiCard*, unsigned char)+0xb4>
    b6a0:	movs	r2, #1
    b6a2:	mov	r1, r2
    b6a4:	b.n	b6a8 <FatPartition::init(SdSpiCard*, unsigned char)+0x9c>
    b6a6:	mov	r2, r3
    b6a8:	lsls	r1, r1, #1
    b6aa:	uxtb	r1, r1
    b6ac:	adds	r3, r2, #1
    b6ae:	cmp	r6, r1
    b6b0:	uxtb	r3, r3
    b6b2:	beq.n	b6be <FatPartition::init(SdSpiCard*, unsigned char)+0xb2>
    if (tmp == 0) {
    b6b4:	cmp	r3, #9
    b6b6:	bne.n	b6a6 <FatPartition::init(SdSpiCard*, unsigned char)+0x9a>
    b6b8:	strb	r2, [r4, #6]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    b6ba:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    b6bc:	pop	{r3, r4, r5, r6, r7, pc}
    b6be:	strb	r2, [r4, #6]
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    b6c0:	ldrh	r6, [r0, #22]
    b6c2:	str	r6, [r4, #16]
  if (m_sectorsPerFat == 0) {
    b6c4:	cbnz	r6, b6ca <FatPartition::init(SdSpiCard*, unsigned char)+0xbe>
    b6c6:	ldr	r6, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    b6c8:	str	r6, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    b6ca:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    b6cc:	ldrh.w	r3, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    b6d0:	strh	r3, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    b6d2:	add	r1, r5
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    b6d4:	lsls	r3, r3, #5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    b6d6:	add.w	r7, r1, r6, lsl #1
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    b6da:	addw	r3, r3, #511	; 0x1ff
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    b6de:	str	r1, [r4, #24]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    b6e0:	ldrh.w	r1, [r0, #19]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    b6e4:	str	r7, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    b6e6:	add.w	r3, r7, r3, asr #9
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    b6ea:	str	r3, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    b6ec:	cbnz	r1, b6f0 <FatPartition::init(SdSpiCard*, unsigned char)+0xe4>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    b6ee:	ldr	r1, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    b6f0:	subs	r5, r5, r3
    b6f2:	add	r5, r1

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    b6f4:	lsr.w	r2, r5, r2
  m_lastCluster = clusterCount + 1;

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    b6f8:	movw	r3, #4084	; 0xff4
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    b6fc:	adds	r1, r2, #1

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    b6fe:	cmp	r2, r3
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    b700:	str	r1, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    b702:	bls.n	b720 <FatPartition::init(SdSpiCard*, unsigned char)+0x114>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    b704:	movw	r3, #65524	; 0xfff4
    b708:	cmp	r2, r3
    b70a:	ittet	hi
    b70c:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    b70e:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    b710:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    b712:	movhi	r3, #32
    b714:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    b716:	str	r6, [r4, #44]	; 0x2c
    b718:	str.w	r6, [r4, #572]	; 0x23c
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    b71c:	movs	r0, #1
    b71e:	pop	{r3, r4, r5, r6, r7, pc}

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    b720:	movs	r3, #12
    b722:	strb	r3, [r4, #7]
    b724:	b.n	b63a <FatPartition::init(SdSpiCard*, unsigned char)+0x2e>
    b726:	nop

0000b728 <lfnGetChar(DirLfn_t*, unsigned char)>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    b728:	cmp	r1, #4
    b72a:	bls.n	b746 <lfnGetChar(DirLfn_t*, unsigned char)+0x1e>
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    b72c:	cmp	r1, #10
    b72e:	bls.n	b73e <lfnGetChar(DirLfn_t*, unsigned char)+0x16>
    return getLe16(ldir->unicode2 + 2*i - 10);
  } else if (i < 13) {
    b730:	cmp	r1, #12
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    b732:	itte	ls
    b734:	addls.w	r1, r0, r1, lsl #1
    b738:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  return 0;
    b73a:	movhi	r0, #0
}
    b73c:	bx	lr
    b73e:	add.w	r1, r0, r1, lsl #1
    b742:	ldrh	r0, [r1, #4]
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    return getLe16(ldir->unicode2 + 2*i - 10);
    b744:	bx	lr
    b746:	add.w	r1, r0, r1, lsl #1
    b74a:	ldrh.w	r0, [r1, #1]
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
    b74e:	bx	lr

0000b750 <FatFile::lfnChecksum(unsigned char*)>:
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    b750:	push	{r4}
    b752:	subs	r2, r0, #1
    b754:	add.w	r4, r0, #10
  uint8_t sum = 0;
    b758:	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b75a:	ldrb.w	r1, [r2, #1]!
    b75e:	lsrs	r3, r0, #1
    b760:	orr.w	r0, r3, r0, lsl #7
    b764:	uxtab	r0, r1, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b768:	cmp	r4, r2
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b76a:	uxtb	r0, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b76c:	bne.n	b75a <FatFile::lfnChecksum(unsigned char*)+0xa>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    b76e:	pop	{r4}
    b770:	bx	lr
    b772:	nop

0000b774 <FatFile::openCluster(FatFile*)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    b774:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    b776:	ldr	r3, [r1, #12]
    b778:	cbz	r3, b798 <FatFile::openCluster(FatFile*)+0x24>
    b77a:	mov	r5, r0
    b77c:	mov	r4, r1
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
    b77e:	movs	r2, #36	; 0x24
    b780:	movs	r1, #0
    b782:	bl	106dc <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    b786:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    b788:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    b78a:	strb	r3, [r5, #0]
  m_flags = FILE_FLAG_READ;
    b78c:	strb	r0, [r5, #2]
  m_vol = file->m_vol;
    b78e:	ldr	r2, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    b790:	ldr	r3, [r4, #12]
    b792:	str	r3, [r5, #32]
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
    b794:	str	r2, [r5, #8]
  m_firstCluster = file->m_dirCluster;
  return true;
}
    b796:	pop	{r3, r4, r5, pc}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    b798:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    b79a:	ldmia.w	sp!, {r3, r4, r5, lr}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    b79e:	b.w	aadc <FatFile::openRoot(FatVolume*)>
    b7a2:	nop

0000b7a4 <FatFile::getName(char*, unsigned int)>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    b7a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b7a8:	sub	sp, #52	; 0x34
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    b7aa:	ldrb	r3, [r0, #0]
    b7ac:	movs	r4, #0
    b7ae:	strb.w	r4, [sp, #12]
    b7b2:	strb.w	r4, [sp, #13]
    b7b6:	strb.w	r4, [sp, #14]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    b7ba:	mov	r8, r1
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    b7bc:	cbz	r3, b7c4 <FatFile::getName(char*, unsigned int)+0x20>
    b7be:	cmp	r2, #12
    b7c0:	mov	r9, r2
    b7c2:	bhi.n	b7d0 <FatFile::getName(char*, unsigned int)+0x2c>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
    b7c4:	movs	r0, #0
    b7c6:	strb.w	r0, [r8]
  return 0;
}
    b7ca:	add	sp, #52	; 0x34
    b7cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    b7d0:	ldrb	r3, [r0, #3]
    b7d2:	mov	r7, r0
    b7d4:	cmp	r3, #0
    b7d6:	beq.n	b87e <FatFile::getName(char*, unsigned int)+0xda>
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    b7d8:	add	r0, sp, #12
    b7da:	mov	r1, r7
    b7dc:	bl	b774 <FatFile::openCluster(FatFile*)>
    b7e0:	cmp	r0, #0
    b7e2:	beq.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b7e4:	ldrb	r3, [r7, #3]
    b7e6:	cmp	r3, #0
    b7e8:	beq.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    b7ea:	str	r4, [sp, #4]
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b7ec:	movs	r6, #1
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    b7ee:	add.w	r5, r9, #4294967295
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    b7f2:	ldrh	r1, [r7, #4]
    b7f4:	subs	r1, r1, r6
    b7f6:	lsls	r1, r1, #5
    b7f8:	add	r0, sp, #12
    b7fa:	bl	af1c <FatFile::seekSet(unsigned long)>
    b7fe:	cmp	r0, #0
    b800:	beq.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    b802:	movs	r1, #0
    b804:	add	r0, sp, #12
    b806:	bl	acac <FatFile::readDirCache(bool)>
    if (!ldir) {
    b80a:	mov	fp, r0
    b80c:	cmp	r0, #0
    b80e:	beq.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
    b810:	ldrb	r3, [r0, #11]
    b812:	cmp	r3, #15
    b814:	bne.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (order != (ldir->order & 0X1F)) {
    b816:	ldrb	r3, [r0, #0]
    b818:	and.w	r3, r3, #31
    b81c:	cmp	r6, r3
    b81e:	bne.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
  return 0;
}
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
    b820:	subs	r3, r6, #1
    b822:	add.w	r4, r3, r3, lsl #1
    b826:	add.w	r4, r3, r4, lsl #2
    b82a:	mov	r3, r4
    b82c:	add.w	sl, r8, r4
    b830:	add.w	r2, r4, #13
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    b834:	subs	r1, r3, r4
    b836:	uxtb	r1, r1
    b838:	mov	r0, fp
    b83a:	bl	b728 <lfnGetChar(DirLfn_t*, unsigned char)>
    if (c == 0 || k >= (n - 1)) {
    b83e:	cbz	r0, b888 <FatFile::getName(char*, unsigned int)+0xe4>
    b840:	cmp	r5, r3
    b842:	bls.n	b888 <FatFile::getName(char*, unsigned int)+0xe4>
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    b844:	cmp	r0, #126	; 0x7e
    b846:	add.w	r3, r3, #1
    b84a:	ite	ls
    b84c:	uxtbls	r0, r0
    b84e:	movhi	r0, #63	; 0x3f
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    b850:	cmp	r2, r3
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    b852:	strb.w	r0, [sl], #1
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    b856:	bne.n	b834 <FatFile::getName(char*, unsigned int)+0x90>
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte.
  if (k >= n) {  // <<----------added
    k = n - 1;   // <<--------- added
    b858:	cmp	r9, r2
    b85a:	it	ls
    b85c:	movls	r2, r5
  }             // <<---------added
  name[k] = '\0';
    b85e:	ldrb.w	r3, [sp, #4]
    b862:	strb.w	r3, [r8, r2]
    if (order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    n = lfnGetName(ldir, name, size);
    if (n == 0) {
    b866:	cmp	r2, #0
    b868:	beq.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    b86a:	ldrb.w	r3, [fp]
    b86e:	lsls	r3, r3, #25
    b870:	bmi.n	b88c <FatFile::getName(char*, unsigned int)+0xe8>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b872:	adds	r6, #1
    b874:	ldrb	r3, [r7, #3]
    b876:	uxtb	r6, r6
    b878:	cmp	r3, r6
    b87a:	bcs.n	b7f2 <FatFile::getName(char*, unsigned int)+0x4e>
    b87c:	b.n	b7c4 <FatFile::getName(char*, unsigned int)+0x20>
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    return getSFN(name);
    b87e:	bl	c048 <FatFile::getSFN(char*)>
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
  return 0;
}
    b882:	add	sp, #52	; 0x34
    b884:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    b888:	mov	r2, r3
    b88a:	b.n	b858 <FatFile::getName(char*, unsigned int)+0xb4>
    b88c:	mov	r0, r2
    b88e:	b.n	b7ca <FatFile::getName(char*, unsigned int)+0x26>

0000b890 <FatFile::parsePathName(char const*, fname_t*, char const**)>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    b890:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    b894:	ldrb	r3, [r0, #0]
    b896:	cmp	r3, #32
    b898:	bne.n	b8a2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x12>
    b89a:	ldrb.w	r3, [r0, #1]!
    b89e:	cmp	r3, #32
    b8a0:	beq.n	b89a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa>
    path++;
  }
  fname->lfn = path;
    b8a2:	str	r0, [r1, #8]

  for (len = 0; ; len++) {
    c = path[len];
    b8a4:	ldrb	r3, [r0, #0]
    if (c == 0 || isDirSeparator(c)) {
    b8a6:	cmp	r3, #0
    b8a8:	beq.w	baba <FatFile::parsePathName(char const*, fname_t*, char const**)+0x22a>
    b8ac:	cmp	r3, #47	; 0x2f
    b8ae:	beq.n	b910 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x80>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    b8b0:	cmp	r3, #92	; 0x5c
    b8b2:	beq.n	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    b8b4:	sub.w	r4, r3, #34	; 0x22
    b8b8:	uxtb	r4, r4
    b8ba:	cmp	r4, #29
    b8bc:	bls.n	b900 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x70>
    b8be:	ldr.w	lr, [pc, #536]	; bad8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>
    b8c2:	adds	r6, r0, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    b8c4:	movs	r4, #0
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    b8c6:	cmp	r3, #124	; 0x7c
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    b8c8:	sub.w	r5, r3, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    b8cc:	mov	r7, r6
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    b8ce:	beq.n	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    b8d0:	cmp	r5, #94	; 0x5e
    b8d2:	bhi.n	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    b8d4:	ldrb.w	r3, [r6], #1
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    b8d8:	sub.w	r5, r3, #34	; 0x22
    b8dc:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    b8de:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    b8e0:	cmp	r3, #0
    b8e2:	beq.w	ba8c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1fc>
    b8e6:	cmp	r3, #47	; 0x2f
    b8e8:	beq.n	b912 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x82>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    b8ea:	cmp	r3, #92	; 0x5c
    b8ec:	lsr.w	r7, lr, r5
    b8f0:	beq.n	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    b8f2:	cmp	r5, #29
    b8f4:	bhi.n	b8c6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    b8f6:	lsls	r7, r7, #31
    b8f8:	bpl.n	b8c6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    b8fa:	movs	r0, #0
    b8fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    b900:	ldr	r5, [pc, #468]	; (bad8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>)
    b902:	lsr.w	r4, r5, r4
    b906:	lsls	r4, r4, #31
    b908:	bpl.n	b8be <FatFile::parsePathName(char const*, fname_t*, char const**)+0x2e>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    b90a:	movs	r0, #0
    b90c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    b910:	movs	r4, #0
    b912:	adds	r7, r0, r4
    b914:	mov	r6, r7
    b916:	mov	r5, r4
    b918:	movs	r3, #47	; 0x2f
    b91a:	b.n	b922 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x92>
    b91c:	ldrb.w	r3, [r6, #1]!
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    b920:	adds	r5, #1
    b922:	cmp	r3, #32
    b924:	beq.n	b91c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
    b926:	cmp	r3, #47	; 0x2f
    b928:	beq.n	b91c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
  *ptr = &path[end];
    b92a:	add	r5, r0
    b92c:	str	r5, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    b92e:	cbz	r4, b944 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb4>
    b930:	mov	r2, r7
    c = path[len - 1];
    b932:	ldrb.w	r3, [r2, #-1]!
    if (c != '.' && c != ' ') {
    b936:	cmp	r3, #46	; 0x2e
    b938:	beq.n	b940 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb0>
    b93a:	cmp	r3, #32
    b93c:	bne.w	ba92 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x202>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    b940:	subs	r4, #1
    b942:	bne.n	b932 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa2>
    b944:	mov.w	r5, #4294967295
    b948:	mov	r3, r4
  // Max length of LFN is 255.
  if (len > 255) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
    b94a:	str	r3, [r1, #4]
    b94c:	add.w	r6, r1, #23
    b950:	add.w	r3, r1, #12
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    b954:	movs	r2, #32
    b956:	strb.w	r2, [r3, #1]!
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    b95a:	cmp	r3, r6
    b95c:	bne.n	b956 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xc6>
    b95e:	subs	r6, r0, #1
    b960:	movs	r2, #0
    b962:	b.n	b966 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd6>
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    b964:	adds	r2, #1
    b966:	ldrb.w	r3, [r6, #1]!
    b96a:	cmp	r3, #46	; 0x2e
    b96c:	beq.n	b964 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
    b96e:	cmp	r3, #32
    b970:	beq.n	b964 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    b972:	clz	ip, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    b976:	adds	r6, r5, #1
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    b978:	mov.w	ip, ip, lsr #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    b97c:	beq.n	b998 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    b97e:	ldrb	r7, [r0, r5]
    b980:	cmp	r7, #46	; 0x2e
    b982:	add.w	r6, r0, r5
    b986:	bne.n	b992 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x102>
    b988:	b.n	b998 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    b98a:	ldrb.w	r7, [r6, #-1]!
    b98e:	cmp	r7, #46	; 0x2e
    b990:	beq.n	b998 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    b992:	adds.w	r5, r5, #4294967295
    b996:	bcs.n	b98a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xfa>
  for (; si < len; si++) {
    b998:	cmp	r2, r4
    b99a:	mov.w	r9, #0
    b99e:	bge.w	bac4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x234>
    b9a2:	mov	r6, r9
    b9a4:	mov	sl, r9
    b9a6:	movs	r7, #7
    b9a8:	mov.w	r8, #8
    b9ac:	b.n	b9fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16a>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    b9ae:	cmp	r3, #46	; 0x2e
    b9b0:	beq.n	ba42 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b2>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    b9b2:	cmp	r3, #34	; 0x22
    b9b4:	beq.n	b9ce <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    b9b6:	cmp	r3, #124	; 0x7c
    b9b8:	beq.n	b9ce <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    b9ba:	sub.w	lr, r3, #42	; 0x2a
    b9be:	cmp.w	lr, #5
    b9c2:	bls.n	ba56 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1c6>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    b9c4:	sub.w	lr, r3, #58	; 0x3a
    b9c8:	cmp.w	lr, #5
    b9cc:	bhi.n	ba80 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1f0>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    b9ce:	cmp	r5, r2
    b9d0:	beq.n	ba46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    b9d2:	cmp	r7, r6
    b9d4:	bcc.n	ba2a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
    b9d6:	mov.w	ip, #0
      c = '_';
    b9da:	movs	r3, #95	; 0x5f
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    b9dc:	add.w	lr, r6, #1
    b9e0:	add.w	fp, r1, r6
    b9e4:	uxtb.w	r6, lr
      if (i < 7) {
    b9e8:	cmp	r6, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    b9ea:	strb.w	r3, [fp, #13]
      if (i < 7) {
    b9ee:	bhi.n	b9f2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
        fname->seqPos = i;
    b9f0:	strb	r6, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    b9f2:	adds	r2, #1
    b9f4:	cmp	r2, r4
    b9f6:	bge.n	ba08 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
    b9f8:	ldrb	r3, [r0, r2]
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    b9fa:	cmp	r3, #32
    b9fc:	bne.n	b9ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x11e>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    b9fe:	adds	r2, #1
    ba00:	cmp	r2, r4
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    ba02:	mov.w	ip, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    ba06:	blt.n	b9f8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x168>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    ba08:	ldrb	r3, [r1, #13]
    ba0a:	cmp	r3, #32
    ba0c:	beq.w	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (is83) {
    ba10:	cmp.w	ip, #0
    ba14:	beq.n	baa6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x216>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    ba16:	tst.w	sl, r9
    ba1a:	it	ne
    ba1c:	movne.w	r9, #2
    ba20:	strb.w	r9, [r1]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    ba24:	movs	r0, #1
    ba26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    ba2a:	cmp	r7, #10
    ba2c:	beq.n	ba9e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    ba2e:	cmp	r5, r2
    ba30:	blt.n	ba9e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    ba32:	mov	r2, r5
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    ba34:	movs	r7, #10
      i = 8;    // Place for extension.
    ba36:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    ba38:	mov.w	r8, #16
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    ba3c:	mov.w	ip, #0
    ba40:	b.n	b9f2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    ba42:	cmp	r5, r2
    ba44:	bne.n	b9fe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16e>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    ba46:	cmp	r7, #10
    ba48:	beq.n	ba9e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    ba4a:	mov	r2, r5
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    ba4c:	movs	r7, #10
      i = 8;    // Place for extension.
    ba4e:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    ba50:	mov.w	r8, #16
    ba54:	b.n	b9f2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    ba56:	cmp	r3, #45	; 0x2d
    ba58:	bne.n	b9ce <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    ba5a:	sub.w	lr, r3, #33	; 0x21
    ba5e:	cmp.w	lr, #93	; 0x5d
    ba62:	bhi.n	b9ce <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    ba64:	cmp	r5, r2
    ba66:	beq.n	ba46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
    ba68:	cmp	r7, r6
    ba6a:	bcc.n	ba2a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    ba6c:	sub.w	lr, r3, #97	; 0x61
    ba70:	cmp.w	lr, #25
    ba74:	bhi.n	bac8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x238>
        c += 'A' - 'a';
    ba76:	subs	r3, #32
    ba78:	uxtb	r3, r3
        lc |= bit;
    ba7a:	orr.w	r9, r8, r9
    ba7e:	b.n	b9dc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    ba80:	sub.w	lr, r3, #91	; 0x5b
    ba84:	cmp.w	lr, #2
    ba88:	bls.n	b9ce <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    ba8a:	b.n	ba5a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1ca>
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    ba8c:	str	r7, [r2, #0]
    ba8e:	adds	r7, r0, r4
    ba90:	b.n	b930 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa0>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
    ba92:	cmp	r4, #255	; 0xff
    ba94:	bgt.w	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    ba98:	subs	r5, r4, #1
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    c = path[len - 1];
    ba9a:	mov	r3, r4
    ba9c:	b.n	b94a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    ba9e:	ldrb	r3, [r1, #13]
    baa0:	cmp	r3, #32
    baa2:	beq.w	b8fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    baa6:	ldrb	r3, [r1, #12]
    baa8:	add	r3, r1
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    baaa:	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
    baac:	movs	r4, #126	; 0x7e
    fname->sfn[fname->seqPos + 1] = '1';
    baae:	movs	r2, #49	; 0x31
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    bab0:	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    bab2:	strb	r4, [r3, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    bab4:	strb	r2, [r3, #14]
    bab6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    baba:	str	r0, [r2, #0]
    babc:	mov	r4, r3
    babe:	mov.w	r5, #4294967295
    bac2:	b.n	b94a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    bac4:	mov	sl, r9
    bac6:	b.n	ba08 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    bac8:	sub.w	lr, r3, #65	; 0x41
    bacc:	cmp.w	lr, #25
        uc |= bit;
    bad0:	it	ls
    bad2:	orrls.w	sl, r8, sl
    bad6:	b.n	b9dc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    bad8:	.word	0x35000101

0000badc <FatFile::remove()>:

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    badc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    bae0:	ldrb	r2, [r0, #2]

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    bae2:	sub	sp, #40	; 0x28
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    bae4:	movs	r3, #0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    bae6:	lsls	r2, r2, #30
    bae8:	strb.w	r3, [sp, #4]
    baec:	strb.w	r3, [sp, #5]
    baf0:	strb.w	r3, [sp, #6]
    baf4:	bpl.n	bb3c <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    baf6:	ldr	r1, [r0, #32]
    baf8:	mov	r5, r0
    bafa:	cbnz	r1, bb46 <FatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    bafc:	movs	r1, #1
    bafe:	mov	r0, r5
    bb00:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    bb04:	cbz	r0, bb3c <FatFile::remove()+0x60>
    bb06:	subs	r1, r0, #1
    bb08:	add.w	r7, r0, #10
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    bb0c:	movs	r4, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    bb0e:	lsrs	r2, r4, #1
    bb10:	ldrb.w	r6, [r1, #1]!
    bb14:	orr.w	r3, r2, r4, lsl #7
    bb18:	uxtab	r3, r6, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    bb1c:	cmp	r7, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    bb1e:	uxtb	r4, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    bb20:	bne.n	bb0e <FatFile::remove()+0x32>
    goto fail;
  }
  checksum = lfnChecksum(dir->name);

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    bb22:	mov.w	r8, #229	; 0xe5
    bb26:	strb.w	r8, [r0]
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    bb2a:	ldr	r6, [r5, #8]

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    bb2c:	movs	r3, #0
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    bb2e:	add.w	r0, r6, #36	; 0x24
    bb32:	strb	r3, [r5, #0]
  m_flags = 0;
    bb34:	strb	r3, [r5, #2]
    bb36:	bl	8da0 <FsCache::sync()>
    bb3a:	cbnz	r0, bb52 <FatFile::remove()+0x76>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    bb3c:	movs	r6, #0
}
    bb3e:	mov	r0, r6
    bb40:	add	sp, #40	; 0x28
    bb42:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    bb46:	ldr	r0, [r0, #8]
    bb48:	bl	b520 <FatPartition::freeChain(unsigned long)>
    bb4c:	cmp	r0, #0
    bb4e:	bne.n	bafc <FatFile::remove()+0x20>
    bb50:	b.n	bb3c <FatFile::remove()+0x60>
    bb52:	add.w	r0, r6, #564	; 0x234
    bb56:	bl	8da0 <FsCache::sync()>
    bb5a:	cmp	r0, #0
    bb5c:	beq.n	bb3c <FatFile::remove()+0x60>
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    bb5e:	ldr	r0, [r6, #0]
    bb60:	bl	c4f8 <SdSpiCard::syncDevice()>
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    bb64:	mov	r6, r0
    bb66:	cmp	r0, #0
    bb68:	beq.n	bb3c <FatFile::remove()+0x60>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    bb6a:	ldrb	r3, [r5, #3]
    bb6c:	cmp	r3, #0
    bb6e:	beq.n	bb3e <FatFile::remove()+0x62>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    bb70:	add	r0, sp, #4
    bb72:	mov	r1, r5
    bb74:	bl	b774 <FatFile::openCluster(FatFile*)>
    bb78:	cmp	r0, #0
    bb7a:	beq.n	bb3c <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    bb7c:	ldrb	r3, [r5, #3]
    bb7e:	cmp	r3, #0
    bb80:	beq.n	bb3c <FatFile::remove()+0x60>
    bb82:	movs	r7, #1
    bb84:	b.n	bbc6 <FatFile::remove()+0xea>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    bb86:	add	r0, sp, #4
    bb88:	bl	acac <FatFile::readDirCache(bool)>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    bb8c:	adds	r3, r7, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
    bb8e:	cmp	r0, #0
    bb90:	beq.n	bb3c <FatFile::remove()+0x60>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    bb92:	ldrb	r2, [r0, #11]
    bb94:	cmp	r2, #15
    bb96:	bne.n	bb3c <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    bb98:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    bb9a:	and.w	r1, r2, #31
    bb9e:	cmp	r7, r1
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    bba0:	uxtb	r7, r3
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    bba2:	bne.n	bb3c <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    bba4:	ldrb	r3, [r0, #13]
    bba6:	cmp	r3, r4
    bba8:	bne.n	bb3c <FatFile::remove()+0x60>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    bbaa:	strb.w	r8, [r0]
    m_vol->cacheDirty();
    bbae:	ldr	r1, [r5, #8]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    bbb0:	ldrb.w	r3, [r1, #36]	; 0x24
    bbb4:	orr.w	r3, r3, #1
    bbb8:	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
    bbbc:	lsls	r3, r2, #25
    bbbe:	bmi.n	bbda <FatFile::remove()+0xfe>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    bbc0:	ldrb	r3, [r5, #3]
    bbc2:	cmp	r3, r7
    bbc4:	bcc.n	bb3c <FatFile::remove()+0x60>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    bbc6:	ldrh	r1, [r5, #4]
    bbc8:	subs	r1, r1, r7
    bbca:	lsls	r1, r1, #5
    bbcc:	add	r0, sp, #4
    bbce:	bl	af1c <FatFile::seekSet(unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    bbd2:	movs	r1, #0
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    bbd4:	cmp	r0, #0
    bbd6:	bne.n	bb86 <FatFile::remove()+0xaa>
    bbd8:	b.n	bb3c <FatFile::remove()+0x60>
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
    bbda:	ldr	r4, [r5, #8]
    bbdc:	add.w	r0, r4, #36	; 0x24
    bbe0:	bl	8da0 <FsCache::sync()>
    bbe4:	cmp	r0, #0
    bbe6:	beq.n	bb3c <FatFile::remove()+0x60>
    bbe8:	add.w	r0, r4, #564	; 0x234
    bbec:	bl	8da0 <FsCache::sync()>
    bbf0:	cmp	r0, #0
    bbf2:	beq.n	bb3c <FatFile::remove()+0x60>
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    bbf4:	ldr	r0, [r4, #0]
    bbf6:	bl	c4f8 <SdSpiCard::syncDevice()>
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    bbfa:	cmp	r0, #0
    bbfc:	beq.n	bb3c <FatFile::remove()+0x60>
    bbfe:	b.n	bb3e <FatFile::remove()+0x62>

0000bc00 <FatFile::lfnUniqueSfn(fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    bc00:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    bc04:	ldrb	r7, [r1, #12]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    bc06:	mov	r6, r1
    bc08:	mov	r4, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    bc0a:	add.w	r5, r1, #13
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    bc0e:	mov.w	r8, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    bc12:	mov.w	r9, #126	; 0x7e
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    bc16:	ldr	r0, [r6, #4]
    bc18:	ldr	r1, [r6, #8]
    bc1a:	add.w	r3, r8, r0
    bc1e:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    bc20:	cbz	r0, bc34 <FatFile::lfnUniqueSfn(fname_t*)+0x34>
    bc22:	add	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    bc24:	ldrb.w	r2, [r1], #1
    bc28:	add.w	r3, r3, r3, lsl #5
    bc2c:	eors	r3, r2
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    bc2e:	cmp	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    bc30:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    bc32:	bne.n	bc24 <FatFile::lfnUniqueSfn(fname_t*)+0x24>
    bc34:	cmp	r7, #3
    bc36:	it	cs
    bc38:	movcs	r7, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    bc3a:	adds	r2, r7, #4
    bc3c:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    bc3e:	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    bc42:	adds	r0, r6, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    bc44:	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    bc46:	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    bc48:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    bc4a:	ite	ls
    bc4c:	addls	r1, #48	; 0x30
    bc4e:	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    bc50:	cmp	r7, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
    bc52:	mov.w	r3, r3, lsr #4
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    bc56:	strb	r1, [r0, #13]
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    bc58:	bcc.n	bc3e <FatFile::lfnUniqueSfn(fname_t*)+0x3e>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    bc5a:	adds	r3, r6, r7
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    bc5c:	movs	r1, #0
    bc5e:	strb.w	r9, [r3, #13]
    bc62:	mov	r0, r4
    bc64:	bl	af1c <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    bc68:	movs	r1, #1
    bc6a:	mov	r0, r4
    bc6c:	bl	acac <FatFile::readDirCache(bool)>
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    bc70:	movs	r2, #11
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    bc72:	mov	r3, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    bc74:	mov	r1, r0
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    bc76:	cbz	r0, bca4 <FatFile::lfnUniqueSfn(fname_t*)+0xa4>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    bc78:	ldrb.w	lr, [r3]
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    bc7c:	mov	r0, r5
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    bc7e:	cmp.w	lr, #0
    bc82:	beq.n	bcb0 <FatFile::lfnUniqueSfn(fname_t*)+0xb0>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    bc84:	ldrb	r3, [r3, #11]
    bc86:	lsls	r3, r3, #28
    bc88:	bmi.n	bc68 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    bc8a:	bl	105b0 <memcmp>
    bc8e:	cmp	r0, #0
    bc90:	bne.n	bc68 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    bc92:	add.w	r8, r8, #1
    bc96:	uxth.w	r8, r8
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    bc9a:	cmp.w	r8, #100	; 0x64
    bc9e:	bne.n	bc16 <FatFile::lfnUniqueSfn(fname_t*)+0x16>
 fail:
  return false;

 done:
  return true;
}
    bca0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
        if (!getError()) {
    bca4:	ldrb	r0, [r4, #1]
    bca6:	clz	r0, r0
    bcaa:	lsrs	r0, r0, #5
    bcac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

 fail:
  return false;

 done:
  return true;
    bcb0:	movs	r0, #1
    bcb2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bcb6:	nop

0000bcb8 <FatFile::open(FatFile*, fname_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    bcb8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    bcbc:	ldrb	r4, [r1, #0]
    bcbe:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    bcc2:	sub	sp, #52	; 0x34
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    bcc4:	beq.n	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    bcc6:	ldrb	r4, [r0, #0]
    bcc8:	cbz	r4, bcd2 <FatFile::open(FatFile*, fname_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    bcca:	movs	r0, #0
}
    bccc:	add	sp, #52	; 0x34
    bcce:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    bcd2:	ldrb	r4, [r2, #0]
  uint16_t curIndex;
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;
    bcd4:	ldr.w	sl, [r2, #4]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    bcd8:	lsls	r4, r4, #30
    bcda:	bne.n	bd62 <FatFile::open(FatFile*, fname_t*, int)+0xaa>
    bcdc:	mov.w	r8, #1
    bce0:	mov	r6, r1
    bce2:	mov	fp, r2
    bce4:	str	r0, [sp, #36]	; 0x24
    bce6:	movs	r1, #0
    bce8:	mov	r0, r6
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint16_t freeIndex = 0;
    bcea:	mov	r7, r1
    bcec:	str	r3, [sp, #28]
    bcee:	bl	af1c <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    bcf2:	add.w	r3, fp, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    bcf6:	str	r7, [sp, #24]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    bcf8:	str	r7, [sp, #12]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    bcfa:	mov	r4, r7
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    bcfc:	mov	r9, r7
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    bcfe:	str	r7, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    bd00:	str	r3, [sp, #16]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    bd02:	movs	r1, #1
    bd04:	mov	r0, r6
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    bd06:	ldr	r5, [r6, #20]
    dir = dirFile->readDirCache(true);
    bd08:	bl	acac <FatFile::readDirCache(bool)>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    bd0c:	ubfx	r5, r5, #5, #16
    dir = dirFile->readDirCache(true);
    if (!dir) {
    bd10:	mov	r3, r0
    bd12:	cmp	r0, #0
    bd14:	beq.w	be30 <FatFile::open(FatFile*, fname_t*, int)+0x178>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    bd18:	ldrb	r2, [r0, #0]
    bd1a:	cmp	r2, #229	; 0xe5
    bd1c:	beq.n	bd94 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
    bd1e:	cmp	r2, #0
    bd20:	beq.n	bd94 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
      if (dir->name[0] == FAT_NAME_FREE) {
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    bd22:	cmp	r4, r8
    bd24:	it	cc
    bd26:	movcc	r4, #0
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    bd28:	cmp	r2, #46	; 0x2e
    bd2a:	beq.n	bd8e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    bd2c:	ldrb	r1, [r3, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    bd2e:	cmp	r1, #15
    bd30:	beq.n	bdb0 <FatFile::open(FatFile*, fname_t*, int)+0xf8>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
    bd32:	and.w	r1, r1, #8
    bd36:	and.w	r2, r1, #255	; 0xff
    bd3a:	cbnz	r1, bd8e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (lfnOrd) {
    bd3c:	cmp.w	r9, #0
    bd40:	bne.w	c004 <FatFile::open(FatFile*, fname_t*, int)+0x34c>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    bd44:	mov	r0, r3
    bd46:	movs	r2, #11
    bd48:	ldr	r1, [sp, #16]
    bd4a:	bl	105b0 <memcmp>
    bd4e:	cmp	r0, #0
    bd50:	bne.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    bd52:	ldrb.w	r3, [fp]
    bd56:	lsls	r0, r3, #31
    bd58:	bpl.w	c02c <FatFile::open(FatFile*, fname_t*, int)+0x374>
          goto found;
        }
        fnameFound = true;
    bd5c:	movs	r3, #1
    bd5e:	str	r3, [sp, #20]
    bd60:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    bd62:	ldr	r5, [pc, #732]	; (c040 <FatFile::open(FatFile*, fname_t*, int)+0x388>)
    bd64:	add.w	r4, sl, #12
    bd68:	umull	r4, r8, r5, r4
    bd6c:	mov.w	r8, r8, lsr #2
    bd70:	add.w	r8, r8, #1
    bd74:	uxtb.w	r8, r8
    bd78:	b.n	bce0 <FatFile::open(FatFile*, fname_t*, int)+0x28>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    bd7a:	ldr	r1, [sp, #12]
    bd7c:	subs	r1, #1
    bd7e:	uxtb	r1, r1
    bd80:	cmp	r2, r1
    bd82:	str	r1, [sp, #12]
    bd84:	bne.n	bd8e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    bd86:	ldrb	r2, [r3, #13]
    bd88:	ldr	r1, [sp, #24]
    bd8a:	cmp	r1, r2
    bd8c:	beq.n	bdc6 <FatFile::open(FatFile*, fname_t*, int)+0x10e>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    bd8e:	mov.w	r9, #0
    bd92:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    bd94:	cmp	r4, #0
    bd96:	it	eq
    bd98:	moveq	r7, r5
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    bd9a:	cmp	r4, r8
        freeFound++;
    bd9c:	itt	cc
    bd9e:	addcc	r4, #1
    bda0:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    bda2:	cmp	r2, #0
    bda4:	beq.n	be38 <FatFile::open(FatFile*, fname_t*, int)+0x180>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    bda6:	cmp	r2, #229	; 0xe5
    bda8:	bne.n	bd28 <FatFile::open(FatFile*, fname_t*, int)+0x70>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    bdaa:	mov.w	r9, #0
    bdae:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    bdb0:	cmp.w	r9, #0
    bdb4:	bne.n	bd7a <FatFile::open(FatFile*, fname_t*, int)+0xc2>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
    bdb6:	lsls	r5, r2, #25
    bdb8:	bpl.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    bdba:	and.w	r9, r2, #31
        checksum = ldir->checksum;
    bdbe:	ldrb	r2, [r3, #13]
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    bdc0:	str.w	r9, [sp, #12]
        checksum = ldir->checksum;
    bdc4:	str	r2, [sp, #24]
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    bdc6:	ldr	r2, [sp, #12]
    bdc8:	subs	r2, #1
    bdca:	add.w	r5, r2, r2, lsl #1
    bdce:	add.w	r5, r2, r5, lsl #2
      if (k >= len) {
    bdd2:	cmp	sl, r5
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    bdd4:	mov	r2, r5
      if (k >= len) {
    bdd6:	bls.n	bd8e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    bdd8:	add.w	r1, r5, #13
    bddc:	str.w	r9, [sp, #32]
    bde0:	mov	r9, r1
    bde2:	b.n	be0c <FatFile::open(FatFile*, fname_t*, int)+0x154>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    bde4:	ldr.w	r0, [fp, #8]
    bde8:	ldrb	r2, [r0, r2]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    bdea:	cmp.w	ip, #25
    bdee:	it	ls
    bdf0:	addls	r1, #32
    bdf2:	sub.w	r0, r2, #65	; 0x41
    bdf6:	it	ls
    bdf8:	uxtbls	r1, r1
    bdfa:	cmp	r0, #25
    bdfc:	itt	ls
    bdfe:	addls	r2, #32
    be00:	uxtbls	r2, r2
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    be02:	cmp	r1, r2
    be04:	bne.n	bd8e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    be06:	cmp	lr, r9
    be08:	beq.n	be90 <FatFile::open(FatFile*, fname_t*, int)+0x1d8>
    be0a:	mov	r2, lr
        uint16_t u = lfnGetChar(ldir, i);
    be0c:	subs	r1, r2, r5
    be0e:	uxtb	r1, r1
    be10:	mov	r0, r3
    be12:	bl	b728 <lfnGetChar(DirLfn_t*, unsigned char)>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    be16:	uxtb	r1, r0
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    be18:	cmp	sl, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    be1a:	sub.w	ip, r1, #65	; 0x41
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    be1e:	add.w	lr, r2, #1
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    be22:	beq.w	bff6 <FatFile::open(FatFile*, fname_t*, int)+0x33e>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    be26:	cmp	r0, #255	; 0xff
    be28:	bls.n	bde4 <FatFile::open(FatFile*, fname_t*, int)+0x12c>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    be2a:	mov.w	r9, #0
    be2e:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
    be30:	ldrb	r3, [r6, #1]
    be32:	cmp	r3, #0
    be34:	bne.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    be38:	ldr	r2, [sp, #28]
    be3a:	mov	r3, r2
    be3c:	lsls	r2, r3, #22
    be3e:	bpl.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    be42:	and.w	r3, r3, #3
    be46:	subs	r3, #1
    be48:	cmp	r3, #1
    be4a:	bhi.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    be4e:	cmp	r4, #0
    be50:	it	eq
    be52:	moveq	r7, r5
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    be54:	cmp	r4, r8
    be56:	bcc.n	be60 <FatFile::open(FatFile*, fname_t*, int)+0x1a8>
    be58:	b.n	be96 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    be5a:	uxtb	r4, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    be5c:	cmp	r8, r4
    be5e:	bls.n	be96 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    dir = dirFile->readDirCache();
    be60:	movs	r1, #0
    be62:	mov	r0, r6
    be64:	bl	acac <FatFile::readDirCache(bool)>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    be68:	adds	r3, r4, #1
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
    be6a:	cmp	r0, #0
    be6c:	bne.n	be5a <FatFile::open(FatFile*, fname_t*, int)+0x1a2>
      if (dirFile->getError()) {
    be6e:	ldrb	r3, [r6, #1]
    be70:	cbz	r3, be7c <FatFile::open(FatFile*, fname_t*, int)+0x1c4>
    be72:	b.n	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    be74:	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
    be76:	ldrb	r3, [r3, #4]
    be78:	cmp	r3, #1
    be7a:	bhi.n	be96 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    be7c:	cmp	r8, r4
    be7e:	bls.n	be96 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    be80:	mov	r0, r6
    be82:	bl	a684 <FatFile::addDirCluster()>
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
    be86:	adds	r4, #16
    be88:	uxtb	r4, r4
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    be8a:	cmp	r0, #0
    be8c:	bne.n	be74 <FatFile::open(FatFile*, fname_t*, int)+0x1bc>
    be8e:	b.n	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    be90:	ldr.w	r9, [sp, #32]
    be94:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    be96:	ldr	r3, [sp, #20]
    be98:	cbz	r3, bea8 <FatFile::open(FatFile*, fname_t*, int)+0x1f0>
    if (!dirFile->lfnUniqueSfn(fname)) {
    be9a:	mov	r1, fp
    be9c:	mov	r0, r6
    be9e:	bl	bc00 <FatFile::lfnUniqueSfn(fname_t*)>
    bea2:	cmp	r0, #0
    bea4:	beq.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    bea8:	lsls	r1, r7, #5
    beaa:	mov	r0, r6
    beac:	bl	af1c <FatFile::seekSet(unsigned long)>
    beb0:	cmp	r0, #0
    beb2:	beq.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    beb6:	add.w	r8, r8, #4294967295
  for (order = lfnOrd ; order ; order--) {
    beba:	ands.w	r9, r8, #255	; 0xff
    bebe:	beq.n	bf74 <FatFile::open(FatFile*, fname_t*, int)+0x2bc>
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    bec0:	orr.w	r4, r9, #64	; 0x40
    bec4:	uxtb	r4, r4
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    bec6:	mov	r5, r9
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    bec8:	movs	r7, #0
    beca:	movs	r1, #0
    becc:	mov	r0, r6
    bece:	bl	acac <FatFile::readDirCache(bool)>
    if (!ldir) {
    bed2:	cmp	r0, #0
    bed4:	beq.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    bed8:	ldr	r2, [r6, #8]
    beda:	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    bede:	cmp	r9, r5
    bee0:	orr.w	r3, r3, #1
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    bee4:	mov.w	ip, #15
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    bee8:	ite	ne
    beea:	movne	r1, r5
    beec:	moveq	r1, r4
    beee:	strb.w	r3, [r2, #36]	; 0x24
    bef2:	add.w	lr, fp, #12
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    bef6:	strb.w	ip, [r0, #11]
    ldir->mustBeZero1 = 0;
    befa:	strb	r7, [r0, #12]
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    befc:	strb	r1, [r0, #0]
    befe:	add.w	ip, fp, #23
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    bf02:	movs	r3, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    bf04:	ldrb.w	r8, [lr, #1]!
    bf08:	lsrs	r2, r3, #1
    bf0a:	orr.w	r3, r2, r3, lsl #7
    bf0e:	uxtab	r3, r8, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    bf12:	cmp	lr, ip
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    bf14:	uxtb	r3, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    bf16:	bne.n	bf04 <FatFile::open(FatFile*, fname_t*, int)+0x24c>
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    bf18:	and.w	r1, r1, #31
    bf1c:	subs	r1, #1
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    bf1e:	strb	r3, [r0, #13]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    bf20:	add.w	r2, r1, r1, lsl #1
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
    bf24:	ldr.w	lr, [fp, #8]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    bf28:	strh	r7, [r0, #26]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    bf2a:	add.w	r2, r1, r2, lsl #2
    bf2e:	adds	r0, #4
  for (uint8_t i = 0; i < 13; i++, k++) {
    bf30:	movs	r3, #0
    bf32:	b.n	bf54 <FatFile::open(FatFile*, fname_t*, int)+0x29c>
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    bf34:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    bf36:	ldrb.w	r1, [lr, r2]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    bf3a:	bls.n	bf66 <FatFile::open(FatFile*, fname_t*, int)+0x2ae>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    bf3c:	cmp	r3, #10
    bf3e:	ite	ls
    bf40:	strhls	r1, [r0, #0]
    bf42:	strhhi	r1, [r0, #2]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    bf44:	adds	r3, #1
    bf46:	uxtb	r3, r3
    bf48:	cmp	r3, #13
    bf4a:	add.w	r2, r2, #1
    bf4e:	add.w	r0, r0, #2
    bf52:	beq.n	bf6c <FatFile::open(FatFile*, fname_t*, int)+0x2b4>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    bf54:	cmp	sl, r2
    bf56:	bhi.n	bf34 <FatFile::open(FatFile*, fname_t*, int)+0x27c>
    bf58:	ite	ne
    bf5a:	movne.w	r1, #4294967295
    bf5e:	moveq	r1, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    bf60:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    bf62:	uxth	r1, r1
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    bf64:	bhi.n	bf3c <FatFile::open(FatFile*, fname_t*, int)+0x284>
    bf66:	strh.w	r1, [r0, #-3]
    bf6a:	b.n	bf44 <FatFile::open(FatFile*, fname_t*, int)+0x28c>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    bf6c:	subs	r5, #1
    bf6e:	ands.w	r5, r5, #255	; 0xff
    bf72:	bne.n	beca <FatFile::open(FatFile*, fname_t*, int)+0x212>
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
    bf74:	movs	r1, #0
    bf76:	mov	r0, r6
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    bf78:	ldr	r5, [r6, #20]
  dir = dirFile->readDirCache();
    bf7a:	bl	acac <FatFile::readDirCache(bool)>
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    bf7e:	ubfx	r5, r5, #5, #16
  dir = dirFile->readDirCache();
  if (!dir) {
    bf82:	mov	r4, r0
    bf84:	cmp	r0, #0
    bf86:	beq.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    bf8a:	movs	r2, #32
    bf8c:	movs	r1, #0
    bf8e:	bl	106dc <memset>
  memcpy(dir->name, fname->sfn, 11);
    bf92:	mov	r3, fp

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;

  // Set timestamps.
  if (FsDateTime::callback) {
    bf94:	ldr	r2, [pc, #172]	; (c044 <FatFile::open(FatFile*, fname_t*, int)+0x38c>)
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);
    bf96:	ldr.w	r1, [r3, #13]!
    bf9a:	ldr	r0, [r3, #4]
    bf9c:	str	r0, [r4, #4]
    bf9e:	str	r1, [r4, #0]
    bfa0:	ldrh	r1, [r3, #8]
    bfa2:	ldrb	r3, [r3, #10]
    bfa4:	strb	r3, [r4, #10]
    bfa6:	strh	r1, [r4, #8]

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    bfa8:	ldrb.w	r3, [fp]

  // Set timestamps.
  if (FsDateTime::callback) {
    bfac:	ldr	r7, [r2, #0]
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    bfae:	and.w	r3, r3, #24
    bfb2:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    bfb4:	cmp	r7, #0
    bfb6:	beq.n	c034 <FatFile::open(FatFile*, fname_t*, int)+0x37c>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    bfb8:	add.w	r2, sp, #43	; 0x2b
    bfbc:	add.w	r1, sp, #46	; 0x2e
    bfc0:	add	r0, sp, #44	; 0x2c
    bfc2:	blx	r7
    bfc4:	ldrh.w	r1, [sp, #44]	; 0x2c
    bfc8:	ldrh.w	r2, [sp, #46]	; 0x2e
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    bfcc:	ldrb.w	r3, [sp, #43]	; 0x2b
    bfd0:	strh	r1, [r4, #16]
    bfd2:	strh	r2, [r4, #14]
    bfd4:	strb	r3, [r4, #13]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    bfd6:	ldr	r2, [r6, #8]
    bfd8:	ldrb.w	r3, [r2, #36]	; 0x24
    bfdc:	orr.w	r3, r3, #1
    bfe0:	strb.w	r3, [r2, #36]	; 0x24

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    bfe4:	str.w	r9, [sp]
    bfe8:	ldr	r3, [sp, #28]
    bfea:	ldr	r0, [sp, #36]	; 0x24
    bfec:	mov	r2, r5
    bfee:	mov	r1, r6
    bff0:	bl	afcc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    bff4:	b.n	bccc <FatFile::open(FatFile*, fname_t*, int)+0x14>
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    bff6:	cmp	r0, #0
    bff8:	ldr.w	r9, [sp, #32]
    bffc:	it	ne
    bffe:	movne.w	r9, #0
    c002:	b.n	bd02 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    c004:	ldr	r1, [sp, #12]
    c006:	cmp	r1, #1
    c008:	bne.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    c00c:	subs	r4, r3, #1
    c00e:	adds	r3, #10
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    c010:	ldrb.w	r0, [r4, #1]!
    c014:	lsrs	r1, r2, #1
    c016:	orr.w	r2, r1, r2, lsl #7
    c01a:	uxtab	r2, r0, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    c01e:	cmp	r4, r3
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    c020:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    c022:	bne.n	c010 <FatFile::open(FatFile*, fname_t*, int)+0x358>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    c024:	ldr	r3, [sp, #24]
    c026:	cmp	r3, r2
    c028:	bne.w	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    c02c:	ldr	r3, [sp, #28]
    c02e:	lsls	r1, r3, #20
    c030:	bpl.n	bfe4 <FatFile::open(FatFile*, fname_t*, int)+0x32c>
    c032:	b.n	bcca <FatFile::open(FatFile*, fname_t*, int)+0x12>
    c034:	movw	r3, #21025	; 0x5221
    c038:	strh	r3, [r4, #16]
    c03a:	strh	r3, [r4, #24]
    c03c:	strh	r3, [r4, #18]
    c03e:	b.n	bfd6 <FatFile::open(FatFile*, fname_t*, int)+0x31e>
    c040:	.word	0x4ec4ec4f
    c044:	.word	0x20002bd8

0000c048 <FatFile::getSFN(char*)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name) {
    c048:	push	{r3, r4, r5, r6, r7, lr}
    c04a:	ldrb	r3, [r0, #0]
    c04c:	mov	r5, r1
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t* dir;

  if (!isOpen()) {
    c04e:	cbz	r3, c062 <FatFile::getSFN(char*)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    c050:	ands.w	r4, r3, #96	; 0x60
    c054:	beq.n	c068 <FatFile::getSFN(char*)+0x20>
    name[0] = '/';
    c056:	movs	r2, #47	; 0x2f
    name[1] = '\0';
    c058:	movs	r3, #0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    name[0] = '/';
    c05a:	strb	r2, [r1, #0]
    name[1] = '\0';
    c05c:	strb	r3, [r1, #1]
    return 1;
    c05e:	movs	r0, #1
    c060:	pop	{r3, r4, r5, r6, r7, pc}
  }
  name[j] = '\0';
  return j;

 fail:
  name[0] = '\0';
    c062:	movs	r0, #0
    c064:	strb	r0, [r5, #0]
  return 0;
}
    c066:	pop	{r3, r4, r5, r6, r7, pc}
    name[0] = '/';
    name[1] = '\0';
    return 1;
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FsCache::CACHE_FOR_READ));
    c068:	mov	r1, r4
    c06a:	bl	a728 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    c06e:	cmp	r0, #0
    c070:	beq.n	c062 <FatFile::getSFN(char*)+0x1a>
    c072:	mov	r1, r4
    c074:	mov	r3, r4
    c076:	movs	r7, #8
    c078:	subs	r4, r0, #1
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    c07a:	mov.w	lr, #46	; 0x2e
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    c07e:	ldrb.w	r2, [r4, #1]!
    c082:	cmp	r2, #32
    c084:	beq.n	c0a2 <FatFile::getSFN(char*)+0x5a>
      continue;
    }
    if (i == 8) {
    c086:	cmp	r1, #8
    c088:	beq.n	c0b0 <FatFile::getSFN(char*)+0x68>
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    }
    char c = dir->name[i];
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    c08a:	sub.w	r6, r2, #65	; 0x41
    c08e:	cmp	r6, #25
    c090:	bhi.n	c09c <FatFile::getSFN(char*)+0x54>
    c092:	ldrb	r6, [r0, #12]
    c094:	tst	r7, r6
      c += 'a' - 'A';
    c096:	itt	ne
    c098:	addne	r2, #32
    c09a:	uxtbne	r2, r2
    }
    name[j++] = c;
    c09c:	strb	r2, [r5, r3]
    c09e:	adds	r3, #1
    c0a0:	uxtb	r3, r3
    c0a2:	adds	r1, #1
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    c0a4:	cmp	r1, #11
    c0a6:	bne.n	c07e <FatFile::getSFN(char*)+0x36>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = '\0';
    c0a8:	movs	r2, #0
    c0aa:	strb	r2, [r5, r3]
  return j;
    c0ac:	mov	r0, r3
    c0ae:	pop	{r3, r4, r5, r6, r7, pc}
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    c0b0:	strb.w	lr, [r5, r3]
    c0b4:	adds	r3, #1
    c0b6:	uxtb	r3, r3
    c0b8:	ldrb	r2, [r4, #0]
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
    c0ba:	movs	r7, #16
    c0bc:	b.n	c08a <FatFile::getSFN(char*)+0x42>
    c0be:	nop

0000c0c0 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    c0c0:	push	{r3, r4, r5, r6, r7, lr}
    c0c2:	movs	r5, #0
    c0c4:	str	r5, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    c0c6:	ldr	r4, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    c0c8:	str	r5, [r0, #60]	; 0x3c
    c0ca:	mov	r6, r0
    c0cc:	mov	r7, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    c0ce:	cbz	r4, c0f4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    c0d0:	mov	r1, r0
    c0d2:	movs	r0, #36	; 0x24
    c0d4:	bl	c330 <operator new(unsigned int, unsigned long*)>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    c0d8:	strb	r5, [r0, #0]
    c0da:	strb	r5, [r0, #1]
    c0dc:	strb	r5, [r0, #2]
    c0de:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    c0e0:	ldr	r5, [r7, #56]	; 0x38
    c0e2:	mov	r4, r0
    c0e4:	ldmia	r5!, {r0, r1, r2, r3}
    c0e6:	stmia	r4!, {r0, r1, r2, r3}
    c0e8:	ldmia	r5!, {r0, r1, r2, r3}
    c0ea:	stmia	r4!, {r0, r1, r2, r3}
    c0ec:	ldr	r3, [r5, #0]
    c0ee:	str	r3, [r4, #0]
  } else if (from.m_xFile) {
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
}
    c0f0:	mov	r0, r6
    c0f2:	pop	{r3, r4, r5, r6, r7, pc}
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    *m_fFile = *from.m_fFile;
  } else if (from.m_xFile) {
    c0f4:	ldr	r3, [r1, #60]	; 0x3c
    c0f6:	cmp	r3, #0
    c0f8:	beq.n	c0f0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>
    m_xFile = new (m_fileMem) ExFatFile;
    c0fa:	mov	r1, r0
    c0fc:	movs	r0, #56	; 0x38
    c0fe:	bl	c330 <operator new(unsigned int, unsigned long*)>
    c102:	strb.w	r4, [r0, #49]	; 0x31
    c106:	strb.w	r4, [r0, #50]	; 0x32
    c10a:	strb.w	r4, [r0, #51]	; 0x33
    c10e:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    c110:	ldr	r3, [r7, #60]	; 0x3c
    c112:	mov	r2, r0
    c114:	add.w	r1, r3, #48	; 0x30
    c118:	ldr	r5, [r3, #0]
    c11a:	ldr	r4, [r3, #4]
    c11c:	ldr	r0, [r3, #8]
    c11e:	ldr	r7, [r3, #12]
    c120:	str	r7, [r2, #12]
    c122:	adds	r3, #16
    c124:	cmp	r3, r1
    c126:	str	r5, [r2, #0]
    c128:	str	r4, [r2, #4]
    c12a:	str	r0, [r2, #8]
    c12c:	add.w	r2, r2, #16
    c130:	bne.n	c118 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x58>
    c132:	ldr	r3, [r3, #0]
    c134:	str	r3, [r2, #0]
    c136:	b.n	c0f0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>

0000c138 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    c138:	push	{r4, lr}
    c13a:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    c13c:	ldr	r0, [r0, #56]	; 0x38
    c13e:	cbz	r0, c14c <FsBaseFile::close()+0x14>
    c140:	bl	a7dc <FatFile::close()>
    c144:	cbz	r0, c14c <FsBaseFile::close()+0x14>
    m_fFile = nullptr;
    c146:	movs	r3, #0
    c148:	str	r3, [r4, #56]	; 0x38
    return true;
    c14a:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    c14c:	ldr	r0, [r4, #60]	; 0x3c
    c14e:	cbz	r0, c15c <FsBaseFile::close()+0x24>
    c150:	bl	8db0 <ExFatFile::close()>
    c154:	cbz	r0, c15c <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    c156:	movs	r3, #0
    c158:	str	r3, [r4, #60]	; 0x3c
    c15a:	pop	{r4, pc}
    return true;
  }
  return false;
    c15c:	movs	r0, #0
}
    c15e:	pop	{r4, pc}

0000c160 <FsBaseFile::open(FsVolume*, char const*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    c160:	cbz	r1, c1d6 <FsBaseFile::open(FsVolume*, char const*, int)+0x76>
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    c162:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c166:	mov	r4, r1
    c168:	mov	r5, r0
    c16a:	mov	r8, r3
    c16c:	mov	r7, r2
  if (!vol) {
    return false;
  }
  close();
    c16e:	bl	c138 <FsBaseFile::close()>
  if (vol->m_fVol) {
    c172:	ldr.w	r6, [r4, #1152]	; 0x480
    c176:	cbz	r6, c1a4 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    c178:	mov	r1, r5
    c17a:	movs	r0, #36	; 0x24
    c17c:	bl	c330 <operator new(unsigned int, unsigned long*)>
    c180:	movs	r1, #0
    c182:	strb	r1, [r0, #0]
    c184:	strb	r1, [r0, #1]
    c186:	strb	r1, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    c188:	ldr.w	r1, [r4, #1152]	; 0x480
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    c18c:	str	r0, [r5, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    c18e:	mov	r3, r8
    c190:	mov	r2, r7
    c192:	bl	aacc <FatFile::open(FatVolume*, char const*, int)>
    c196:	cbz	r0, c19e <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    c198:	movs	r0, #1
    c19a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
    c19e:	str	r0, [r5, #56]	; 0x38
    c1a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (vol->m_xVol) {
    c1a4:	ldr.w	r3, [r4, #1156]	; 0x484
    c1a8:	cbz	r3, c1da <FsBaseFile::open(FsVolume*, char const*, int)+0x7a>
    m_xFile = new (m_fileMem) ExFatFile;
    c1aa:	mov	r1, r5
    c1ac:	movs	r0, #56	; 0x38
    c1ae:	bl	c330 <operator new(unsigned int, unsigned long*)>
    c1b2:	strb.w	r6, [r0, #49]	; 0x31
    c1b6:	strb.w	r6, [r0, #50]	; 0x32
    c1ba:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    c1be:	ldr.w	r1, [r4, #1156]	; 0x484
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    c1c2:	str	r0, [r5, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    c1c4:	mov	r3, r8
    c1c6:	mov	r2, r7
    c1c8:	bl	9714 <ExFatFile::open(ExFatVolume*, char const*, int)>
    c1cc:	cmp	r0, #0
    c1ce:	bne.n	c198 <FsBaseFile::open(FsVolume*, char const*, int)+0x38>
      return true;
    }
    m_xFile = nullptr;
    c1d0:	str	r0, [r5, #60]	; 0x3c
  }
  return false;
}
    c1d2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    c1d6:	movs	r0, #0
      return true;
    }
    m_xFile = nullptr;
  }
  return false;
}
    c1d8:	bx	lr
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    c1da:	movs	r0, #0
    c1dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000c1e0 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    c1e0:	push	{r3, r4, r5, r6, r7, lr}
    c1e2:	mov	r5, r1
    c1e4:	mov	r7, r2
    c1e6:	mov	r4, r0
  close();
    c1e8:	bl	c138 <FsBaseFile::close()>
  if (dir->m_fFile) {
    c1ec:	ldr	r6, [r5, #56]	; 0x38
    c1ee:	cbz	r6, c214 <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    c1f0:	mov	r1, r4
    c1f2:	movs	r0, #36	; 0x24
    c1f4:	bl	c330 <operator new(unsigned int, unsigned long*)>
    c1f8:	movs	r2, #0
    c1fa:	strb	r2, [r0, #0]
    c1fc:	strb	r2, [r0, #1]
    c1fe:	strb	r2, [r0, #2]
    c200:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    c202:	mov	r2, r7
    c204:	ldr	r1, [r5, #56]	; 0x38
    c206:	bl	b0a4 <FatFile::openNext(FatFile*, int)>
    c20a:	cbz	r0, c210 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    c20c:	movs	r0, #1
    c20e:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    c210:	str	r0, [r4, #56]	; 0x38
    c212:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    c214:	ldr	r0, [r5, #60]	; 0x3c
    c216:	cbz	r0, c23c <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    c218:	mov	r1, r4
    c21a:	movs	r0, #56	; 0x38
    c21c:	bl	c330 <operator new(unsigned int, unsigned long*)>
    c220:	strb.w	r6, [r0, #49]	; 0x31
    c224:	strb.w	r6, [r0, #50]	; 0x32
    c228:	strb.w	r6, [r0, #51]	; 0x33
    c22c:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    c22e:	mov	r2, r7
    c230:	ldr	r1, [r5, #60]	; 0x3c
    c232:	bl	9724 <ExFatFile::openNext(ExFatFile*, int)>
    c236:	cmp	r0, #0
    c238:	bne.n	c20c <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    c23a:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    c23c:	pop	{r3, r4, r5, r6, r7, pc}
    c23e:	nop

0000c240 <FsVolume::begin(SdSpiCard*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    c240:	push	{r4, r5, r6, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    c242:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    c244:	mov	r4, r0
  m_blockDev = blockDev;
    c246:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    c24a:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    c24e:	mov	r1, r0
    c250:	mov.w	r0, #1152	; 0x480
    c254:	bl	c330 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    c258:	strb.w	r6, [r0, #1092]	; 0x444
    c25c:	strb.w	r6, [r0, #1145]	; 0x479
    c260:	strb.w	r6, [r0, #1146]	; 0x47a
    c264:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    c268:	movs	r2, #1
    c26a:	ldr.w	r1, [r4, #1160]	; 0x488
    c26e:	str.w	r0, [r4, #1156]	; 0x484
    c272:	mov	r5, r0
    c274:	bl	9b10 <ExFatPartition::init(SdSpiCard*, unsigned char)>
    c278:	cbnz	r0, c2b6 <FsVolume::begin(SdSpiCard*)+0x76>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    c27a:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    c27c:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    c27e:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    c282:	mov.w	r0, #1128	; 0x468
    c286:	bl	c330 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    c28a:	strb	r6, [r0, #7]
    c28c:	strb.w	r6, [r0, #1092]	; 0x444
    c290:	strb.w	r6, [r0, #1093]	; 0x445
    c294:	strb.w	r6, [r0, #1094]	; 0x446
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    c298:	movs	r2, #1
    c29a:	ldr.w	r1, [r4, #1160]	; 0x488
    c29e:	str.w	r0, [r4, #1152]	; 0x480
    c2a2:	mov	r5, r0
    c2a4:	bl	b60c <FatPartition::init(SdSpiCard*, unsigned char)>
    c2a8:	cbnz	r0, c2da <FsVolume::begin(SdSpiCard*)+0x9a>
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    c2aa:	ldr	r3, [pc, #80]	; (c2fc <FsVolume::begin(SdSpiCard*)+0xbc>)
    c2ac:	movs	r0, #0
    c2ae:	str	r0, [r3, #0]
  m_fVol = nullptr;
    c2b0:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    c2b4:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    c2b6:	add.w	r6, r5, #1096	; 0x448
    c2ba:	mov	r0, r6
    c2bc:	bl	8db0 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    c2c0:	mov	r1, r5
    c2c2:	mov	r0, r6
    c2c4:	bl	8e74 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    c2c8:	cmp	r0, #0
    c2ca:	beq.n	c27a <FsVolume::begin(SdSpiCard*)+0x3a>
      return false;
    }
    if (setCwv || !m_cwv) {
    c2cc:	ldr	r3, [pc, #48]	; (c300 <FsVolume::begin(SdSpiCard*)+0xc0>)
    c2ce:	ldr	r2, [r3, #0]
    c2d0:	cbz	r2, c2f8 <FsVolume::begin(SdSpiCard*)+0xb8>
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    c2d2:	ldr	r3, [pc, #40]	; (c2fc <FsVolume::begin(SdSpiCard*)+0xbc>)
  return true;
    c2d4:	movs	r0, #1
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    c2d6:	str	r4, [r3, #0]
  return true;
    c2d8:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    c2da:	addw	r6, r5, #1092	; 0x444
    c2de:	mov	r0, r6
    c2e0:	bl	a7dc <FatFile::close()>
    return m_vwd.openRoot(this);
    c2e4:	mov	r1, r5
    c2e6:	mov	r0, r6
    c2e8:	bl	aadc <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    c2ec:	cmp	r0, #0
    c2ee:	beq.n	c2aa <FsVolume::begin(SdSpiCard*)+0x6a>
      return false;
    }
    if (setCwv || !m_cwv) {
    c2f0:	ldr	r3, [pc, #16]	; (c304 <FsVolume::begin(SdSpiCard*)+0xc4>)
    c2f2:	ldr	r2, [r3, #0]
    c2f4:	cmp	r2, #0
    c2f6:	bne.n	c2d2 <FsVolume::begin(SdSpiCard*)+0x92>
      m_cwv = this;
    c2f8:	str	r5, [r3, #0]
    c2fa:	b.n	c2d2 <FsVolume::begin(SdSpiCard*)+0x92>
    c2fc:	.word	0x20002be4
    c300:	.word	0x20002bdc
    c304:	.word	0x20002be0

0000c308 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    c308:	push	{r3, r4, r5, r6, r7, lr}
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    c30a:	movs	r5, #0
    c30c:	mov.w	r7, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    c310:	ldr	r6, [pc, #24]	; (c32c <FsVolume::open(char const*, int)+0x24>)
    c312:	str	r7, [r0, #8]
    c314:	mov	r4, r0
    c316:	strb	r5, [r0, #4]
    c318:	strb	r5, [r0, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    c31a:	str	r5, [r0, #72]	; 0x48
    c31c:	str	r5, [r0, #76]	; 0x4c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    c31e:	str.w	r6, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    c322:	bl	c160 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    c326:	mov	r0, r4
    c328:	pop	{r3, r4, r5, r6, r7, pc}
    c32a:	nop
    c32c:	.word	0x000141c8

0000c330 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    c330:	mov	r0, r1
    c332:	bx	lr

0000c334 <SdSpiCard::spiStart() [clone .part.7]>:
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    c334:	push	{r4, lr}
    c336:	mov	r4, r0
  bool waitNotBusy(SdMillis_t timeoutMS);
  bool writeData(uint8_t token, const uint8_t* src);

#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
    c338:	bl	c938 <SdSpiArduinoDriver::activate()>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    c33c:	ldrb	r0, [r4, #14]
    c33e:	movs	r1, #0
    c340:	bl	cac0 <sdCsWrite(unsigned char, bool)>
  if (!m_spiActive) {
    spiActivate();
    spiSelect();
    m_spiActive = true;
    c344:	movs	r3, #1
    c346:	strb	r3, [r4, #16]
    c348:	pop	{r4, pc}
    c34a:	nop

0000c34c <SdSpiCard::spiStop() [clone .part.8]>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    c34c:	push	{r4, lr}
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    c34e:	movs	r1, #1
    c350:	mov	r4, r0
    c352:	ldrb	r0, [r0, #14]
    c354:	bl	cac0 <sdCsWrite(unsigned char, bool)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c358:	mov	r0, r4
    c35a:	movs	r1, #255	; 0xff
    c35c:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
    c360:	mov	r0, r4
    c362:	bl	c9d8 <SdSpiArduinoDriver::deactivate()>
  if (m_spiActive) {
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
    c366:	movs	r3, #0
    c368:	strb	r3, [r4, #16]
    c36a:	pop	{r4, pc}

0000c36c <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    c36c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c370:	ldr	r5, [pc, #124]	; (c3f0 <SdSpiCard::readData(unsigned char*, unsigned int)+0x84>)
    c372:	sub	sp, #8
    c374:	ldr	r3, [r5, #0]
    c376:	str	r3, [sp, #0]
	return ret;
    c378:	ldr	r4, [sp, #0]
    c37a:	mov	r8, r0
    c37c:	mov	r6, r1
    c37e:	mov	r7, r2

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    c380:	uxth	r4, r4
    c382:	b.n	c394 <SdSpiCard::readData(unsigned char*, unsigned int)+0x28>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c384:	ldr	r3, [r5, #0]
    c386:	str	r3, [sp, #4]
	return ret;
    c388:	ldr	r3, [sp, #4]
    c38a:	uxth	r3, r3
    c38c:	subs	r3, r3, r4
    c38e:	cmp.w	r3, #300	; 0x12c
    c392:	bgt.n	c3c0 <SdSpiCard::readData(unsigned char*, unsigned int)+0x54>
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c394:	mov	r0, r8
    c396:	bl	ca10 <SdSpiArduinoDriver::receive()>
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    c39a:	cmp	r0, #255	; 0xff
    c39c:	strb.w	r0, [r8, #17]
    c3a0:	beq.n	c384 <SdSpiCard::readData(unsigned char*, unsigned int)+0x18>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    c3a2:	cmp	r0, #254	; 0xfe
    c3a4:	beq.n	c3c8 <SdSpiCard::readData(unsigned char*, unsigned int)+0x5c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c3a6:	movs	r3, #24
    c3a8:	strb.w	r3, [r8, #15]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c3ac:	ldrb.w	r0, [r8, #16]
    c3b0:	cbz	r0, c3ba <SdSpiCard::readData(unsigned char*, unsigned int)+0x4e>
    c3b2:	mov	r0, r8
    c3b4:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
  return false;
    c3b8:	movs	r0, #0
}
    c3ba:	add	sp, #8
    c3bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c3c0:	movs	r3, #29
    c3c2:	strb.w	r3, [r8, #15]
    c3c6:	b.n	c3ac <SdSpiCard::readData(unsigned char*, unsigned int)+0x40>
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
    c3c8:	mov	r2, r7
    c3ca:	mov	r1, r6
    c3cc:	mov	r0, r8
    c3ce:	bl	ca2c <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>
  if (m_status != DATA_START_SECTOR) {
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    c3d2:	strb.w	r0, [r8, #17]
    c3d6:	cbz	r0, c3e0 <SdSpiCard::readData(unsigned char*, unsigned int)+0x74>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c3d8:	movs	r3, #37	; 0x25
    c3da:	strb.w	r3, [r8, #15]
    c3de:	b.n	c3ac <SdSpiCard::readData(unsigned char*, unsigned int)+0x40>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c3e0:	mov	r0, r8
    c3e2:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c3e6:	mov	r0, r8
    c3e8:	bl	ca10 <SdSpiArduinoDriver::receive()>
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
  spiReceive();
#endif  // USE_SD_CRC
  return true;
    c3ec:	movs	r0, #1
    c3ee:	b.n	c3ba <SdSpiCard::readData(unsigned char*, unsigned int)+0x4e>
    c3f0:	.word	0x200030a4

0000c3f4 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    c3f4:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c3f6:	ldr	r5, [pc, #52]	; (c42c <SdSpiCard::waitNotBusy(unsigned short)+0x38>)
    c3f8:	sub	sp, #12
    c3fa:	ldr	r3, [r5, #0]
    c3fc:	str	r3, [sp, #0]
	return ret;
    c3fe:	ldr	r4, [sp, #0]
    c400:	mov	r6, r0
    c402:	mov	r7, r1
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    c404:	uxth	r4, r4
    c406:	b.n	c416 <SdSpiCard::waitNotBusy(unsigned short)+0x22>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c408:	ldr	r3, [r5, #0]
    c40a:	str	r3, [sp, #4]
	return ret;
    c40c:	ldr	r3, [sp, #4]
    c40e:	uxth	r3, r3
    c410:	subs	r3, r3, r4
    c412:	cmp	r3, r7
    c414:	bgt.n	c426 <SdSpiCard::waitNotBusy(unsigned short)+0x32>
    c416:	mov	r0, r6
    c418:	bl	ca10 <SdSpiArduinoDriver::receive()>
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    c41c:	cmp	r0, #255	; 0xff
    c41e:	bne.n	c408 <SdSpiCard::waitNotBusy(unsigned short)+0x14>
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    }
  }
  return true;
    c420:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    c422:	add	sp, #12
    c424:	pop	{r4, r5, r6, r7, pc}
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    c426:	movs	r0, #0
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
    c428:	add	sp, #12
    c42a:	pop	{r4, r5, r6, r7, pc}
    c42c:	.word	0x200030a4

0000c430 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    c430:	push	{r3, r4, r5, lr}
    c432:	mov	r4, r0
    c434:	mov	r5, r2
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c436:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver.send(buf, n);
    c43a:	mov.w	r2, #512	; 0x200
    c43e:	mov	r1, r5
    c440:	mov	r0, r4
    c442:	bl	ca64 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c446:	mov	r0, r4
    c448:	movs	r1, #255	; 0xff
    c44a:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
    c44e:	mov	r0, r4
    c450:	movs	r1, #255	; 0xff
    c452:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c456:	mov	r0, r4
    c458:	bl	ca10 <SdSpiArduinoDriver::receive()>
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    c45c:	and.w	r3, r0, #31
    c460:	cmp	r3, #5
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    c462:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    c464:	beq.n	c47a <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x4a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c466:	ldrb	r0, [r4, #16]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c468:	movs	r3, #32
    c46a:	strb	r3, [r4, #15]
    c46c:	cbnz	r0, c470 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x40>
  return true;

 fail:
  spiStop();
  return false;
}
    c46e:	pop	{r3, r4, r5, pc}
    c470:	mov	r0, r4
    c472:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
  }
  return true;

 fail:
  spiStop();
  return false;
    c476:	movs	r0, #0
    c478:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    c47a:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    c47c:	pop	{r3, r4, r5, pc}
    c47e:	nop

0000c480 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    c480:	push	{r3, r4, r5, lr}
    c482:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c484:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    c488:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c48a:	bl	c3f4 <SdSpiCard::waitNotBusy(unsigned short)>
    c48e:	cbnz	r0, c4a2 <SdSpiCard::writeData(unsigned char const*)+0x22>
    c490:	movs	r3, #36	; 0x24
    c492:	strb	r3, [r4, #15]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c494:	ldrb	r0, [r4, #16]
    c496:	cbz	r0, c4a0 <SdSpiCard::writeData(unsigned char const*)+0x20>
    c498:	mov	r0, r4
    c49a:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
  }
  return true;

 fail:
  spiStop();
  return false;
    c49e:	movs	r0, #0
}
    c4a0:	pop	{r3, r4, r5, pc}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    c4a2:	mov	r2, r5
    c4a4:	movs	r1, #252	; 0xfc
    c4a6:	mov	r0, r4
    c4a8:	bl	c430 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    c4ac:	cmp	r0, #0
    c4ae:	beq.n	c494 <SdSpiCard::writeData(unsigned char const*)+0x14>
  return true;

 fail:
  spiStop();
  return false;
}
    c4b0:	pop	{r3, r4, r5, pc}
    c4b2:	nop

0000c4b4 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    c4b4:	push	{r4, r5, r6, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c4b6:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    c4ba:	mov	r5, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c4bc:	bl	c3f4 <SdSpiCard::waitNotBusy(unsigned short)>
    c4c0:	mov	r6, r0
    c4c2:	cbnz	r0, c4dc <SdSpiCard::writeStop()+0x28>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c4c4:	ldrb	r4, [r5, #16]
    c4c6:	movs	r3, #30
    c4c8:	strb	r3, [r5, #15]
    c4ca:	cbnz	r4, c4d0 <SdSpiCard::writeStop()+0x1c>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    c4cc:	mov	r0, r4
    c4ce:	pop	{r4, r5, r6, pc}
    c4d0:	mov	r0, r5
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
    c4d2:	mov	r4, r6
    c4d4:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
}
    c4d8:	mov	r0, r4
    c4da:	pop	{r4, r5, r6, pc}
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c4dc:	movs	r1, #253	; 0xfd
    c4de:	mov	r0, r5
    c4e0:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c4e4:	ldrb	r4, [r5, #16]
    c4e6:	cbnz	r4, c4ee <SdSpiCard::writeStop()+0x3a>
    c4e8:	mov	r4, r6

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    c4ea:	mov	r0, r4
    c4ec:	pop	{r4, r5, r6, pc}
    c4ee:	mov	r0, r5
    c4f0:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c4f4:	b.n	c4cc <SdSpiCard::writeStop()+0x18>
    c4f6:	nop

0000c4f8 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    c4f8:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    c4fa:	movs	r1, #0
  if (state == WRITE_STATE) {
    c4fc:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    c4fe:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    c500:	beq.n	c50e <SdSpiCard::syncDevice()+0x16>
    return writeStop();
  }
  if (state == READ_STATE) {
    c502:	cmp	r2, #1
    c504:	beq.n	c50a <SdSpiCard::syncDevice()+0x12>
    return readStop();
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    c506:	movs	r0, #1
    c508:	bx	lr
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
  }
  if (state == READ_STATE) {
    return readStop();
    c50a:	b.w	c7b8 <SdSpiCard::readStop()>
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
    c50e:	b.w	c4b4 <SdSpiCard::writeStop()>
    c512:	nop

0000c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    c514:	push	{r4, r5, r6, r7, lr}
    c516:	sub	sp, #12
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c518:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    c51a:	str	r2, [sp, #4]
    c51c:	mov	r4, r0
    c51e:	mov	r6, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c520:	cbnz	r3, c578 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
    return 0XFF;
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    c522:	ldrb	r3, [r4, #16]
    c524:	cmp	r3, #0
    c526:	beq.n	c592 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x7e>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    c528:	cbnz	r6, c586 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x72>
    c52a:	orr.w	r1, r6, #64	; 0x40
    c52e:	mov	r0, r4
    c530:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
    c534:	add	r7, sp, #4
    c536:	add	r5, sp, #8
    c538:	ldrb.w	r1, [r5, #-1]!
    c53c:	mov	r0, r4
    c53e:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    c542:	cmp	r7, r5
    c544:	bne.n	c538 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x24>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    c546:	cmp	r6, #0
    c548:	ite	eq
    c54a:	moveq	r1, #149	; 0x95
    c54c:	movne	r1, #135	; 0x87
    c54e:	mov	r0, r4
    c550:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c554:	mov	r0, r4
    c556:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c55a:	movs	r5, #11
    c55c:	mov	r0, r4
    c55e:	bl	ca10 <SdSpiArduinoDriver::receive()>

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    c562:	lsls	r3, r0, #24
    c564:	strb	r0, [r4, #17]
    c566:	bmi.n	c56c <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x58>
  }
  return m_status;
}
    c568:	add	sp, #12
    c56a:	pop	{r4, r5, r6, r7, pc}
    c56c:	subs	r3, r5, #1

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    c56e:	ands.w	r5, r3, #255	; 0xff
    c572:	bne.n	c55c <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x48>
  }
  return m_status;
}
    c574:	add	sp, #12
    c576:	pop	{r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c578:	bl	c4f8 <SdSpiCard::syncDevice()>
    c57c:	cmp	r0, #0
    c57e:	bne.n	c522 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0xe>
    return 0XFF;
    c580:	movs	r0, #255	; 0xff

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
  }
  return m_status;
}
    c582:	add	sp, #12
    c584:	pop	{r4, r5, r6, r7, pc}
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    c586:	mov.w	r1, #300	; 0x12c
    c58a:	mov	r0, r4
    c58c:	bl	c3f4 <SdSpiCard::waitNotBusy(unsigned short)>
    c590:	b.n	c52a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x16>
    c592:	mov	r0, r4
    c594:	bl	c334 <SdSpiCard::spiStart() [clone .part.7]>
    c598:	b.n	c528 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x14>
    c59a:	nop

0000c59c <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    c59c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c5a0:	sub	sp, #40	; 0x28
    c5a2:	add	r4, sp, #4
    c5a4:	stmia.w	r4, {r1, r2, r3}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c5a8:	ldr	r6, [pc, #456]	; (c774 <SdSpiCard::begin(SdSpiConfig)+0x1d8>)
    c5aa:	ldrb.w	r3, [sp, #4]
    c5ae:	ldr	r2, [r6, #0]
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
  m_errorCode = SD_CARD_ERROR_NONE;
  m_type = 0;
  m_csPin = spiConfig.csPin;
    c5b0:	strb	r3, [r0, #14]
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    c5b2:	mov	r5, r0
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    c5b4:	mov.w	sl, #0
    c5b8:	str	r2, [sp, #20]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    c5ba:	mov	r0, r3
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    c5bc:	strb.w	sl, [r5, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    c5c0:	strb.w	sl, [r5, #15]
  m_type = 0;
    c5c4:	strb.w	sl, [r5, #18]
    c5c8:	ldrb.w	r9, [sp, #5]
	return ret;
    c5cc:	ldr	r7, [sp, #20]
    c5ce:	ldr.w	r8, [sp, #8]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    c5d2:	bl	cab8 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    c5d6:	ldrb	r0, [r5, #14]
    c5d8:	movs	r1, #1
    c5da:	bl	cac0 <sdCsWrite(unsigned char, bool)>
    c5de:	ldmia.w	r4, {r0, r1, r2}
    c5e2:	add	r3, sp, #28
    c5e4:	stmia.w	r3, {r0, r1, r2}
  /** Save high speed SPISettings after SD initialization.
   *
   * \param[in] maxSck Maximum SCK frequency.
   */
  void setSckSpeed(uint32_t maxSck) {
    m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0);
    c5e8:	ldr	r2, [pc, #396]	; (c778 <SdSpiCard::begin(SdSpiConfig)+0x1dc>)
    c5ea:	str	r2, [r5, #4]
#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
    c5ec:	mov	r0, r5
    c5ee:	ldmia	r3, {r1, r2, r3}
    c5f0:	bl	c9b0 <SdSpiArduinoDriver::begin(SdSpiConfig)>
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    c5f4:	and.w	r3, r9, #1
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    c5f8:	ldrb	r2, [r5, #16]
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    c5fa:	strb.w	sl, [r5, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    c5fe:	eor.w	r3, r3, #1
    c602:	strb	r3, [r5, #13]
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    c604:	cmp	r2, #0
    c606:	beq.n	c6fe <SdSpiCard::begin(SdSpiConfig)+0x162>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    c608:	movs	r1, #1
    c60a:	ldrb	r0, [r5, #14]
    c60c:	bl	cac0 <sdCsWrite(unsigned char, bool)>
    c610:	movs	r4, #10
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c612:	movs	r1, #255	; 0xff
    c614:	mov	r0, r5
    c616:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
    c61a:	subs	r3, r4, #1
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    c61c:	ands.w	r4, r3, #255	; 0xff
    c620:	bne.n	c612 <SdSpiCard::begin(SdSpiConfig)+0x76>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    c622:	mov	r1, r4
    c624:	ldrb	r0, [r5, #14]
    c626:	bl	cac0 <sdCsWrite(unsigned char, bool)>
    c62a:	mov.w	r9, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    c62e:	movs	r2, #0
    c630:	mov	r1, r2
    c632:	mov	r0, r5
    c634:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c638:	cmp	r0, #1
    c63a:	mov	r4, r0
    c63c:	beq.n	c67c <SdSpiCard::begin(SdSpiConfig)+0xe0>
    c63e:	add.w	r3, r9, #4294967295
      break;
    }
    if (i == SD_CMD0_RETRY) {
    c642:	ands.w	r9, r3, #255	; 0xff
    c646:	beq.n	c660 <SdSpiCard::begin(SdSpiConfig)+0xc4>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c648:	movs	r1, #253	; 0xfd
    c64a:	mov	r0, r5
    c64c:	bl	ca4c <SdSpiArduinoDriver::send(unsigned char)>
    c650:	mov.w	r4, #520	; 0x208
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c654:	mov	r0, r5
    c656:	bl	ca10 <SdSpiArduinoDriver::receive()>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    c65a:	subs	r4, #1
    c65c:	bne.n	c654 <SdSpiCard::begin(SdSpiConfig)+0xb8>
    c65e:	b.n	c62e <SdSpiCard::begin(SdSpiConfig)+0x92>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c660:	movs	r3, #1
    c662:	strb	r3, [r5, #15]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c664:	ldrb	r0, [r5, #16]
    c666:	cbnz	r0, c66e <SdSpiCard::begin(SdSpiConfig)+0xd2>
  return true;

 fail:
  spiStop();
  return false;
}
    c668:	add	sp, #40	; 0x28
    c66a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c66e:	mov	r0, r5
    c670:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
  return false;
    c674:	movs	r0, #0
}
    c676:	add	sp, #40	; 0x28
    c678:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    c67c:	mov.w	r2, #426	; 0x1aa
    c680:	movs	r1, #8
    c682:	mov	r0, r5
    c684:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c688:	lsls	r3, r0, #29
    c68a:	bpl.n	c706 <SdSpiCard::begin(SdSpiConfig)+0x16a>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    c68c:	strb	r4, [r5, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    c68e:	movs	r4, #0
    c690:	b.n	c6a2 <SdSpiCard::begin(SdSpiConfig)+0x106>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    c692:	ldr	r3, [r6, #0]
    c694:	str	r3, [sp, #24]
	return ret;
    c696:	ldr	r3, [sp, #24]
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    c698:	uxth	r3, r3
    c69a:	subs	r3, r3, r2
    c69c:	cmp.w	r3, #2000	; 0x7d0
    c6a0:	bgt.n	c726 <SdSpiCard::begin(SdSpiConfig)+0x18a>
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    c6a2:	movs	r2, #0
    c6a4:	movs	r1, #55	; 0x37
    c6a6:	mov	r0, r5
    c6a8:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    c6ac:	mov	r2, r4
    c6ae:	movs	r1, #41	; 0x29
    c6b0:	mov	r0, r5
    c6b2:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c6b6:	uxth	r2, r7
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    c6b8:	cmp	r0, #0
    c6ba:	bne.n	c692 <SdSpiCard::begin(SdSpiConfig)+0xf6>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    c6bc:	ldrb	r3, [r5, #18]
    c6be:	cmp	r3, #2
    c6c0:	beq.n	c72c <SdSpiCard::begin(SdSpiConfig)+0x190>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c6c2:	ldrb	r3, [r5, #16]
    c6c4:	cbz	r3, c6cc <SdSpiCard::begin(SdSpiConfig)+0x130>
    c6c6:	mov	r0, r5
    c6c8:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c6cc:	ldr	r1, [pc, #172]	; (c77c <SdSpiCard::begin(SdSpiConfig)+0x1e0>)
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    c6ce:	ldr	r4, [pc, #176]	; (c780 <SdSpiCard::begin(SdSpiConfig)+0x1e4>)
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    c6d0:	movs	r3, #0
    c6d2:	b.n	c6da <SdSpiCard::begin(SdSpiConfig)+0x13e>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    c6d4:	cmp	r0, #23
    c6d6:	beq.n	c6ea <SdSpiCard::begin(SdSpiConfig)+0x14e>
    c6d8:	mov	r3, r0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    c6da:	ldrh.w	r2, [r1, #2]!
    c6de:	sdiv	r2, r4, r2
    c6e2:	cmp	r8, r2
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    c6e4:	add.w	r0, r3, #1
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    c6e8:	bcc.n	c6d4 <SdSpiCard::begin(SdSpiConfig)+0x138>
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    c6ea:	ldr	r2, [pc, #152]	; (c784 <SdSpiCard::begin(SdSpiConfig)+0x1e8>)
    c6ec:	ldr.w	r3, [r2, r3, lsl #2]
      spiReceive();
    }
  }
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    c6f0:	movs	r0, #1
    c6f2:	orr.w	r3, r3, #939524096	; 0x38000000
    c6f6:	str	r3, [r5, #4]

 fail:
  spiStop();
  return false;
}
    c6f8:	add	sp, #40	; 0x28
    c6fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c6fe:	mov	r0, r5
    c700:	bl	c334 <SdSpiCard::spiStart() [clone .part.7]>
    c704:	b.n	c608 <SdSpiCard::begin(SdSpiConfig)+0x6c>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    c706:	movs	r3, #2
    c708:	strb	r3, [r5, #18]
    c70a:	movs	r4, #4
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c70c:	mov	r0, r5
    c70e:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c712:	subs	r4, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    c714:	ands.w	r4, r4, #255	; 0xff
      m_status = spiReceive();
    c718:	strb	r0, [r5, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    c71a:	bne.n	c70c <SdSpiCard::begin(SdSpiConfig)+0x170>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    c71c:	cmp	r0, #170	; 0xaa
    c71e:	beq.n	c73e <SdSpiCard::begin(SdSpiConfig)+0x1a2>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c720:	movs	r3, #6
    c722:	strb	r3, [r5, #15]
    c724:	b.n	c664 <SdSpiCard::begin(SdSpiConfig)+0xc8>
    c726:	movs	r3, #23
    c728:	strb	r3, [r5, #15]
    c72a:	b.n	c664 <SdSpiCard::begin(SdSpiConfig)+0xc8>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    c72c:	mov	r2, r0
    c72e:	movs	r1, #58	; 0x3a
    c730:	mov	r0, r5
    c732:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c736:	cbz	r0, c74c <SdSpiCard::begin(SdSpiConfig)+0x1b0>
    c738:	movs	r3, #18
    c73a:	strb	r3, [r5, #15]
    c73c:	b.n	c664 <SdSpiCard::begin(SdSpiConfig)+0xc8>
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    c73e:	ldrb	r3, [r5, #18]
    c740:	cmp	r3, #2
    c742:	ite	eq
    c744:	moveq.w	r4, #1073741824	; 0x40000000
    c748:	movne	r4, #0
    c74a:	b.n	c6a2 <SdSpiCard::begin(SdSpiConfig)+0x106>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c74c:	mov	r0, r5
    c74e:	bl	ca10 <SdSpiArduinoDriver::receive()>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    c752:	and.w	r0, r0, #192	; 0xc0
    c756:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    c758:	itt	eq
    c75a:	moveq	r3, #3
    c75c:	strbeq	r3, [r5, #18]
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c75e:	mov	r0, r5
    c760:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c764:	mov	r0, r5
    c766:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c76a:	mov	r0, r5
    c76c:	bl	ca10 <SdSpiArduinoDriver::receive()>
    c770:	b.n	c6c2 <SdSpiCard::begin(SdSpiConfig)+0x126>
    c772:	nop
    c774:	.word	0x200030a4
    c778:	.word	0x38005006
    c77c:	.word	0x00014596
    c780:	.word	0x02dc6c00
    c784:	.word	0x000145c8

0000c788 <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    c788:	push	{r4, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    c78a:	ldrb	r3, [r0, #18]
    c78c:	cmp	r3, #3
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    c78e:	mov	r2, r1
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
    c790:	it	ne
    c792:	lslne	r2, r1, #9
  }
  if (cardCommand(CMD18, sector)) {
    c794:	movs	r1, #18
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    c796:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
  }
  if (cardCommand(CMD18, sector)) {
    c798:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c79c:	cbz	r0, c7b2 <SdSpiCard::readStart(unsigned long)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c79e:	ldrb	r0, [r4, #16]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c7a0:	movs	r3, #12
    c7a2:	strb	r3, [r4, #15]
    c7a4:	cbnz	r0, c7a8 <SdSpiCard::readStart(unsigned long)+0x20>
  return true;

 fail:
  spiStop();
  return false;
}
    c7a6:	pop	{r4, pc}
    c7a8:	mov	r0, r4
    c7aa:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c7ae:	movs	r0, #0
    c7b0:	pop	{r4, pc}
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
    c7b2:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    c7b4:	pop	{r4, pc}
    c7b6:	nop

0000c7b8 <SdSpiCard::readStop()>:
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    c7b8:	push	{r3, r4, r5, lr}
  if (cardCommand(CMD12, 0)) {
    c7ba:	movs	r2, #0
    c7bc:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    c7be:	mov	r5, r0
  if (cardCommand(CMD12, 0)) {
    c7c0:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c7c4:	ldrb	r4, [r5, #16]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    c7c6:	cbz	r0, c7d2 <SdSpiCard::readStop()+0x1a>
    c7c8:	movs	r3, #9
    c7ca:	strb	r3, [r5, #15]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c7cc:	cbnz	r4, c7e4 <SdSpiCard::readStop()+0x2c>
  return true;

 fail:
  spiStop();
  return false;
}
    c7ce:	mov	r0, r4
    c7d0:	pop	{r3, r4, r5, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c7d2:	cbnz	r4, c7da <SdSpiCard::readStop()+0x22>
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
  return true;
    c7d4:	movs	r4, #1

 fail:
  spiStop();
  return false;
}
    c7d6:	mov	r0, r4
    c7d8:	pop	{r3, r4, r5, pc}
    c7da:	mov	r0, r5
    c7dc:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c7e0:	mov	r0, r4
    c7e2:	pop	{r3, r4, r5, pc}
    c7e4:	mov	r0, r5
    c7e6:	movs	r4, #0
    c7e8:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c7ec:	mov	r0, r4
    c7ee:	pop	{r3, r4, r5, pc}

0000c7f0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    c7f0:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    c7f2:	ldrb	r3, [r0, #18]
    c7f4:	cmp	r3, #3
    sector <<= 9;
    c7f6:	it	ne
    c7f8:	lslne	r1, r1, #9
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    c7fa:	mov	r5, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
  }
  if (cardCommand(CMD24, sector)) {
    c7fc:	mov	r2, r1
    c7fe:	movs	r1, #24
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    c800:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
  }
  if (cardCommand(CMD24, sector)) {
    c802:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c806:	cbz	r0, c81a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x2a>
    c808:	movs	r3, #13
    c80a:	strb	r3, [r4, #15]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c80c:	ldrb	r0, [r4, #16]
    c80e:	cbz	r0, c818 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x28>
    c810:	mov	r0, r4
    c812:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    c816:	movs	r0, #0
}
    c818:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD24, sector)) {
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    c81a:	mov	r2, r5
    c81c:	movs	r1, #254	; 0xfe
    c81e:	mov	r0, r4
    c820:	bl	c430 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    c824:	cmp	r0, #0
    c826:	beq.n	c80c <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x1c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c828:	ldrb	r5, [r4, #16]
    c82a:	cmp	r5, #0
    c82c:	beq.n	c818 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x28>
    c82e:	mov	r0, r4
    c830:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
  return true;
    c834:	mov	r0, r5
    c836:	pop	{r3, r4, r5, pc}

0000c838 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    c838:	push	{r4, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    c83a:	ldrb	r3, [r0, #18]
    c83c:	cmp	r3, #3
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    c83e:	mov	r2, r1
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
    c840:	it	ne
    c842:	lslne	r2, r1, #9
  }
  if (cardCommand(CMD25, sector)) {
    c844:	movs	r1, #25
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    c846:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    sector <<= 9;
  }
  if (cardCommand(CMD25, sector)) {
    c848:	bl	c514 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c84c:	cbz	r0, c862 <SdSpiCard::writeStart(unsigned long)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c84e:	ldrb	r0, [r4, #16]
    c850:	movs	r3, #14
    c852:	strb	r3, [r4, #15]
    c854:	cbnz	r0, c858 <SdSpiCard::writeStart(unsigned long)+0x20>
  return true;

 fail:
  spiStop();
  return false;
}
    c856:	pop	{r4, pc}
    c858:	mov	r0, r4
    c85a:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
    c85e:	movs	r0, #0
    c860:	pop	{r4, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    c862:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    c864:	pop	{r4, pc}
    c866:	nop

0000c868 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    c868:	push	{r3, r4, r5, r6, r7, lr}
    c86a:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    c86c:	ldrb	r1, [r0, #12]
    c86e:	cmp	r1, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    c870:	mov	r6, r0
    c872:	mov	r4, r2
    c874:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    c876:	beq.n	c8ac <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x44>
    if (!readStart(sector)) {
    c878:	mov	r1, r5
    c87a:	mov	r0, r6
    c87c:	bl	c788 <SdSpiCard::readStart(unsigned long)>
    c880:	cbz	r0, c8a8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x40>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    c882:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    c884:	str	r5, [r6, #8]
    m_curState = READ_STATE;
    c886:	strb	r3, [r6, #12]
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    c888:	movs	r5, #0
    c88a:	cbnz	r7, c892 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
    c88c:	b.n	c8b4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    c88e:	cmp	r7, r5
    c890:	beq.n	c8b4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    if (!readData(dst, 512)) {
    c892:	mov	r1, r4
    c894:	mov.w	r2, #512	; 0x200
    c898:	mov	r0, r6
    c89a:	bl	c36c <SdSpiCard::readData(unsigned char*, unsigned int)>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    c89e:	adds	r5, #1
    c8a0:	add.w	r4, r4, #512	; 0x200
    if (!readData(dst, 512)) {
    c8a4:	cmp	r0, #0
    c8a6:	bne.n	c88e <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    c8a8:	movs	r0, #0
    c8aa:	pop	{r3, r4, r5, r6, r7, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    c8ac:	ldr	r3, [r0, #8]
    c8ae:	cmp	r3, r5
    c8b0:	bne.n	c878 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x10>
    c8b2:	b.n	c888 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x20>
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    c8b4:	ldr	r3, [r6, #8]
  return m_sharedSpi ? syncDevice() : true;
    c8b6:	ldrb	r2, [r6, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    c8b8:	add	r7, r3
    c8ba:	str	r7, [r6, #8]
  return m_sharedSpi ? syncDevice() : true;
    c8bc:	cbnz	r2, c8c2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x5a>
    c8be:	movs	r0, #1
    c8c0:	pop	{r3, r4, r5, r6, r7, pc}
    c8c2:	mov	r0, r6
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    c8c4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    c8c8:	b.w	c4f8 <SdSpiCard::syncDevice()>

0000c8cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    c8cc:	push	{r3, r4, r5, r6, r7, lr}
    c8ce:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    c8d0:	ldrb	r1, [r0, #12]
    c8d2:	cmp	r1, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    c8d4:	mov	r6, r0
    c8d6:	mov	r4, r2
    c8d8:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    c8da:	beq.n	c918 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    if (!writeStart(sector)) {
    c8dc:	mov	r1, r5
    c8de:	mov	r0, r6
    c8e0:	bl	c838 <SdSpiCard::writeStart(unsigned long)>
    c8e4:	cbz	r0, c908 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x3c>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    c8e6:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    c8e8:	str	r5, [r6, #8]
    m_curState = WRITE_STATE;
    c8ea:	strb	r3, [r6, #12]
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    c8ec:	movs	r5, #0
    c8ee:	cbnz	r7, c8f6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    c8f0:	b.n	c920 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x54>
    c8f2:	cmp	r7, r5
    c8f4:	beq.n	c920 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x54>
    if (!writeData(src)) {
    c8f6:	mov	r1, r4
    c8f8:	mov	r0, r6
    c8fa:	bl	c480 <SdSpiCard::writeData(unsigned char const*)>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    c8fe:	adds	r5, #1
    c900:	add.w	r4, r4, #512	; 0x200
    if (!writeData(src)) {
    c904:	cmp	r0, #0
    c906:	bne.n	c8f2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c908:	ldrb	r0, [r6, #16]
    c90a:	cbnz	r0, c90e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    c90c:	pop	{r3, r4, r5, r6, r7, pc}
    c90e:	mov	r0, r6
    c910:	bl	c34c <SdSpiCard::spiStop() [clone .part.8]>
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
    c914:	movs	r0, #0
}
    c916:	pop	{r3, r4, r5, r6, r7, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    c918:	ldr	r3, [r0, #8]
    c91a:	cmp	r3, r5
    c91c:	bne.n	c8dc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x10>
    c91e:	b.n	c8ec <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x20>
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    c920:	ldr	r3, [r6, #8]
  return m_sharedSpi ? syncDevice() : true;
    c922:	ldrb	r2, [r6, #13]
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    c924:	add	r7, r3
    c926:	str	r7, [r6, #8]
  return m_sharedSpi ? syncDevice() : true;
    c928:	cbnz	r2, c92e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x62>
    c92a:	movs	r0, #1
    c92c:	pop	{r3, r4, r5, r6, r7, pc}
    c92e:	mov	r0, r6
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    c930:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    c934:	b.w	c4f8 <SdSpiCard::syncDevice()>

0000c938 <SdSpiArduinoDriver::activate()>:
 */
#include "SdSpiDriver.h"
#if defined(SD_USE_CUSTOM_SPI) &&  defined(__arm__) && defined(CORE_TEENSY)
#define USE_BLOCK_TRANSFER 1
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::activate() {
    c938:	push	{r4}
  m_spi->beginTransaction(m_spiSettings);
    c93a:	ldr	r3, [r0, #0]
    c93c:	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    c93e:	ldrb	r1, [r3, #11]
    c940:	cbz	r1, c970 <SdSpiArduinoDriver::activate()+0x38>
			__disable_irq();
    c942:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    c944:	ldrb	r1, [r3, #11]
    c946:	lsls	r4, r1, #31
    c948:	bpl.n	c958 <SdSpiArduinoDriver::activate()+0x20>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    c94a:	ldr	r0, [pc, #80]	; (c99c <SdSpiArduinoDriver::activate()+0x64>)
    c94c:	ldr	r1, [r3, #12]
    c94e:	ldr	r4, [r0, #0]
    c950:	ands	r1, r4
    c952:	str	r1, [r3, #24]
				NVIC_ICER0 = interruptSave[0];
    c954:	str	r1, [r0, #0]
    c956:	ldrb	r1, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    c958:	lsls	r0, r1, #30
    c95a:	bpl.n	c96a <SdSpiArduinoDriver::activate()+0x32>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    c95c:	ldr	r0, [pc, #64]	; (c9a0 <SdSpiArduinoDriver::activate()+0x68>)
    c95e:	ldr	r1, [r3, #16]
    c960:	ldr	r4, [r0, #0]
    c962:	ands	r1, r4
    c964:	str	r1, [r3, #28]
				NVIC_ICER1 = interruptSave[1];
    c966:	str	r1, [r0, #0]
    c968:	ldrb	r1, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    c96a:	lsls	r1, r1, #29
    c96c:	bmi.n	c98c <SdSpiArduinoDriver::activate()+0x54>
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    c96e:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    c970:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    c972:	ldr	r1, [r3, #12]
    c974:	cmp	r1, r2
    c976:	beq.n	c988 <SdSpiArduinoDriver::activate()+0x50>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    c978:	ldr	r0, [pc, #40]	; (c9a4 <SdSpiArduinoDriver::activate()+0x6c>)
    c97a:	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    c97c:	ldr	r1, [pc, #40]	; (c9a8 <SdSpiArduinoDriver::activate()+0x70>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    c97e:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    c980:	orr.w	r0, r2, #1073741824	; 0x40000000
    c984:	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    c986:	str	r1, [r3, #0]
}
    c988:	pop	{r4}
    c98a:	bx	lr
				NVIC_ICER1 = interruptSave[1];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    c98c:	ldr	r0, [pc, #28]	; (c9ac <SdSpiArduinoDriver::activate()+0x74>)
    c98e:	ldr	r1, [r3, #20]
    c990:	ldr	r4, [r0, #0]
    c992:	ands	r1, r4
    c994:	str	r1, [r3, #32]
				NVIC_ICER2 = interruptSave[2];
    c996:	str	r1, [r0, #0]
    c998:	b.n	c96e <SdSpiArduinoDriver::activate()+0x36>
    c99a:	nop
    c99c:	.word	0xe000e180
    c9a0:	.word	0xe000e184
    c9a4:	.word	0x003f4001
    c9a8:	.word	0x803f0000
    c9ac:	.word	0xe000e188

0000c9b0 <SdSpiArduinoDriver::begin(SdSpiConfig)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
    c9b0:	push	{lr}
    c9b2:	sub	sp, #20
    c9b4:	add.w	lr, sp, #16
    c9b8:	stmdb	lr, {r1, r2, r3}
    c9bc:	ldr	r3, [sp, #12]
  if (spiConfig.spiPort) {
    c9be:	cbz	r3, c9ce <SdSpiArduinoDriver::begin(SdSpiConfig)+0x1e>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    c9c0:	str	r3, [r0, #0]
    c9c2:	mov	r0, r3
  }
  m_spi->begin();
}
    c9c4:	add	sp, #20
    c9c6:	ldr.w	lr, [sp], #4
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
  }
  m_spi->begin();
    c9ca:	b.w	7a7c <SPIClass::begin()>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    c9ce:	ldr	r3, [pc, #4]	; (c9d4 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x24>)
    c9d0:	b.n	c9c0 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x10>
    c9d2:	nop
    c9d4:	.word	0x1fff8a60

0000c9d8 <SdSpiArduinoDriver::deactivate()>:
  }
  m_spi->begin();
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::deactivate() {
  m_spi->endTransaction();
    c9d8:	ldr	r2, [r0, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    c9da:	ldrb	r3, [r2, #11]
    c9dc:	cbz	r3, ca00 <SdSpiArduinoDriver::deactivate()+0x28>
			if (interruptMasksUsed & 0x01) {
    c9de:	lsls	r0, r3, #31
    c9e0:	bpl.n	c9ea <SdSpiArduinoDriver::deactivate()+0x12>
				NVIC_ISER0 = interruptSave[0];
    c9e2:	ldr	r3, [pc, #32]	; (ca04 <SdSpiArduinoDriver::deactivate()+0x2c>)
    c9e4:	ldr	r1, [r2, #24]
    c9e6:	str	r1, [r3, #0]
    c9e8:	ldrb	r3, [r2, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    c9ea:	lsls	r1, r3, #30
    c9ec:	bpl.n	c9f6 <SdSpiArduinoDriver::deactivate()+0x1e>
				NVIC_ISER1 = interruptSave[1];
    c9ee:	ldr	r3, [pc, #24]	; (ca08 <SdSpiArduinoDriver::deactivate()+0x30>)
    c9f0:	ldr	r1, [r2, #28]
    c9f2:	str	r1, [r3, #0]
    c9f4:	ldrb	r3, [r2, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    c9f6:	lsls	r3, r3, #29
    c9f8:	bpl.n	ca00 <SdSpiArduinoDriver::deactivate()+0x28>
				NVIC_ISER2 = interruptSave[2];
    c9fa:	ldr	r3, [pc, #16]	; (ca0c <SdSpiArduinoDriver::deactivate()+0x34>)
    c9fc:	ldr	r2, [r2, #32]
    c9fe:	str	r2, [r3, #0]
    ca00:	bx	lr
    ca02:	nop
    ca04:	.word	0xe000e100
    ca08:	.word	0xe000e104
    ca0c:	.word	0xe000e108

0000ca10 <SdSpiArduinoDriver::receive()>:
}
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive() {
    ca10:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    ca12:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    ca14:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    ca18:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    ca1a:	str	r1, [r2, #44]	; 0x2c
		port().PUSHR = data;
    ca1c:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    ca1e:	ldr	r3, [r2, #44]	; 0x2c
    ca20:	cmp	r3, #0
    ca22:	bge.n	ca1e <SdSpiArduinoDriver::receive()+0xe>
		return port().POPR;
    ca24:	ldr	r0, [r2, #56]	; 0x38
  return m_spi->transfer(0XFF);
}
    ca26:	uxtb	r0, r0
    ca28:	bx	lr
    ca2a:	nop

0000ca2c <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive(uint8_t* buf, size_t count) {
    ca2c:	push	{r4, r5, r6, lr}
    ca2e:	mov	r5, r0
    ca30:	mov	r4, r1
    ca32:	mov	r6, r2
#if USE_BLOCK_TRANSFER
  memset(buf, 0XFF, count);
    ca34:	mov	r0, r1
    ca36:	movs	r1, #255	; 0xff
    ca38:	bl	106dc <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    ca3c:	ldr	r0, [r5, #0]
    ca3e:	mov	r3, r6
    ca40:	mov	r2, r4
    ca42:	mov	r1, r4
    ca44:	bl	7ca0 <SPIClass::transfer(void const*, void*, unsigned int)>
  for (size_t i = 0; i < count; i++) {
    buf[i] = m_spi->transfer(0XFF);
  }
#endif  // USE_BLOCK_TRANSFER
  return 0;
}
    ca48:	movs	r0, #0
    ca4a:	pop	{r4, r5, r6, pc}

0000ca4c <SdSpiArduinoDriver::send(unsigned char)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
    ca4c:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    ca4e:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    ca50:	mov.w	r3, #2147483648	; 0x80000000
    ca54:	str	r3, [r2, #44]	; 0x2c
		port().PUSHR = data;
    ca56:	str	r1, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    ca58:	ldr	r3, [r2, #44]	; 0x2c
    ca5a:	cmp	r3, #0
    ca5c:	bge.n	ca58 <SdSpiArduinoDriver::send(unsigned char)+0xc>
		return port().POPR;
    ca5e:	ldr	r3, [r2, #56]	; 0x38
    ca60:	bx	lr
    ca62:	nop

0000ca64 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>:
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    ca64:	push	{r4, r5, lr}
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    ca66:	subs	r5, r2, #1
    ca68:	cmp.w	r5, #512	; 0x200
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    ca6c:	sub.w	sp, sp, #516	; 0x204
    ca70:	mov	r3, r2
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    ca72:	bcc.n	ca9a <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x36>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    ca74:	cbz	r2, ca94 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x30>
    ca76:	ldr	r2, [r0, #0]
    ca78:	ldr	r2, [r2, #0]
    ca7a:	adds	r0, r1, r3
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    ca7c:	mov.w	r4, #2147483648	; 0x80000000
    m_spi->transfer(buf[i]);
    ca80:	ldrb.w	r3, [r1], #1
    ca84:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    ca86:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    ca88:	ldr	r3, [r2, #44]	; 0x2c
    ca8a:	cmp	r3, #0
    ca8c:	bge.n	ca88 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x24>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    ca8e:	cmp	r1, r0
		return port().POPR;
    ca90:	ldr	r3, [r2, #56]	; 0x38
    ca92:	bne.n	ca80 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x1c>
    m_spi->transfer(buf[i]);
  }
}
    ca94:	add.w	sp, sp, #516	; 0x204
    ca98:	pop	{r4, r5, pc}
    ca9a:	mov	r5, r0
    ca9c:	mov	r4, r2
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    memcpy(tmp, buf, count);
    ca9e:	mov	r0, sp
    caa0:	bl	cb10 <memcpy>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    caa4:	mov	r3, r4
    caa6:	mov	r2, sp
    caa8:	mov	r1, sp
    caaa:	ldr	r0, [r5, #0]
    caac:	bl	7ca0 <SPIClass::transfer(void const*, void*, unsigned int)>
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    m_spi->transfer(buf[i]);
  }
}
    cab0:	add.w	sp, sp, #516	; 0x204
    cab4:	pop	{r4, r5, pc}
    cab6:	nop

0000cab8 <sdCsInit(unsigned char)>:
#include "SdSpiDriver.h"
#if ENABLE_ARDUINO_FEATURES
#if SD_CHIP_SELECT_MODE == 0
//------------------------------------------------------------------------------
void sdCsInit(SdCsPin_t pin) {
  pinMode(pin, OUTPUT);
    cab8:	movs	r1, #1
    caba:	b.w	d7b8 <pinMode>
    cabe:	nop

0000cac0 <sdCsWrite(unsigned char, bool)>:
}
//------------------------------------------------------------------------------
void sdCsWrite(SdCsPin_t pin, bool level) {
  digitalWrite(pin, level);
    cac0:	b.w	d7ac <digitalWrite>

0000cac4 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    cac4:	bx	lr
    cac6:	nop

0000cac8 <_GLOBAL__sub_I_SD>:
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    cac8:	push	{r4, r5, r6, r7}
{
public:
	SDClass() { }
    caca:	ldr	r3, [pc, #48]	; (cafc <_GLOBAL__sub_I_SD+0x34>)
    cacc:	ldr	r0, [pc, #48]	; (cb00 <_GLOBAL__sub_I_SD+0x38>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    cace:	ldr	r7, [pc, #52]	; (cb04 <_GLOBAL__sub_I_SD+0x3c>)
    cad0:	str	r0, [r3, #0]
    cad2:	movs	r4, #0
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    cad4:	movs	r5, #41	; 0x29
    cad6:	movs	r6, #1
    cad8:	strb.w	r5, [r3, #1187]	; 0x4a3
    cadc:	strb.w	r4, [r3, #1190]	; 0x4a6
    cae0:	str.w	r7, [r3, #1176]	; 0x498
    cae4:	strb.w	r6, [r3, #1185]	; 0x4a1
    cae8:	str.w	r4, [r3, #1156]	; 0x484
    caec:	str.w	r4, [r3, #1160]	; 0x488
    caf0:	ldr	r2, [pc, #20]	; (cb08 <_GLOBAL__sub_I_SD+0x40>)
    caf2:	ldr	r1, [pc, #24]	; (cb0c <_GLOBAL__sub_I_SD+0x44>)
    caf4:	mov	r0, r3
    caf6:	pop	{r4, r5, r6, r7}
    caf8:	b.w	eb28 <__aeabi_atexit>
    cafc:	.word	0x20002be8
    cb00:	.word	0x000142ac
    cb04:	.word	0x38011001
    cb08:	.word	0x1fff8a3c
    cb0c:	.word	0x0000cac5

0000cb10 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    cb10:	push	{r0}
#endif
	orr	r3, r1, r0
    cb12:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    cb16:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    cb1a:	bne.n	cbfc <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    cb1c:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    cb1e:	bcc.n	cba4 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    cb20:	ldr.w	r3, [r1], #4
    cb24:	str.w	r3, [r0], #4
    cb28:	ldr.w	r3, [r1], #4
    cb2c:	str.w	r3, [r0], #4
    cb30:	ldr.w	r3, [r1], #4
    cb34:	str.w	r3, [r0], #4
    cb38:	ldr.w	r3, [r1], #4
    cb3c:	str.w	r3, [r0], #4
    cb40:	ldr.w	r3, [r1], #4
    cb44:	str.w	r3, [r0], #4
    cb48:	ldr.w	r3, [r1], #4
    cb4c:	str.w	r3, [r0], #4
    cb50:	ldr.w	r3, [r1], #4
    cb54:	str.w	r3, [r0], #4
    cb58:	ldr.w	r3, [r1], #4
    cb5c:	str.w	r3, [r0], #4
    cb60:	ldr.w	r3, [r1], #4
    cb64:	str.w	r3, [r0], #4
    cb68:	ldr.w	r3, [r1], #4
    cb6c:	str.w	r3, [r0], #4
    cb70:	ldr.w	r3, [r1], #4
    cb74:	str.w	r3, [r0], #4
    cb78:	ldr.w	r3, [r1], #4
    cb7c:	str.w	r3, [r0], #4
    cb80:	ldr.w	r3, [r1], #4
    cb84:	str.w	r3, [r0], #4
    cb88:	ldr.w	r3, [r1], #4
    cb8c:	str.w	r3, [r0], #4
    cb90:	ldr.w	r3, [r1], #4
    cb94:	str.w	r3, [r0], #4
    cb98:	ldr.w	r3, [r1], #4
    cb9c:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    cba0:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    cba2:	bcs.n	cb20 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    cba4:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    cba6:	bcc.n	cbcc <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    cba8:	ldr.w	r3, [r1], #4
    cbac:	str.w	r3, [r0], #4
    cbb0:	ldr.w	r3, [r1], #4
    cbb4:	str.w	r3, [r0], #4
    cbb8:	ldr.w	r3, [r1], #4
    cbbc:	str.w	r3, [r0], #4
    cbc0:	ldr.w	r3, [r1], #4
    cbc4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    cbc8:	subs	r2, #16
	bhs	.Lmid_block_loop
    cbca:	bcs.n	cba8 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    cbcc:	adds	r2, #12
	blo	.Lcopy_less_than_4
    cbce:	bcc.n	cbdc <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    cbd0:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    cbd4:	str.w	r3, [r0], #4
	subs	r2, #4
    cbd8:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    cbda:	bcs.n	cbd0 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    cbdc:	adds	r2, #4
	beq	.Ldone
    cbde:	beq.n	cbf6 <memcpy+0xe6>

	lsls	r2, r2, #31
    cbe0:	lsls	r2, r2, #31
	itt ne
    cbe2:	itt	ne
	ldrbne  r3, [r1], #1
    cbe4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    cbe8:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    cbec:	bcc.n	cbf6 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    cbee:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    cbf0:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    cbf2:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    cbf4:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    cbf6:	pop	{r0}
#endif
	bx	lr
    cbf8:	bx	lr
    cbfa:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    cbfc:	cmp	r2, #12
	blo	.Lbyte_copy
    cbfe:	bcc.n	cc96 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    cc00:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    cc04:	beq.n	cc2a <memcpy+0x11a>

	rsb	r3, #4
    cc06:	rsb	r3, r3, #4
	subs	r2, r3
    cc0a:	subs	r2, r2, r3

	lsls    r3, r3, #31
    cc0c:	lsls	r3, r3, #31
	itt ne
    cc0e:	itt	ne
	ldrbne  r3, [r1], #1
    cc10:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    cc14:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    cc18:	bcc.n	cc2a <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    cc1a:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    cc1e:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    cc22:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    cc26:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    cc2a:	ands.w	r3, r1, #3
	beq	.Lbig_block
    cc2e:	beq.w	cb1c <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    cc32:	push	{r4, r5}
	subs	r2, #4
    cc34:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    cc36:	subs	r1, r1, r3
	rsb	ip, r3, #4
    cc38:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    cc3c:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    cc40:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    cc42:	beq.n	cc78 <memcpy+0x168>
	cmp	r3, #3
    cc44:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    cc46:	beq.n	cc60 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    cc48:	lsrs	r4, r4, #8
    cc4a:	ldr.w	r3, [r1], #4
    cc4e:	lsls	r5, r3, #24
    cc50:	orr.w	r4, r4, r5
    cc54:	str.w	r4, [r0], #4
    cc58:	mov	r4, r3
    cc5a:	subs	r2, #4
    cc5c:	bcs.n	cc48 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    cc5e:	b.n	cc8e <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    cc60:	lsrs	r4, r4, #24
    cc62:	ldr.w	r3, [r1], #4
    cc66:	lsls	r5, r3, #8
    cc68:	orr.w	r4, r4, r5
    cc6c:	str.w	r4, [r0], #4
    cc70:	mov	r4, r3
    cc72:	subs	r2, #4
    cc74:	bcs.n	cc60 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    cc76:	b.n	cc8e <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    cc78:	lsrs	r4, r4, #16
    cc7a:	ldr.w	r3, [r1], #4
    cc7e:	lsls	r5, r3, #16
    cc80:	orr.w	r4, r4, r5
    cc84:	str.w	r4, [r0], #4
    cc88:	mov	r4, r3
    cc8a:	subs	r2, #4
    cc8c:	bcs.n	cc78 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    cc8e:	adds	r2, #4
	subs	r1, ip
    cc90:	subs.w	r1, r1, ip
	pop	{r4, r5}
    cc94:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    cc96:	subs	r2, #4
	blo	.Lcopy_less_than_4
    cc98:	bcc.n	cbdc <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    cc9a:	subs	r2, #1
	ldrb    r3, [r1], #1
    cc9c:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    cca0:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    cca4:	bcs.n	cc9a <memcpy+0x18a>

	ldrb	r3, [r1]
    cca6:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    cca8:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    ccaa:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    ccac:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    ccae:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    ccb0:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    ccb2:	pop	{r0}
#endif
	bx	lr
    ccb4:	bx	lr
    ccb6:	nop

0000ccb8 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    ccb8:	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    ccba:	ldr	r5, [pc, #60]	; (ccf8 <usb_serial_getchar+0x40>)
    ccbc:	ldr	r0, [r5, #0]
    ccbe:	cbz	r0, cce0 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    ccc0:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    ccc2:	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    ccc4:	adds	r1, r0, r3
    ccc6:	adds	r3, #1
	if (i >= rx_packet->len) {
    ccc8:	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    ccca:	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    cccc:	bcs.n	ccd4 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    ccce:	strh	r3, [r0, #2]
	}
	return c;
    ccd0:	mov	r0, r4
}
    ccd2:	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    ccd4:	bl	d9c4 <usb_free>
		rx_packet = NULL;
    ccd8:	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    ccda:	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    ccdc:	str	r3, [r5, #0]
    ccde:	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    cce0:	ldr	r3, [pc, #24]	; (ccfc <usb_serial_getchar+0x44>)
    cce2:	ldrb	r3, [r3, #0]
    cce4:	cbz	r3, ccf2 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    cce6:	movs	r0, #2
    cce8:	bl	da10 <usb_rx>
    ccec:	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    ccee:	cmp	r0, #0
    ccf0:	bne.n	ccc0 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    ccf2:	mov.w	r0, #4294967295
    ccf6:	pop	{r3, r4, r5, pc}
    ccf8:	.word	0x2000309c
    ccfc:	.word	0x200031a8

0000cd00 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    cd00:	push	{r4, lr}
	if (!rx_packet) {
    cd02:	ldr	r4, [pc, #36]	; (cd28 <usb_serial_peekchar+0x28>)
    cd04:	ldr	r0, [r4, #0]
    cd06:	cbz	r0, cd10 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    cd08:	ldrh	r3, [r0, #2]
    cd0a:	add	r0, r3
    cd0c:	ldrb	r0, [r0, #8]
}
    cd0e:	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    cd10:	ldr	r3, [pc, #24]	; (cd2c <usb_serial_peekchar+0x2c>)
    cd12:	ldrb	r3, [r3, #0]
    cd14:	cbz	r3, cd22 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    cd16:	movs	r0, #2
    cd18:	bl	da10 <usb_rx>
    cd1c:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    cd1e:	cmp	r0, #0
    cd20:	bne.n	cd08 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    cd22:	mov.w	r0, #4294967295
    cd26:	pop	{r4, pc}
    cd28:	.word	0x2000309c
    cd2c:	.word	0x200031a8

0000cd30 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    cd30:	ldr	r3, [pc, #16]	; (cd44 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    cd32:	ldr	r2, [pc, #20]	; (cd48 <usb_serial_available+0x18>)
    cd34:	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    cd36:	ldrh	r0, [r2, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    cd38:	cbz	r3, cd42 <usb_serial_available+0x12>
    cd3a:	ldrh	r2, [r3, #0]
    cd3c:	ldrh	r3, [r3, #2]
    cd3e:	subs	r3, r2, r3
    cd40:	add	r0, r3
	return count;
}
    cd42:	bx	lr
    cd44:	.word	0x2000309c
    cd48:	.word	0x20003224

0000cd4c <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    cd4c:	ldr	r3, [pc, #44]	; (cd7c <usb_serial_flush_input+0x30>)
    cd4e:	ldrb	r3, [r3, #0]
    cd50:	cbz	r3, cd7a <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    cd52:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    cd54:	ldr	r4, [pc, #40]	; (cd80 <usb_serial_flush_input+0x34>)
    cd56:	ldr	r0, [r4, #0]
    cd58:	cbz	r0, cd6e <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    cd5a:	bl	d9c4 <usb_free>
		rx_packet = NULL;
    cd5e:	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    cd60:	movs	r0, #2
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    cd62:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    cd64:	bl	da10 <usb_rx>
		if (!rx) break;
    cd68:	cbz	r0, cd78 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    cd6a:	bl	d9c4 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    cd6e:	movs	r0, #2
    cd70:	bl	da10 <usb_rx>
		if (!rx) break;
    cd74:	cmp	r0, #0
    cd76:	bne.n	cd6a <usb_serial_flush_input+0x1e>
    cd78:	pop	{r4, pc}
    cd7a:	bx	lr
    cd7c:	.word	0x200031a8
    cd80:	.word	0x2000309c

0000cd84 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    cd84:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    cd88:	ldr.w	r9, [pc, #248]	; ce84 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    cd8c:	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    cd8e:	movs	r2, #1
    cd90:	strb.w	r2, [r9]
	while (size > 0) {
    cd94:	str	r1, [sp, #4]
    cd96:	cbz	r1, cdf4 <usb_serial_write+0x70>
    cd98:	ldr.w	r8, [pc, #236]	; ce88 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    cd9c:	ldr	r7, [pc, #216]	; (ce78 <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    cd9e:	ldr	r6, [sp, #4]
    cda0:	mov	fp, r0
		if (!tx_packet) {
    cda2:	ldr.w	r0, [r8]
    cda6:	cbz	r0, ce16 <usb_serial_write+0x92>
    cda8:	ldr	r5, [pc, #208]	; (ce7c <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    cdaa:	ldrh	r4, [r0, #2]
    cdac:	rsb	r1, r4, #64	; 0x40
    cdb0:	cmp	r1, r6
    cdb2:	it	cs
    cdb4:	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    cdb6:	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    cdba:	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    cdbc:	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    cdc0:	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    cdc2:	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    cdc4:	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    cdc8:	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    cdcc:	cbz	r1, cde4 <usb_serial_write+0x60>
    cdce:	subs	r4, #1
    cdd0:	add	r2, r4
    cdd2:	add	r1, fp
    cdd4:	ldrb.w	r4, [fp], #1
    cdd8:	strb.w	r4, [r2, #1]!
    cddc:	cmp	fp, r1
    cdde:	bne.n	cdd4 <usb_serial_write+0x50>
    cde0:	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    cde4:	cmp.w	lr, #63	; 0x3f
    cde8:	bhi.n	ce02 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    cdea:	ldr	r2, [pc, #148]	; (ce80 <usb_serial_write+0xfc>)
    cdec:	movs	r1, #5
    cdee:	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    cdf0:	cmp	r6, #0
    cdf2:	bne.n	cda2 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    cdf4:	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    cdf6:	movs	r3, #0
    cdf8:	strb.w	r3, [r9]
	return ret;
}
    cdfc:	add	sp, #12
    cdfe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    ce02:	movs	r2, #64	; 0x40
    ce04:	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    ce06:	mov	r1, r0
    ce08:	movs	r0, #3
    ce0a:	bl	dafc <usb_tx>
			tx_packet = NULL;
    ce0e:	movs	r2, #0
    ce10:	str.w	r2, [r8]
    ce14:	b.n	cdea <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    ce16:	ldrb	r2, [r7, #0]
    ce18:	cbz	r2, ce66 <usb_serial_write+0xe2>
    ce1a:	ldr	r5, [pc, #96]	; (ce7c <usb_serial_write+0xf8>)
    ce1c:	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    ce20:	mov.w	sl, #1
    ce24:	b.n	ce36 <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    ce26:	subs	r4, #1
    ce28:	beq.n	ce58 <usb_serial_write+0xd4>
    ce2a:	ldrb	r2, [r5, #0]
    ce2c:	cbnz	r2, ce58 <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    ce2e:	bl	e4a8 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    ce32:	ldrb	r2, [r7, #0]
    ce34:	cbz	r2, ce66 <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    ce36:	movs	r0, #3
    ce38:	bl	da4c <usb_tx_packet_count>
    ce3c:	cmp	r0, #7
    ce3e:	bhi.n	ce26 <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    ce40:	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    ce44:	bl	d984 <usb_malloc>
    ce48:	str.w	r0, [r8]
					if (tx_packet) break;
    ce4c:	cmp	r0, #0
    ce4e:	bne.n	cdaa <usb_serial_write+0x26>
					tx_noautoflush = 0;
    ce50:	ldr	r3, [pc, #48]	; (ce84 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    ce52:	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    ce54:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    ce56:	bne.n	ce2a <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    ce58:	movs	r3, #1
					return -1;
    ce5a:	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    ce5e:	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    ce60:	add	sp, #12
    ce62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    ce66:	movs	r3, #0
					return -1;
    ce68:	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    ce6c:	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    ce70:	add	sp, #12
    ce72:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ce76:	nop
    ce78:	.word	0x200031a8
    ce7c:	.word	0x20003098
    ce80:	.word	0x20003090
    ce84:	.word	0x20003091
    ce88:	.word	0x20003094

0000ce8c <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    ce8c:	push	{lr}
    ce8e:	sub	sp, #12
    ce90:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    ce92:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    ce94:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    ce98:	mov	r0, r3
    ce9a:	bl	cd84 <usb_serial_write>
}
    ce9e:	add	sp, #12
    cea0:	ldr.w	pc, [sp], #4

0000cea4 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    cea4:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    cea6:	ldr	r5, [pc, #56]	; (cee0 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    cea8:	ldr	r4, [pc, #56]	; (cee4 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    ceaa:	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    ceac:	movs	r3, #1
    ceae:	strb	r3, [r4, #0]
	if (!tx_packet) {
    ceb0:	cbz	r0, cebe <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    ceb2:	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    ceb4:	movs	r3, #0
    ceb6:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    ceb8:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    cebc:	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    cebe:	ldr	r3, [pc, #40]	; (cee8 <usb_serial_write_buffer_free+0x44>)
    cec0:	ldrb	r3, [r3, #0]
    cec2:	cbnz	r3, ceca <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    cec4:	movs	r0, #0
    cec6:	strb	r0, [r4, #0]
			return 0;
    cec8:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    ceca:	movs	r0, #3
    cecc:	bl	da4c <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    ced0:	cmp	r0, #7
    ced2:	bhi.n	cec4 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    ced4:	bl	d984 <usb_malloc>
    ced8:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    ceda:	cmp	r0, #0
    cedc:	bne.n	ceb2 <usb_serial_write_buffer_free+0xe>
    cede:	b.n	cec4 <usb_serial_write_buffer_free+0x20>
    cee0:	.word	0x20003094
    cee4:	.word	0x20003091
    cee8:	.word	0x200031a8

0000ceec <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    ceec:	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    ceee:	ldr	r3, [pc, #68]	; (cf34 <usb_serial_flush_output+0x48>)
    cef0:	ldrb	r3, [r3, #0]
    cef2:	cbz	r3, cf18 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    cef4:	ldr	r6, [pc, #64]	; (cf38 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    cef6:	ldr	r5, [pc, #68]	; (cf3c <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    cef8:	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    cefa:	movs	r7, #1
    cefc:	strb	r7, [r5, #0]
	if (tx_packet) {
    cefe:	cbz	r4, cf1a <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    cf00:	ldr	r2, [pc, #60]	; (cf40 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    cf02:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    cf04:	movs	r7, #0
    cf06:	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    cf08:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    cf0a:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    cf0c:	movs	r0, #3
    cf0e:	bl	dafc <usb_tx>
		tx_packet = NULL;
    cf12:	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    cf14:	movs	r3, #0
    cf16:	strb	r3, [r5, #0]
    cf18:	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    cf1a:	bl	d984 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    cf1e:	ldr	r3, [pc, #32]	; (cf40 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    cf20:	cbz	r0, cf2e <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    cf22:	mov	r1, r0
    cf24:	movs	r0, #3
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    cf26:	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    cf28:	bl	dafc <usb_tx>
    cf2c:	b.n	cf14 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    cf2e:	strb	r7, [r3, #0]
    cf30:	b.n	cf14 <usb_serial_flush_output+0x28>
    cf32:	nop
    cf34:	.word	0x200031a8
    cf38:	.word	0x20003094
    cf3c:	.word	0x20003091
    cf40:	.word	0x20003090

0000cf44 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    cf44:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    cf46:	ldr	r3, [pc, #56]	; (cf80 <usb_serial_flush_callback+0x3c>)
    cf48:	ldrb	r3, [r3, #0]
    cf4a:	cbnz	r3, cf6a <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    cf4c:	ldr	r4, [pc, #52]	; (cf84 <usb_serial_flush_callback+0x40>)
    cf4e:	ldr	r1, [r4, #0]
    cf50:	cbz	r1, cf6c <usb_serial_flush_callback+0x28>
    cf52:	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    cf56:	ldrh	r3, [r1, #2]
    cf58:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    cf5a:	movs	r0, #3
    cf5c:	bl	dafc <usb_tx>
		tx_packet = NULL;
    cf60:	str	r5, [r4, #0]
    cf62:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    cf64:	ldr	r3, [pc, #32]	; (cf88 <usb_serial_flush_callback+0x44>)
    cf66:	movs	r2, #1
    cf68:	strb	r2, [r3, #0]
    cf6a:	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    cf6c:	bl	d984 <usb_malloc>
		if (tx) {
    cf70:	cmp	r0, #0
    cf72:	beq.n	cf64 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    cf74:	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    cf76:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    cf7a:	movs	r0, #3
    cf7c:	b.w	dafc <usb_tx>
    cf80:	.word	0x20003091
    cf84:	.word	0x20003094
    cf88:	.word	0x20003090

0000cf8c <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    cf8c:	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    cf8e:	ldr	r0, [pc, #164]	; (d034 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    cf90:	ldr	r2, [pc, #164]	; (d038 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    cf92:	ldr	r3, [pc, #168]	; (d03c <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    cf94:	ldr	r5, [pc, #168]	; (d040 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    cf96:	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    cf98:	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    cf9a:	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    cf9c:	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    cf9e:	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    cfa0:	ldr	r4, [pc, #160]	; (d044 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    cfa2:	cmp	r3, #8
    cfa4:	beq.n	d008 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    cfa6:	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    cfa8:	ldr	r0, [pc, #156]	; (d048 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    cfaa:	ldr	r1, [pc, #160]	; (d04c <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    cfac:	beq.n	d01e <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    cfae:	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    cfb0:	ite	eq
    cfb2:	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    cfb4:	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    cfb6:	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    cfb8:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    cfba:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    cfbc:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    cfbe:	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    cfc0:	ldr	r3, [pc, #140]	; (d050 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    cfc2:	ldr	r1, [pc, #144]	; (d054 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    cfc4:	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    cfc6:	ldr	r2, [pc, #144]	; (d058 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    cfc8:	cbz	r3, cffa <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    cfca:	movs	r3, #1
    cfcc:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    cfce:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    cfd0:	ldr	r3, [pc, #136]	; (d05c <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    cfd2:	ldr	r1, [pc, #140]	; (d060 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    cfd4:	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    cfd6:	ldr	r2, [pc, #140]	; (d064 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    cfd8:	cmp	r3, #1
    cfda:	bls.n	d02a <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    cfdc:	cmp	r3, #4
    cfde:	bls.n	d000 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    cfe0:	cmp	r3, #8
    cfe2:	bls.n	d022 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    cfe4:	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    cfe6:	ite	ls
    cfe8:	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    cfea:	movhi	r3, #135	; 0x87
    cfec:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    cfee:	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    cff0:	ldr	r3, [pc, #116]	; (d068 <analog_init+0xdc>)
    cff2:	movs	r2, #1
    cff4:	strb	r2, [r3, #0]
}
    cff6:	pop	{r4, r5}
    cff8:	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    cffa:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    cffc:	str	r3, [r2, #0]
    cffe:	b.n	cfd0 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    d000:	movs	r3, #132	; 0x84
    d002:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    d004:	str	r3, [r2, #0]
    d006:	b.n	cff0 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    d008:	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    d00c:	ldr	r1, [pc, #60]	; (d04c <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    d00e:	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    d010:	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    d012:	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    d014:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    d016:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    d018:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    d01a:	str	r3, [r1, #0]
    d01c:	b.n	cfc0 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    d01e:	movs	r2, #57	; 0x39
    d020:	b.n	d012 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    d022:	movs	r3, #133	; 0x85
    d024:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    d026:	str	r3, [r2, #0]
    d028:	b.n	cff0 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    d02a:	movs	r3, #128	; 0x80
    d02c:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    d02e:	str	r3, [r2, #0]
    d030:	b.n	cff0 <analog_init+0x64>
    d032:	nop
    d034:	.word	0x40074000
    d038:	.word	0x40074001
    d03c:	.word	0x1fff8b74
    d040:	.word	0x4003b008
    d044:	.word	0x4003b00c
    d048:	.word	0x400bb008
    d04c:	.word	0x400bb00c
    d050:	.word	0x200030a2
    d054:	.word	0x4003b020
    d058:	.word	0x400bb020
    d05c:	.word	0x1fff8b75
    d060:	.word	0x4003b024
    d064:	.word	0x400bb024
    d068:	.word	0x200030a1

0000d06c <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    d06c:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d06e:	ldr	r4, [pc, #64]	; (d0b0 <fault_isr+0x44>)
    d070:	b.n	d084 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d072:	ldr	r3, [r4, #0]
    d074:	lsls	r1, r3, #21
    d076:	bmi.n	d094 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d078:	ldr	r3, [r4, #0]
    d07a:	lsls	r2, r3, #20
    d07c:	bmi.n	d09e <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d07e:	ldr	r3, [r4, #0]
    d080:	lsls	r3, r3, #19
    d082:	bmi.n	d0a8 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d084:	ldr	r3, [r4, #0]
    d086:	lsls	r0, r3, #13
    d088:	bpl.n	d072 <fault_isr+0x6>
    d08a:	bl	db80 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d08e:	ldr	r3, [r4, #0]
    d090:	lsls	r1, r3, #21
    d092:	bpl.n	d078 <fault_isr+0xc>
    d094:	bl	d0b4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d098:	ldr	r3, [r4, #0]
    d09a:	lsls	r2, r3, #20
    d09c:	bpl.n	d07e <fault_isr+0x12>
    d09e:	bl	d0b4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d0a2:	ldr	r3, [r4, #0]
    d0a4:	lsls	r3, r3, #19
    d0a6:	bpl.n	d084 <fault_isr+0x18>
    d0a8:	bl	d0b4 <unused_isr>
    d0ac:	b.n	d084 <fault_isr+0x18>
    d0ae:	nop
    d0b0:	.word	0x40048034

0000d0b4 <unused_isr>:
	}
}

void unused_isr(void)
{
    d0b4:	push	{r3, lr}
	fault_isr();
    d0b6:	bl	d06c <fault_isr>
    d0ba:	nop

0000d0bc <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    d0bc:	ldr	r3, [pc, #4]	; (d0c4 <startup_early_hook+0x8>)
    d0be:	movs	r2, #16
    d0c0:	strh	r2, [r3, #0]
    d0c2:	bx	lr
    d0c4:	.word	0x40052000

0000d0c8 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    d0c8:	bx	lr
    d0ca:	nop

0000d0cc <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    d0cc:	ldr	r1, [pc, #36]	; (d0f4 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    d0ce:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    d0d0:	ldr	r3, [r1, #0]
	if (incr != 0) {
    d0d2:	cbz	r0, d0e2 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    d0d4:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    d0d6:	add	r0, r3
    d0d8:	sub.w	r2, r2, #4096	; 0x1000
    d0dc:	cmp	r0, r2
    d0de:	bcs.n	d0e6 <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    d0e0:	str	r0, [r1, #0]
	}
	return prev;
    d0e2:	mov	r0, r3
}
    d0e4:	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    d0e6:	bl	fef8 <__errno>
    d0ea:	movs	r3, #12
    d0ec:	str	r3, [r0, #0]
			return (void *)-1;
    d0ee:	mov.w	r0, #4294967295
    d0f2:	pop	{r3, pc}
    d0f4:	.word	0x1fff8b78

0000d0f8 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    d0f8:	b.n	d0f8 <__cxa_pure_virtual>
    d0fa:	nop

0000d0fc <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    d0fc:	push	{r4, r5, r6, lr}
    d0fe:	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    d100:	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d102:	ldr	r3, [pc, #100]	; (d168 <usb_init_serialnumber+0x6c>)
	FTFL_FCCOB0 = 0x41;
    d104:	ldr	r5, [pc, #100]	; (d16c <usb_init_serialnumber+0x70>)
	FTFL_FCCOB1 = 15;
    d106:	ldr	r0, [pc, #104]	; (d170 <usb_init_serialnumber+0x74>)
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d108:	movs	r2, #112	; 0x70
	FTFL_FCCOB0 = 0x41;
    d10a:	movs	r6, #65	; 0x41
	FTFL_FCCOB1 = 15;
    d10c:	movs	r4, #15
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d10e:	movs	r1, #128	; 0x80
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d110:	strb	r2, [r3, #0]
	FTFL_FCCOB0 = 0x41;
    d112:	strb	r6, [r5, #0]
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d114:	mov	r2, r3

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	FTFL_FCCOB0 = 0x41;
	FTFL_FCCOB1 = 15;
    d116:	strb	r4, [r0, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d118:	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d11a:	ldrb	r3, [r2, #0]
    d11c:	lsls	r3, r3, #24
    d11e:	bpl.n	d11a <usb_init_serialnumber+0x1e>
	num = *(uint32_t *)&FTFL_FCCOB7;
    d120:	ldr	r3, [pc, #80]	; (d174 <usb_init_serialnumber+0x78>)
    d122:	ldr	r0, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    d124:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d126:	ldr	r3, [pc, #80]	; (d178 <usb_init_serialnumber+0x7c>)
    d128:	ldr	r4, [pc, #80]	; (d17c <usb_init_serialnumber+0x80>)
    d12a:	cmp	r0, r3
    d12c:	it	ls
    d12e:	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    d132:	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d134:	it	ls
    d136:	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    d138:	movs	r2, #10
    d13a:	bl	d180 <ultoa>
    d13e:	add	r1, sp, #4
    d140:	mov	r0, r4
	for (i=0; i<10; i++) {
    d142:	movs	r3, #0
		char c = buf[i];
    d144:	ldrb.w	r2, [r1], #1
    d148:	adds	r3, #1
		if (!c) break;
    d14a:	cbz	r2, d15c <usb_init_serialnumber+0x60>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d14c:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    d14e:	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d152:	bne.n	d144 <usb_init_serialnumber+0x48>
    d154:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d156:	strb	r3, [r4, #0]
}
    d158:	add	sp, #16
    d15a:	pop	{r4, r5, r6, pc}
    d15c:	lsls	r3, r3, #1
    d15e:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d160:	strb	r3, [r4, #0]
}
    d162:	add	sp, #16
    d164:	pop	{r4, r5, r6, pc}
    d166:	nop
    d168:	.word	0x40020000
    d16c:	.word	0x40020007
    d170:	.word	0x40020006
    d174:	.word	0x40020008
    d178:	.word	0x0098967f
    d17c:	.word	0x1fff8c50

0000d180 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    d180:	push	{r4, r5, r6, r7}
    d182:	subs	r5, r1, #1
    d184:	mov	r6, r5
	unsigned digit;
	int i=0, j;
    d186:	movs	r4, #0
    d188:	b.n	d18c <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    d18a:	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    d18c:	udiv	r3, r0, r2
    d190:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    d194:	cmp	r0, #9
    d196:	add.w	r7, r0, #48	; 0x30
    d19a:	itet	hi
    d19c:	addhi	r0, #55	; 0x37
    d19e:	uxtbls	r0, r7
    d1a0:	uxtbhi	r0, r0
    d1a2:	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    d1a6:	mov	r0, r3
    d1a8:	cmp	r3, #0
    d1aa:	bne.n	d18a <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    d1ac:	adds	r2, r1, r4
    d1ae:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    d1b0:	cbz	r4, d1c6 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    d1b2:	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    d1b4:	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    d1b8:	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    d1ba:	adds	r3, #1
    d1bc:	subs	r0, r4, r3
    d1be:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    d1c0:	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    d1c4:	blt.n	d1b2 <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    d1c6:	mov	r0, r1
    d1c8:	pop	{r4, r5, r6, r7}
    d1ca:	bx	lr

0000d1cc <dtostrf>:
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    d1cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d1d0:	mov	r5, r1
    d1d2:	sub	sp, #20
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    d1d4:	eor.w	r9, r5, r5, asr #31
	if (isnanf(val)) {
    d1d8:	mov	r1, r0
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    d1da:	mov	sl, r0
    d1dc:	mov	r7, r2
    d1de:	mov	r4, r3
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    d1e0:	sub.w	r9, r9, r5, asr #31
	if (isnanf(val)) {
    d1e4:	bl	fa9c <__aeabi_fcmpun>
    d1e8:	cmp	r0, #0
    d1ea:	bne.w	d44c <dtostrf+0x280>
			awidth--;
		}
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
    d1ee:	bic.w	r8, sl, #2147483648	; 0x80000000
    d1f2:	mov	r0, r8
    d1f4:	ldr	r1, [pc, #796]	; (d514 <dtostrf+0x348>)
    d1f6:	bl	fa9c <__aeabi_fcmpun>
    d1fa:	cmp	r0, #0
    d1fc:	bne.n	d28e <dtostrf+0xc2>
    d1fe:	mov	r0, r8
    d200:	ldr	r1, [pc, #784]	; (d514 <dtostrf+0x348>)
    d202:	bl	fa60 <__aeabi_fcmple>
    d206:	mov	r6, r0
    d208:	cmp	r0, #0
    d20a:	bne.n	d28e <dtostrf+0xc2>
		int ndigs = (val<0) ? 4 : 3;
    d20c:	movs	r1, #0
    d20e:	mov	r0, sl
    d210:	bl	fa4c <__aeabi_fcmplt>
    d214:	cmp	r0, #0
    d216:	ite	ne
    d218:	movne	r0, #4
    d21a:	moveq	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d21c:	cmp	r0, r9
    d21e:	blt.n	d25c <dtostrf+0x90>
		if (width<0) {
    d220:	cmp	r5, #0
    d222:	blt.w	d50e <dtostrf+0x342>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    d226:	mov	r0, sl
    d228:	movs	r1, #0
    d22a:	bl	fa4c <__aeabi_fcmplt>
    d22e:	mov	r5, r4
    d230:	cbnz	r0, d286 <dtostrf+0xba>
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d232:	movs	r1, #73	; 0x49
    d234:	movs	r2, #78	; 0x4e
    d236:	movs	r3, #70	; 0x46
    d238:	strb	r1, [r4, #0]
    d23a:	strb	r2, [r4, #1]
    d23c:	strb	r3, [r4, #2]
    d23e:	adds	r4, #3
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    d240:	cmp	r6, #0
    d242:	beq.w	d532 <dtostrf+0x366>
    d246:	adds	r0, r4, r6
			*buf++ = ' ';
    d248:	movs	r3, #32
    d24a:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    d24e:	cmp	r0, r4
    d250:	bne.n	d24a <dtostrf+0x7e>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    d252:	movs	r3, #0
    d254:	strb	r3, [r0, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    d256:	add	sp, #20
    d258:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d25c:	cmp	r5, #0
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d25e:	rsb	r6, r0, r9
		if (width<0) {
    d262:	bge.n	d226 <dtostrf+0x5a>
			while (awidth) {
    d264:	cmp	r6, #0
    d266:	beq.w	d50e <dtostrf+0x342>
    d26a:	adds	r5, r4, r6
				*buf++ = ' ';
    d26c:	movs	r3, #32
    d26e:	strb.w	r3, [r4], #1
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    d272:	cmp	r4, r5
    d274:	bne.n	d26e <dtostrf+0xa2>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    d276:	mov	r0, sl
    d278:	movs	r1, #0
    d27a:	bl	fa4c <__aeabi_fcmplt>
    d27e:	cmp	r0, #0
    d280:	beq.w	d4c8 <dtostrf+0x2fc>
    d284:	movs	r6, #0
    d286:	movs	r3, #45	; 0x2d
    d288:	strb	r3, [r5, #0]
    d28a:	adds	r4, r5, #1
    d28c:	b.n	d232 <dtostrf+0x66>
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    d28e:	add	r3, sp, #8
    d290:	add	r2, sp, #4
    d292:	mov	r1, r7
    d294:	mov	r0, sl
    d296:	bl	fed8 <fcvtf>
    d29a:	mov	fp, r7
    d29c:	mov	r8, r0

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    d29e:	ldr.w	r9, [sp, #4]
    d2a2:	cmp	r7, #0
    d2a4:	beq.n	d356 <dtostrf+0x18a>
    d2a6:	rsb	r3, r9, #0
		s = (*s < '5') ? "0" : "1";
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
    d2aa:	cmp	r3, r7
    d2ac:	bgt.w	d3d8 <dtostrf+0x20c>
    d2b0:	mov	r0, r8
    d2b2:	bl	10d40 <strlen>
    d2b6:	mov	r6, r0
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d2b8:	cmp	r9, r6
    d2ba:	it	lt
    d2bc:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d2be:	cmp.w	r9, #0
    d2c2:	bne.w	d3f6 <dtostrf+0x22a>
    d2c6:	adds	r6, #1
			if (newDecimalPoint - decpt == precision + 1) decpt++;
		}
	}

	// add 1 for sign if negative
	if (sign) reqd++;
    d2c8:	ldr.w	lr, [sp, #8]
    d2cc:	cmp.w	lr, #0
    d2d0:	beq.n	d37a <dtostrf+0x1ae>
    d2d2:	adds	r6, #1

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    d2d4:	subs	r0, r5, r6
	if (pad > 0) {
    d2d6:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    d2d8:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    d2dc:	bgt.n	d386 <dtostrf+0x1ba>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    d2de:	mov	r3, r4
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
    d2e0:	movs	r2, #45	; 0x2d
    d2e2:	strb	r2, [r3, #0]
    d2e4:	adds	r3, #1
	if (decpt == 0 && precision > 0) {
    d2e6:	cmp.w	r9, #0
    d2ea:	bne.n	d3b4 <dtostrf+0x1e8>
    d2ec:	cbz	r7, d2fc <dtostrf+0x130>
		*p++ = '0';
    d2ee:	mov	r2, r3
    d2f0:	movs	r0, #48	; 0x30
    d2f2:	strb.w	r0, [r2], #2
		*p++ = '.';
    d2f6:	movs	r0, #46	; 0x2e
    d2f8:	strb	r0, [r3, #1]
    d2fa:	mov	r3, r2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d2fc:	cmp	r3, r1
    d2fe:	bcs.n	d342 <dtostrf+0x176>
		*p++ = *s++;
    d300:	adds	r7, r3, #1
    d302:	ldrb.w	r2, [r8]
    d306:	strb	r2, [r3, #0]
		if (p == e) break;
    d308:	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    d30a:	add.w	r8, r8, #1
		if (p == e) break;
    d30e:	beq.n	d344 <dtostrf+0x178>
    d310:	ldr	r2, [sp, #4]
		if (--decpt == 0) *p++ = '.';
    d312:	mov.w	lr, #46	; 0x2e
    d316:	b.n	d330 <dtostrf+0x164>
    d318:	strb.w	lr, [r3, #1]
    d31c:	adds	r3, #2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d31e:	cmp	r3, r1
		*p++ = *s++;
    d320:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d324:	bcs.n	d342 <dtostrf+0x176>
		*p++ = *s++;
    d326:	ldrb.w	r0, [r8], #1
    d32a:	strb	r0, [r3, #0]
		if (p == e) break;
    d32c:	cmp	r7, r1
    d32e:	beq.n	d344 <dtostrf+0x178>
		if (--decpt == 0) *p++ = '.';
    d330:	subs	r2, #1
    d332:	str	r2, [sp, #4]
    d334:	cmp	r2, #0
    d336:	beq.n	d318 <dtostrf+0x14c>
    d338:	mov	r3, r7
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d33a:	cmp	r3, r1
		*p++ = *s++;
    d33c:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d340:	bcc.n	d326 <dtostrf+0x15a>
    d342:	mov	r1, r3
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
    d344:	cmp	r5, #0
    d346:	blt.w	d49c <dtostrf+0x2d0>
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    d34a:	movs	r3, #0

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
    d34c:	mov	r0, r4
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    d34e:	strb	r3, [r1, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    d350:	add	sp, #20
    d352:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    d356:	cmp.w	r9, #0
    d35a:	bne.n	d2a6 <dtostrf+0xda>
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    d35c:	ldrb.w	r8, [r0]
    d360:	ldr	r1, [pc, #436]	; (d518 <dtostrf+0x34c>)
    d362:	ldr	r2, [pc, #440]	; (d51c <dtostrf+0x350>)
		decpt++;
    d364:	movs	r3, #1
    d366:	str	r3, [sp, #4]
    d368:	mov	r9, r3
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    d36a:	cmp.w	r8, #52	; 0x34
    d36e:	ite	hi
    d370:	movhi	r8, r1
    d372:	movls	r8, r2
		decpt++;
    d374:	mov.w	r3, #4294967295
    d378:	b.n	d2aa <dtostrf+0xde>
	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    d37a:	subs	r0, r5, r6
	if (pad > 0) {
    d37c:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    d37e:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    d382:	ble.w	d536 <dtostrf+0x36a>
		e += pad;
    d386:	add	r1, r0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    d388:	mov	r2, r4
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    d38a:	subs	r0, #1
    d38c:	mov.w	ip, #32
    d390:	strb.w	ip, [r2], #1
    d394:	rsb	r3, r2, #1
    d398:	add	r3, r0
    d39a:	add	r3, r4
    d39c:	cmp	r3, #0
    d39e:	bgt.n	d390 <dtostrf+0x1c4>
    d3a0:	bic.w	r3, r0, r0, asr #31
    d3a4:	adds	r3, #1
    d3a6:	add	r3, r4
	}
	if (sign) *p++ = '-';
    d3a8:	cmp.w	lr, #0
    d3ac:	bne.n	d2e0 <dtostrf+0x114>
	if (decpt == 0 && precision > 0) {
    d3ae:	cmp.w	r9, #0
    d3b2:	beq.n	d2ec <dtostrf+0x120>
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
    d3b4:	bge.n	d2fc <dtostrf+0x130>
    d3b6:	cmp	r7, #0
    d3b8:	beq.n	d2fc <dtostrf+0x130>
		*p++ = '0';
    d3ba:	mov	r2, r3
    d3bc:	movs	r0, #48	; 0x30
    d3be:	strb.w	r0, [r2], #2
		*p++ = '.';
    d3c2:	movs	r7, #46	; 0x2e
    d3c4:	strb	r7, [r3, #1]
    d3c6:	rsb	r3, r9, r2
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
    d3ca:	strb.w	r0, [r2], #1
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
    d3ce:	cmp	r3, r2
    d3d0:	bne.n	d3ca <dtostrf+0x1fe>
    d3d2:	movs	r2, #0
    d3d4:	str	r2, [sp, #4]
    d3d6:	b.n	d2fc <dtostrf+0x130>
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    d3d8:	rsb	r9, r7, #0
    d3dc:	movs	r6, #1
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d3de:	cmp	r9, r6
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    d3e0:	mov	r0, r6
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d3e2:	it	lt
    d3e4:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d3e6:	cmp.w	r9, #0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    d3ea:	ldr.w	r8, [pc, #304]	; d51c <dtostrf+0x350>
		decpt = -precision;
    d3ee:	str.w	r9, [sp, #4]

	// add 1 for decimal point
	if (reqd > decpt) reqd++;

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d3f2:	beq.w	d2c6 <dtostrf+0xfa>

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
    d3f6:	bge.w	d2c8 <dtostrf+0xfc>
    d3fa:	cmp	r7, #0
    d3fc:	beq.w	d2c8 <dtostrf+0xfc>
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;

		if (strlen(s) > precision + decpt) {
    d400:	add.w	r3, r9, r7
    d404:	cmp	r0, r3
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;
    d406:	add.w	r6, r7, #2

		if (strlen(s) > precision + decpt) {
    d40a:	bls.w	d2c8 <dtostrf+0xfc>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d40e:	cmp	r7, #0
    d410:	ble.n	d422 <dtostrf+0x256>
				val *= 10.0;
    d412:	mov	r0, sl
    d414:	ldr	r1, [pc, #264]	; (d520 <dtostrf+0x354>)
    d416:	bl	f710 <__aeabi_fmul>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d41a:	subs.w	fp, fp, #1
				val *= 10.0;
    d41e:	mov	sl, r0

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d420:	bne.n	d412 <dtostrf+0x246>
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    d422:	add	r3, sp, #8
    d424:	add	r2, sp, #12
    d426:	mov	r1, fp
    d428:	mov	r0, sl
    d42a:	bl	fed8 <fcvtf>

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    d42e:	ldr.w	r9, [sp, #4]
    d432:	ldr	r2, [sp, #12]
    d434:	adds	r3, r7, #1
    d436:	rsb	r2, r9, r2
    d43a:	cmp	r2, r3
    d43c:	it	eq
    d43e:	addeq.w	r9, r9, #1
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    d442:	mov	r8, r0

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    d444:	it	eq
    d446:	streq.w	r9, [sp, #4]
    d44a:	b.n	d2c8 <dtostrf+0xfc>
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
    d44c:	movs	r1, #0
    d44e:	mov	r0, sl
    d450:	bl	fa4c <__aeabi_fcmplt>
    d454:	cmp	r0, #0
    d456:	ite	ne
    d458:	movne	r0, #4
    d45a:	moveq	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d45c:	cmp	r0, r9
    d45e:	bge.n	d4d8 <dtostrf+0x30c>
		if (width<0) {
    d460:	cmp	r5, #0
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d462:	rsb	r6, r0, r9
		if (width<0) {
    d466:	blt.n	d4e0 <dtostrf+0x314>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d468:	mov.w	r3, #1065353216	; 0x3f800000
    d46c:	mov	r0, sl
    d46e:	movs	r1, #0
    d470:	bfi	r0, r3, #0, #31
    d474:	bl	fa4c <__aeabi_fcmplt>
    d478:	mov	r5, r4
    d47a:	cmp	r0, #0
    d47c:	bne.n	d502 <dtostrf+0x336>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    d47e:	movs	r3, #78	; 0x4e
    d480:	movs	r2, #65	; 0x41
    d482:	strb	r3, [r4, #0]
    d484:	strb	r3, [r4, #2]
    d486:	strb	r2, [r4, #1]
    d488:	adds	r4, #3
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    d48a:	cmp	r6, #0
    d48c:	beq.n	d532 <dtostrf+0x366>
    d48e:	adds	r0, r4, r6
			*buf++ = ' ';
    d490:	movs	r3, #32
    d492:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    d496:	cmp	r4, r0
    d498:	bne.n	d492 <dtostrf+0x2c6>
    d49a:	b.n	d252 <dtostrf+0x86>
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
    d49c:	adds	r0, r5, r6
		while (pad-- > 0) *p++ = ' ';
    d49e:	negs	r3, r0
    d4a0:	cmp	r3, #0
    d4a2:	mvn.w	r0, r0
    d4a6:	ble.w	d34a <dtostrf+0x17e>
    d4aa:	mov	r2, r1
    d4ac:	movs	r5, #32
    d4ae:	strb.w	r5, [r2], #1
    d4b2:	rsb	r3, r2, #1
    d4b6:	add	r3, r0
    d4b8:	add	r3, r1
    d4ba:	cmp	r3, #0
    d4bc:	bgt.n	d4ae <dtostrf+0x2e2>
    d4be:	bic.w	r3, r0, r0, asr #31
    d4c2:	adds	r3, #1
    d4c4:	add	r1, r3
    d4c6:	b.n	d34a <dtostrf+0x17e>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d4c8:	movs	r1, #73	; 0x49
    d4ca:	movs	r2, #78	; 0x4e
    d4cc:	movs	r3, #70	; 0x46
    d4ce:	strb	r1, [r5, #0]
    d4d0:	strb	r2, [r5, #1]
    d4d2:	strb	r3, [r5, #2]
    d4d4:	adds	r0, r5, #3
    d4d6:	b.n	d252 <dtostrf+0x86>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d4d8:	cmp	r5, #0
    d4da:	blt.n	d50a <dtostrf+0x33e>
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d4dc:	movs	r6, #0
    d4de:	b.n	d468 <dtostrf+0x29c>
		if (width<0) {
			while (awidth) {
    d4e0:	cbz	r6, d50a <dtostrf+0x33e>
    d4e2:	adds	r5, r4, r6
				*buf++ = ' ';
    d4e4:	movs	r3, #32
    d4e6:	strb.w	r3, [r4], #1
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    d4ea:	cmp	r4, r5
    d4ec:	bne.n	d4e6 <dtostrf+0x31a>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d4ee:	mov.w	r3, #1065353216	; 0x3f800000
    d4f2:	mov	r0, sl
    d4f4:	movs	r1, #0
    d4f6:	bfi	r0, r3, #0, #31
    d4fa:	bl	fa4c <__aeabi_fcmplt>
    d4fe:	cbz	r0, d524 <dtostrf+0x358>
    d500:	movs	r6, #0
    d502:	movs	r3, #45	; 0x2d
    d504:	strb	r3, [r5, #0]
    d506:	adds	r4, r5, #1
    d508:	b.n	d47e <dtostrf+0x2b2>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d50a:	mov	r5, r4
    d50c:	b.n	d4ee <dtostrf+0x322>
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d50e:	mov	r5, r4
    d510:	b.n	d276 <dtostrf+0xaa>
    d512:	nop
    d514:	.word	0x7f7fffff
    d518:	.word	0x0001479c
    d51c:	.word	0x00014798
    d520:	.word	0x41200000
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    d524:	movs	r3, #78	; 0x4e
    d526:	movs	r2, #65	; 0x41
    d528:	strb	r3, [r5, #0]
    d52a:	strb	r3, [r5, #2]
    d52c:	strb	r2, [r5, #1]
    d52e:	adds	r0, r5, #3
    d530:	b.n	d252 <dtostrf+0x86>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d532:	mov	r0, r4
    d534:	b.n	d252 <dtostrf+0x86>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    d536:	mov	r3, r4
    d538:	b.n	d2e6 <dtostrf+0x11a>
    d53a:	nop

0000d53c <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    d53c:	bx	lr
    d53e:	nop

0000d540 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    d540:	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    d542:	ldr	r3, [pc, #60]	; (d580 <digitalWrite.part.1+0x40>)
    d544:	ldr.w	r2, [r3, r0, lsl #3]
    d548:	ldrb.w	r4, [r2, #640]	; 0x280
    d54c:	cbz	r4, d55a <digitalWrite.part.1+0x1a>
		if (val) {
			*portSetRegister(pin) = 1;
    d54e:	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    d550:	cbz	r1, d56e <digitalWrite.part.1+0x2e>
			*portSetRegister(pin) = 1;
    d552:	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d556:	pop	{r4}
    d558:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    d55a:	add.w	r3, r3, r0, lsl #3
    d55e:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    d560:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    d562:	cbnz	r1, d576 <digitalWrite.part.1+0x36>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    d564:	bic.w	r2, r2, #2
    d568:	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d56a:	pop	{r4}
    d56c:	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    d56e:	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d572:	pop	{r4}
    d574:	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    d576:	orr.w	r2, r2, #3
    d57a:	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d57c:	pop	{r4}
    d57e:	bx	lr
    d580:	.word	0x000147a0

0000d584 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    d584:	ldr	r2, [pc, #112]	; (d5f8 <pinMode.part.2+0x74>)
    d586:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    d58a:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    d58c:	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    d58e:	beq.n	d5b4 <pinMode.part.2+0x30>
    d590:	cmp	r1, #4
    d592:	beq.n	d5cc <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    d594:	ldr.w	r0, [r2, r0, lsl #3]
    d598:	movs	r2, #0
    d59a:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    d59e:	cbz	r1, d5ac <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    d5a0:	cmp	r1, #2
    d5a2:	beq.n	d5e6 <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    d5a4:	cmp	r1, #3
    d5a6:	beq.n	d5ee <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    d5a8:	str	r2, [r3, #0]
    d5aa:	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    d5ac:	mov.w	r2, #256	; 0x100
    d5b0:	str	r2, [r3, #0]
    d5b2:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d5b4:	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d5b8:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d5bc:	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d5c0:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    d5c2:	ldr	r2, [r3, #0]
    d5c4:	bic.w	r2, r2, #32
    d5c8:	str	r2, [r3, #0]
    d5ca:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d5cc:	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d5d0:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d5d4:	movs	r0, #1
    d5d6:	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d5da:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    d5dc:	ldr	r2, [r3, #0]
    d5de:	orr.w	r2, r2, #32
    d5e2:	str	r2, [r3, #0]
    d5e4:	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    d5e6:	movw	r2, #259	; 0x103
    d5ea:	str	r2, [r3, #0]
    d5ec:	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    d5ee:	mov.w	r2, #258	; 0x102
    d5f2:	str	r2, [r3, #0]
    d5f4:	bx	lr
    d5f6:	nop
    d5f8:	.word	0x000147a0

0000d5fc <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    d5fc:	cmp	r0, #33	; 0x21
    d5fe:	bhi.n	d692 <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    d600:	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    d602:	cmp	r2, #4
    d604:	bhi.n	d690 <attachInterrupt+0x94>
    d606:	tbb	[pc, r2]
    d60a:	.short	0x4b48
    d60c:	.short	0x034e
    d60e:	.byte	0x45
    d60f:	.byte	0x00
    d610:	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    d614:	ldr	r3, [pc, #172]	; (d6c4 <attachInterrupt+0xc8>)
    d616:	add.w	r3, r3, r0, lsl #3
    d61a:	mov	r5, r1
    d61c:	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    d61e:	ldr	r1, [r4, #0]
    d620:	ands.w	r1, r1, #1792	; 0x700
    d624:	beq.n	d6b8 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    d626:	ldr	r3, [pc, #160]	; (d6c8 <attachInterrupt+0xcc>)
    d628:	ldr	r2, [pc, #160]	; (d6cc <attachInterrupt+0xd0>)
    d62a:	ldr	r1, [pc, #164]	; (d6d0 <attachInterrupt+0xd4>)
    d62c:	str.w	r2, [r3, #412]	; 0x19c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d630:	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    d634:	ldr	r0, [pc, #156]	; (d6d4 <attachInterrupt+0xd8>)
    d636:	str.w	r1, [r3, #420]	; 0x1a4

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d63a:	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    d63e:	ldr	r7, [pc, #152]	; (d6d8 <attachInterrupt+0xdc>)
    d640:	str.w	r0, [r3, #416]	; 0x1a0

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d644:	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    d646:	ldr	r0, [pc, #148]	; (d6dc <attachInterrupt+0xe0>)
    d648:	str.w	r7, [r3, #424]	; 0x1a8
    d64c:	str.w	r0, [r3, #428]	; 0x1ac

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d650:	bls.n	d6ac <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    d652:	sub.w	r3, r2, #303104	; 0x4a000
    d656:	cmp	r3, #124	; 0x7c
    d658:	bls.n	d6b0 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    d65a:	sub.w	r3, r2, #307200	; 0x4b000
    d65e:	cmp	r3, #124	; 0x7c
    d660:	bls.n	d6b4 <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    d662:	sub.w	r3, r2, #311296	; 0x4c000
    d666:	cmp	r3, #124	; 0x7c
    d668:	bls.n	d6be <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    d66a:	sub.w	r2, r2, #315392	; 0x4d000
    d66e:	cmp	r2, #124	; 0x7c
    d670:	bhi.n	d6c2 <attachInterrupt+0xc6>
    d672:	ldr	r0, [pc, #108]	; (d6e0 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    d674:	cpsid	i
	cfg = *config;
    d676:	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    d678:	bic.w	r3, r3, #983040	; 0xf0000
    d67c:	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    d680:	ubfx	r1, r4, #2, #5
	cfg |= mask;
    d684:	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    d686:	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    d688:	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    d68c:	str	r6, [r4, #0]
	__enable_irq();
    d68e:	cpsie	i
    d690:	pop	{r3, r4, r5, r6, r7, pc}
    d692:	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    d694:	mov.w	r6, #720896	; 0xb0000
    d698:	b.n	d614 <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    d69a:	mov.w	r6, #524288	; 0x80000
    d69e:	b.n	d614 <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    d6a0:	mov.w	r6, #786432	; 0xc0000
    d6a4:	b.n	d614 <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    d6a6:	mov.w	r6, #655360	; 0xa0000
    d6aa:	b.n	d614 <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d6ac:	ldr	r0, [pc, #52]	; (d6e4 <attachInterrupt+0xe8>)
    d6ae:	b.n	d674 <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    d6b0:	ldr	r0, [pc, #52]	; (d6e8 <attachInterrupt+0xec>)
    d6b2:	b.n	d674 <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    d6b4:	ldr	r0, [pc, #52]	; (d6ec <attachInterrupt+0xf0>)
    d6b6:	b.n	d674 <attachInterrupt+0x78>
    d6b8:	bl	d584 <pinMode.part.2>
    d6bc:	b.n	d626 <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    d6be:	ldr	r0, [pc, #48]	; (d6f0 <attachInterrupt+0xf4>)
    d6c0:	b.n	d674 <attachInterrupt+0x78>
    d6c2:	pop	{r3, r4, r5, r6, r7, pc}
    d6c4:	.word	0x000147a0
    d6c8:	.word	0x1fff8200
    d6cc:	.word	0x1fff8a11
    d6d0:	.word	0x1fff89b9
    d6d4:	.word	0x1fff89e5
    d6d8:	.word	0x1fff898d
    d6dc:	.word	0x1fff8961
    d6e0:	.word	0x1fff8d40
    d6e4:	.word	0x1fff8c68
    d6e8:	.word	0x1fff8ca0
    d6ec:	.word	0x1fff8cf0
    d6f0:	.word	0x1fff8d20

0000d6f4 <detachInterrupt>:

void detachInterrupt(uint8_t pin)
{
	volatile uint32_t *config;

	config = portConfigRegister(pin);
    d6f4:	ldr	r3, [pc, #104]	; (d760 <detachInterrupt+0x6c>)
    d6f6:	add.w	r0, r3, r0, lsl #3
	__enable_irq();
#endif
}

void detachInterrupt(uint8_t pin)
{
    d6fa:	push	{r4}
	volatile uint32_t *config;

	config = portConfigRegister(pin);
    d6fc:	ldr	r2, [r0, #4]

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d6fe:	add.w	r3, r2, #3221225472	; 0xc0000000
    d702:	sub.w	r1, r3, #299008	; 0x49000
    d706:	cmp	r1, #124	; 0x7c
    d708:	bls.n	d752 <detachInterrupt+0x5e>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    d70a:	sub.w	r1, r3, #303104	; 0x4a000
    d70e:	cmp	r1, #124	; 0x7c
    d710:	bls.n	d72e <detachInterrupt+0x3a>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    d712:	sub.w	r1, r3, #307200	; 0x4b000
    d716:	cmp	r1, #124	; 0x7c
    d718:	bls.n	d75a <detachInterrupt+0x66>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    d71a:	sub.w	r1, r3, #311296	; 0x4c000
    d71e:	cmp	r1, #124	; 0x7c
    d720:	bls.n	d756 <detachInterrupt+0x62>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    d722:	sub.w	r3, r3, #315392	; 0x4d000
    d726:	cmp	r3, #124	; 0x7c
    d728:	bhi.n	d74e <detachInterrupt+0x5a>
    d72a:	ldr	r4, [pc, #56]	; (d764 <detachInterrupt+0x70>)
    d72c:	b.n	d730 <detachInterrupt+0x3c>
// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    d72e:	ldr	r4, [pc, #56]	; (d768 <detachInterrupt+0x74>)
	config = portConfigRegister(pin);
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    d730:	cpsid	i
	*config = ((*config & ~0x000F0000) | 0x01000000);
    d732:	ldr	r3, [r2, #0]
	isr_table[pin_index] = dummy_isr;
    d734:	ldr	r0, [pc, #52]	; (d76c <detachInterrupt+0x78>)
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
    d736:	bic.w	r3, r3, #17694720	; 0x10e0000
	isr_table[pin_index] = dummy_isr;
    d73a:	ubfx	r1, r2, #2, #5
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
    d73e:	bic.w	r3, r3, #65536	; 0x10000
    d742:	orr.w	r3, r3, #16777216	; 0x1000000
    d746:	str	r3, [r2, #0]
	isr_table[pin_index] = dummy_isr;
    d748:	str.w	r0, [r4, r1, lsl #2]
	__enable_irq();
    d74c:	cpsie	i
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
	intFunc[pin] = dummy_isr;
	__enable_irq();
#endif
}
    d74e:	pop	{r4}
    d750:	bx	lr

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    d752:	ldr	r4, [pc, #28]	; (d770 <detachInterrupt+0x7c>)
    d754:	b.n	d730 <detachInterrupt+0x3c>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    d756:	ldr	r4, [pc, #28]	; (d774 <detachInterrupt+0x80>)
    d758:	b.n	d730 <detachInterrupt+0x3c>
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    d75a:	ldr	r4, [pc, #28]	; (d778 <detachInterrupt+0x84>)
    d75c:	b.n	d730 <detachInterrupt+0x3c>
    d75e:	nop
    d760:	.word	0x000147a0
    d764:	.word	0x1fff8d40
    d768:	.word	0x1fff8ca0
    d76c:	.word	0x0000d53d
    d770:	.word	0x1fff8c68
    d774:	.word	0x1fff8d20
    d778:	.word	0x1fff8cf0

0000d77c <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    d77c:	ldr	r3, [pc, #4]	; (d784 <rtc_get+0x8>)
    d77e:	ldr	r0, [r3, #0]
}
    d780:	bx	lr
    d782:	nop
    d784:	.word	0x4003d000

0000d788 <rtc_set>:

void rtc_set(unsigned long t)
{
    d788:	push	{r4, r5}
	RTC_SR = 0;
    d78a:	ldr	r3, [pc, #20]	; (d7a0 <rtc_set+0x18>)
	RTC_TPR = 0;
    d78c:	ldr	r5, [pc, #20]	; (d7a4 <rtc_set+0x1c>)
	RTC_TSR = t;
    d78e:	ldr	r4, [pc, #24]	; (d7a8 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    d790:	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    d792:	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    d794:	str	r2, [r3, #0]
	RTC_TPR = 0;
    d796:	str	r2, [r5, #0]
	RTC_TSR = t;
    d798:	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    d79a:	str	r1, [r3, #0]
}
    d79c:	pop	{r4, r5}
    d79e:	bx	lr
    d7a0:	.word	0x4003d014
    d7a4:	.word	0x4003d004
    d7a8:	.word	0x4003d000

0000d7ac <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    d7ac:	cmp	r0, #33	; 0x21
    d7ae:	bhi.n	d7b4 <digitalWrite+0x8>
    d7b0:	b.w	d540 <digitalWrite.part.1>
    d7b4:	bx	lr
    d7b6:	nop

0000d7b8 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    d7b8:	cmp	r0, #33	; 0x21
    d7ba:	bhi.n	d7c0 <pinMode+0x8>
    d7bc:	b.w	d584 <pinMode.part.2>
    d7c0:	bx	lr
    d7c2:	nop

0000d7c4 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    d7c4:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    d7c6:	ldr	r1, [pc, #48]	; (d7f8 <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    d7c8:	ldr	r3, [pc, #48]	; (d7fc <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d7ca:	ldr	r2, [pc, #52]	; (d800 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    d7cc:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    d7ce:	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d7d0:	ldr	r2, [r2, #0]
	__enable_irq();
    d7d2:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    d7d4:	lsls	r2, r2, #5
    d7d6:	bpl.n	d7de <micros+0x1a>
    d7d8:	cmp	r3, #50	; 0x32
    d7da:	it	hi
    d7dc:	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    d7de:	ldr	r1, [pc, #36]	; (d804 <micros+0x40>)
    d7e0:	rsb	r3, r3, #95744	; 0x17600
    d7e4:	mov.w	r2, #1000	; 0x3e8
    d7e8:	adds	r3, #255	; 0xff
    d7ea:	umull	r1, r3, r1, r3
    d7ee:	mul.w	r0, r2, r0
}
    d7f2:	add.w	r0, r0, r3, lsr #6
    d7f6:	bx	lr
    d7f8:	.word	0x200030a4
    d7fc:	.word	0xe000e018
    d800:	.word	0xe000ed04
    d804:	.word	0xaaaaaaab

0000d808 <delay>:

void delay(uint32_t ms)
{
    d808:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d80c:	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    d80e:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    d810:	ldr	r7, [pc, #128]	; (d894 <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    d812:	ldr	r3, [pc, #132]	; (d898 <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d814:	ldr	r2, [pc, #132]	; (d89c <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    d816:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    d818:	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d81a:	ldr	r2, [r2, #0]
	__enable_irq();
    d81c:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    d81e:	lsls	r2, r2, #5
    d820:	bpl.n	d828 <delay+0x20>
    d822:	cmp	r3, #50	; 0x32
    d824:	it	hi
    d826:	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    d828:	cbz	r5, d890 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    d82a:	rsb	r3, r3, #95744	; 0x17600
    d82e:	ldr	r6, [pc, #112]	; (d8a0 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    d830:	ldr.w	r9, [pc, #100]	; d898 <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d834:	ldr.w	r8, [pc, #100]	; d89c <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    d838:	adds	r3, #255	; 0xff
    d83a:	mov.w	r2, #1000	; 0x3e8
    d83e:	umull	r1, r3, r6, r3
    d842:	mul.w	r4, r2, r4
    d846:	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    d84a:	cpsid	i
	current = SYST_CVR;
    d84c:	ldr.w	r1, [r9]
	count = systick_millis_count;
    d850:	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    d852:	ldr.w	lr, [r8]
	__enable_irq();
    d856:	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    d858:	rsb	r3, r1, #95744	; 0x17600
    d85c:	adds	r3, #255	; 0xff
    d85e:	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    d862:	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    d866:	rsb	r3, r4, r3, lsr #6
    d86a:	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    d86e:	beq.n	d876 <delay+0x6e>
    d870:	cmp	r1, #50	; 0x32
    d872:	it	hi
    d874:	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    d876:	mla	r3, r0, r2, r3
    d87a:	cmp.w	r3, #1000	; 0x3e8
    d87e:	bcc.n	d88a <delay+0x82>
				ms--;
				if (ms == 0) return;
    d880:	subs	r5, #1
    d882:	beq.n	d890 <delay+0x88>
				start += 1000;
    d884:	add.w	r4, r4, #1000	; 0x3e8
    d888:	b.n	d84a <delay+0x42>
			}
			yield();
    d88a:	bl	e4a8 <yield>
		}
    d88e:	b.n	d84a <delay+0x42>
    d890:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d894:	.word	0x200030a4
    d898:	.word	0xe000e018
    d89c:	.word	0xe000ed04
    d8a0:	.word	0xaaaaaaab

0000d8a4 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    d8a4:	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    d8a6:	ldr	r3, [pc, #180]	; (d95c <_init_Teensyduino_internal_+0xb8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    d8a8:	ldr	r1, [pc, #180]	; (d960 <_init_Teensyduino_internal_+0xbc>)
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    d8aa:	ldr.w	lr, [pc, #208]	; d97c <_init_Teensyduino_internal_+0xd8>
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    d8ae:	ldr.w	ip, [pc, #208]	; d980 <_init_Teensyduino_internal_+0xdc>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    d8b2:	ldr	r6, [pc, #176]	; (d964 <_init_Teensyduino_internal_+0xc0>)
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    d8b4:	ldr	r5, [pc, #176]	; (d968 <_init_Teensyduino_internal_+0xc4>)
	FTM0_C4SC = 0x28;
    d8b6:	ldr	r4, [pc, #180]	; (d96c <_init_Teensyduino_internal_+0xc8>)
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    d8b8:	ldr	r2, [pc, #180]	; (d970 <_init_Teensyduino_internal_+0xcc>)
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    d8ba:	ldr	r7, [pc, #184]	; (d974 <_init_Teensyduino_internal_+0xd0>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    d8bc:	mov.w	r0, #8388608	; 0x800000
    d8c0:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    d8c2:	mov.w	r0, #16777216	; 0x1000000
    d8c6:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    d8c8:	mov.w	r0, #33554432	; 0x2000000
    d8cc:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    d8ce:	mov.w	r0, #67108864	; 0x4000000
    d8d2:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    d8d4:	mov.w	r0, #134217728	; 0x8000000
    d8d8:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    d8da:	movs	r0, #0
    d8dc:	str	r0, [r1, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    d8de:	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    d8e0:	movw	r1, #49151	; 0xbfff
    d8e4:	str.w	r1, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    d8e8:	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    d8ec:	str	r3, [r6, #0]
	FTM0_C2SC = 0x28;
    d8ee:	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
    d8f0:	str	r3, [r5, #0]
	FTM0_C4SC = 0x28;
    d8f2:	str	r3, [r4, #0]
	FTM0_C5SC = 0x28;
    d8f4:	str	r3, [r7, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    d8f6:	str	r3, [r6, #40]	; 0x28
	FTM0_C7SC = 0x28;
    d8f8:	str	r3, [r2, #40]	; 0x28
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    d8fa:	movs	r2, #9
    d8fc:	str.w	r2, [r5, #-36]
	FTM1_CNT = 0;
    d900:	str.w	r0, [r4, #4056]	; 0xfd8
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
    d904:	add.w	r5, r5, #4080	; 0xff0
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
    d908:	str.w	r1, [r7, #4052]	; 0xfd4
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    d90c:	add.w	r7, r7, #522240	; 0x7f800
    d910:	add.w	r7, r7, #2000	; 0x7d0
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
    d914:	str.w	r3, [r6, #4088]	; 0xff8
	FTM1_C1SC = 0x28;
    d918:	str	r3, [r5, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    d91a:	add.w	r6, r6, #522240	; 0x7f800
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    d91e:	str.w	r2, [r4, #4052]	; 0xfd4
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    d922:	add.w	r5, r5, #518144	; 0x7e800
	FTM2_C1SC = 0x28;
    d926:	add.w	r4, r4, #522240	; 0x7f800
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    d92a:	str	r0, [r7, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    d92c:	addw	r6, r6, #2036	; 0x7f4
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    d930:	ldr	r0, [pc, #68]	; (d978 <_init_Teensyduino_internal_+0xd4>)
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    d932:	str	r1, [r6, #0]
	FTM2_C0SC = 0x28;
    d934:	add.w	r5, r5, #2040	; 0x7f8
	FTM2_C1SC = 0x28;
    d938:	add.w	r4, r4, #2024	; 0x7e8
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    d93c:	str	r3, [r5, #0]
	FTM2_C1SC = 0x28;
    d93e:	str	r3, [r4, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    d940:	str	r2, [r0, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    d942:	bl	cf8c <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    d946:	movs	r0, #25
    d948:	bl	d808 <delay>
	usb_init();
    d94c:	bl	e3f4 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    d950:	movw	r0, #275	; 0x113
}
    d954:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    d958:	b.w	d808 <delay>
    d95c:	.word	0xe000e108
    d960:	.word	0x40038004
    d964:	.word	0x40038014
    d968:	.word	0x40038024
    d96c:	.word	0x4003802c
    d970:	.word	0x4003801c
    d974:	.word	0x40038034
    d978:	.word	0x400b8000
    d97c:	.word	0x4003800c
    d980:	.word	0x40038008

0000d984 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    d984:	cpsid	i
	avail = usb_buffer_available;
    d986:	ldr	r0, [pc, #52]	; (d9bc <usb_malloc+0x38>)
    d988:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    d98a:	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    d98e:	cmp	r3, #19
    d990:	bgt.n	d9b4 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    d992:	mov.w	r1, #2147483648	; 0x80000000
    d996:	lsrs	r1, r3
    d998:	bic.w	r2, r2, r1
    d99c:	str	r2, [r0, #0]
	__enable_irq();
    d99e:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    d9a0:	ldr	r0, [pc, #28]	; (d9c0 <usb_malloc+0x3c>)
    d9a2:	add.w	r3, r3, r3, lsl #3
    d9a6:	lsls	r3, r3, #3
    d9a8:	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    d9aa:	movs	r1, #0
    d9ac:	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    d9ae:	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    d9b0:	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    d9b2:	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    d9b4:	cpsie	i
		return NULL;
    d9b6:	movs	r0, #0
    d9b8:	bx	lr
    d9ba:	nop
    d9bc:	.word	0x1fff8d48
    d9c0:	.word	0x1fff83bc

0000d9c4 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    d9c4:	ldr	r3, [pc, #52]	; (d9fc <usb_free+0x38>)
    d9c6:	ldr	r2, [pc, #56]	; (da00 <usb_free+0x3c>)
    d9c8:	subs	r3, r0, r3
    d9ca:	umull	r2, r3, r2, r3
    d9ce:	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    d9d0:	cmp	r3, #19
    d9d2:	bhi.n	d9ee <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    d9d4:	ldr	r2, [pc, #44]	; (da04 <usb_free+0x40>)
    d9d6:	ldrb	r2, [r2, #0]
    d9d8:	cbnz	r2, d9f0 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    d9da:	cpsid	i
	usb_buffer_available |= mask;
    d9dc:	ldr	r0, [pc, #40]	; (da08 <usb_free+0x44>)
    d9de:	mov.w	r1, #2147483648	; 0x80000000
    d9e2:	ldr	r2, [r0, #0]
    d9e4:	lsr.w	r3, r1, r3
    d9e8:	orrs	r2, r3
    d9ea:	str	r2, [r0, #0]
	__enable_irq();
    d9ec:	cpsie	i
    d9ee:	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    d9f0:	ldr	r2, [pc, #24]	; (da0c <usb_free+0x48>)
    d9f2:	ldrb	r2, [r2, #0]
    d9f4:	cmp	r2, #0
    d9f6:	beq.n	d9da <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    d9f8:	b.w	da78 <usb_rx_memory>
    d9fc:	.word	0x1fff83bc
    da00:	.word	0x38e38e39
    da04:	.word	0x2000319d
    da08:	.word	0x1fff8d48
    da0c:	.word	0x200031a8

0000da10 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    da10:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    da12:	cmp	r3, #5
    da14:	bhi.n	da40 <usb_rx+0x30>
	__disable_irq();
    da16:	cpsid	i
	ret = rx_first[endpoint];
    da18:	ldr	r1, [pc, #40]	; (da44 <usb_rx+0x34>)
    da1a:	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    da1e:	cbz	r0, da3c <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    da20:	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    da22:	ldr	r4, [pc, #36]	; (da48 <usb_rx+0x38>)
    da24:	ldrh	r5, [r0, #0]
    da26:	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    da2a:	ldr	r6, [r0, #4]
    da2c:	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    da30:	subs	r2, r2, r5
    da32:	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    da36:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    da38:	pop	{r4, r5, r6}
    da3a:	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    da3c:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    da3e:	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    da40:	movs	r0, #0
    da42:	bx	lr
    da44:	.word	0x20003108
    da48:	.word	0x20003224

0000da4c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    da4c:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    da4e:	cmp	r0, #5
    da50:	bhi.n	da6a <usb_tx_packet_count+0x1e>
	__disable_irq();
    da52:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    da54:	ldr	r3, [pc, #28]	; (da74 <usb_tx_packet_count+0x28>)
    da56:	ldr.w	r3, [r3, r0, lsl #2]
    da5a:	cbz	r3, da6e <usb_tx_packet_count+0x22>
    da5c:	movs	r0, #0
    da5e:	ldr	r3, [r3, #4]
    da60:	adds	r0, #1
    da62:	cmp	r3, #0
    da64:	bne.n	da5e <usb_tx_packet_count+0x12>
	__enable_irq();
    da66:	cpsie	i
	return count;
    da68:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    da6a:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    da6c:	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    da6e:	mov	r0, r3
    da70:	b.n	da66 <usb_tx_packet_count+0x1a>
    da72:	nop
    da74:	.word	0x20003164

0000da78 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    da78:	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    da7a:	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    da7c:	ldr	r1, [pc, #104]	; (dae8 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    da7e:	ldr	r6, [pc, #108]	; (daec <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    da80:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    da82:	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    da86:	ldr	r7, [pc, #100]	; (daec <usb_rx_memory+0x74>)
    da88:	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    da8a:	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    da8c:	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    da90:	bpl.n	da9e <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    da92:	ldr.w	r4, [r6, r2, lsl #3]
    da96:	cbz	r4, dab2 <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    da98:	ldr.w	r2, [r6, r5, lsl #3]
    da9c:	cbz	r2, dace <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    da9e:	adds	r3, #1
    daa0:	cmp	r3, #7
    daa2:	bne.n	da82 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    daa4:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    daa6:	ldr	r3, [pc, #72]	; (daf0 <usb_rx_memory+0x78>)
    daa8:	movs	r2, #0
    daaa:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    daac:	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    daae:	b.w	d9c4 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dab2:	ldr	r4, [pc, #60]	; (daf0 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    dab4:	ldr	r5, [pc, #60]	; (daf4 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    dab6:	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    dab8:	add.w	r3, r7, r3, lsl #5
    dabc:	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dabe:	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    dac0:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dac2:	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    dac4:	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    dac8:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    daca:	pop	{r4, r5, r6, r7}
    dacc:	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dace:	ldr	r2, [pc, #32]	; (daf0 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    dad0:	ldr	r1, [pc, #36]	; (daf8 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    dad2:	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    dad4:	add.w	r4, r7, r5, lsl #3
    dad8:	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dada:	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    dadc:	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dade:	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    dae0:	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    dae4:	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    dae6:	b.n	daca <usb_rx_memory+0x52>
    dae8:	.word	0x00014730
    daec:	.word	0x1fff8000
    daf0:	.word	0x2000319d
    daf4:	.word	0x00400088
    daf8:	.word	0x004000c8

0000dafc <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    dafc:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    dafe:	cmp	r3, #5
    db00:	bhi.n	db3e <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    db02:	ldr	r2, [pc, #108]	; (db70 <usb_tx+0x74>)
    db04:	lsls	r0, r0, #5
    db06:	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    db0a:	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    db0c:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    db0e:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    db10:	ldr	r4, [pc, #96]	; (db74 <usb_tx+0x78>)
    db12:	ldrb	r2, [r4, r3]
    db14:	cmp	r2, #3
    db16:	bhi.n	db50 <usb_tx+0x54>
    db18:	tbb	[pc, r2]
    db1c:	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    db20:	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    db22:	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    db24:	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    db26:	tst.w	r0, #8
    db2a:	ite	ne
    db2c:	movne	r3, #200	; 0xc8
    db2e:	moveq	r3, #136	; 0x88
    db30:	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    db34:	adds	r1, #8
    db36:	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    db38:	str	r3, [r0, #0]
	__enable_irq();
    db3a:	cpsie	i
}
    db3c:	pop	{r4, r5}
    db3e:	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    db40:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    db42:	movs	r2, #2
		break;
    db44:	b.n	db22 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    db46:	movs	r2, #5
    db48:	b.n	db22 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    db4a:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    db4c:	movs	r2, #4
		break;
    db4e:	b.n	db22 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    db50:	ldr	r2, [pc, #36]	; (db78 <usb_tx+0x7c>)
    db52:	ldr.w	r0, [r2, r3, lsl #2]
    db56:	cbz	r0, db68 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    db58:	ldr	r2, [pc, #32]	; (db7c <usb_tx+0x80>)
    db5a:	ldr.w	r0, [r2, r3, lsl #2]
    db5e:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    db60:	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    db64:	cpsie	i
		return;
    db66:	b.n	db3c <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    db68:	str.w	r1, [r2, r3, lsl #2]
    db6c:	ldr	r2, [pc, #12]	; (db7c <usb_tx+0x80>)
    db6e:	b.n	db60 <usb_tx+0x64>
    db70:	.word	0x1fff8000
    db74:	.word	0x200031ac
    db78:	.word	0x20003164
    db7c:	.word	0x2000317c

0000db80 <usb_isr>:
}



void usb_isr(void)
{
    db80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    db84:	ldr.w	fp, [pc, #788]	; de9c <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    db88:	ldr.w	sl, [pc, #788]	; dea0 <usb_isr+0x320>
}



void usb_isr(void)
{
    db8c:	sub	sp, #28
    db8e:	b.n	dc1a <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    db90:	ldr	r7, [pc, #700]	; (de50 <usb_isr+0x2d0>)
    db92:	mov.w	r8, r3, lsr #2
    db96:	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    db9a:	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    db9c:	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    dba0:	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    dba4:	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    dba6:	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    dbaa:	and.w	r4, r3, #255	; 0xff
    dbae:	cmp	r3, #0
    dbb0:	bne.w	dea4 <usb_isr+0x324>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    dbb4:	ldr.w	r3, [r7, r8, lsl #3]
    dbb8:	lsrs	r3, r3, #16
    dbba:	uxth	r1, r3
    dbbc:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    dbc0:	cmp	r3, #0
    dbc2:	beq.w	de3c <usb_isr+0x2bc>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    dbc6:	ldr	r3, [pc, #652]	; (de54 <usb_isr+0x2d4>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    dbc8:	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    dbcc:	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    dbd0:	ldr.w	r2, [r3, r6, lsl #2]
    dbd4:	cmp	r2, #0
    dbd6:	beq.w	df40 <usb_isr+0x3c0>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    dbda:	ldr	r5, [pc, #636]	; (de58 <usb_isr+0x2d8>)
    dbdc:	ldr.w	r3, [r5, r6, lsl #2]
    dbe0:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    dbe2:	ldr	r4, [pc, #632]	; (de5c <usb_isr+0x2dc>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    dbe4:	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    dbe8:	ldrh.w	r3, [r4, r6, lsl #1]
    dbec:	add	r1, r3
    dbee:	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    dbf2:	bl	d984 <usb_malloc>
					if (packet) {
    dbf6:	cmp	r0, #0
    dbf8:	beq.w	df32 <usb_isr+0x3b2>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    dbfc:	ldr	r2, [pc, #608]	; (de60 <usb_isr+0x2e0>)
    dbfe:	ldr	r3, [pc, #612]	; (de64 <usb_isr+0x2e4>)
    dc00:	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    dc04:	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    dc08:	it	ne
    dc0a:	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    dc0c:	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    dc10:	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    dc14:	movs	r3, #8
    dc16:	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    dc1a:	ldrb.w	r4, [fp]
    dc1e:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    dc20:	lsls	r0, r4, #29
    dc22:	bpl.n	dc5c <usb_isr+0xdc>
		if (usb_configuration) {
    dc24:	ldr	r3, [pc, #576]	; (de68 <usb_isr+0x2e8>)
    dc26:	ldrb	r3, [r3, #0]
    dc28:	cbz	r3, dc56 <usb_isr+0xd6>
			t = usb_reboot_timer;
    dc2a:	ldr	r1, [pc, #576]	; (de6c <usb_isr+0x2ec>)
    dc2c:	ldrb	r2, [r1, #0]
			if (t) {
    dc2e:	and.w	r3, r2, #255	; 0xff
    dc32:	cbz	r2, dc40 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    dc34:	subs	r3, #1
    dc36:	uxtb	r3, r3
    dc38:	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    dc3a:	cmp	r3, #0
    dc3c:	beq.w	e3bc <usb_isr+0x83c>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    dc40:	ldr	r1, [pc, #556]	; (de70 <usb_isr+0x2f0>)
    dc42:	ldrb	r2, [r1, #0]
			if (t) {
    dc44:	and.w	r3, r2, #255	; 0xff
    dc48:	cbz	r2, dc56 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    dc4a:	subs	r3, #1
    dc4c:	uxtb	r3, r3
    dc4e:	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    dc50:	cmp	r3, #0
    dc52:	beq.w	df2c <usb_isr+0x3ac>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    dc56:	movs	r3, #4
    dc58:	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    dc5c:	and.w	r3, r4, #8
    dc60:	and.w	r2, r3, #255	; 0xff
    dc64:	cmp	r3, #0
    dc66:	beq.w	defe <usb_isr+0x37e>
		uint8_t endpoint;
		stat = USB0_STAT;
    dc6a:	ldrb.w	r3, [sl]
    dc6e:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    dc70:	lsrs	r6, r3, #4
    dc72:	bne.n	db90 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    dc74:	lsrs	r0, r3, #2
    dc76:	ldr	r7, [pc, #472]	; (de50 <usb_isr+0x2d0>)
	pid = BDT_PID(b->desc);
    dc78:	ldr.w	r2, [r7, r0, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    dc7c:	add.w	r1, r7, r0, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    dc80:	ubfx	r2, r2, #2, #4
    dc84:	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    dc86:	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    dc88:	cmp	r2, #12
    dc8a:	bhi.w	de1e <usb_isr+0x29e>
    dc8e:	tbh	[pc, r2, lsl #1]
    dc92:	.short	0x00ca
    dc94:	.word	0x00c600ca
    dc98:	.word	0x00c600c6
    dc9c:	.word	0x00c600c6
    dca0:	.word	0x008b00c6
    dca4:	.word	0x00c600c6
    dca8:	.word	0x000d00c6
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    dcac:	ldr	r2, [r1, #0]
    dcae:	ldr	r5, [pc, #452]	; (de74 <usb_isr+0x2f4>)
		setup.word2 = *(uint32_t *)(buf + 4);
    dcb0:	ldr	r1, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    dcb2:	ldr	r3, [pc, #452]	; (de78 <usb_isr+0x2f8>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    dcb4:	ldr	r6, [pc, #452]	; (de7c <usb_isr+0x2fc>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    dcb6:	ldr	r4, [pc, #424]	; (de60 <usb_isr+0x2e0>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    dcb8:	str	r1, [r5, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    dcba:	uxth	r1, r2
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    dcbc:	str.w	r4, [r7, r0, lsl #3]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    dcc0:	str	r2, [r5, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    dcc2:	movs	r0, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    dcc4:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    dcc6:	cmp.w	r1, #2176	; 0x880
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    dcca:	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    dccc:	str	r3, [sp, #4]
    dcce:	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    dcd0:	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    dcd2:	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    dcd4:	beq.w	e334 <usb_isr+0x7b4>
    dcd8:	bls.w	df48 <usb_isr+0x3c8>
    dcdc:	movw	r4, #8993	; 0x2321
    dce0:	cmp	r1, r4
    dce2:	beq.w	e33e <usb_isr+0x7be>
    dce6:	bhi.w	e074 <usb_isr+0x4f4>
    dcea:	movw	r4, #8225	; 0x2021
    dcee:	cmp	r1, r4
    dcf0:	beq.w	e08a <usb_isr+0x50a>
    dcf4:	movw	r4, #8737	; 0x2221
    dcf8:	cmp	r1, r4
    dcfa:	beq.w	e1dc <usb_isr+0x65c>
    dcfe:	cmp.w	r1, #2304	; 0x900
    dd02:	bne.w	e084 <usb_isr+0x504>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    dd06:	ldr	r2, [pc, #352]	; (de68 <usb_isr+0x2e8>)
    dd08:	ldrb	r1, [r5, #2]
    dd0a:	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    dd0c:	ldr	r5, [pc, #320]	; (de50 <usb_isr+0x2d0>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dd0e:	movs	r4, #4
    dd10:	b.n	dd18 <usb_isr+0x198>
    dd12:	adds	r4, #1
    dd14:	cmp	r4, #28
    dd16:	beq.n	dd32 <usb_isr+0x1b2>
			if (table[i].desc & BDT_OWN) {
    dd18:	ldr.w	r3, [r7, r4, lsl #3]
    dd1c:	lsls	r1, r3, #24
    dd1e:	bpl.n	dd12 <usb_isr+0x192>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    dd20:	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dd24:	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    dd26:	ldr	r0, [r3, #4]
    dd28:	subs	r0, #8
    dd2a:	bl	d9c4 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dd2e:	cmp	r4, #28
    dd30:	bne.n	dd18 <usb_isr+0x198>
    dd32:	ldr	r3, [pc, #288]	; (de54 <usb_isr+0x2d4>)
    dd34:	ldr	r2, [pc, #328]	; (de80 <usb_isr+0x300>)
    dd36:	ldr	r1, [pc, #332]	; (de84 <usb_isr+0x304>)
    dd38:	ldr	r5, [pc, #284]	; (de58 <usb_isr+0x2d8>)
    dd3a:	ldr	r4, [pc, #288]	; (de5c <usb_isr+0x2dc>)
    dd3c:	ldr	r0, [pc, #328]	; (de88 <usb_isr+0x308>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    dd3e:	str	r5, [sp, #12]
    dd40:	str	r4, [sp, #16]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dd42:	mov.w	r9, #0
    dd46:	str	r0, [sp, #8]
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    dd48:	mov	r8, r1
    dd4a:	str	r6, [sp, #20]
    dd4c:	mov	r5, r2
    dd4e:	mov	r4, r3
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    dd50:	ldr	r0, [r4, #0]
			while (p) {
    dd52:	cbz	r0, dd60 <usb_isr+0x1e0>
				n = p->next;
    dd54:	ldr	r6, [r0, #4]
				usb_free(p);
    dd56:	bl	d9c4 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    dd5a:	mov	r0, r6
    dd5c:	cmp	r6, #0
    dd5e:	bne.n	dd54 <usb_isr+0x1d4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    dd60:	movs	r3, #0
    dd62:	str	r3, [r4, #0]
			rx_last[i] = NULL;
    dd64:	ldr	r3, [sp, #12]
			p = tx_first[i];
    dd66:	ldr	r0, [r5, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    dd68:	mov	r2, r3
    dd6a:	movs	r3, #0
    dd6c:	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    dd70:	cbz	r0, dd7e <usb_isr+0x1fe>
				n = p->next;
    dd72:	ldr	r6, [r0, #4]
				usb_free(p);
    dd74:	bl	d9c4 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    dd78:	mov	r0, r6
    dd7a:	cmp	r6, #0
    dd7c:	bne.n	dd72 <usb_isr+0x1f2>
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    dd7e:	ldr	r3, [sp, #8]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    dd80:	movs	r2, #0
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    dd82:	ldrb	r3, [r3, #0]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    dd84:	str	r2, [r5, #0]
			tx_last[i] = NULL;
    dd86:	str.w	r2, [r8], #4
			usb_rx_byte_count_data[i] = 0;
    dd8a:	ldr	r2, [sp, #16]
    dd8c:	mov.w	r1, #0
			switch (tx_state[i]) {
    dd90:	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    dd92:	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    dd96:	cmp	r3, #3
    dd98:	bhi.w	e290 <usb_isr+0x710>
    dd9c:	tbh	[pc, r3, lsl #1]
    dda0:	.word	0x027402c0
    dda4:	.word	0x027402c0
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    dda8:	ldr	r3, [pc, #204]	; (de78 <usb_isr+0x2f8>)
    ddaa:	str	r3, [sp, #4]
    ddac:	ldr	r2, [r3, #0]
		if (data) {
    ddae:	cbz	r2, de0a <usb_isr+0x28a>
			size = ep0_tx_len;
    ddb0:	ldr	r3, [pc, #216]	; (de8c <usb_isr+0x30c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ddb2:	ldr	r1, [pc, #220]	; (de90 <usb_isr+0x310>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddb4:	ldr	r6, [pc, #196]	; (de7c <usb_isr+0x2fc>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    ddb6:	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ddb8:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddba:	ldrb.w	lr, [r6]
    ddbe:	cmp	r0, #64	; 0x40
    ddc0:	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    ddc2:	eor.w	ip, r4, #1
    ddc6:	it	cs
    ddc8:	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ddca:	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddce:	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    ddd2:	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    ddd6:	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ddda:	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddde:	ite	eq
    dde0:	moveq	r1, #136	; 0x88
    dde2:	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    dde4:	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    dde6:	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddea:	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ddee:	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    ddf2:	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    ddf4:	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    ddf8:	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ddfa:	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    ddfe:	cbnz	r0, de06 <usb_isr+0x286>
    de00:	cmp	r5, #64	; 0x40
    de02:	it	ne
    de04:	movne	r2, #0
    de06:	ldr	r3, [sp, #4]
    de08:	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    de0a:	ldr	r3, [pc, #104]	; (de74 <usb_isr+0x2f4>)
    de0c:	ldrh	r2, [r3, #0]
    de0e:	cmp.w	r2, #1280	; 0x500
    de12:	bne.n	de1e <usb_isr+0x29e>
			setup.bRequest = 0;
    de14:	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    de16:	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    de18:	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    de1a:	ldr	r3, [pc, #120]	; (de94 <usb_isr+0x314>)
    de1c:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    de1e:	ldr	r2, [pc, #120]	; (de98 <usb_isr+0x318>)
    de20:	movs	r3, #1
    de22:	strb	r3, [r2, #0]
    de24:	b.n	dc14 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    de26:	ldr	r2, [pc, #76]	; (de74 <usb_isr+0x2f4>)
    de28:	ldrh	r5, [r2, #0]
    de2a:	movw	r4, #8225	; 0x2021
    de2e:	cmp	r5, r4
    de30:	beq.w	e028 <usb_isr+0x4a8>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    de34:	ldr	r2, [pc, #40]	; (de60 <usb_isr+0x2e0>)
    de36:	str.w	r2, [r7, r0, lsl #3]
    de3a:	b.n	de1e <usb_isr+0x29e>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    de3c:	ldr	r2, [pc, #32]	; (de60 <usb_isr+0x2e0>)
    de3e:	ldr	r3, [pc, #36]	; (de64 <usb_isr+0x2e4>)
    de40:	tst.w	r9, #8
    de44:	it	ne
    de46:	movne	r3, r2
    de48:	str.w	r3, [r7, r8, lsl #3]
    de4c:	b.n	dc14 <usb_isr+0x94>
    de4e:	nop
    de50:	.word	0x1fff8000
    de54:	.word	0x20003108
    de58:	.word	0x200030ac
    de5c:	.word	0x20003224
    de60:	.word	0x004000c8
    de64:	.word	0x00400088
    de68:	.word	0x200031a8
    de6c:	.word	0x20003121
    de70:	.word	0x20003090
    de74:	.word	0x20003194
    de78:	.word	0x200030a8
    de7c:	.word	0x20003120
    de80:	.word	0x20003164
    de84:	.word	0x2000317c
    de88:	.word	0x200031ac
    de8c:	.word	0x200030c4
    de90:	.word	0x2000319c
    de94:	.word	0x40072098
    de98:	.word	0x40072094
    de9c:	.word	0x40072080
    dea0:	.word	0x40072090
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    dea4:	bl	d9c4 <usb_free>
				packet = tx_first[endpoint];
    dea8:	ldr	r2, [pc, #724]	; (e180 <usb_isr+0x600>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    deaa:	ldr	r1, [pc, #728]	; (e184 <usb_isr+0x604>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    deac:	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    deb0:	cmp	r3, #0
    deb2:	beq.w	e00a <usb_isr+0x48a>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    deb6:	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    deb8:	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    deba:	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    debe:	add.w	r2, r3, #8
    dec2:	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    dec6:	cmp	r4, #3
    dec8:	bhi.n	ded6 <usb_isr+0x356>
    deca:	tbb	[pc, r4]
    dece:	.short	0x0f12
    ded0:	.short	0x0215
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    ded2:	movs	r2, #4
    ded4:	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    ded6:	ldrh	r2, [r3, #0]
    ded8:	tst.w	r9, #8
    dedc:	ite	eq
    dede:	moveq	r3, #136	; 0x88
    dee0:	movne	r3, #200	; 0xc8
    dee2:	orr.w	r3, r3, r2, lsl #16
    dee6:	str.w	r3, [r7, r8, lsl #3]
    deea:	b.n	dc14 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    deec:	movs	r2, #2
    deee:	strb	r2, [r1, r6]
						break;
    def0:	b.n	ded6 <usb_isr+0x356>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    def2:	movs	r2, #3
    def4:	strb	r2, [r1, r6]
						break;
    def6:	b.n	ded6 <usb_isr+0x356>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    def8:	movs	r2, #5
    defa:	strb	r2, [r1, r6]
						break;
    defc:	b.n	ded6 <usb_isr+0x356>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    defe:	lsls	r0, r4, #31
    df00:	bmi.w	e092 <usb_isr+0x512>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    df04:	lsls	r1, r4, #24
    df06:	bmi.w	e12e <usb_isr+0x5ae>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    df0a:	lsls	r2, r4, #30
    df0c:	bpl.n	df1c <usb_isr+0x39c>
		uint8_t err = USB0_ERRSTAT;
    df0e:	ldr	r2, [pc, #632]	; (e188 <usb_isr+0x608>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    df10:	ldr	r1, [pc, #632]	; (e18c <usb_isr+0x60c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    df12:	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    df14:	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    df16:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    df18:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    df1a:	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    df1c:	lsls	r3, r4, #27
    df1e:	bpl.n	df26 <usb_isr+0x3a6>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    df20:	ldr	r3, [pc, #616]	; (e18c <usb_isr+0x60c>)
    df22:	movs	r2, #16
    df24:	strb	r2, [r3, #0]
	}

}
    df26:	add	sp, #28
    df28:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    df2c:	bl	cf44 <usb_serial_flush_callback>
    df30:	b.n	dc56 <usb_isr+0xd6>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    df32:	ldr	r2, [pc, #604]	; (e190 <usb_isr+0x610>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    df34:	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    df38:	ldrb	r3, [r2, #0]
    df3a:	adds	r3, #1
    df3c:	strb	r3, [r2, #0]
    df3e:	b.n	dc14 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    df40:	str.w	r0, [r3, r6, lsl #2]
    df44:	ldr	r5, [pc, #588]	; (e194 <usb_isr+0x614>)
    df46:	b.n	dbe2 <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    df48:	movw	r4, #770	; 0x302
    df4c:	cmp	r1, r4
    df4e:	beq.w	e346 <usb_isr+0x7c6>
    df52:	bhi.w	e0ec <usb_isr+0x56c>
    df56:	cmp	r1, #130	; 0x82
    df58:	beq.w	e264 <usb_isr+0x6e4>
    df5c:	cmp.w	r1, #258	; 0x102
    df60:	beq.w	e15c <usb_isr+0x5dc>
    df64:	cmp	r1, #128	; 0x80
    df66:	bne.w	e084 <usb_isr+0x504>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    df6a:	ldr	r4, [pc, #556]	; (e198 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		datalen = 2;
    df6c:	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    df6e:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    df70:	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    df72:	ldrh	r2, [r5, #6]
    df74:	cmp	r2, r0
    df76:	bcs.w	e39c <usb_isr+0x81c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    df7a:	ldr	r1, [pc, #544]	; (e19c <usb_isr+0x61c>)
    df7c:	ldrb	r5, [r1, #0]
    df7e:	orr.w	ip, r5, #2
    df82:	add.w	r0, r7, ip, lsl #3
    df86:	cmp	r2, #64	; 0x40
    df88:	mov	lr, r2
    df8a:	mov.w	r3, #1
    df8e:	it	cs
    df90:	movcs.w	lr, #64	; 0x40
    df94:	str	r4, [r0, #4]
    df96:	add.w	r9, r4, lr
    df9a:	rsb	r0, lr, r2
    df9e:	mov.w	r8, lr, lsl #16
    dfa2:	str	r3, [sp, #8]
    dfa4:	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    dfa6:	movs	r4, #200	; 0xc8
    dfa8:	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    dfac:	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    dfb0:	str.w	r3, [r7, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
    dfb4:	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    dfb6:	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    dfb8:	ldr.w	ip, [pc, #508]	; e1b8 <usb_isr+0x638>
	ep0_tx_data_toggle ^= 1;
    dfbc:	ldr	r3, [pc, #480]	; (e1a0 <usb_isr+0x620>)
	ep0_tx_bdt_bank ^= 1;
    dfbe:	ldr.w	r8, [pc, #476]	; e19c <usb_isr+0x61c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    dfc2:	cmp	r0, #0
    dfc4:	bne.w	e21e <usb_isr+0x69e>
    dfc8:	cmp.w	lr, #64	; 0x40
    dfcc:	bne.n	e08a <usb_isr+0x50a>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    dfce:	orr.w	r4, r4, #2
    dfd2:	add.w	r3, r7, r4, lsl #3
    dfd6:	ldr.w	lr, [pc, #480]	; e1b8 <usb_isr+0x638>
    dfda:	str.w	r9, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    dfde:	cmp	r2, #0
    dfe0:	bne.w	e24a <usb_isr+0x6ca>
    dfe4:	lsls	r2, r0, #16
    dfe6:	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    dfea:	ldrb.w	r3, [sp, #8]
    dfee:	strb	r3, [r6, #0]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    dff0:	cmp	r0, #64	; 0x40
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    dff2:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    dff4:	add.w	r3, r9, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    dff8:	str.w	r2, [lr, r4, lsl #3]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    dffc:	bne.n	e08a <usb_isr+0x50a>
    dffe:	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    e000:	ldr	r2, [pc, #416]	; (e1a4 <usb_isr+0x624>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e002:	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    e004:	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e006:	str	r3, [r1, #0]
    e008:	b.n	e08a <usb_isr+0x50a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    e00a:	ldrb	r3, [r1, r6]
    e00c:	cmp	r3, #3
    e00e:	bhi.w	e256 <usb_isr+0x6d6>
    e012:	add	r2, pc, #4	; (adr r2, e018 <usb_isr+0x498>)
    e014:	ldr.w	pc, [r2, r3, lsl #2]
    e018:	.word	0x0000dc15
    e01c:	.word	0x0000dc15
    e020:	.word	0x0000e0e7
    e024:	.word	0x0000e0e1
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    e028:	ldrh	r2, [r2, #4]
    e02a:	cbnz	r2, e044 <usb_isr+0x4c4>
    e02c:	ldr	r2, [pc, #376]	; (e1a8 <usb_isr+0x628>)
    e02e:	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    e030:	ldrb.w	r3, [r1], #1
    e034:	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    e038:	cmp	r5, r1
    e03a:	bne.n	e030 <usb_isr+0x4b0>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e03c:	ldr	r2, [pc, #364]	; (e1ac <usb_isr+0x62c>)
    e03e:	ldr	r2, [r2, #0]
    e040:	cmp	r2, #134	; 0x86
    e042:	beq.n	e142 <usb_isr+0x5c2>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e044:	ldr	r1, [pc, #340]	; (e19c <usb_isr+0x61c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e046:	ldr	r6, [pc, #344]	; (e1a0 <usb_isr+0x620>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e048:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e04a:	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e04c:	orr.w	r5, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e050:	eor.w	r4, r4, #1
    e054:	strb	r4, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e056:	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e05a:	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e05c:	mov.w	r4, #0
    e060:	str	r4, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e062:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e066:	ite	eq
    e068:	moveq	r1, #136	; 0x88
    e06a:	movne	r1, #200	; 0xc8
    e06c:	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    e070:	strb	r2, [r6, #0]
    e072:	b.n	de34 <usb_isr+0x2b4>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e074:	movw	r4, #26273	; 0x66a1
    e078:	cmp	r1, r4
    e07a:	beq.n	e084 <usb_isr+0x504>
    e07c:	movw	r4, #26529	; 0x67a1
    e080:	cmp	r1, r4
    e082:	beq.n	e14a <usb_isr+0x5ca>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e084:	ldr	r3, [pc, #296]	; (e1b0 <usb_isr+0x630>)
    e086:	movs	r2, #15
    e088:	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    e08a:	ldr	r2, [pc, #296]	; (e1b4 <usb_isr+0x634>)
    e08c:	movs	r3, #1
    e08e:	strb	r3, [r2, #0]
    e090:	b.n	de1e <usb_isr+0x29e>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e092:	ldr	r1, [pc, #288]	; (e1b4 <usb_isr+0x634>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e094:	ldr	r3, [pc, #288]	; (e1b8 <usb_isr+0x638>)
    e096:	ldr	r0, [pc, #292]	; (e1bc <usb_isr+0x63c>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e098:	ldr	r6, [pc, #256]	; (e19c <usb_isr+0x61c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e09a:	ldr.w	ip, [pc, #276]	; e1b0 <usb_isr+0x630>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e09e:	ldr	r5, [pc, #232]	; (e188 <usb_isr+0x608>)
		USB0_ISTAT = 0xFF;
    e0a0:	ldr.w	lr, [pc, #232]	; e18c <usb_isr+0x60c>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e0a4:	ldr	r7, [pc, #280]	; (e1c0 <usb_isr+0x640>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e0a6:	movs	r4, #2
    e0a8:	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e0aa:	ldr	r4, [pc, #280]	; (e1c4 <usb_isr+0x644>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e0ac:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e0ae:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    e0b0:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    e0b2:	ldr	r0, [pc, #276]	; (e1c8 <usb_isr+0x648>)
    e0b4:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    e0b6:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    e0b8:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e0ba:	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e0bc:	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e0be:	ldr	r4, [pc, #268]	; (e1cc <usb_isr+0x64c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e0c0:	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e0c4:	ldr	r6, [pc, #264]	; (e1d0 <usb_isr+0x650>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e0c6:	movs	r3, #255	; 0xff
    e0c8:	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e0ca:	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e0cc:	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    e0ce:	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e0d2:	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e0d4:	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e0d6:	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e0d8:	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    e0da:	add	sp, #28
    e0dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e0e0:	movs	r3, #1
    e0e2:	strb	r3, [r1, r6]
						break;
    e0e4:	b.n	dc14 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    e0e6:	movs	r3, #0
    e0e8:	strb	r3, [r1, r6]
						break;
    e0ea:	b.n	dc14 <usb_isr+0x94>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e0ec:	cmp.w	r1, #1280	; 0x500
    e0f0:	beq.w	e33e <usb_isr+0x7be>
    e0f4:	bcc.n	e084 <usb_isr+0x504>
    e0f6:	sub.w	r1, r1, #1664	; 0x680
    e0fa:	cmp	r1, #1
    e0fc:	bhi.n	e084 <usb_isr+0x504>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    e0fe:	ldr	r2, [pc, #212]	; (e1d4 <usb_isr+0x654>)
    e100:	ldr	r4, [r2, #4]
    e102:	cmp	r4, #0
    e104:	beq.n	e084 <usb_isr+0x504>
    e106:	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e108:	ldrh.w	lr, [r5, #4]
    e10c:	b.n	e116 <usb_isr+0x596>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    e10e:	adds	r2, #12
			if (list->addr == NULL) break;
    e110:	ldr	r4, [r2, #4]
    e112:	cmp	r4, #0
    e114:	beq.n	e084 <usb_isr+0x504>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e116:	ldrh	r3, [r2, #0]
    e118:	cmp	r3, r0
    e11a:	bne.n	e10e <usb_isr+0x58e>
    e11c:	ldrh	r3, [r2, #2]
    e11e:	cmp	r3, lr
    e120:	bne.n	e10e <usb_isr+0x58e>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    e122:	lsrs	r0, r0, #8
    e124:	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    e126:	ite	eq
    e128:	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    e12a:	ldrhne	r0, [r2, #8]
    e12c:	b.n	df72 <usb_isr+0x3f2>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e12e:	ldr	r1, [pc, #128]	; (e1b0 <usb_isr+0x630>)
		USB0_ISTAT = USB_ISTAT_STALL;
    e130:	ldr	r3, [pc, #88]	; (e18c <usb_isr+0x60c>)
    e132:	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e134:	movs	r0, #13
    e136:	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    e138:	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    e13a:	lsls	r2, r4, #30
    e13c:	bpl.w	df1c <usb_isr+0x39c>
    e140:	b.n	df0e <usb_isr+0x38e>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e142:	ldr	r2, [pc, #148]	; (e1d8 <usb_isr+0x658>)
    e144:	movs	r1, #15
    e146:	strb	r1, [r2, #0]
    e148:	b.n	e044 <usb_isr+0x4c4>
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e14a:	ldr	r4, [pc, #76]	; (e198 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
    e14c:	movs	r1, #32
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
		reply_buffer[1] = 0;
    e14e:	strb	r2, [r4, #1]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e150:	movs	r2, #4
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
    e152:	strb	r0, [r4, #2]
		reply_buffer[3] = 0x20;
    e154:	strb	r1, [r4, #3]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e156:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
		data = reply_buffer;
		datalen = 4;
    e158:	mov	r0, r2
    e15a:	b.n	df72 <usb_isr+0x3f2>
    e15c:	ldrh	r1, [r5, #4]
    e15e:	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    e162:	cmp	r1, #6
    e164:	bhi.n	e084 <usb_isr+0x504>
    e166:	ldrh	r2, [r5, #2]
    e168:	cmp	r2, #0
    e16a:	bne.n	e084 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    e16c:	ldr	r4, [pc, #64]	; (e1b0 <usb_isr+0x630>)
    e16e:	str	r0, [sp, #8]
    e170:	lsls	r1, r1, #2
    e172:	add	r4, r1
    e174:	ldrb	r1, [r4, #0]
    e176:	bic.w	r1, r1, #2
    e17a:	strb	r1, [r4, #0]
    e17c:	b.n	e1f6 <usb_isr+0x676>
    e17e:	nop
    e180:	.word	0x20003164
    e184:	.word	0x200031ac
    e188:	.word	0x40072088
    e18c:	.word	0x40072080
    e190:	.word	0x2000319d
    e194:	.word	0x200030ac
    e198:	.word	0x200031a0
    e19c:	.word	0x2000319c
    e1a0:	.word	0x20003120
    e1a4:	.word	0x200030c4
    e1a8:	.word	0x20003217
    e1ac:	.word	0x20003218
    e1b0:	.word	0x400720c0
    e1b4:	.word	0x40072094
    e1b8:	.word	0x1fff8000
    e1bc:	.word	0x00400088
    e1c0:	.word	0x40072098
    e1c4:	.word	0x200030c8
    e1c8:	.word	0x20003124
    e1cc:	.word	0x40072084
    e1d0:	.word	0x4007208c
    e1d4:	.word	0x00014738
    e1d8:	.word	0x20003121
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    e1dc:	ldrh	r1, [r5, #4]
    e1de:	cmp	r1, #0
    e1e0:	bne.w	e36c <usb_isr+0x7ec>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e1e4:	ldr	r3, [pc, #472]	; (e3c0 <usb_isr+0x840>)
    e1e6:	ldr	r2, [pc, #476]	; (e3c4 <usb_isr+0x844>)
			usb_cdc_line_rtsdtr = setup.wValue;
    e1e8:	ldr	r4, [pc, #476]	; (e3c8 <usb_isr+0x848>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e1ea:	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e1ec:	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e1ee:	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e1f0:	str	r0, [sp, #8]
    e1f2:	mov	r2, r1
    e1f4:	strb	r5, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e1f6:	movs	r0, #0
    e1f8:	mov	r9, r0
    e1fa:	mov	r8, r0
    e1fc:	mov	lr, r0
    e1fe:	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e200:	ldr	r1, [pc, #456]	; (e3cc <usb_isr+0x84c>)
    e202:	ldrb	r5, [r1, #0]
    e204:	orr.w	ip, r5, #2
    e208:	add.w	r3, r7, ip, lsl #3
    e20c:	str	r3, [sp, #12]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e20e:	ldr	r3, [sp, #8]
    e210:	cmp	r3, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e212:	ldr	r3, [sp, #12]
    e214:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e216:	ite	eq
    e218:	moveq	r4, #136	; 0x88
    e21a:	movne	r4, #200	; 0xc8
    e21c:	b.n	dfa8 <usb_isr+0x428>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    e21e:	cmp	r0, #64	; 0x40
    e220:	bls.w	dfce <usb_isr+0x44e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e224:	orr.w	r4, r4, #2
    e228:	add.w	r1, ip, r4, lsl #3
    e22c:	str.w	r9, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e230:	cbz	r2, e252 <usb_isr+0x6d2>
    e232:	ldr	r2, [pc, #412]	; (e3d0 <usb_isr+0x850>)
	ep0_tx_data_toggle ^= 1;
    e234:	ldrb.w	r1, [sp, #8]
    e238:	strb	r1, [r3, #0]
	ep0_tx_bdt_bank ^= 1;
    e23a:	strb.w	r5, [r8]
    e23e:	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    e240:	add.w	r3, r9, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e244:	str.w	r2, [ip, r4, lsl #3]
    e248:	b.n	e000 <usb_isr+0x480>
    e24a:	lsls	r2, r0, #16
    e24c:	orr.w	r2, r2, #200	; 0xc8
    e250:	b.n	dfea <usb_isr+0x46a>
    e252:	ldr	r2, [pc, #384]	; (e3d4 <usb_isr+0x854>)
    e254:	b.n	e234 <usb_isr+0x6b4>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    e256:	tst.w	r9, #8
    e25a:	ite	eq
    e25c:	moveq	r3, #2
    e25e:	movne	r3, #3
    e260:	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    e262:	b.n	dc14 <usb_isr+0x94>
    e264:	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e266:	ldr	r3, [pc, #368]	; (e3d8 <usb_isr+0x858>)
    e268:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    e26c:	cmp	r1, #6
    e26e:	bhi.w	e086 <usb_isr+0x506>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e272:	ldr	r4, [pc, #360]	; (e3dc <usb_isr+0x85c>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e274:	lsls	r1, r1, #2
    e276:	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e278:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    e27a:	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e27c:	ldrb	r2, [r3, #0]
    e27e:	lsls	r3, r2, #30
    e280:	bpl.n	e370 <usb_isr+0x7f0>
    e282:	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    e284:	movs	r0, #2
    e286:	b.n	df72 <usb_isr+0x3f2>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e288:	ldr	r3, [sp, #8]
    e28a:	mov.w	r2, #1
    e28e:	strb	r2, [r3, #0]
    e290:	ldr	r3, [sp, #8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    e292:	add.w	r9, r9, #1
    e296:	adds	r3, #1
    e298:	cmp.w	r9, #6
    e29c:	add.w	r4, r4, #4
    e2a0:	add.w	r5, r5, #4
    e2a4:	str	r3, [sp, #8]
    e2a6:	bne.w	dd50 <usb_isr+0x1d0>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e2aa:	ldr	r3, [pc, #308]	; (e3e0 <usb_isr+0x860>)
    e2ac:	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    e2ae:	ldr	r5, [pc, #308]	; (e3e4 <usb_isr+0x864>)
		cfg = usb_endpoint_config_table;
    e2b0:	ldr.w	r8, [pc, #316]	; e3f0 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e2b4:	movs	r0, #0
    e2b6:	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e2b8:	mov.w	r9, #1
    e2bc:	b.n	e2de <usb_isr+0x75e>
    e2be:	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e2c2:	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    e2c6:	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e2ca:	movs	r3, #0
    e2cc:	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    e2d0:	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e2d4:	ldr	r3, [pc, #272]	; (e3e8 <usb_isr+0x868>)
    e2d6:	cmp	r5, r3
    e2d8:	add.w	r9, r9, #1
    e2dc:	beq.n	e32a <usb_isr+0x7aa>
			epconf = *cfg++;
    e2de:	ldrb.w	r3, [r8], #1
			*reg = epconf;
    e2e2:	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    e2e6:	lsls	r2, r3, #28
    e2e8:	bpl.n	e2be <usb_isr+0x73e>
				usb_packet_t *p;
				p = usb_malloc();
    e2ea:	bl	d984 <usb_malloc>
				if (p) {
    e2ee:	cmp	r0, #0
    e2f0:	beq.n	e388 <usb_isr+0x808>
					table[index(i, RX, EVEN)].addr = p->buf;
    e2f2:	add.w	r3, r7, r9, lsl #5
    e2f6:	mov.w	r4, r9, lsl #2
    e2fa:	adds	r0, #8
    e2fc:	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    e2fe:	ldr	r3, [pc, #212]	; (e3d4 <usb_isr+0x854>)
    e300:	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    e304:	bl	d984 <usb_malloc>
				if (p) {
    e308:	cmp	r0, #0
    e30a:	beq.n	e374 <usb_isr+0x7f4>
					table[index(i, RX, ODD)].addr = p->buf;
    e30c:	orr.w	r3, r4, #1
    e310:	add.w	r2, r7, r3, lsl #3
    e314:	adds	r0, #8
    e316:	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    e318:	ldr	r2, [pc, #180]	; (e3d0 <usb_isr+0x850>)
    e31a:	str.w	r2, [r7, r3, lsl #3]
    e31e:	b.n	e2c2 <usb_isr+0x742>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    e320:	ldr	r3, [sp, #8]
    e322:	mov.w	r2, #0
    e326:	strb	r2, [r3, #0]
    e328:	b.n	e290 <usb_isr+0x710>
    e32a:	ldrb	r3, [r6, #0]
    e32c:	str	r3, [sp, #8]
    e32e:	eor.w	r2, r3, #1
    e332:	b.n	e1f6 <usb_isr+0x676>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    e334:	ldr	r2, [pc, #180]	; (e3ec <usb_isr+0x86c>)
    e336:	ldr	r4, [pc, #164]	; (e3dc <usb_isr+0x85c>)
    e338:	ldrb	r2, [r2, #0]
    e33a:	strb	r2, [r4, #0]
    e33c:	b.n	df72 <usb_isr+0x3f2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e33e:	movs	r3, #1
    e340:	movs	r2, #0
    e342:	str	r3, [sp, #8]
    e344:	b.n	e1f6 <usb_isr+0x676>
    e346:	ldrh	r1, [r5, #4]
    e348:	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    e34c:	cmp	r1, #6
    e34e:	bhi.w	e084 <usb_isr+0x504>
    e352:	ldrh	r2, [r5, #2]
    e354:	cmp	r2, #0
    e356:	bne.w	e084 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    e35a:	ldr	r4, [pc, #124]	; (e3d8 <usb_isr+0x858>)
    e35c:	str	r0, [sp, #8]
    e35e:	lsls	r1, r1, #2
    e360:	add	r4, r1
    e362:	ldrb	r1, [r4, #0]
    e364:	orr.w	r1, r1, #2
    e368:	strb	r1, [r4, #0]
    e36a:	b.n	e1f6 <usb_isr+0x676>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    e36c:	str	r0, [sp, #8]
    e36e:	b.n	e1f6 <usb_isr+0x676>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    e370:	movs	r0, #2
    e372:	b.n	df72 <usb_isr+0x3f2>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    e374:	ldr	r3, [pc, #104]	; (e3e0 <usb_isr+0x860>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    e376:	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    e37a:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    e37c:	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    e380:	ldr	r2, [pc, #92]	; (e3e0 <usb_isr+0x860>)
    e382:	adds	r3, #1
    e384:	strb	r3, [r2, #0]
    e386:	b.n	e2c2 <usb_isr+0x742>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    e388:	ldr	r3, [pc, #84]	; (e3e0 <usb_isr+0x860>)
    e38a:	ldr	r2, [pc, #84]	; (e3e0 <usb_isr+0x860>)
    e38c:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    e38e:	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    e392:	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    e394:	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    e398:	strb	r3, [r2, #0]
    e39a:	b.n	e304 <usb_isr+0x784>
    e39c:	cmp	r0, #64	; 0x40
    e39e:	mov	lr, r0
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e3a0:	mov.w	r3, #1
    e3a4:	it	cs
    e3a6:	movcs.w	lr, #64	; 0x40
    e3aa:	rsb	r0, lr, r0
    e3ae:	mov.w	r8, lr, lsl #16
    e3b2:	add.w	r9, r4, lr
    e3b6:	movs	r2, #0
    e3b8:	str	r3, [sp, #8]
    e3ba:	b.n	e200 <usb_isr+0x680>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    e3bc:	bkpt	0x0000
    e3be:	nop
    e3c0:	.word	0x200030a4
    e3c4:	.word	0x20003220
    e3c8:	.word	0x200030a0
    e3cc:	.word	0x2000319c
    e3d0:	.word	0x004000c8
    e3d4:	.word	0x00400088
    e3d8:	.word	0x400720c0
    e3dc:	.word	0x200031a0
    e3e0:	.word	0x2000319d
    e3e4:	.word	0x400720c4
    e3e8:	.word	0x400720dc
    e3ec:	.word	0x200031a8
    e3f0:	.word	0x00014730

0000e3f4 <usb_init>:
}



void usb_init(void)
{
    e3f4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    e3f8:	bl	d0fc <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e3fc:	movs	r3, #0
    e3fe:	ldr	r1, [pc, #124]	; (e47c <usb_init+0x88>)
		table[i].desc = 0;
    e400:	mov	r2, r3
		table[i].addr = 0;
    e402:	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    e406:	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e40a:	adds	r3, #1
    e40c:	cmp	r3, #28
		table[i].desc = 0;
		table[i].addr = 0;
    e40e:	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    e410:	mov.w	r4, #0
    e414:	ldr	r0, [pc, #100]	; (e47c <usb_init+0x88>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e416:	bne.n	e402 <usb_init+0xe>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e418:	ldr	r2, [pc, #100]	; (e480 <usb_init+0x8c>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    e41a:	ldr	r7, [pc, #104]	; (e484 <usb_init+0x90>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e41c:	ldr	r3, [r2, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    e41e:	ldr	r1, [pc, #104]	; (e488 <usb_init+0x94>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e420:	ldr	r5, [pc, #104]	; (e48c <usb_init+0x98>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    e422:	ldr	r6, [pc, #108]	; (e490 <usb_init+0x9c>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e424:	ldr.w	ip, [pc, #116]	; e49c <usb_init+0xa8>
	USB0_ERRSTAT = 0xFF;
    e428:	ldr.w	lr, [pc, #116]	; e4a0 <usb_init+0xac>
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    e42c:	ldr.w	r8, [pc, #116]	; e4a4 <usb_init+0xb0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e430:	orr.w	r3, r3, #262144	; 0x40000
    e434:	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    e436:	ubfx	r3, r0, #8, #8
    e43a:	strb	r3, [r7, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    e43c:	ubfx	r3, r0, #16, #8
    e440:	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e442:	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e444:	movs	r3, #255	; 0xff
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e446:	add.w	r2, r2, #172032	; 0x2a000
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e44a:	strb	r0, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e44c:	adds	r2, #212	; 0xd4
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e44e:	strb.w	r3, [ip]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e452:	ldr	r5, [pc, #64]	; (e494 <usb_init+0xa0>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    e454:	strb.w	r3, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e458:	ldr	r0, [pc, #60]	; (e498 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    e45a:	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    e45c:	movs	r3, #1
    e45e:	strb.w	r3, [r8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e462:	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    e464:	strb.w	r4, [r1, #80]	; 0x50
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e468:	mov.w	r4, #512	; 0x200

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e46c:	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    e46e:	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e472:	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e474:	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e476:	strb	r1, [r2, #0]
    e478:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e47c:	.word	0x1fff8000
    e480:	.word	0x40048034
    e484:	.word	0x4007209c
    e488:	.word	0x400720b0
    e48c:	.word	0x400720b4
    e490:	.word	0x40072010
    e494:	.word	0xe000e449
    e498:	.word	0xe000e108
    e49c:	.word	0x40072080
    e4a0:	.word	0x40072088
    e4a4:	.word	0x40072094

0000e4a8 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    e4a8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    e4ac:	ldr	r6, [pc, #196]	; (e574 <yield+0xcc>)
    e4ae:	ldrb	r3, [r6, #0]
    e4b0:	cbz	r3, e4d8 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    e4b2:	ldr	r7, [pc, #196]	; (e578 <yield+0xd0>)
    e4b4:	ldrb	r2, [r7, #0]
    e4b6:	cbnz	r2, e4d8 <yield+0x30>
	running = 1;
    e4b8:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    e4ba:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    e4bc:	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    e4be:	bmi.n	e52e <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    e4c0:	lsls	r2, r3, #30
    e4c2:	bmi.n	e4f8 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    e4c4:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    e4c6:	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    e4c8:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    e4ca:	bpl.n	e4d8 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    e4cc:	ldr	r3, [pc, #172]	; (e57c <yield+0xd4>)
    e4ce:	ldr	r2, [r3, #0]
    e4d0:	cbz	r2, e4d8 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    e4d2:	mrs	r2, IPSR
		if (ipsr != 0) return;
    e4d6:	cbz	r2, e4dc <yield+0x34>
    e4d8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e4dc:	mrs	r1, PRIMASK
		__disable_irq();
    e4e0:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    e4e2:	ldr	r0, [r3, #0]
		if (first == nullptr) {
    e4e4:	cbz	r0, e4ee <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    e4e6:	ldr	r4, [pc, #152]	; (e580 <yield+0xd8>)
    e4e8:	ldrb	r2, [r4, #0]
    e4ea:	cmp	r2, #0
    e4ec:	beq.n	e54c <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e4ee:	cmp	r1, #0
    e4f0:	bne.n	e4d8 <yield+0x30>
    e4f2:	cpsie	i
    e4f4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    e4f8:	ldr.w	r8, [pc, #144]	; e58c <yield+0xe4>
    e4fc:	ldrb.w	r2, [r8]
    e500:	cmp	r2, #0
    e502:	beq.n	e4c4 <yield+0x1c>
    e504:	ldr.w	r9, [pc, #136]	; e590 <yield+0xe8>
    e508:	movs	r4, #0
    e50a:	b.n	e518 <yield+0x70>
    e50c:	adds	r4, #1
    e50e:	ldrb.w	r3, [r8]
    e512:	uxtb	r4, r4
    e514:	cmp	r3, r4
    e516:	bls.n	e53e <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    e518:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    e51c:	ldr	r3, [r5, #0]
    e51e:	mov	r0, r5
    e520:	ldr	r3, [r3, #16]
    e522:	blx	r3
    e524:	cmp	r0, #0
    e526:	beq.n	e50c <yield+0x64>
    e528:	ldr	r3, [r5, #16]
    e52a:	blx	r3
    e52c:	b.n	e50c <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    e52e:	bl	cd30 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    e532:	cbnz	r0, e568 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    e534:	ldr	r3, [pc, #76]	; (e584 <yield+0xdc>)
    e536:	ldrb	r3, [r3, #0]
    e538:	cbnz	r3, e542 <yield+0x9a>
    e53a:	ldrb	r3, [r6, #0]
    e53c:	b.n	e4c0 <yield+0x18>
    e53e:	ldrb	r3, [r6, #0]
    e540:	b.n	e4c4 <yield+0x1c>
    e542:	ldrb	r3, [r6, #0]
    e544:	and.w	r3, r3, #254	; 0xfe
    e548:	strb	r3, [r6, #0]
    e54a:	b.n	e4c0 <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    e54c:	ldr	r5, [r0, #20]
    e54e:	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    e550:	movs	r3, #1
    e552:	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    e554:	cbz	r5, e56e <yield+0xc6>
			firstYield->_prev = nullptr;
    e556:	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e558:	cbnz	r1, e55c <yield+0xb4>
    e55a:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    e55c:	movs	r5, #0
    e55e:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    e560:	ldr	r3, [r0, #8]
    e562:	blx	r3
		runningFromYield = false;
    e564:	strb	r5, [r4, #0]
    e566:	b.n	e4d8 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    e568:	bl	e958 <serialEvent()>
    e56c:	b.n	e534 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    e56e:	ldr	r3, [pc, #24]	; (e588 <yield+0xe0>)
    e570:	str	r5, [r3, #0]
    e572:	b.n	e558 <yield+0xb0>
    e574:	.word	0x1fff8d4c
    e578:	.word	0x200031b2
    e57c:	.word	0x200031c4
    e580:	.word	0x200031c8
    e584:	.word	0x1fff8d60
    e588:	.word	0x200031c0
    e58c:	.word	0x200031e0
    e590:	.word	0x200031d4

0000e594 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    e594:	push	{r4, r5, r6, r7, lr}
	uint32_t ch = 0;

	__disable_irq();
    e596:	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    e598:	cbnz	r1, e5c2 <DMAChannel::begin(bool)+0x2e>
    e59a:	ldr	r2, [r0, #0]
    e59c:	cbz	r2, e5c2 <DMAChannel::begin(bool)+0x2e>
    e59e:	ldrb	r3, [r0, #4]
    e5a0:	cmp	r3, #15
    e5a2:	bhi.n	e5c2 <DMAChannel::begin(bool)+0x2e>
	  && (dma_channel_allocated_mask & (1 << channel))
    e5a4:	ldr	r4, [pc, #156]	; (e644 <DMAChannel::begin(bool)+0xb0>)
    e5a6:	ldrh	r1, [r4, #0]
    e5a8:	asr.w	r5, r1, r3
    e5ac:	lsls	r5, r5, #31
    e5ae:	bpl.n	e5c6 <DMAChannel::begin(bool)+0x32>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    e5b0:	add.w	r3, r3, #33554432	; 0x2000000
    e5b4:	add.w	r3, r3, #1152	; 0x480
    e5b8:	cmp.w	r2, r3, lsl #5
    e5bc:	bne.n	e5c6 <DMAChannel::begin(bool)+0x32>
		// DMA channel already allocated
		__enable_irq();
    e5be:	cpsie	i
		return;
    e5c0:	pop	{r4, r5, r6, r7, pc}
    e5c2:	ldr	r4, [pc, #128]	; (e644 <DMAChannel::begin(bool)+0xb0>)
    e5c4:	ldrh	r1, [r4, #0]
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    e5c6:	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    e5c8:	asr.w	r2, r1, r3
    e5cc:	ands.w	r2, r2, #1
    e5d0:	beq.n	e5e2 <DMAChannel::begin(bool)+0x4e>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    e5d2:	adds	r3, #1
    e5d4:	cmp	r3, #16
    e5d6:	bne.n	e5c8 <DMAChannel::begin(bool)+0x34>
			__enable_irq();
    e5d8:	cpsie	i
			TCD = (TCD_t *)0;
    e5da:	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
    e5dc:	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
    e5de:	str	r2, [r0, #0]
    e5e0:	pop	{r4, r5, r6, r7, pc}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    e5e2:	movs	r5, #1
    e5e4:	lsls	r5, r3
    e5e6:	orrs	r1, r5
    e5e8:	strh	r1, [r4, #0]
			__enable_irq();
    e5ea:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    e5ec:	ldr	r6, [pc, #88]	; (e648 <DMAChannel::begin(bool)+0xb4>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    e5ee:	ldr	r5, [pc, #92]	; (e64c <DMAChannel::begin(bool)+0xb8>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    e5f0:	ldr	r7, [pc, #92]	; (e650 <DMAChannel::begin(bool)+0xbc>)
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    e5f2:	ldr.w	lr, [pc, #100]	; e658 <DMAChannel::begin(bool)+0xc4>
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    e5f6:	uxtb	r1, r3
    e5f8:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    e5fa:	ldr	r4, [r6, #0]
    e5fc:	orr.w	r4, r4, #2
    e600:	str	r4, [r6, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    e602:	ldr	r4, [r5, #0]
    e604:	orr.w	r4, r4, #2
    e608:	str	r4, [r5, #0]
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    e60a:	sub.w	r6, r6, #262144	; 0x40000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    e60e:	movs	r4, #130	; 0x82
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
    e610:	sub.w	r5, r5, #262144	; 0x40000
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    e614:	add.w	r3, r3, #33554432	; 0x2000000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    e618:	str	r4, [r7, #0]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    e61a:	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    e61e:	subs	r6, #34	; 0x22
	DMA_CEEI = ch;
    e620:	subs	r5, #36	; 0x24
	DMA_CINT = ch;
    e622:	ldr	r4, [pc, #48]	; (e654 <DMAChannel::begin(bool)+0xc0>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    e624:	strb.w	r1, [lr]
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    e628:	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    e62a:	strb	r1, [r6, #0]
	DMA_CEEI = ch;
    e62c:	strb	r1, [r5, #0]
	DMA_CINT = ch;
    e62e:	strb	r1, [r4, #0]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    e630:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    e632:	str	r2, [r3, #0]
	*p++ = 0;
    e634:	str	r2, [r3, #4]
	*p++ = 0;
    e636:	str	r2, [r3, #8]
	*p++ = 0;
    e638:	str	r2, [r3, #12]
	*p++ = 0;
    e63a:	str	r2, [r3, #16]
	*p++ = 0;
    e63c:	str	r2, [r3, #20]
	*p++ = 0;
    e63e:	str	r2, [r3, #24]
	*p++ = 0;
    e640:	str	r2, [r3, #28]
    e642:	pop	{r4, r5, r6, r7, pc}
    e644:	.word	0x200031b4
    e648:	.word	0x40048040
    e64c:	.word	0x4004803c
    e650:	.word	0x40008000
    e654:	.word	0x4000801f
    e658:	.word	0x4000801a

0000e65c <DMAChannel::release()>:
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    e65c:	ldrb	r3, [r0, #4]
    e65e:	cmp	r3, #15
    e660:	bhi.n	e686 <DMAChannel::release()+0x2a>
	DMA_CERQ = channel;
    e662:	ldr	r2, [pc, #36]	; (e688 <DMAChannel::release()+0x2c>)
	*p++ = 0;
	*p++ = 0;
}

void DMAChannel::release(void)
{
    e664:	push	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
    e666:	strb	r3, [r2, #0]
	__disable_irq();
    e668:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    e66a:	ldr	r1, [pc, #32]	; (e68c <DMAChannel::release()+0x30>)
    e66c:	ldrb	r4, [r0, #4]
    e66e:	ldrh	r2, [r1, #0]
    e670:	movs	r3, #1
    e672:	lsls	r3, r4
    e674:	bic.w	r3, r2, r3
    e678:	strh	r3, [r1, #0]
	__enable_irq();
    e67a:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    e67c:	movs	r2, #16
	TCD = (TCD_t *)0;
    e67e:	movs	r3, #0
}
    e680:	pop	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
    e682:	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
    e684:	str	r3, [r0, #0]
}
    e686:	bx	lr
    e688:	.word	0x4000801a
    e68c:	.word	0x200031b4

0000e690 <EventResponder::triggerEventNotImmediate()>:
uint8_t _serialEvent_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB1_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB2_default __attribute__((weak)) PROGMEM = 0 ;	

void EventResponder::triggerEventNotImmediate()
{
    e690:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e692:	mrs	r2, PRIMASK
		__disable_irq();
    e696:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    e698:	ldrb	r3, [r0, #29]
    e69a:	cbnz	r3, e6aa <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    e69c:	ldrb	r1, [r0, #28]
    e69e:	cmp	r1, #1
    e6a0:	beq.n	e6b2 <EventResponder::triggerEventNotImmediate()+0x22>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    e6a2:	cmp	r1, #3
    e6a4:	beq.n	e6c6 <EventResponder::triggerEventNotImmediate()+0x36>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    e6a6:	movs	r3, #1
    e6a8:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e6aa:	cbnz	r2, e6ae <EventResponder::triggerEventNotImmediate()+0x1e>
    e6ac:	cpsie	i
	}
	enableInterrupts(irq);
}
    e6ae:	pop	{r4}
    e6b0:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    e6b2:	ldr	r4, [pc, #72]	; (e6fc <EventResponder::triggerEventNotImmediate()+0x6c>)
    e6b4:	ldr	r1, [r4, #0]
    e6b6:	cbz	r1, e6e2 <EventResponder::triggerEventNotImmediate()+0x52>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    e6b8:	ldr	r1, [pc, #68]	; (e700 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    e6ba:	str	r3, [r0, #20]
				_prev = lastYield;
    e6bc:	ldr	r3, [r1, #0]
    e6be:	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    e6c0:	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    e6c2:	str	r0, [r3, #20]
    e6c4:	b.n	e6a6 <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    e6c6:	ldr	r4, [pc, #60]	; (e704 <EventResponder::triggerEventNotImmediate()+0x74>)
    e6c8:	ldr	r1, [r4, #0]
    e6ca:	cbz	r1, e6ee <EventResponder::triggerEventNotImmediate()+0x5e>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    e6cc:	ldr	r1, [pc, #56]	; (e708 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    e6ce:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    e6d0:	ldr	r3, [r1, #0]
    e6d2:	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    e6d4:	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    e6d6:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    e6d8:	ldr	r3, [pc, #48]	; (e70c <EventResponder::triggerEventNotImmediate()+0x7c>)
    e6da:	mov.w	r1, #268435456	; 0x10000000
    e6de:	str	r1, [r3, #0]
    e6e0:	b.n	e6a6 <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    e6e2:	ldr	r3, [pc, #28]	; (e700 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    e6e4:	str	r1, [r0, #20]
				_prev = nullptr;
    e6e6:	str	r1, [r0, #24]
				firstYield = this;
    e6e8:	str	r0, [r4, #0]
				lastYield = this;
    e6ea:	str	r0, [r3, #0]
    e6ec:	b.n	e6a6 <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    e6ee:	ldr	r3, [pc, #24]	; (e708 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    e6f0:	str	r1, [r0, #20]
				_prev = nullptr;
    e6f2:	str	r1, [r0, #24]
				firstInterrupt = this;
    e6f4:	str	r0, [r4, #0]
				lastInterrupt = this;
    e6f6:	str	r0, [r3, #0]
    e6f8:	b.n	e6d8 <EventResponder::triggerEventNotImmediate()+0x48>
    e6fa:	nop
    e6fc:	.word	0x200031c4
    e700:	.word	0x200031c0
    e704:	.word	0x200031b8
    e708:	.word	0x200031bc
    e70c:	.word	0xe000ed04

0000e710 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    e710:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e712:	mrs	r2, PRIMASK
		__disable_irq();
    e716:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    e718:	ldr	r4, [pc, #48]	; (e74c <EventResponder::runFromInterrupt()+0x3c>)
    e71a:	ldr	r0, [r4, #0]
		if (first) {
    e71c:	cbz	r0, e740 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    e71e:	ldr	r6, [pc, #48]	; (e750 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    e720:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    e722:	ldr	r3, [r0, #20]
    e724:	str	r3, [r4, #0]
			if (firstInterrupt) {
    e726:	cbz	r3, e746 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    e728:	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e72a:	cbnz	r2, e72e <EventResponder::runFromInterrupt()+0x1e>
    e72c:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    e72e:	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    e730:	ldr	r3, [r0, #8]
    e732:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e734:	mrs	r2, PRIMASK
		__disable_irq();
    e738:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    e73a:	ldr	r0, [r4, #0]
		if (first) {
    e73c:	cmp	r0, #0
    e73e:	bne.n	e722 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e740:	cbnz	r2, e744 <EventResponder::runFromInterrupt()+0x34>
    e742:	cpsie	i
    e744:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    e746:	str	r3, [r6, #0]
    e748:	b.n	e72a <EventResponder::runFromInterrupt()+0x1a>
    e74a:	nop
    e74c:	.word	0x200031b8
    e750:	.word	0x200031bc

0000e754 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    e754:	b.w	e710 <EventResponder::runFromInterrupt()>

0000e758 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    e758:	ldr	r2, [pc, #8]	; (e764 <systick_isr+0xc>)
    e75a:	ldr	r3, [r2, #0]
    e75c:	adds	r3, #1
    e75e:	str	r3, [r2, #0]
    e760:	bx	lr
    e762:	nop
    e764:	.word	0x200030a4

0000e768 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    e768:	b.w	cd4c <usb_serial_flush_input>

0000e76c <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    e76c:	b.w	cd00 <usb_serial_peekchar>

0000e770 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    e770:	b.w	ccb8 <usb_serial_getchar>

0000e774 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    e774:	b.w	cd30 <usb_serial_available>

0000e778 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    e778:	b.w	ceec <usb_serial_flush_output>

0000e77c <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    e77c:	b.w	cea4 <usb_serial_write_buffer_free>

0000e780 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    e780:	mov	r0, r1
    e782:	mov	r1, r2
    e784:	b.w	cd84 <usb_serial_write>

0000e788 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    e788:	mov	r0, r1
    e78a:	b.w	ce8c <usb_serial_putchar>
    e78e:	nop

0000e790 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    e790:	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
    e792:	mov	r6, r1
    e794:	cbz	r1, e7b4 <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
    e796:	cbz	r2, e7b8 <Print::write(unsigned char const*, unsigned int)+0x28>
    e798:	mov	r7, r0
    e79a:	mov	r4, r2
    e79c:	movs	r5, #0
    e79e:	ldr	r3, [r7, #0]
    e7a0:	ldrb.w	r1, [r6], #1
    e7a4:	ldr	r3, [r3, #0]
    e7a6:	mov	r0, r7
    e7a8:	blx	r3
    e7aa:	subs	r4, #1
    e7ac:	add	r5, r0
    e7ae:	bne.n	e79e <Print::write(unsigned char const*, unsigned int)+0xe>
    e7b0:	mov	r0, r5
    e7b2:	pop	{r3, r4, r5, r6, r7, pc}
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    e7b4:	mov	r0, r1
    e7b6:	pop	{r3, r4, r5, r6, r7, pc}
    e7b8:	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    e7ba:	pop	{r3, r4, r5, r6, r7, pc}

0000e7bc <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    e7bc:	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    e7be:	ldr	r2, [pc, #24]	; (e7d8 <Print::println()+0x1c>)
	return write(buf, 2);
    e7c0:	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    e7c2:	ldrh	r2, [r2, #0]
	return write(buf, 2);
    e7c4:	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    e7c6:	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    e7c8:	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    e7ca:	strh.w	r2, [sp, #4]
	return write(buf, 2);
    e7ce:	movs	r2, #2
    e7d0:	blx	r3
}
    e7d2:	add	sp, #12
    e7d4:	ldr.w	pc, [sp], #4
    e7d8:	.word	0x000148d8

0000e7dc <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    e7dc:	push	{r4, lr}
	((class Print *)file)->write((uint8_t *)ptr, len);
    e7de:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    e7e0:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    e7e2:	ldr	r3, [r3, #4]
    e7e4:	blx	r3
	return len;
}
    e7e6:	mov	r0, r4
    e7e8:	pop	{r4, pc}
    e7ea:	nop

0000e7ec <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    e7ec:	push	{r1, r2, r3}
    e7ee:	push	{lr}
    e7f0:	sub	sp, #8
    e7f2:	add	r2, sp, #12
    e7f4:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    e7f8:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    e7fa:	bl	125b8 <vdprintf>
#endif
}
    e7fe:	add	sp, #8
    e800:	ldr.w	lr, [sp], #4
    e804:	add	sp, #12
    e806:	bx	lr

0000e808 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    e808:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e80c:	sub	sp, #72	; 0x48
    e80e:	ldrb.w	r6, [sp, #104]	; 0x68
    e812:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    e816:	cmp	r6, #1
    e818:	bls.n	e8ba <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xb2>
    e81a:	mov	r4, r2
    e81c:	mov	r5, r3
	if (n == 0) {
    e81e:	orrs.w	r3, r4, r5
    e822:	mov	r9, r0
    e824:	beq.n	e8ae <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa6>
    e826:	uxtb	r6, r6
    e828:	movs	r7, #0
    e82a:	mov.w	r8, #65	; 0x41
    e82e:	b.n	e834 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    e830:	uxtb.w	r8, r3
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    e834:	mov	r0, r4
    e836:	mov	r1, r5
    e838:	mov	r2, r6
    e83a:	mov	r3, r7
    e83c:	bl	fb54 <__aeabi_uldivmod>
    e840:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    e842:	cmp	r1, #0
    e844:	it	eq
    e846:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    e848:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
    e84a:	mov	r0, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    e84c:	add	r4, sp, #72	; 0x48
    e84e:	add.w	lr, r3, #48	; 0x30
    e852:	add	r4, r8
    e854:	itte	cs
    e856:	addcs	r3, #55	; 0x37
    e858:	uxtbcs.w	lr, r3
    e85c:	uxtbcc.w	lr, lr
			n /= base;
    e860:	mov	r3, r7
    e862:	mov	r1, r5
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    e864:	strb.w	lr, [r4, #-68]
			n /= base;
    e868:	mov	r2, r6
    e86a:	bl	fb54 <__aeabi_uldivmod>
    e86e:	mov	r4, r0
    e870:	mov	r5, r1
			if (n == 0) break;
    e872:	orrs.w	r3, r4, r5
			i--;
    e876:	add.w	r3, r8, #4294967295
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    e87a:	bne.n	e830 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x28>
			i--;
		}
	}
	if (sign) {
    e87c:	cmp.w	sl, #0
    e880:	beq.n	e894 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    e882:	add.w	r8, r8, #4294967295
    e886:	uxtb.w	r8, r8
		buf[i] = '-';
    e88a:	add	r3, sp, #72	; 0x48
    e88c:	add	r3, r8
    e88e:	movs	r2, #45	; 0x2d
    e890:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    e894:	ldr.w	r3, [r9]
    e898:	add	r2, sp, #4
    e89a:	add.w	r1, r2, r8
    e89e:	ldr	r3, [r3, #4]
    e8a0:	mov	r0, r9
    e8a2:	rsb	r2, r8, #66	; 0x42
    e8a6:	blx	r3
}
    e8a8:	add	sp, #72	; 0x48
    e8aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    e8ae:	movs	r3, #48	; 0x30
    e8b0:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    e8b4:	mov.w	r8, #65	; 0x41
    e8b8:	b.n	e87c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x74>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    e8ba:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    e8bc:	add	sp, #72	; 0x48
    e8be:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e8c2:	nop

0000e8c4 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    e8c4:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    e8c6:	bl	1cdc <setup>
	while (1) {
		loop();
    e8ca:	bl	1ab8 <loop>
		yield();
    e8ce:	bl	e4a8 <yield>
    e8d2:	b.n	e8ca <main+0x6>

0000e8d4 <software_isr>:
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    e8d4:	ldr	r1, [pc, #104]	; (e940 <software_isr+0x6c>)
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    e8d6:	ldr	r2, [pc, #108]	; (e944 <software_isr+0x70>)
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    e8d8:	ldr	r0, [pc, #108]	; (e948 <software_isr+0x74>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    e8da:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    e8dc:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    e8de:	ldr	r5, [pc, #108]	; (e94c <software_isr+0x78>)
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    e8e0:	ldr	r4, [r0, #0]
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    e8e2:	orr.w	r3, r3, #16777216	; 0x1000000
    e8e6:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    e8e8:	ldr	r3, [r2, #0]
    e8ea:	orr.w	r3, r3, #1
    e8ee:	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    e8f0:	ldr	r6, [r5, #0]
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    e8f2:	cbnz	r4, e8fa <software_isr+0x26>
    e8f4:	b.n	e922 <software_isr+0x4e>
    e8f6:	ldr	r4, [r4, #20]
    e8f8:	cbz	r4, e922 <software_isr+0x4e>
		if (p->active) {
    e8fa:	ldrb	r3, [r4, #8]
    e8fc:	cmp	r3, #0
    e8fe:	beq.n	e8f6 <software_isr+0x22>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    e900:	ldr	r3, [r4, #0]
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    e902:	ldr	r7, [r5, #0]
			p->update();
    e904:	ldr	r3, [r3, #0]
    e906:	mov	r0, r4
    e908:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    e90a:	ldr	r3, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    e90c:	ldrh	r1, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    e90e:	subs	r3, r3, r7
    e910:	lsrs	r3, r3, #4
			p->cpu_cycles = cycles;
    e912:	uxth	r2, r3
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    e914:	cmp	r3, r1
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    e916:	strh	r2, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    e918:	it	hi
    e91a:	strhhi	r2, [r4, #6]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    e91c:	ldr	r4, [r4, #20]
    e91e:	cmp	r4, #0
    e920:	bne.n	e8fa <software_isr+0x26>
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    e922:	ldr	r3, [pc, #40]	; (e94c <software_isr+0x78>)
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    e924:	ldr	r2, [pc, #40]	; (e950 <software_isr+0x7c>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    e926:	ldr	r3, [r3, #0]
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    e928:	ldrh	r0, [r2, #0]
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    e92a:	ldr	r4, [pc, #40]	; (e954 <software_isr+0x80>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    e92c:	subs	r3, r3, r6
    e92e:	lsrs	r3, r3, #4
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    e930:	uxth	r1, r3
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    e932:	cmp	r3, r0
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    e934:	strh	r1, [r4, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    e936:	bls.n	e93c <software_isr+0x68>
		AudioStream::cpu_cycles_total_max = totalcycles;
    e938:	strh	r1, [r2, #0]
    e93a:	pop	{r3, r4, r5, r6, r7, pc}
    e93c:	pop	{r3, r4, r5, r6, r7, pc}
    e93e:	nop
    e940:	.word	0xe000edfc
    e944:	.word	0xe0001000
    e948:	.word	0x200031cc
    e94c:	.word	0xe0001004
    e950:	.word	0x200031d0
    e954:	.word	0x200031d2

0000e958 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    e958:	bx	lr
    e95a:	nop

0000e95c <operator new(unsigned int)>:
    e95c:	b.w	ff54 <malloc>

0000e960 <operator delete(void*, unsigned int)>:
    e960:	b.w	ff64 <free>

0000e964 <fmodf>:
    e964:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e968:	sub	sp, #44	; 0x2c
    e96a:	mov	r6, r0
    e96c:	mov	r4, r1
    e96e:	bl	ea20 <__ieee754_fmodf>
    e972:	ldr	r3, [pc, #164]	; (ea18 <fmodf+0xb4>)
    e974:	ldrsb.w	r7, [r3]
    e978:	adds	r3, r7, #1
    e97a:	mov	r5, r0
    e97c:	beq.n	e9e2 <fmodf+0x7e>
    e97e:	mov	r1, r4
    e980:	mov	r0, r4
    e982:	bl	fa9c <__aeabi_fcmpun>
    e986:	cbnz	r0, e9e2 <fmodf+0x7e>
    e988:	mov	r1, r6
    e98a:	mov	r0, r6
    e98c:	bl	fa9c <__aeabi_fcmpun>
    e990:	mov	r8, r0
    e992:	cbnz	r0, e9e2 <fmodf+0x7e>
    e994:	movs	r1, #0
    e996:	mov	r0, r4
    e998:	bl	fa38 <__aeabi_fcmpeq>
    e99c:	cbz	r0, e9e2 <fmodf+0x7e>
    e99e:	ldr	r3, [pc, #124]	; (ea1c <fmodf+0xb8>)
    e9a0:	str.w	r8, [sp, #32]
    e9a4:	movs	r2, #1
    e9a6:	mov	r0, r6
    e9a8:	stmia.w	sp, {r2, r3}
    e9ac:	bl	edfc <__aeabi_f2d>
    e9b0:	mov	r8, r0
    e9b2:	mov	r9, r1
    e9b4:	mov	r0, r4
    e9b6:	strd	r8, r9, [sp, #8]
    e9ba:	bl	edfc <__aeabi_f2d>
    e9be:	strd	r0, r1, [sp, #16]
    e9c2:	cbnz	r7, e9ea <fmodf+0x86>
    e9c4:	strd	r8, r9, [sp, #24]
    e9c8:	mov	r0, sp
    e9ca:	bl	eb24 <matherr>
    e9ce:	cbz	r0, e9fe <fmodf+0x9a>
    e9d0:	ldr	r3, [sp, #32]
    e9d2:	cbnz	r3, ea0c <fmodf+0xa8>
    e9d4:	ldrd	r0, r1, [sp, #24]
    e9d8:	bl	f454 <__aeabi_d2f>
    e9dc:	add	sp, #44	; 0x2c
    e9de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e9e2:	mov	r0, r5
    e9e4:	add	sp, #44	; 0x2c
    e9e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e9ea:	movs	r2, #0
    e9ec:	movs	r3, #0
    e9ee:	mov	r0, r2
    e9f0:	mov	r1, r3
    e9f2:	bl	f0f8 <__aeabi_ddiv>
    e9f6:	cmp	r7, #2
    e9f8:	strd	r0, r1, [sp, #24]
    e9fc:	bne.n	e9c8 <fmodf+0x64>
    e9fe:	bl	fef8 <__errno>
    ea02:	movs	r3, #33	; 0x21
    ea04:	str	r3, [r0, #0]
    ea06:	ldr	r3, [sp, #32]
    ea08:	cmp	r3, #0
    ea0a:	beq.n	e9d4 <fmodf+0x70>
    ea0c:	bl	fef8 <__errno>
    ea10:	ldr	r3, [sp, #32]
    ea12:	str	r3, [r0, #0]
    ea14:	b.n	e9d4 <fmodf+0x70>
    ea16:	nop
    ea18:	.word	0x1fff8d61
    ea1c:	.word	0x000148dc

0000ea20 <__ieee754_fmodf>:
    ea20:	push	{r4, r5, r6, lr}
    ea22:	bics.w	r6, r1, #2147483648	; 0x80000000
    ea26:	beq.n	ea9a <__ieee754_fmodf+0x7a>
    ea28:	mov	r2, r0
    ea2a:	and.w	r4, r0, #2147483648	; 0x80000000
    ea2e:	eors	r2, r4
    ea30:	cmp.w	r2, #2139095040	; 0x7f800000
    ea34:	bge.n	ea9a <__ieee754_fmodf+0x7a>
    ea36:	cmp.w	r6, #2139095040	; 0x7f800000
    ea3a:	bgt.n	ea9a <__ieee754_fmodf+0x7a>
    ea3c:	cmp	r2, r6
    ea3e:	blt.n	eaa6 <__ieee754_fmodf+0x86>
    ea40:	beq.n	eab0 <__ieee754_fmodf+0x90>
    ea42:	cmp.w	r2, #8388608	; 0x800000
    ea46:	mov	r3, r1
    ea48:	bge.n	eaba <__ieee754_fmodf+0x9a>
    ea4a:	lsls	r0, r2, #8
    ea4c:	cmp	r0, #0
    ea4e:	mvn.w	r1, #125	; 0x7d
    ea52:	ble.n	ea5e <__ieee754_fmodf+0x3e>
    ea54:	lsls	r0, r0, #1
    ea56:	cmp	r0, #0
    ea58:	add.w	r1, r1, #4294967295
    ea5c:	bgt.n	ea54 <__ieee754_fmodf+0x34>
    ea5e:	cmp.w	r6, #8388608	; 0x800000
    ea62:	blt.n	ead6 <__ieee754_fmodf+0xb6>
    ea64:	asrs	r5, r6, #23
    ea66:	subs	r5, #127	; 0x7f
    ea68:	cmn.w	r1, #126	; 0x7e
    ea6c:	blt.n	eacc <__ieee754_fmodf+0xac>
    ea6e:	ubfx	r2, r2, #0, #23
    ea72:	orr.w	r2, r2, #8388608	; 0x800000
    ea76:	cmn.w	r5, #126	; 0x7e
    ea7a:	blt.n	eac0 <__ieee754_fmodf+0xa0>
    ea7c:	ubfx	r3, r3, #0, #23
    ea80:	orr.w	r3, r3, #8388608	; 0x800000
    ea84:	subs	r1, r1, r5
    ea86:	b.n	ea8e <__ieee754_fmodf+0x6e>
    ea88:	beq.n	eab0 <__ieee754_fmodf+0x90>
    ea8a:	lsls	r2, r0, #1
    ea8c:	subs	r1, #1
    ea8e:	subs	r0, r2, r3
    ea90:	cbz	r1, eaa8 <__ieee754_fmodf+0x88>
    ea92:	cmp	r0, #0
    ea94:	bge.n	ea88 <__ieee754_fmodf+0x68>
    ea96:	lsls	r2, r2, #1
    ea98:	b.n	ea8c <__ieee754_fmodf+0x6c>
    ea9a:	bl	f710 <__aeabi_fmul>
    ea9e:	mov	r1, r0
    eaa0:	bl	f878 <__aeabi_fdiv>
    eaa4:	pop	{r4, r5, r6, pc}
    eaa6:	pop	{r4, r5, r6, pc}
    eaa8:	subs	r3, r2, r3
    eaaa:	it	mi
    eaac:	movmi	r3, r2
    eaae:	cbnz	r3, eae6 <__ieee754_fmodf+0xc6>
    eab0:	lsrs	r0, r4, #31
    eab2:	ldr	r2, [pc, #104]	; (eb1c <__ieee754_fmodf+0xfc>)
    eab4:	ldr.w	r0, [r2, r0, lsl #2]
    eab8:	pop	{r4, r5, r6, pc}
    eaba:	asrs	r1, r2, #23
    eabc:	subs	r1, #127	; 0x7f
    eabe:	b.n	ea5e <__ieee754_fmodf+0x3e>
    eac0:	mvn.w	r3, #125	; 0x7d
    eac4:	subs	r3, r3, r5
    eac6:	lsl.w	r3, r6, r3
    eaca:	b.n	ea84 <__ieee754_fmodf+0x64>
    eacc:	mvn.w	r0, #125	; 0x7d
    ead0:	subs	r0, r0, r1
    ead2:	lsls	r2, r0
    ead4:	b.n	ea76 <__ieee754_fmodf+0x56>
    ead6:	lsls	r0, r6, #8
    ead8:	mvn.w	r5, #125	; 0x7d
    eadc:	lsls	r0, r0, #1
    eade:	add.w	r5, r5, #4294967295
    eae2:	bpl.n	eadc <__ieee754_fmodf+0xbc>
    eae4:	b.n	ea68 <__ieee754_fmodf+0x48>
    eae6:	ldr	r2, [pc, #56]	; (eb20 <__ieee754_fmodf+0x100>)
    eae8:	cmp	r3, r2
    eaea:	bgt.n	eaf6 <__ieee754_fmodf+0xd6>
    eaec:	lsls	r3, r3, #1
    eaee:	cmp	r3, r2
    eaf0:	add.w	r5, r5, #4294967295
    eaf4:	ble.n	eaec <__ieee754_fmodf+0xcc>
    eaf6:	cmn.w	r5, #126	; 0x7e
    eafa:	bge.n	eb0a <__ieee754_fmodf+0xea>
    eafc:	mvn.w	r0, #125	; 0x7d
    eb00:	subs	r0, r0, r5
    eb02:	asrs	r3, r0
    eb04:	orr.w	r0, r3, r4
    eb08:	pop	{r4, r5, r6, pc}
    eb0a:	sub.w	r3, r3, #8388608	; 0x800000
    eb0e:	orrs	r3, r4
    eb10:	add.w	r0, r5, #127	; 0x7f
    eb14:	orr.w	r0, r3, r0, lsl #23
    eb18:	pop	{r4, r5, r6, pc}
    eb1a:	nop
    eb1c:	.word	0x000148e4
    eb20:	.word	0x007fffff

0000eb24 <matherr>:
    eb24:	movs	r0, #0
    eb26:	bx	lr

0000eb28 <__aeabi_atexit>:
    eb28:	mov	r3, r1
    eb2a:	mov	r1, r0
    eb2c:	mov	r0, r3
    eb2e:	b.w	fecc <__cxa_atexit>
    eb32:	nop

0000eb34 <__aeabi_drsub>:
    eb34:	eor.w	r1, r1, #2147483648	; 0x80000000
    eb38:	b.n	eb40 <__adddf3>
    eb3a:	nop

0000eb3c <__aeabi_dsub>:
    eb3c:	eor.w	r3, r3, #2147483648	; 0x80000000

0000eb40 <__adddf3>:
    eb40:	push	{r4, r5, lr}
    eb42:	mov.w	r4, r1, lsl #1
    eb46:	mov.w	r5, r3, lsl #1
    eb4a:	teq	r4, r5
    eb4e:	it	eq
    eb50:	teqeq	r0, r2
    eb54:	itttt	ne
    eb56:	orrsne.w	ip, r4, r0
    eb5a:	orrsne.w	ip, r5, r2
    eb5e:	mvnsne.w	ip, r4, asr #21
    eb62:	mvnsne.w	ip, r5, asr #21
    eb66:	beq.w	ed2e <__adddf3+0x1ee>
    eb6a:	mov.w	r4, r4, lsr #21
    eb6e:	rsbs	r5, r4, r5, lsr #21
    eb72:	it	lt
    eb74:	neglt	r5, r5
    eb76:	ble.n	eb92 <__adddf3+0x52>
    eb78:	add	r4, r5
    eb7a:	eor.w	r2, r0, r2
    eb7e:	eor.w	r3, r1, r3
    eb82:	eor.w	r0, r2, r0
    eb86:	eor.w	r1, r3, r1
    eb8a:	eor.w	r2, r0, r2
    eb8e:	eor.w	r3, r1, r3
    eb92:	cmp	r5, #54	; 0x36
    eb94:	it	hi
    eb96:	pophi	{r4, r5, pc}
    eb98:	tst.w	r1, #2147483648	; 0x80000000
    eb9c:	mov.w	r1, r1, lsl #12
    eba0:	mov.w	ip, #1048576	; 0x100000
    eba4:	orr.w	r1, ip, r1, lsr #12
    eba8:	beq.n	ebb0 <__adddf3+0x70>
    ebaa:	negs	r0, r0
    ebac:	sbc.w	r1, r1, r1, lsl #1
    ebb0:	tst.w	r3, #2147483648	; 0x80000000
    ebb4:	mov.w	r3, r3, lsl #12
    ebb8:	orr.w	r3, ip, r3, lsr #12
    ebbc:	beq.n	ebc4 <__adddf3+0x84>
    ebbe:	negs	r2, r2
    ebc0:	sbc.w	r3, r3, r3, lsl #1
    ebc4:	teq	r4, r5
    ebc8:	beq.w	ed1a <__adddf3+0x1da>
    ebcc:	sub.w	r4, r4, #1
    ebd0:	rsbs	lr, r5, #32
    ebd4:	blt.n	ebf2 <__adddf3+0xb2>
    ebd6:	lsl.w	ip, r2, lr
    ebda:	lsr.w	r2, r2, r5
    ebde:	adds	r0, r0, r2
    ebe0:	adc.w	r1, r1, #0
    ebe4:	lsl.w	r2, r3, lr
    ebe8:	adds	r0, r0, r2
    ebea:	asr.w	r3, r3, r5
    ebee:	adcs	r1, r3
    ebf0:	b.n	ec10 <__adddf3+0xd0>
    ebf2:	sub.w	r5, r5, #32
    ebf6:	add.w	lr, lr, #32
    ebfa:	cmp	r2, #1
    ebfc:	lsl.w	ip, r3, lr
    ec00:	it	cs
    ec02:	orrcs.w	ip, ip, #2
    ec06:	asr.w	r3, r3, r5
    ec0a:	adds	r0, r0, r3
    ec0c:	adcs.w	r1, r1, r3, asr #31
    ec10:	and.w	r5, r1, #2147483648	; 0x80000000
    ec14:	bpl.n	ec26 <__adddf3+0xe6>
    ec16:	mov.w	lr, #0
    ec1a:	rsbs	ip, ip, #0
    ec1e:	sbcs.w	r0, lr, r0
    ec22:	sbc.w	r1, lr, r1
    ec26:	cmp.w	r1, #1048576	; 0x100000
    ec2a:	bcc.n	ec64 <__adddf3+0x124>
    ec2c:	cmp.w	r1, #2097152	; 0x200000
    ec30:	bcc.n	ec4c <__adddf3+0x10c>
    ec32:	lsrs	r1, r1, #1
    ec34:	movs.w	r0, r0, rrx
    ec38:	mov.w	ip, ip, rrx
    ec3c:	add.w	r4, r4, #1
    ec40:	mov.w	r2, r4, lsl #21
    ec44:	cmn.w	r2, #4194304	; 0x400000
    ec48:	bcs.w	ed80 <__adddf3+0x240>
    ec4c:	cmp.w	ip, #2147483648	; 0x80000000
    ec50:	it	eq
    ec52:	movseq.w	ip, r0, lsr #1
    ec56:	adcs.w	r0, r0, #0
    ec5a:	adc.w	r1, r1, r4, lsl #20
    ec5e:	orr.w	r1, r1, r5
    ec62:	pop	{r4, r5, pc}
    ec64:	movs.w	ip, ip, lsl #1
    ec68:	adcs	r0, r0
    ec6a:	adc.w	r1, r1, r1
    ec6e:	tst.w	r1, #1048576	; 0x100000
    ec72:	sub.w	r4, r4, #1
    ec76:	bne.n	ec4c <__adddf3+0x10c>
    ec78:	teq	r1, #0
    ec7c:	itt	eq
    ec7e:	moveq	r1, r0
    ec80:	moveq	r0, #0
    ec82:	clz	r3, r1
    ec86:	it	eq
    ec88:	addeq	r3, #32
    ec8a:	sub.w	r3, r3, #11
    ec8e:	subs.w	r2, r3, #32
    ec92:	bge.n	ecae <__adddf3+0x16e>
    ec94:	adds	r2, #12
    ec96:	ble.n	ecaa <__adddf3+0x16a>
    ec98:	add.w	ip, r2, #20
    ec9c:	rsb	r2, r2, #12
    eca0:	lsl.w	r0, r1, ip
    eca4:	lsr.w	r1, r1, r2
    eca8:	b.n	ecc4 <__adddf3+0x184>
    ecaa:	add.w	r2, r2, #20
    ecae:	it	le
    ecb0:	rsble	ip, r2, #32
    ecb4:	lsl.w	r1, r1, r2
    ecb8:	lsr.w	ip, r0, ip
    ecbc:	itt	le
    ecbe:	orrle.w	r1, r1, ip
    ecc2:	lslle	r0, r2
    ecc4:	subs	r4, r4, r3
    ecc6:	ittt	ge
    ecc8:	addge.w	r1, r1, r4, lsl #20
    eccc:	orrge	r1, r5
    ecce:	popge	{r4, r5, pc}
    ecd0:	mvn.w	r4, r4
    ecd4:	subs	r4, #31
    ecd6:	bge.n	ed12 <__adddf3+0x1d2>
    ecd8:	adds	r4, #12
    ecda:	bgt.n	ecfa <__adddf3+0x1ba>
    ecdc:	add.w	r4, r4, #20
    ece0:	rsb	r2, r4, #32
    ece4:	lsr.w	r0, r0, r4
    ece8:	lsl.w	r3, r1, r2
    ecec:	orr.w	r0, r0, r3
    ecf0:	lsr.w	r3, r1, r4
    ecf4:	orr.w	r1, r5, r3
    ecf8:	pop	{r4, r5, pc}
    ecfa:	rsb	r4, r4, #12
    ecfe:	rsb	r2, r4, #32
    ed02:	lsr.w	r0, r0, r2
    ed06:	lsl.w	r3, r1, r4
    ed0a:	orr.w	r0, r0, r3
    ed0e:	mov	r1, r5
    ed10:	pop	{r4, r5, pc}
    ed12:	lsr.w	r0, r1, r4
    ed16:	mov	r1, r5
    ed18:	pop	{r4, r5, pc}
    ed1a:	teq	r4, #0
    ed1e:	eor.w	r3, r3, #1048576	; 0x100000
    ed22:	itte	eq
    ed24:	eoreq.w	r1, r1, #1048576	; 0x100000
    ed28:	addeq	r4, #1
    ed2a:	subne	r5, #1
    ed2c:	b.n	ebcc <__adddf3+0x8c>
    ed2e:	mvns.w	ip, r4, asr #21
    ed32:	it	ne
    ed34:	mvnsne.w	ip, r5, asr #21
    ed38:	beq.n	ed8e <__adddf3+0x24e>
    ed3a:	teq	r4, r5
    ed3e:	it	eq
    ed40:	teqeq	r0, r2
    ed44:	beq.n	ed52 <__adddf3+0x212>
    ed46:	orrs.w	ip, r4, r0
    ed4a:	itt	eq
    ed4c:	moveq	r1, r3
    ed4e:	moveq	r0, r2
    ed50:	pop	{r4, r5, pc}
    ed52:	teq	r1, r3
    ed56:	ittt	ne
    ed58:	movne	r1, #0
    ed5a:	movne	r0, #0
    ed5c:	popne	{r4, r5, pc}
    ed5e:	movs.w	ip, r4, lsr #21
    ed62:	bne.n	ed70 <__adddf3+0x230>
    ed64:	lsls	r0, r0, #1
    ed66:	adcs	r1, r1
    ed68:	it	cs
    ed6a:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    ed6e:	pop	{r4, r5, pc}
    ed70:	adds.w	r4, r4, #4194304	; 0x400000
    ed74:	itt	cc
    ed76:	addcc.w	r1, r1, #1048576	; 0x100000
    ed7a:	popcc	{r4, r5, pc}
    ed7c:	and.w	r5, r1, #2147483648	; 0x80000000
    ed80:	orr.w	r1, r5, #2130706432	; 0x7f000000
    ed84:	orr.w	r1, r1, #15728640	; 0xf00000
    ed88:	mov.w	r0, #0
    ed8c:	pop	{r4, r5, pc}
    ed8e:	mvns.w	ip, r4, asr #21
    ed92:	itte	ne
    ed94:	movne	r1, r3
    ed96:	movne	r0, r2
    ed98:	mvnseq.w	ip, r5, asr #21
    ed9c:	itt	ne
    ed9e:	movne	r3, r1
    eda0:	movne	r2, r0
    eda2:	orrs.w	r4, r0, r1, lsl #12
    eda6:	itte	eq
    eda8:	orrseq.w	r5, r2, r3, lsl #12
    edac:	teqeq	r1, r3
    edb0:	orrne.w	r1, r1, #524288	; 0x80000
    edb4:	pop	{r4, r5, pc}
    edb6:	nop

0000edb8 <__aeabi_ui2d>:
    edb8:	teq	r0, #0
    edbc:	itt	eq
    edbe:	moveq	r1, #0
    edc0:	bxeq	lr
    edc2:	push	{r4, r5, lr}
    edc4:	mov.w	r4, #1024	; 0x400
    edc8:	add.w	r4, r4, #50	; 0x32
    edcc:	mov.w	r5, #0
    edd0:	mov.w	r1, #0
    edd4:	b.n	ec78 <__adddf3+0x138>
    edd6:	nop

0000edd8 <__aeabi_i2d>:
    edd8:	teq	r0, #0
    eddc:	itt	eq
    edde:	moveq	r1, #0
    ede0:	bxeq	lr
    ede2:	push	{r4, r5, lr}
    ede4:	mov.w	r4, #1024	; 0x400
    ede8:	add.w	r4, r4, #50	; 0x32
    edec:	ands.w	r5, r0, #2147483648	; 0x80000000
    edf0:	it	mi
    edf2:	negmi	r0, r0
    edf4:	mov.w	r1, #0
    edf8:	b.n	ec78 <__adddf3+0x138>
    edfa:	nop

0000edfc <__aeabi_f2d>:
    edfc:	lsls	r2, r0, #1
    edfe:	mov.w	r1, r2, asr #3
    ee02:	mov.w	r1, r1, rrx
    ee06:	mov.w	r0, r2, lsl #28
    ee0a:	itttt	ne
    ee0c:	andsne.w	r3, r2, #4278190080	; 0xff000000
    ee10:	teqne	r3, #4278190080	; 0xff000000
    ee14:	eorne.w	r1, r1, #939524096	; 0x38000000
    ee18:	bxne	lr
    ee1a:	teq	r2, #0
    ee1e:	ite	ne
    ee20:	teqne	r3, #4278190080	; 0xff000000
    ee24:	bxeq	lr
    ee26:	push	{r4, r5, lr}
    ee28:	mov.w	r4, #896	; 0x380
    ee2c:	and.w	r5, r1, #2147483648	; 0x80000000
    ee30:	bic.w	r1, r1, #2147483648	; 0x80000000
    ee34:	b.n	ec78 <__adddf3+0x138>
    ee36:	nop

0000ee38 <__aeabi_ul2d>:
    ee38:	orrs.w	r2, r0, r1
    ee3c:	it	eq
    ee3e:	bxeq	lr
    ee40:	push	{r4, r5, lr}
    ee42:	mov.w	r5, #0
    ee46:	b.n	ee5e <__aeabi_l2d+0x16>

0000ee48 <__aeabi_l2d>:
    ee48:	orrs.w	r2, r0, r1
    ee4c:	it	eq
    ee4e:	bxeq	lr
    ee50:	push	{r4, r5, lr}
    ee52:	ands.w	r5, r1, #2147483648	; 0x80000000
    ee56:	bpl.n	ee5e <__aeabi_l2d+0x16>
    ee58:	negs	r0, r0
    ee5a:	sbc.w	r1, r1, r1, lsl #1
    ee5e:	mov.w	r4, #1024	; 0x400
    ee62:	add.w	r4, r4, #50	; 0x32
    ee66:	movs.w	ip, r1, lsr #22
    ee6a:	beq.w	ec26 <__adddf3+0xe6>
    ee6e:	mov.w	r2, #3
    ee72:	movs.w	ip, ip, lsr #3
    ee76:	it	ne
    ee78:	addne	r2, #3
    ee7a:	movs.w	ip, ip, lsr #3
    ee7e:	it	ne
    ee80:	addne	r2, #3
    ee82:	add.w	r2, r2, ip, lsr #3
    ee86:	rsb	r3, r2, #32
    ee8a:	lsl.w	ip, r0, r3
    ee8e:	lsr.w	r0, r0, r2
    ee92:	lsl.w	lr, r1, r3
    ee96:	orr.w	r0, r0, lr
    ee9a:	lsr.w	r1, r1, r2
    ee9e:	add	r4, r2
    eea0:	b.n	ec26 <__adddf3+0xe6>
    eea2:	nop

0000eea4 <__aeabi_dmul>:
    eea4:	push	{r4, r5, r6, lr}
    eea6:	mov.w	ip, #255	; 0xff
    eeaa:	orr.w	ip, ip, #1792	; 0x700
    eeae:	ands.w	r4, ip, r1, lsr #20
    eeb2:	ittte	ne
    eeb4:	andsne.w	r5, ip, r3, lsr #20
    eeb8:	teqne	r4, ip
    eebc:	teqne	r5, ip
    eec0:	bleq	f080 <__aeabi_dmul+0x1dc>
    eec4:	add	r4, r5
    eec6:	eor.w	r6, r1, r3
    eeca:	bic.w	r1, r1, ip, lsl #21
    eece:	bic.w	r3, r3, ip, lsl #21
    eed2:	orrs.w	r5, r0, r1, lsl #12
    eed6:	it	ne
    eed8:	orrsne.w	r5, r2, r3, lsl #12
    eedc:	orr.w	r1, r1, #1048576	; 0x100000
    eee0:	orr.w	r3, r3, #1048576	; 0x100000
    eee4:	beq.n	ef58 <__aeabi_dmul+0xb4>
    eee6:	umull	ip, lr, r0, r2
    eeea:	mov.w	r5, #0
    eeee:	umlal	lr, r5, r1, r2
    eef2:	and.w	r2, r6, #2147483648	; 0x80000000
    eef6:	umlal	lr, r5, r0, r3
    eefa:	mov.w	r6, #0
    eefe:	umlal	r5, r6, r1, r3
    ef02:	teq	ip, #0
    ef06:	it	ne
    ef08:	orrne.w	lr, lr, #1
    ef0c:	sub.w	r4, r4, #255	; 0xff
    ef10:	cmp.w	r6, #512	; 0x200
    ef14:	sbc.w	r4, r4, #768	; 0x300
    ef18:	bcs.n	ef24 <__aeabi_dmul+0x80>
    ef1a:	movs.w	lr, lr, lsl #1
    ef1e:	adcs	r5, r5
    ef20:	adc.w	r6, r6, r6
    ef24:	orr.w	r1, r2, r6, lsl #11
    ef28:	orr.w	r1, r1, r5, lsr #21
    ef2c:	mov.w	r0, r5, lsl #11
    ef30:	orr.w	r0, r0, lr, lsr #21
    ef34:	mov.w	lr, lr, lsl #11
    ef38:	subs.w	ip, r4, #253	; 0xfd
    ef3c:	it	hi
    ef3e:	cmphi.w	ip, #1792	; 0x700
    ef42:	bhi.n	ef82 <__aeabi_dmul+0xde>
    ef44:	cmp.w	lr, #2147483648	; 0x80000000
    ef48:	it	eq
    ef4a:	movseq.w	lr, r0, lsr #1
    ef4e:	adcs.w	r0, r0, #0
    ef52:	adc.w	r1, r1, r4, lsl #20
    ef56:	pop	{r4, r5, r6, pc}
    ef58:	and.w	r6, r6, #2147483648	; 0x80000000
    ef5c:	orr.w	r1, r6, r1
    ef60:	orr.w	r0, r0, r2
    ef64:	eor.w	r1, r1, r3
    ef68:	subs.w	r4, r4, ip, lsr #1
    ef6c:	ittt	gt
    ef6e:	rsbsgt	r5, r4, ip
    ef72:	orrgt.w	r1, r1, r4, lsl #20
    ef76:	popgt	{r4, r5, r6, pc}
    ef78:	orr.w	r1, r1, #1048576	; 0x100000
    ef7c:	mov.w	lr, #0
    ef80:	subs	r4, #1
    ef82:	bgt.w	f0dc <__aeabi_dmul+0x238>
    ef86:	cmn.w	r4, #54	; 0x36
    ef8a:	ittt	le
    ef8c:	movle	r0, #0
    ef8e:	andle.w	r1, r1, #2147483648	; 0x80000000
    ef92:	pople	{r4, r5, r6, pc}
    ef94:	rsb	r4, r4, #0
    ef98:	subs	r4, #32
    ef9a:	bge.n	f008 <__aeabi_dmul+0x164>
    ef9c:	adds	r4, #12
    ef9e:	bgt.n	efd8 <__aeabi_dmul+0x134>
    efa0:	add.w	r4, r4, #20
    efa4:	rsb	r5, r4, #32
    efa8:	lsl.w	r3, r0, r5
    efac:	lsr.w	r0, r0, r4
    efb0:	lsl.w	r2, r1, r5
    efb4:	orr.w	r0, r0, r2
    efb8:	and.w	r2, r1, #2147483648	; 0x80000000
    efbc:	bic.w	r1, r1, #2147483648	; 0x80000000
    efc0:	adds.w	r0, r0, r3, lsr #31
    efc4:	lsr.w	r6, r1, r4
    efc8:	adc.w	r1, r2, r6
    efcc:	orrs.w	lr, lr, r3, lsl #1
    efd0:	it	eq
    efd2:	biceq.w	r0, r0, r3, lsr #31
    efd6:	pop	{r4, r5, r6, pc}
    efd8:	rsb	r4, r4, #12
    efdc:	rsb	r5, r4, #32
    efe0:	lsl.w	r3, r0, r4
    efe4:	lsr.w	r0, r0, r5
    efe8:	lsl.w	r2, r1, r4
    efec:	orr.w	r0, r0, r2
    eff0:	and.w	r1, r1, #2147483648	; 0x80000000
    eff4:	adds.w	r0, r0, r3, lsr #31
    eff8:	adc.w	r1, r1, #0
    effc:	orrs.w	lr, lr, r3, lsl #1
    f000:	it	eq
    f002:	biceq.w	r0, r0, r3, lsr #31
    f006:	pop	{r4, r5, r6, pc}
    f008:	rsb	r5, r4, #32
    f00c:	lsl.w	r2, r0, r5
    f010:	orr.w	lr, lr, r2
    f014:	lsr.w	r3, r0, r4
    f018:	lsl.w	r2, r1, r5
    f01c:	orr.w	r3, r3, r2
    f020:	lsr.w	r0, r1, r4
    f024:	and.w	r1, r1, #2147483648	; 0x80000000
    f028:	lsr.w	r2, r1, r4
    f02c:	bic.w	r0, r0, r2
    f030:	add.w	r0, r0, r3, lsr #31
    f034:	orrs.w	lr, lr, r3, lsl #1
    f038:	it	eq
    f03a:	biceq.w	r0, r0, r3, lsr #31
    f03e:	pop	{r4, r5, r6, pc}
    f040:	teq	r4, #0
    f044:	bne.n	f066 <__aeabi_dmul+0x1c2>
    f046:	and.w	r6, r1, #2147483648	; 0x80000000
    f04a:	lsls	r0, r0, #1
    f04c:	adc.w	r1, r1, r1
    f050:	tst.w	r1, #1048576	; 0x100000
    f054:	it	eq
    f056:	subeq	r4, #1
    f058:	beq.n	f04a <__aeabi_dmul+0x1a6>
    f05a:	orr.w	r1, r1, r6
    f05e:	teq	r5, #0
    f062:	it	ne
    f064:	bxne	lr
    f066:	and.w	r6, r3, #2147483648	; 0x80000000
    f06a:	lsls	r2, r2, #1
    f06c:	adc.w	r3, r3, r3
    f070:	tst.w	r3, #1048576	; 0x100000
    f074:	it	eq
    f076:	subeq	r5, #1
    f078:	beq.n	f06a <__aeabi_dmul+0x1c6>
    f07a:	orr.w	r3, r3, r6
    f07e:	bx	lr
    f080:	teq	r4, ip
    f084:	and.w	r5, ip, r3, lsr #20
    f088:	it	ne
    f08a:	teqne	r5, ip
    f08e:	beq.n	f0aa <__aeabi_dmul+0x206>
    f090:	orrs.w	r6, r0, r1, lsl #1
    f094:	it	ne
    f096:	orrsne.w	r6, r2, r3, lsl #1
    f09a:	bne.n	f040 <__aeabi_dmul+0x19c>
    f09c:	eor.w	r1, r1, r3
    f0a0:	and.w	r1, r1, #2147483648	; 0x80000000
    f0a4:	mov.w	r0, #0
    f0a8:	pop	{r4, r5, r6, pc}
    f0aa:	orrs.w	r6, r0, r1, lsl #1
    f0ae:	itte	eq
    f0b0:	moveq	r0, r2
    f0b2:	moveq	r1, r3
    f0b4:	orrsne.w	r6, r2, r3, lsl #1
    f0b8:	beq.n	f0ee <__aeabi_dmul+0x24a>
    f0ba:	teq	r4, ip
    f0be:	bne.n	f0c6 <__aeabi_dmul+0x222>
    f0c0:	orrs.w	r6, r0, r1, lsl #12
    f0c4:	bne.n	f0ee <__aeabi_dmul+0x24a>
    f0c6:	teq	r5, ip
    f0ca:	bne.n	f0d8 <__aeabi_dmul+0x234>
    f0cc:	orrs.w	r6, r2, r3, lsl #12
    f0d0:	itt	ne
    f0d2:	movne	r0, r2
    f0d4:	movne	r1, r3
    f0d6:	bne.n	f0ee <__aeabi_dmul+0x24a>
    f0d8:	eor.w	r1, r1, r3
    f0dc:	and.w	r1, r1, #2147483648	; 0x80000000
    f0e0:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f0e4:	orr.w	r1, r1, #15728640	; 0xf00000
    f0e8:	mov.w	r0, #0
    f0ec:	pop	{r4, r5, r6, pc}
    f0ee:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f0f2:	orr.w	r1, r1, #16252928	; 0xf80000
    f0f6:	pop	{r4, r5, r6, pc}

0000f0f8 <__aeabi_ddiv>:
    f0f8:	push	{r4, r5, r6, lr}
    f0fa:	mov.w	ip, #255	; 0xff
    f0fe:	orr.w	ip, ip, #1792	; 0x700
    f102:	ands.w	r4, ip, r1, lsr #20
    f106:	ittte	ne
    f108:	andsne.w	r5, ip, r3, lsr #20
    f10c:	teqne	r4, ip
    f110:	teqne	r5, ip
    f114:	bleq	f266 <__aeabi_ddiv+0x16e>
    f118:	sub.w	r4, r4, r5
    f11c:	eor.w	lr, r1, r3
    f120:	orrs.w	r5, r2, r3, lsl #12
    f124:	mov.w	r1, r1, lsl #12
    f128:	beq.w	f23c <__aeabi_ddiv+0x144>
    f12c:	mov.w	r3, r3, lsl #12
    f130:	mov.w	r5, #268435456	; 0x10000000
    f134:	orr.w	r3, r5, r3, lsr #4
    f138:	orr.w	r3, r3, r2, lsr #24
    f13c:	mov.w	r2, r2, lsl #8
    f140:	orr.w	r5, r5, r1, lsr #4
    f144:	orr.w	r5, r5, r0, lsr #24
    f148:	mov.w	r6, r0, lsl #8
    f14c:	and.w	r1, lr, #2147483648	; 0x80000000
    f150:	cmp	r5, r3
    f152:	it	eq
    f154:	cmpeq	r6, r2
    f156:	adc.w	r4, r4, #253	; 0xfd
    f15a:	add.w	r4, r4, #768	; 0x300
    f15e:	bcs.n	f166 <__aeabi_ddiv+0x6e>
    f160:	lsrs	r3, r3, #1
    f162:	mov.w	r2, r2, rrx
    f166:	subs	r6, r6, r2
    f168:	sbc.w	r5, r5, r3
    f16c:	lsrs	r3, r3, #1
    f16e:	mov.w	r2, r2, rrx
    f172:	mov.w	r0, #1048576	; 0x100000
    f176:	mov.w	ip, #524288	; 0x80000
    f17a:	subs.w	lr, r6, r2
    f17e:	sbcs.w	lr, r5, r3
    f182:	ittt	cs
    f184:	subcs	r6, r6, r2
    f186:	movcs	r5, lr
    f188:	orrcs.w	r0, r0, ip
    f18c:	lsrs	r3, r3, #1
    f18e:	mov.w	r2, r2, rrx
    f192:	subs.w	lr, r6, r2
    f196:	sbcs.w	lr, r5, r3
    f19a:	ittt	cs
    f19c:	subcs	r6, r6, r2
    f19e:	movcs	r5, lr
    f1a0:	orrcs.w	r0, r0, ip, lsr #1
    f1a4:	lsrs	r3, r3, #1
    f1a6:	mov.w	r2, r2, rrx
    f1aa:	subs.w	lr, r6, r2
    f1ae:	sbcs.w	lr, r5, r3
    f1b2:	ittt	cs
    f1b4:	subcs	r6, r6, r2
    f1b6:	movcs	r5, lr
    f1b8:	orrcs.w	r0, r0, ip, lsr #2
    f1bc:	lsrs	r3, r3, #1
    f1be:	mov.w	r2, r2, rrx
    f1c2:	subs.w	lr, r6, r2
    f1c6:	sbcs.w	lr, r5, r3
    f1ca:	ittt	cs
    f1cc:	subcs	r6, r6, r2
    f1ce:	movcs	r5, lr
    f1d0:	orrcs.w	r0, r0, ip, lsr #3
    f1d4:	orrs.w	lr, r5, r6
    f1d8:	beq.n	f20c <__aeabi_ddiv+0x114>
    f1da:	mov.w	r5, r5, lsl #4
    f1de:	orr.w	r5, r5, r6, lsr #28
    f1e2:	mov.w	r6, r6, lsl #4
    f1e6:	mov.w	r3, r3, lsl #3
    f1ea:	orr.w	r3, r3, r2, lsr #29
    f1ee:	mov.w	r2, r2, lsl #3
    f1f2:	movs.w	ip, ip, lsr #4
    f1f6:	bne.n	f17a <__aeabi_ddiv+0x82>
    f1f8:	tst.w	r1, #1048576	; 0x100000
    f1fc:	bne.n	f216 <__aeabi_ddiv+0x11e>
    f1fe:	orr.w	r1, r1, r0
    f202:	mov.w	r0, #0
    f206:	mov.w	ip, #2147483648	; 0x80000000
    f20a:	b.n	f17a <__aeabi_ddiv+0x82>
    f20c:	tst.w	r1, #1048576	; 0x100000
    f210:	itt	eq
    f212:	orreq	r1, r0
    f214:	moveq	r0, #0
    f216:	subs.w	ip, r4, #253	; 0xfd
    f21a:	it	hi
    f21c:	cmphi.w	ip, #1792	; 0x700
    f220:	bhi.w	ef82 <__aeabi_dmul+0xde>
    f224:	subs.w	ip, r5, r3
    f228:	itt	eq
    f22a:	subseq.w	ip, r6, r2
    f22e:	movseq.w	ip, r0, lsr #1
    f232:	adcs.w	r0, r0, #0
    f236:	adc.w	r1, r1, r4, lsl #20
    f23a:	pop	{r4, r5, r6, pc}
    f23c:	and.w	lr, lr, #2147483648	; 0x80000000
    f240:	orr.w	r1, lr, r1, lsr #12
    f244:	adds.w	r4, r4, ip, lsr #1
    f248:	ittt	gt
    f24a:	rsbsgt	r5, r4, ip
    f24e:	orrgt.w	r1, r1, r4, lsl #20
    f252:	popgt	{r4, r5, r6, pc}
    f254:	orr.w	r1, r1, #1048576	; 0x100000
    f258:	mov.w	lr, #0
    f25c:	subs	r4, #1
    f25e:	b.n	ef82 <__aeabi_dmul+0xde>
    f260:	orr.w	lr, r5, r6
    f264:	b.n	ef82 <__aeabi_dmul+0xde>
    f266:	and.w	r5, ip, r3, lsr #20
    f26a:	teq	r4, ip
    f26e:	it	eq
    f270:	teqeq	r5, ip
    f274:	beq.w	f0ee <__aeabi_dmul+0x24a>
    f278:	teq	r4, ip
    f27c:	bne.n	f294 <__aeabi_ddiv+0x19c>
    f27e:	orrs.w	r4, r0, r1, lsl #12
    f282:	bne.w	f0ee <__aeabi_dmul+0x24a>
    f286:	teq	r5, ip
    f28a:	bne.w	f0d8 <__aeabi_dmul+0x234>
    f28e:	mov	r0, r2
    f290:	mov	r1, r3
    f292:	b.n	f0ee <__aeabi_dmul+0x24a>
    f294:	teq	r5, ip
    f298:	bne.n	f2a8 <__aeabi_ddiv+0x1b0>
    f29a:	orrs.w	r5, r2, r3, lsl #12
    f29e:	beq.w	f09c <__aeabi_dmul+0x1f8>
    f2a2:	mov	r0, r2
    f2a4:	mov	r1, r3
    f2a6:	b.n	f0ee <__aeabi_dmul+0x24a>
    f2a8:	orrs.w	r6, r0, r1, lsl #1
    f2ac:	it	ne
    f2ae:	orrsne.w	r6, r2, r3, lsl #1
    f2b2:	bne.w	f040 <__aeabi_dmul+0x19c>
    f2b6:	orrs.w	r4, r0, r1, lsl #1
    f2ba:	bne.w	f0d8 <__aeabi_dmul+0x234>
    f2be:	orrs.w	r5, r2, r3, lsl #1
    f2c2:	bne.w	f09c <__aeabi_dmul+0x1f8>
    f2c6:	b.n	f0ee <__aeabi_dmul+0x24a>

0000f2c8 <__gedf2>:
    f2c8:	mov.w	ip, #4294967295
    f2cc:	b.n	f2dc <__cmpdf2+0x4>
    f2ce:	nop

0000f2d0 <__ledf2>:
    f2d0:	mov.w	ip, #1
    f2d4:	b.n	f2dc <__cmpdf2+0x4>
    f2d6:	nop

0000f2d8 <__cmpdf2>:
    f2d8:	mov.w	ip, #1
    f2dc:	str.w	ip, [sp, #-4]!
    f2e0:	mov.w	ip, r1, lsl #1
    f2e4:	mvns.w	ip, ip, asr #21
    f2e8:	mov.w	ip, r3, lsl #1
    f2ec:	it	ne
    f2ee:	mvnsne.w	ip, ip, asr #21
    f2f2:	beq.n	f32c <__cmpdf2+0x54>
    f2f4:	add	sp, #4
    f2f6:	orrs.w	ip, r0, r1, lsl #1
    f2fa:	ite	eq
    f2fc:	orrseq.w	ip, r2, r3, lsl #1
    f300:	teqne	r1, r3
    f304:	ittt	eq
    f306:	teqeq	r0, r2
    f30a:	moveq	r0, #0
    f30c:	bxeq	lr
    f30e:	cmn.w	r0, #0
    f312:	teq	r1, r3
    f316:	it	pl
    f318:	cmppl	r1, r3
    f31a:	it	eq
    f31c:	cmpeq	r0, r2
    f31e:	ite	cs
    f320:	asrcs	r0, r3, #31
    f322:	mvncc.w	r0, r3, asr #31
    f326:	orr.w	r0, r0, #1
    f32a:	bx	lr
    f32c:	mov.w	ip, r1, lsl #1
    f330:	mvns.w	ip, ip, asr #21
    f334:	bne.n	f33c <__cmpdf2+0x64>
    f336:	orrs.w	ip, r0, r1, lsl #12
    f33a:	bne.n	f34c <__cmpdf2+0x74>
    f33c:	mov.w	ip, r3, lsl #1
    f340:	mvns.w	ip, ip, asr #21
    f344:	bne.n	f2f4 <__cmpdf2+0x1c>
    f346:	orrs.w	ip, r2, r3, lsl #12
    f34a:	beq.n	f2f4 <__cmpdf2+0x1c>
    f34c:	ldr.w	r0, [sp], #4
    f350:	bx	lr
    f352:	nop

0000f354 <__aeabi_cdrcmple>:
    f354:	mov	ip, r0
    f356:	mov	r0, r2
    f358:	mov	r2, ip
    f35a:	mov	ip, r1
    f35c:	mov	r1, r3
    f35e:	mov	r3, ip
    f360:	b.n	f364 <__aeabi_cdcmpeq>
    f362:	nop

0000f364 <__aeabi_cdcmpeq>:
    f364:	push	{r0, lr}
    f366:	bl	f2d8 <__cmpdf2>
    f36a:	cmp	r0, #0
    f36c:	it	mi
    f36e:	cmnmi.w	r0, #0
    f372:	pop	{r0, pc}

0000f374 <__aeabi_dcmpeq>:
    f374:	str.w	lr, [sp, #-8]!
    f378:	bl	f364 <__aeabi_cdcmpeq>
    f37c:	ite	eq
    f37e:	moveq	r0, #1
    f380:	movne	r0, #0
    f382:	ldr.w	pc, [sp], #8
    f386:	nop

0000f388 <__aeabi_dcmplt>:
    f388:	str.w	lr, [sp, #-8]!
    f38c:	bl	f364 <__aeabi_cdcmpeq>
    f390:	ite	cc
    f392:	movcc	r0, #1
    f394:	movcs	r0, #0
    f396:	ldr.w	pc, [sp], #8
    f39a:	nop

0000f39c <__aeabi_dcmple>:
    f39c:	str.w	lr, [sp, #-8]!
    f3a0:	bl	f364 <__aeabi_cdcmpeq>
    f3a4:	ite	ls
    f3a6:	movls	r0, #1
    f3a8:	movhi	r0, #0
    f3aa:	ldr.w	pc, [sp], #8
    f3ae:	nop

0000f3b0 <__aeabi_dcmpge>:
    f3b0:	str.w	lr, [sp, #-8]!
    f3b4:	bl	f354 <__aeabi_cdrcmple>
    f3b8:	ite	ls
    f3ba:	movls	r0, #1
    f3bc:	movhi	r0, #0
    f3be:	ldr.w	pc, [sp], #8
    f3c2:	nop

0000f3c4 <__aeabi_dcmpgt>:
    f3c4:	str.w	lr, [sp, #-8]!
    f3c8:	bl	f354 <__aeabi_cdrcmple>
    f3cc:	ite	cc
    f3ce:	movcc	r0, #1
    f3d0:	movcs	r0, #0
    f3d2:	ldr.w	pc, [sp], #8
    f3d6:	nop

0000f3d8 <__aeabi_dcmpun>:
    f3d8:	mov.w	ip, r1, lsl #1
    f3dc:	mvns.w	ip, ip, asr #21
    f3e0:	bne.n	f3e8 <__aeabi_dcmpun+0x10>
    f3e2:	orrs.w	ip, r0, r1, lsl #12
    f3e6:	bne.n	f3fe <__aeabi_dcmpun+0x26>
    f3e8:	mov.w	ip, r3, lsl #1
    f3ec:	mvns.w	ip, ip, asr #21
    f3f0:	bne.n	f3f8 <__aeabi_dcmpun+0x20>
    f3f2:	orrs.w	ip, r2, r3, lsl #12
    f3f6:	bne.n	f3fe <__aeabi_dcmpun+0x26>
    f3f8:	mov.w	r0, #0
    f3fc:	bx	lr
    f3fe:	mov.w	r0, #1
    f402:	bx	lr

0000f404 <__aeabi_d2iz>:
    f404:	mov.w	r2, r1, lsl #1
    f408:	adds.w	r2, r2, #2097152	; 0x200000
    f40c:	bcs.n	f43a <__aeabi_d2iz+0x36>
    f40e:	bpl.n	f434 <__aeabi_d2iz+0x30>
    f410:	mvn.w	r3, #992	; 0x3e0
    f414:	subs.w	r2, r3, r2, asr #21
    f418:	bls.n	f440 <__aeabi_d2iz+0x3c>
    f41a:	mov.w	r3, r1, lsl #11
    f41e:	orr.w	r3, r3, #2147483648	; 0x80000000
    f422:	orr.w	r3, r3, r0, lsr #21
    f426:	tst.w	r1, #2147483648	; 0x80000000
    f42a:	lsr.w	r0, r3, r2
    f42e:	it	ne
    f430:	negne	r0, r0
    f432:	bx	lr
    f434:	mov.w	r0, #0
    f438:	bx	lr
    f43a:	orrs.w	r0, r0, r1, lsl #12
    f43e:	bne.n	f44c <__aeabi_d2iz+0x48>
    f440:	ands.w	r0, r1, #2147483648	; 0x80000000
    f444:	it	eq
    f446:	mvneq.w	r0, #2147483648	; 0x80000000
    f44a:	bx	lr
    f44c:	mov.w	r0, #0
    f450:	bx	lr
    f452:	nop

0000f454 <__aeabi_d2f>:
    f454:	mov.w	r2, r1, lsl #1
    f458:	subs.w	r3, r2, #1879048192	; 0x70000000
    f45c:	itt	cs
    f45e:	subscs.w	ip, r3, #2097152	; 0x200000
    f462:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    f466:	bls.n	f484 <__aeabi_d2f+0x30>
    f468:	and.w	ip, r1, #2147483648	; 0x80000000
    f46c:	mov.w	r2, r0, lsl #3
    f470:	orr.w	r0, ip, r0, lsr #29
    f474:	cmp.w	r2, #2147483648	; 0x80000000
    f478:	adc.w	r0, r0, r3, lsl #2
    f47c:	it	eq
    f47e:	biceq.w	r0, r0, #1
    f482:	bx	lr
    f484:	tst.w	r1, #1073741824	; 0x40000000
    f488:	bne.n	f4ce <__aeabi_d2f+0x7a>
    f48a:	adds.w	r2, r3, #48234496	; 0x2e00000
    f48e:	itt	lt
    f490:	andlt.w	r0, r1, #2147483648	; 0x80000000
    f494:	bxlt	lr
    f496:	orr.w	r1, r1, #1048576	; 0x100000
    f49a:	mov.w	r2, r2, lsr #21
    f49e:	rsb	r2, r2, #24
    f4a2:	rsb	ip, r2, #32
    f4a6:	lsls.w	r3, r0, ip
    f4aa:	lsr.w	r0, r0, r2
    f4ae:	it	ne
    f4b0:	orrne.w	r0, r0, #1
    f4b4:	mov.w	r3, r1, lsl #11
    f4b8:	mov.w	r3, r3, lsr #11
    f4bc:	lsl.w	ip, r3, ip
    f4c0:	orr.w	r0, r0, ip
    f4c4:	lsr.w	r3, r3, r2
    f4c8:	mov.w	r3, r3, lsl #1
    f4cc:	b.n	f468 <__aeabi_d2f+0x14>
    f4ce:	mvns.w	r3, r2, asr #21
    f4d2:	bne.n	f4e4 <__aeabi_d2f+0x90>
    f4d4:	orrs.w	r3, r0, r1, lsl #12
    f4d8:	ittt	ne
    f4da:	movne.w	r0, #2130706432	; 0x7f000000
    f4de:	orrne.w	r0, r0, #12582912	; 0xc00000
    f4e2:	bxne	lr
    f4e4:	and.w	r0, r1, #2147483648	; 0x80000000
    f4e8:	orr.w	r0, r0, #2130706432	; 0x7f000000
    f4ec:	orr.w	r0, r0, #8388608	; 0x800000
    f4f0:	bx	lr
    f4f2:	nop

0000f4f4 <__aeabi_frsub>:
    f4f4:	eor.w	r0, r0, #2147483648	; 0x80000000
    f4f8:	b.n	f500 <__addsf3>
    f4fa:	nop

0000f4fc <__aeabi_fsub>:
    f4fc:	eor.w	r1, r1, #2147483648	; 0x80000000

0000f500 <__addsf3>:
    f500:	lsls	r2, r0, #1
    f502:	itttt	ne
    f504:	movsne.w	r3, r1, lsl #1
    f508:	teqne	r2, r3
    f50c:	mvnsne.w	ip, r2, asr #24
    f510:	mvnsne.w	ip, r3, asr #24
    f514:	beq.n	f5ec <__addsf3+0xec>
    f516:	mov.w	r2, r2, lsr #24
    f51a:	rsbs	r3, r2, r3, lsr #24
    f51e:	itttt	gt
    f520:	addgt	r2, r2, r3
    f522:	eorgt	r1, r0
    f524:	eorgt	r0, r1
    f526:	eorgt	r1, r0
    f528:	it	lt
    f52a:	neglt	r3, r3
    f52c:	cmp	r3, #25
    f52e:	it	hi
    f530:	bxhi	lr
    f532:	tst.w	r0, #2147483648	; 0x80000000
    f536:	orr.w	r0, r0, #8388608	; 0x800000
    f53a:	bic.w	r0, r0, #4278190080	; 0xff000000
    f53e:	it	ne
    f540:	negne	r0, r0
    f542:	tst.w	r1, #2147483648	; 0x80000000
    f546:	orr.w	r1, r1, #8388608	; 0x800000
    f54a:	bic.w	r1, r1, #4278190080	; 0xff000000
    f54e:	it	ne
    f550:	negne	r1, r1
    f552:	teq	r2, r3
    f556:	beq.n	f5d8 <__addsf3+0xd8>
    f558:	sub.w	r2, r2, #1
    f55c:	asr.w	ip, r1, r3
    f560:	adds.w	r0, r0, ip
    f564:	rsb	r3, r3, #32
    f568:	lsl.w	r1, r1, r3
    f56c:	and.w	r3, r0, #2147483648	; 0x80000000
    f570:	bpl.n	f578 <__addsf3+0x78>
    f572:	negs	r1, r1
    f574:	sbc.w	r0, r0, r0, lsl #1
    f578:	cmp.w	r0, #8388608	; 0x800000
    f57c:	bcc.n	f5a6 <__addsf3+0xa6>
    f57e:	cmp.w	r0, #16777216	; 0x1000000
    f582:	bcc.n	f592 <__addsf3+0x92>
    f584:	lsrs	r0, r0, #1
    f586:	mov.w	r1, r1, rrx
    f58a:	add.w	r2, r2, #1
    f58e:	cmp	r2, #254	; 0xfe
    f590:	bcs.n	f636 <__addsf3+0x136>
    f592:	cmp.w	r1, #2147483648	; 0x80000000
    f596:	adc.w	r0, r0, r2, lsl #23
    f59a:	it	eq
    f59c:	biceq.w	r0, r0, #1
    f5a0:	orr.w	r0, r0, r3
    f5a4:	bx	lr
    f5a6:	lsls	r1, r1, #1
    f5a8:	adc.w	r0, r0, r0
    f5ac:	tst.w	r0, #8388608	; 0x800000
    f5b0:	sub.w	r2, r2, #1
    f5b4:	bne.n	f592 <__addsf3+0x92>
    f5b6:	clz	ip, r0
    f5ba:	sub.w	ip, ip, #8
    f5be:	subs.w	r2, r2, ip
    f5c2:	lsl.w	r0, r0, ip
    f5c6:	itet	ge
    f5c8:	addge.w	r0, r0, r2, lsl #23
    f5cc:	neglt	r2, r2
    f5ce:	orrge	r0, r3
    f5d0:	itt	lt
    f5d2:	lsrlt	r0, r2
    f5d4:	orrlt	r0, r3
    f5d6:	bx	lr
    f5d8:	teq	r2, #0
    f5dc:	eor.w	r1, r1, #8388608	; 0x800000
    f5e0:	itte	eq
    f5e2:	eoreq.w	r0, r0, #8388608	; 0x800000
    f5e6:	addeq	r2, #1
    f5e8:	subne	r3, #1
    f5ea:	b.n	f558 <__addsf3+0x58>
    f5ec:	mov.w	r3, r1, lsl #1
    f5f0:	mvns.w	ip, r2, asr #24
    f5f4:	it	ne
    f5f6:	mvnsne.w	ip, r3, asr #24
    f5fa:	beq.n	f640 <__addsf3+0x140>
    f5fc:	teq	r2, r3
    f600:	beq.n	f60c <__addsf3+0x10c>
    f602:	teq	r2, #0
    f606:	it	eq
    f608:	moveq	r0, r1
    f60a:	bx	lr
    f60c:	teq	r0, r1
    f610:	itt	ne
    f612:	movne	r0, #0
    f614:	bxne	lr
    f616:	tst.w	r2, #4278190080	; 0xff000000
    f61a:	bne.n	f626 <__addsf3+0x126>
    f61c:	lsls	r0, r0, #1
    f61e:	it	cs
    f620:	orrcs.w	r0, r0, #2147483648	; 0x80000000
    f624:	bx	lr
    f626:	adds.w	r2, r2, #33554432	; 0x2000000
    f62a:	itt	cc
    f62c:	addcc.w	r0, r0, #8388608	; 0x800000
    f630:	bxcc	lr
    f632:	and.w	r3, r0, #2147483648	; 0x80000000
    f636:	orr.w	r0, r3, #2130706432	; 0x7f000000
    f63a:	orr.w	r0, r0, #8388608	; 0x800000
    f63e:	bx	lr
    f640:	mvns.w	r2, r2, asr #24
    f644:	itet	ne
    f646:	movne	r0, r1
    f648:	mvnseq.w	r3, r3, asr #24
    f64c:	movne	r1, r0
    f64e:	lsls	r2, r0, #9
    f650:	itte	eq
    f652:	movseq.w	r3, r1, lsl #9
    f656:	teqeq	r0, r1
    f65a:	orrne.w	r0, r0, #4194304	; 0x400000
    f65e:	bx	lr

0000f660 <__aeabi_ui2f>:
    f660:	mov.w	r3, #0
    f664:	b.n	f670 <__aeabi_i2f+0x8>
    f666:	nop

0000f668 <__aeabi_i2f>:
    f668:	ands.w	r3, r0, #2147483648	; 0x80000000
    f66c:	it	mi
    f66e:	negmi	r0, r0
    f670:	movs.w	ip, r0
    f674:	it	eq
    f676:	bxeq	lr
    f678:	orr.w	r3, r3, #1258291200	; 0x4b000000
    f67c:	mov	r1, r0
    f67e:	mov.w	r0, #0
    f682:	b.n	f6be <__aeabi_l2f+0x2a>

0000f684 <__aeabi_ul2f>:
    f684:	orrs.w	r2, r0, r1
    f688:	it	eq
    f68a:	bxeq	lr
    f68c:	mov.w	r3, #0
    f690:	b.n	f6a8 <__aeabi_l2f+0x14>
    f692:	nop

0000f694 <__aeabi_l2f>:
    f694:	orrs.w	r2, r0, r1
    f698:	it	eq
    f69a:	bxeq	lr
    f69c:	ands.w	r3, r1, #2147483648	; 0x80000000
    f6a0:	bpl.n	f6a8 <__aeabi_l2f+0x14>
    f6a2:	negs	r0, r0
    f6a4:	sbc.w	r1, r1, r1, lsl #1
    f6a8:	movs.w	ip, r1
    f6ac:	ittt	eq
    f6ae:	moveq	ip, r0
    f6b0:	moveq	r1, r0
    f6b2:	moveq	r0, #0
    f6b4:	orr.w	r3, r3, #1526726656	; 0x5b000000
    f6b8:	it	eq
    f6ba:	subeq.w	r3, r3, #268435456	; 0x10000000
    f6be:	sub.w	r3, r3, #8388608	; 0x800000
    f6c2:	clz	r2, ip
    f6c6:	subs	r2, #8
    f6c8:	sub.w	r3, r3, r2, lsl #23
    f6cc:	blt.n	f6f0 <__aeabi_l2f+0x5c>
    f6ce:	lsl.w	ip, r1, r2
    f6d2:	add	r3, ip
    f6d4:	lsl.w	ip, r0, r2
    f6d8:	rsb	r2, r2, #32
    f6dc:	cmp.w	ip, #2147483648	; 0x80000000
    f6e0:	lsr.w	r2, r0, r2
    f6e4:	adc.w	r0, r3, r2
    f6e8:	it	eq
    f6ea:	biceq.w	r0, r0, #1
    f6ee:	bx	lr
    f6f0:	add.w	r2, r2, #32
    f6f4:	lsl.w	ip, r1, r2
    f6f8:	rsb	r2, r2, #32
    f6fc:	orrs.w	r0, r0, ip, lsl #1
    f700:	lsr.w	r2, r1, r2
    f704:	adc.w	r0, r3, r2
    f708:	it	eq
    f70a:	biceq.w	r0, r0, ip, lsr #31
    f70e:	bx	lr

0000f710 <__aeabi_fmul>:
    f710:	mov.w	ip, #255	; 0xff
    f714:	ands.w	r2, ip, r0, lsr #23
    f718:	ittt	ne
    f71a:	andsne.w	r3, ip, r1, lsr #23
    f71e:	teqne	r2, ip
    f722:	teqne	r3, ip
    f726:	beq.n	f808 <__aeabi_fmul+0xf8>
    f728:	add	r2, r3
    f72a:	eor.w	ip, r0, r1
    f72e:	lsls	r0, r0, #9
    f730:	it	ne
    f732:	movsne.w	r1, r1, lsl #9
    f736:	beq.n	f776 <__aeabi_fmul+0x66>
    f738:	mov.w	r3, #134217728	; 0x8000000
    f73c:	orr.w	r0, r3, r0, lsr #5
    f740:	orr.w	r1, r3, r1, lsr #5
    f744:	umull	r3, r1, r0, r1
    f748:	and.w	r0, ip, #2147483648	; 0x80000000
    f74c:	cmp.w	r1, #8388608	; 0x800000
    f750:	ittt	cc
    f752:	lslcc	r1, r1, #1
    f754:	orrcc.w	r1, r1, r3, lsr #31
    f758:	lslcc	r3, r3, #1
    f75a:	orr.w	r0, r0, r1
    f75e:	sbc.w	r2, r2, #127	; 0x7f
    f762:	cmp	r2, #253	; 0xfd
    f764:	bhi.n	f7a2 <__aeabi_fmul+0x92>
    f766:	cmp.w	r3, #2147483648	; 0x80000000
    f76a:	adc.w	r0, r0, r2, lsl #23
    f76e:	it	eq
    f770:	biceq.w	r0, r0, #1
    f774:	bx	lr
    f776:	teq	r0, #0
    f77a:	and.w	ip, ip, #2147483648	; 0x80000000
    f77e:	it	eq
    f780:	lsleq	r1, r1, #9
    f782:	orr.w	r0, ip, r0, lsr #9
    f786:	orr.w	r0, r0, r1, lsr #9
    f78a:	subs	r2, #127	; 0x7f
    f78c:	ittt	gt
    f78e:	rsbsgt	r3, r2, #255	; 0xff
    f792:	orrgt.w	r0, r0, r2, lsl #23
    f796:	bxgt	lr
    f798:	orr.w	r0, r0, #8388608	; 0x800000
    f79c:	mov.w	r3, #0
    f7a0:	subs	r2, #1
    f7a2:	bgt.n	f860 <__aeabi_fmul+0x150>
    f7a4:	cmn.w	r2, #25
    f7a8:	itt	le
    f7aa:	andle.w	r0, r0, #2147483648	; 0x80000000
    f7ae:	bxle	lr
    f7b0:	rsb	r2, r2, #0
    f7b4:	lsls	r1, r0, #1
    f7b6:	lsr.w	r1, r1, r2
    f7ba:	rsb	r2, r2, #32
    f7be:	lsl.w	ip, r0, r2
    f7c2:	movs.w	r0, r1, rrx
    f7c6:	adc.w	r0, r0, #0
    f7ca:	orrs.w	r3, r3, ip, lsl #1
    f7ce:	it	eq
    f7d0:	biceq.w	r0, r0, ip, lsr #31
    f7d4:	bx	lr
    f7d6:	teq	r2, #0
    f7da:	and.w	ip, r0, #2147483648	; 0x80000000
    f7de:	ittt	eq
    f7e0:	lsleq	r0, r0, #1
    f7e2:	tsteq.w	r0, #8388608	; 0x800000
    f7e6:	subeq	r2, #1
    f7e8:	beq.n	f7de <__aeabi_fmul+0xce>
    f7ea:	orr.w	r0, r0, ip
    f7ee:	teq	r3, #0
    f7f2:	and.w	ip, r1, #2147483648	; 0x80000000
    f7f6:	ittt	eq
    f7f8:	lsleq	r1, r1, #1
    f7fa:	tsteq.w	r1, #8388608	; 0x800000
    f7fe:	subeq	r3, #1
    f800:	beq.n	f7f6 <__aeabi_fmul+0xe6>
    f802:	orr.w	r1, r1, ip
    f806:	b.n	f728 <__aeabi_fmul+0x18>
    f808:	and.w	r3, ip, r1, lsr #23
    f80c:	teq	r2, ip
    f810:	it	ne
    f812:	teqne	r3, ip
    f816:	beq.n	f82e <__aeabi_fmul+0x11e>
    f818:	bics.w	ip, r0, #2147483648	; 0x80000000
    f81c:	it	ne
    f81e:	bicsne.w	ip, r1, #2147483648	; 0x80000000
    f822:	bne.n	f7d6 <__aeabi_fmul+0xc6>
    f824:	eor.w	r0, r0, r1
    f828:	and.w	r0, r0, #2147483648	; 0x80000000
    f82c:	bx	lr
    f82e:	teq	r0, #0
    f832:	itett	ne
    f834:	teqne	r0, #2147483648	; 0x80000000
    f838:	moveq	r0, r1
    f83a:	teqne	r1, #0
    f83e:	teqne	r1, #2147483648	; 0x80000000
    f842:	beq.n	f86e <__aeabi_fmul+0x15e>
    f844:	teq	r2, ip
    f848:	bne.n	f84e <__aeabi_fmul+0x13e>
    f84a:	lsls	r2, r0, #9
    f84c:	bne.n	f86e <__aeabi_fmul+0x15e>
    f84e:	teq	r3, ip
    f852:	bne.n	f85c <__aeabi_fmul+0x14c>
    f854:	lsls	r3, r1, #9
    f856:	it	ne
    f858:	movne	r0, r1
    f85a:	bne.n	f86e <__aeabi_fmul+0x15e>
    f85c:	eor.w	r0, r0, r1
    f860:	and.w	r0, r0, #2147483648	; 0x80000000
    f864:	orr.w	r0, r0, #2130706432	; 0x7f000000
    f868:	orr.w	r0, r0, #8388608	; 0x800000
    f86c:	bx	lr
    f86e:	orr.w	r0, r0, #2130706432	; 0x7f000000
    f872:	orr.w	r0, r0, #12582912	; 0xc00000
    f876:	bx	lr

0000f878 <__aeabi_fdiv>:
    f878:	mov.w	ip, #255	; 0xff
    f87c:	ands.w	r2, ip, r0, lsr #23
    f880:	ittt	ne
    f882:	andsne.w	r3, ip, r1, lsr #23
    f886:	teqne	r2, ip
    f88a:	teqne	r3, ip
    f88e:	beq.n	f964 <__aeabi_fdiv+0xec>
    f890:	sub.w	r2, r2, r3
    f894:	eor.w	ip, r0, r1
    f898:	lsls	r1, r1, #9
    f89a:	mov.w	r0, r0, lsl #9
    f89e:	beq.n	f910 <__aeabi_fdiv+0x98>
    f8a0:	mov.w	r3, #268435456	; 0x10000000
    f8a4:	orr.w	r1, r3, r1, lsr #4
    f8a8:	orr.w	r3, r3, r0, lsr #4
    f8ac:	and.w	r0, ip, #2147483648	; 0x80000000
    f8b0:	cmp	r3, r1
    f8b2:	it	cc
    f8b4:	lslcc	r3, r3, #1
    f8b6:	adc.w	r2, r2, #125	; 0x7d
    f8ba:	mov.w	ip, #8388608	; 0x800000
    f8be:	cmp	r3, r1
    f8c0:	itt	cs
    f8c2:	subcs	r3, r3, r1
    f8c4:	orrcs.w	r0, r0, ip
    f8c8:	cmp.w	r3, r1, lsr #1
    f8cc:	itt	cs
    f8ce:	subcs.w	r3, r3, r1, lsr #1
    f8d2:	orrcs.w	r0, r0, ip, lsr #1
    f8d6:	cmp.w	r3, r1, lsr #2
    f8da:	itt	cs
    f8dc:	subcs.w	r3, r3, r1, lsr #2
    f8e0:	orrcs.w	r0, r0, ip, lsr #2
    f8e4:	cmp.w	r3, r1, lsr #3
    f8e8:	itt	cs
    f8ea:	subcs.w	r3, r3, r1, lsr #3
    f8ee:	orrcs.w	r0, r0, ip, lsr #3
    f8f2:	lsls	r3, r3, #4
    f8f4:	it	ne
    f8f6:	movsne.w	ip, ip, lsr #4
    f8fa:	bne.n	f8be <__aeabi_fdiv+0x46>
    f8fc:	cmp	r2, #253	; 0xfd
    f8fe:	bhi.w	f7a2 <__aeabi_fmul+0x92>
    f902:	cmp	r3, r1
    f904:	adc.w	r0, r0, r2, lsl #23
    f908:	it	eq
    f90a:	biceq.w	r0, r0, #1
    f90e:	bx	lr
    f910:	and.w	ip, ip, #2147483648	; 0x80000000
    f914:	orr.w	r0, ip, r0, lsr #9
    f918:	adds	r2, #127	; 0x7f
    f91a:	ittt	gt
    f91c:	rsbsgt	r3, r2, #255	; 0xff
    f920:	orrgt.w	r0, r0, r2, lsl #23
    f924:	bxgt	lr
    f926:	orr.w	r0, r0, #8388608	; 0x800000
    f92a:	mov.w	r3, #0
    f92e:	subs	r2, #1
    f930:	b.n	f7a2 <__aeabi_fmul+0x92>
    f932:	teq	r2, #0
    f936:	and.w	ip, r0, #2147483648	; 0x80000000
    f93a:	ittt	eq
    f93c:	lsleq	r0, r0, #1
    f93e:	tsteq.w	r0, #8388608	; 0x800000
    f942:	subeq	r2, #1
    f944:	beq.n	f93a <__aeabi_fdiv+0xc2>
    f946:	orr.w	r0, r0, ip
    f94a:	teq	r3, #0
    f94e:	and.w	ip, r1, #2147483648	; 0x80000000
    f952:	ittt	eq
    f954:	lsleq	r1, r1, #1
    f956:	tsteq.w	r1, #8388608	; 0x800000
    f95a:	subeq	r3, #1
    f95c:	beq.n	f952 <__aeabi_fdiv+0xda>
    f95e:	orr.w	r1, r1, ip
    f962:	b.n	f890 <__aeabi_fdiv+0x18>
    f964:	and.w	r3, ip, r1, lsr #23
    f968:	teq	r2, ip
    f96c:	bne.n	f980 <__aeabi_fdiv+0x108>
    f96e:	lsls	r2, r0, #9
    f970:	bne.w	f86e <__aeabi_fmul+0x15e>
    f974:	teq	r3, ip
    f978:	bne.w	f85c <__aeabi_fmul+0x14c>
    f97c:	mov	r0, r1
    f97e:	b.n	f86e <__aeabi_fmul+0x15e>
    f980:	teq	r3, ip
    f984:	bne.n	f990 <__aeabi_fdiv+0x118>
    f986:	lsls	r3, r1, #9
    f988:	beq.w	f824 <__aeabi_fmul+0x114>
    f98c:	mov	r0, r1
    f98e:	b.n	f86e <__aeabi_fmul+0x15e>
    f990:	bics.w	ip, r0, #2147483648	; 0x80000000
    f994:	it	ne
    f996:	bicsne.w	ip, r1, #2147483648	; 0x80000000
    f99a:	bne.n	f932 <__aeabi_fdiv+0xba>
    f99c:	bics.w	r2, r0, #2147483648	; 0x80000000
    f9a0:	bne.w	f85c <__aeabi_fmul+0x14c>
    f9a4:	bics.w	r3, r1, #2147483648	; 0x80000000
    f9a8:	bne.w	f824 <__aeabi_fmul+0x114>
    f9ac:	b.n	f86e <__aeabi_fmul+0x15e>
    f9ae:	nop

0000f9b0 <__gesf2>:
    f9b0:	mov.w	ip, #4294967295
    f9b4:	b.n	f9c4 <__cmpsf2+0x4>
    f9b6:	nop

0000f9b8 <__lesf2>:
    f9b8:	mov.w	ip, #1
    f9bc:	b.n	f9c4 <__cmpsf2+0x4>
    f9be:	nop

0000f9c0 <__cmpsf2>:
    f9c0:	mov.w	ip, #1
    f9c4:	str.w	ip, [sp, #-4]!
    f9c8:	mov.w	r2, r0, lsl #1
    f9cc:	mov.w	r3, r1, lsl #1
    f9d0:	mvns.w	ip, r2, asr #24
    f9d4:	it	ne
    f9d6:	mvnsne.w	ip, r3, asr #24
    f9da:	beq.n	fa00 <__cmpsf2+0x40>
    f9dc:	add	sp, #4
    f9de:	orrs.w	ip, r2, r3, lsr #1
    f9e2:	it	ne
    f9e4:	teqne	r0, r1
    f9e8:	it	pl
    f9ea:	subspl.w	r0, r2, r3
    f9ee:	it	hi
    f9f0:	asrhi	r0, r1, #31
    f9f2:	it	cc
    f9f4:	mvncc.w	r0, r1, asr #31
    f9f8:	it	ne
    f9fa:	orrne.w	r0, r0, #1
    f9fe:	bx	lr
    fa00:	mvns.w	ip, r2, asr #24
    fa04:	bne.n	fa0c <__cmpsf2+0x4c>
    fa06:	movs.w	ip, r0, lsl #9
    fa0a:	bne.n	fa18 <__cmpsf2+0x58>
    fa0c:	mvns.w	ip, r3, asr #24
    fa10:	bne.n	f9dc <__cmpsf2+0x1c>
    fa12:	movs.w	ip, r1, lsl #9
    fa16:	beq.n	f9dc <__cmpsf2+0x1c>
    fa18:	ldr.w	r0, [sp], #4
    fa1c:	bx	lr
    fa1e:	nop

0000fa20 <__aeabi_cfrcmple>:
    fa20:	mov	ip, r0
    fa22:	mov	r0, r1
    fa24:	mov	r1, ip
    fa26:	b.n	fa28 <__aeabi_cfcmpeq>

0000fa28 <__aeabi_cfcmpeq>:
    fa28:	push	{r0, r1, r2, r3, lr}
    fa2a:	bl	f9c0 <__cmpsf2>
    fa2e:	cmp	r0, #0
    fa30:	it	mi
    fa32:	cmnmi.w	r0, #0
    fa36:	pop	{r0, r1, r2, r3, pc}

0000fa38 <__aeabi_fcmpeq>:
    fa38:	str.w	lr, [sp, #-8]!
    fa3c:	bl	fa28 <__aeabi_cfcmpeq>
    fa40:	ite	eq
    fa42:	moveq	r0, #1
    fa44:	movne	r0, #0
    fa46:	ldr.w	pc, [sp], #8
    fa4a:	nop

0000fa4c <__aeabi_fcmplt>:
    fa4c:	str.w	lr, [sp, #-8]!
    fa50:	bl	fa28 <__aeabi_cfcmpeq>
    fa54:	ite	cc
    fa56:	movcc	r0, #1
    fa58:	movcs	r0, #0
    fa5a:	ldr.w	pc, [sp], #8
    fa5e:	nop

0000fa60 <__aeabi_fcmple>:
    fa60:	str.w	lr, [sp, #-8]!
    fa64:	bl	fa28 <__aeabi_cfcmpeq>
    fa68:	ite	ls
    fa6a:	movls	r0, #1
    fa6c:	movhi	r0, #0
    fa6e:	ldr.w	pc, [sp], #8
    fa72:	nop

0000fa74 <__aeabi_fcmpge>:
    fa74:	str.w	lr, [sp, #-8]!
    fa78:	bl	fa20 <__aeabi_cfrcmple>
    fa7c:	ite	ls
    fa7e:	movls	r0, #1
    fa80:	movhi	r0, #0
    fa82:	ldr.w	pc, [sp], #8
    fa86:	nop

0000fa88 <__aeabi_fcmpgt>:
    fa88:	str.w	lr, [sp, #-8]!
    fa8c:	bl	fa20 <__aeabi_cfrcmple>
    fa90:	ite	cc
    fa92:	movcc	r0, #1
    fa94:	movcs	r0, #0
    fa96:	ldr.w	pc, [sp], #8
    fa9a:	nop

0000fa9c <__aeabi_fcmpun>:
    fa9c:	mov.w	r2, r0, lsl #1
    faa0:	mov.w	r3, r1, lsl #1
    faa4:	mvns.w	ip, r2, asr #24
    faa8:	bne.n	fab0 <__aeabi_fcmpun+0x14>
    faaa:	movs.w	ip, r0, lsl #9
    faae:	bne.n	fac2 <__aeabi_fcmpun+0x26>
    fab0:	mvns.w	ip, r3, asr #24
    fab4:	bne.n	fabc <__aeabi_fcmpun+0x20>
    fab6:	movs.w	ip, r1, lsl #9
    faba:	bne.n	fac2 <__aeabi_fcmpun+0x26>
    fabc:	mov.w	r0, #0
    fac0:	bx	lr
    fac2:	mov.w	r0, #1
    fac6:	bx	lr

0000fac8 <__aeabi_f2iz>:
    fac8:	mov.w	r2, r0, lsl #1
    facc:	cmp.w	r2, #2130706432	; 0x7f000000
    fad0:	bcc.n	faf2 <__aeabi_f2iz+0x2a>
    fad2:	mov.w	r3, #158	; 0x9e
    fad6:	subs.w	r2, r3, r2, lsr #24
    fada:	bls.n	faf8 <__aeabi_f2iz+0x30>
    fadc:	mov.w	r3, r0, lsl #8
    fae0:	orr.w	r3, r3, #2147483648	; 0x80000000
    fae4:	tst.w	r0, #2147483648	; 0x80000000
    fae8:	lsr.w	r0, r3, r2
    faec:	it	ne
    faee:	negne	r0, r0
    faf0:	bx	lr
    faf2:	mov.w	r0, #0
    faf6:	bx	lr
    faf8:	cmn.w	r2, #97	; 0x61
    fafc:	bne.n	fb02 <__aeabi_f2iz+0x3a>
    fafe:	lsls	r2, r0, #9
    fb00:	bne.n	fb0e <__aeabi_f2iz+0x46>
    fb02:	ands.w	r0, r0, #2147483648	; 0x80000000
    fb06:	it	eq
    fb08:	mvneq.w	r0, #2147483648	; 0x80000000
    fb0c:	bx	lr
    fb0e:	mov.w	r0, #0
    fb12:	bx	lr

0000fb14 <__aeabi_f2uiz>:
    fb14:	lsls	r2, r0, #1
    fb16:	bcs.n	fb36 <__aeabi_f2uiz+0x22>
    fb18:	cmp.w	r2, #2130706432	; 0x7f000000
    fb1c:	bcc.n	fb36 <__aeabi_f2uiz+0x22>
    fb1e:	mov.w	r3, #158	; 0x9e
    fb22:	subs.w	r2, r3, r2, lsr #24
    fb26:	bmi.n	fb3c <__aeabi_f2uiz+0x28>
    fb28:	mov.w	r3, r0, lsl #8
    fb2c:	orr.w	r3, r3, #2147483648	; 0x80000000
    fb30:	lsr.w	r0, r3, r2
    fb34:	bx	lr
    fb36:	mov.w	r0, #0
    fb3a:	bx	lr
    fb3c:	cmn.w	r2, #97	; 0x61
    fb40:	bne.n	fb46 <__aeabi_f2uiz+0x32>
    fb42:	lsls	r2, r0, #9
    fb44:	bne.n	fb4c <__aeabi_f2uiz+0x38>
    fb46:	mov.w	r0, #4294967295
    fb4a:	bx	lr
    fb4c:	mov.w	r0, #0
    fb50:	bx	lr
    fb52:	nop

0000fb54 <__aeabi_uldivmod>:
    fb54:	cbnz	r3, fb6c <__aeabi_uldivmod+0x18>
    fb56:	cbnz	r2, fb6c <__aeabi_uldivmod+0x18>
    fb58:	cmp	r1, #0
    fb5a:	it	eq
    fb5c:	cmpeq	r0, #0
    fb5e:	itt	ne
    fb60:	movne.w	r1, #4294967295
    fb64:	movne.w	r0, #4294967295
    fb68:	b.w	fe68 <__aeabi_idiv0>
    fb6c:	sub.w	ip, sp, #8
    fb70:	strd	ip, lr, [sp, #-16]!
    fb74:	bl	fb84 <__udivmoddi4>
    fb78:	ldr.w	lr, [sp, #4]
    fb7c:	ldrd	r2, r3, [sp, #8]
    fb80:	add	sp, #16
    fb82:	bx	lr

0000fb84 <__udivmoddi4>:
    fb84:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fb88:	mov	ip, r1
    fb8a:	mov	r6, r1
    fb8c:	mov	r4, r0
    fb8e:	ldr	r5, [sp, #32]
    fb90:	cmp	r3, #0
    fb92:	bne.n	fc36 <__udivmoddi4+0xb2>
    fb94:	cmp	r2, r1
    fb96:	mov	r7, r2
    fb98:	bls.n	fc74 <__udivmoddi4+0xf0>
    fb9a:	clz	lr, r2
    fb9e:	cmp.w	lr, #0
    fba2:	beq.n	fbbc <__udivmoddi4+0x38>
    fba4:	rsb	r4, lr, #32
    fba8:	lsr.w	r4, r0, r4
    fbac:	lsl.w	r6, r1, lr
    fbb0:	orr.w	ip, r4, r6
    fbb4:	lsl.w	r7, r2, lr
    fbb8:	lsl.w	r4, r0, lr
    fbbc:	mov.w	r9, r7, lsr #16
    fbc0:	lsrs	r2, r4, #16
    fbc2:	udiv	r0, ip, r9
    fbc6:	uxth.w	r8, r7
    fbca:	mls	r6, r9, r0, ip
    fbce:	orr.w	r6, r2, r6, lsl #16
    fbd2:	mul.w	r3, r0, r8
    fbd6:	cmp	r3, r6
    fbd8:	bls.n	fbee <__udivmoddi4+0x6a>
    fbda:	adds	r6, r6, r7
    fbdc:	add.w	r2, r0, #4294967295
    fbe0:	bcs.w	fe28 <__udivmoddi4+0x2a4>
    fbe4:	cmp	r3, r6
    fbe6:	bls.w	fe28 <__udivmoddi4+0x2a4>
    fbea:	subs	r0, #2
    fbec:	add	r6, r7
    fbee:	subs	r6, r6, r3
    fbf0:	uxth	r2, r4
    fbf2:	udiv	r3, r6, r9
    fbf6:	mls	r6, r9, r3, r6
    fbfa:	orr.w	r4, r2, r6, lsl #16
    fbfe:	mul.w	r8, r3, r8
    fc02:	cmp	r8, r4
    fc04:	bls.n	fc1a <__udivmoddi4+0x96>
    fc06:	adds	r4, r4, r7
    fc08:	add.w	r2, r3, #4294967295
    fc0c:	bcs.w	fe24 <__udivmoddi4+0x2a0>
    fc10:	cmp	r8, r4
    fc12:	bls.w	fe24 <__udivmoddi4+0x2a0>
    fc16:	subs	r3, #2
    fc18:	add	r4, r7
    fc1a:	rsb	r4, r8, r4
    fc1e:	orr.w	r0, r3, r0, lsl #16
    fc22:	movs	r1, #0
    fc24:	cmp	r5, #0
    fc26:	beq.n	fcee <__udivmoddi4+0x16a>
    fc28:	lsr.w	r4, r4, lr
    fc2c:	movs	r3, #0
    fc2e:	str	r4, [r5, #0]
    fc30:	str	r3, [r5, #4]
    fc32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fc36:	cmp	r3, r1
    fc38:	bls.n	fc4a <__udivmoddi4+0xc6>
    fc3a:	cmp	r5, #0
    fc3c:	beq.n	fcea <__udivmoddi4+0x166>
    fc3e:	movs	r1, #0
    fc40:	stmia.w	r5, {r0, r6}
    fc44:	mov	r0, r1
    fc46:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fc4a:	clz	r1, r3
    fc4e:	cmp	r1, #0
    fc50:	bne.w	fd74 <__udivmoddi4+0x1f0>
    fc54:	cmp	r3, r6
    fc56:	bcc.n	fc5e <__udivmoddi4+0xda>
    fc58:	cmp	r2, r0
    fc5a:	bhi.w	fe4e <__udivmoddi4+0x2ca>
    fc5e:	subs	r4, r0, r2
    fc60:	sbc.w	r6, r6, r3
    fc64:	movs	r0, #1
    fc66:	mov	ip, r6
    fc68:	cmp	r5, #0
    fc6a:	beq.n	fcee <__udivmoddi4+0x16a>
    fc6c:	stmia.w	r5, {r4, ip}
    fc70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fc74:	cbnz	r2, fc7c <__udivmoddi4+0xf8>
    fc76:	movs	r7, #1
    fc78:	udiv	r7, r7, r2
    fc7c:	clz	lr, r7
    fc80:	cmp.w	lr, #0
    fc84:	bne.n	fcf2 <__udivmoddi4+0x16e>
    fc86:	subs	r3, r6, r7
    fc88:	mov.w	r8, r7, lsr #16
    fc8c:	uxth.w	ip, r7
    fc90:	movs	r1, #1
    fc92:	udiv	r0, r3, r8
    fc96:	lsrs	r2, r4, #16
    fc98:	mls	r6, r8, r0, r3
    fc9c:	orr.w	r6, r2, r6, lsl #16
    fca0:	mul.w	r3, ip, r0
    fca4:	cmp	r3, r6
    fca6:	bls.n	fcb8 <__udivmoddi4+0x134>
    fca8:	adds	r6, r6, r7
    fcaa:	add.w	r2, r0, #4294967295
    fcae:	bcs.n	fcb6 <__udivmoddi4+0x132>
    fcb0:	cmp	r3, r6
    fcb2:	bhi.w	fe52 <__udivmoddi4+0x2ce>
    fcb6:	mov	r0, r2
    fcb8:	subs	r6, r6, r3
    fcba:	uxth	r2, r4
    fcbc:	udiv	r3, r6, r8
    fcc0:	mls	r6, r8, r3, r6
    fcc4:	orr.w	r4, r2, r6, lsl #16
    fcc8:	mul.w	ip, ip, r3
    fccc:	cmp	ip, r4
    fcce:	bls.n	fce0 <__udivmoddi4+0x15c>
    fcd0:	adds	r4, r4, r7
    fcd2:	add.w	r2, r3, #4294967295
    fcd6:	bcs.n	fcde <__udivmoddi4+0x15a>
    fcd8:	cmp	ip, r4
    fcda:	bhi.w	fe48 <__udivmoddi4+0x2c4>
    fcde:	mov	r3, r2
    fce0:	rsb	r4, ip, r4
    fce4:	orr.w	r0, r3, r0, lsl #16
    fce8:	b.n	fc24 <__udivmoddi4+0xa0>
    fcea:	mov	r1, r5
    fcec:	mov	r0, r5
    fcee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fcf2:	rsb	r1, lr, #32
    fcf6:	lsl.w	r3, r6, lr
    fcfa:	lsl.w	r7, r7, lr
    fcfe:	lsr.w	r9, r0, r1
    fd02:	mov.w	r8, r7, lsr #16
    fd06:	lsrs	r6, r1
    fd08:	orr.w	r9, r9, r3
    fd0c:	udiv	sl, r6, r8
    fd10:	mov.w	r4, r9, lsr #16
    fd14:	mls	r6, r8, sl, r6
    fd18:	uxth.w	ip, r7
    fd1c:	orr.w	r3, r4, r6, lsl #16
    fd20:	mul.w	r2, sl, ip
    fd24:	cmp	r2, r3
    fd26:	lsl.w	r4, r0, lr
    fd2a:	bls.n	fd42 <__udivmoddi4+0x1be>
    fd2c:	adds	r3, r3, r7
    fd2e:	add.w	r1, sl, #4294967295
    fd32:	bcs.w	fe44 <__udivmoddi4+0x2c0>
    fd36:	cmp	r2, r3
    fd38:	bls.w	fe44 <__udivmoddi4+0x2c0>
    fd3c:	sub.w	sl, sl, #2
    fd40:	add	r3, r7
    fd42:	subs	r3, r3, r2
    fd44:	uxth.w	r9, r9
    fd48:	udiv	r1, r3, r8
    fd4c:	mls	r3, r8, r1, r3
    fd50:	orr.w	r3, r9, r3, lsl #16
    fd54:	mul.w	r6, r1, ip
    fd58:	cmp	r6, r3
    fd5a:	bls.n	fd6c <__udivmoddi4+0x1e8>
    fd5c:	adds	r3, r3, r7
    fd5e:	add.w	r2, r1, #4294967295
    fd62:	bcs.n	fe3c <__udivmoddi4+0x2b8>
    fd64:	cmp	r6, r3
    fd66:	bls.n	fe3c <__udivmoddi4+0x2b8>
    fd68:	subs	r1, #2
    fd6a:	add	r3, r7
    fd6c:	subs	r3, r3, r6
    fd6e:	orr.w	r1, r1, sl, lsl #16
    fd72:	b.n	fc92 <__udivmoddi4+0x10e>
    fd74:	rsb	lr, r1, #32
    fd78:	lsr.w	r4, r2, lr
    fd7c:	lsls	r3, r1
    fd7e:	orrs	r3, r4
    fd80:	lsr.w	r7, r0, lr
    fd84:	lsl.w	r4, r6, r1
    fd88:	mov.w	ip, r3, lsr #16
    fd8c:	lsr.w	r6, r6, lr
    fd90:	orrs	r4, r7
    fd92:	udiv	r9, r6, ip
    fd96:	lsrs	r7, r4, #16
    fd98:	mls	r6, ip, r9, r6
    fd9c:	uxth.w	r8, r3
    fda0:	orr.w	r6, r7, r6, lsl #16
    fda4:	mul.w	r7, r9, r8
    fda8:	cmp	r7, r6
    fdaa:	lsl.w	r2, r2, r1
    fdae:	lsl.w	sl, r0, r1
    fdb2:	bls.n	fdc6 <__udivmoddi4+0x242>
    fdb4:	adds	r6, r6, r3
    fdb6:	add.w	r0, r9, #4294967295
    fdba:	bcs.n	fe40 <__udivmoddi4+0x2bc>
    fdbc:	cmp	r7, r6
    fdbe:	bls.n	fe40 <__udivmoddi4+0x2bc>
    fdc0:	sub.w	r9, r9, #2
    fdc4:	add	r6, r3
    fdc6:	subs	r6, r6, r7
    fdc8:	uxth	r0, r4
    fdca:	udiv	r4, r6, ip
    fdce:	mls	r6, ip, r4, r6
    fdd2:	orr.w	r7, r0, r6, lsl #16
    fdd6:	mul.w	r8, r4, r8
    fdda:	cmp	r8, r7
    fddc:	bls.n	fdee <__udivmoddi4+0x26a>
    fdde:	adds	r7, r7, r3
    fde0:	add.w	r0, r4, #4294967295
    fde4:	bcs.n	fe38 <__udivmoddi4+0x2b4>
    fde6:	cmp	r8, r7
    fde8:	bls.n	fe38 <__udivmoddi4+0x2b4>
    fdea:	subs	r4, #2
    fdec:	add	r7, r3
    fdee:	orr.w	r0, r4, r9, lsl #16
    fdf2:	rsb	r7, r8, r7
    fdf6:	umull	r8, r9, r0, r2
    fdfa:	cmp	r7, r9
    fdfc:	mov	r4, r8
    fdfe:	mov	r6, r9
    fe00:	bcc.n	fe2c <__udivmoddi4+0x2a8>
    fe02:	beq.n	fe58 <__udivmoddi4+0x2d4>
    fe04:	cbz	r5, fe60 <__udivmoddi4+0x2dc>
    fe06:	subs.w	r3, sl, r4
    fe0a:	sbc.w	r7, r7, r6
    fe0e:	lsl.w	lr, r7, lr
    fe12:	lsrs	r3, r1
    fe14:	lsrs	r7, r1
    fe16:	orr.w	r3, lr, r3
    fe1a:	stmia.w	r5, {r3, r7}
    fe1e:	movs	r1, #0
    fe20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fe24:	mov	r3, r2
    fe26:	b.n	fc1a <__udivmoddi4+0x96>
    fe28:	mov	r0, r2
    fe2a:	b.n	fbee <__udivmoddi4+0x6a>
    fe2c:	subs.w	r4, r8, r2
    fe30:	sbc.w	r6, r9, r3
    fe34:	subs	r0, #1
    fe36:	b.n	fe04 <__udivmoddi4+0x280>
    fe38:	mov	r4, r0
    fe3a:	b.n	fdee <__udivmoddi4+0x26a>
    fe3c:	mov	r1, r2
    fe3e:	b.n	fd6c <__udivmoddi4+0x1e8>
    fe40:	mov	r9, r0
    fe42:	b.n	fdc6 <__udivmoddi4+0x242>
    fe44:	mov	sl, r1
    fe46:	b.n	fd42 <__udivmoddi4+0x1be>
    fe48:	subs	r3, #2
    fe4a:	add	r4, r7
    fe4c:	b.n	fce0 <__udivmoddi4+0x15c>
    fe4e:	mov	r0, r1
    fe50:	b.n	fc68 <__udivmoddi4+0xe4>
    fe52:	subs	r0, #2
    fe54:	add	r6, r7
    fe56:	b.n	fcb8 <__udivmoddi4+0x134>
    fe58:	cmp	sl, r8
    fe5a:	bcc.n	fe2c <__udivmoddi4+0x2a8>
    fe5c:	mov	r6, r7
    fe5e:	b.n	fe04 <__udivmoddi4+0x280>
    fe60:	mov	r1, r5
    fe62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fe66:	nop

0000fe68 <__aeabi_idiv0>:
    fe68:	bx	lr
    fe6a:	nop

0000fe6c <_calloc_r>:
    fe6c:	push	{r4, lr}
    fe6e:	mul.w	r1, r2, r1
    fe72:	bl	ff74 <_malloc_r>
    fe76:	mov	r4, r0
    fe78:	cbz	r0, feb2 <_calloc_r+0x46>
    fe7a:	ldr.w	r2, [r0, #-4]
    fe7e:	bic.w	r2, r2, #3
    fe82:	subs	r2, #4
    fe84:	cmp	r2, #36	; 0x24
    fe86:	bhi.n	feba <_calloc_r+0x4e>
    fe88:	cmp	r2, #19
    fe8a:	bls.n	feb6 <_calloc_r+0x4a>
    fe8c:	movs	r3, #0
    fe8e:	cmp	r2, #27
    fe90:	str	r3, [r0, #0]
    fe92:	str	r3, [r0, #4]
    fe94:	bls.n	fec4 <_calloc_r+0x58>
    fe96:	cmp	r2, #36	; 0x24
    fe98:	str	r3, [r0, #8]
    fe9a:	str	r3, [r0, #12]
    fe9c:	iteee	ne
    fe9e:	addne.w	r2, r0, #16
    fea2:	streq	r3, [r0, #16]
    fea4:	streq	r3, [r0, #20]
    fea6:	addeq.w	r2, r0, #24
    feaa:	movs	r3, #0
    feac:	str	r3, [r2, #0]
    feae:	str	r3, [r2, #4]
    feb0:	str	r3, [r2, #8]
    feb2:	mov	r0, r4
    feb4:	pop	{r4, pc}
    feb6:	mov	r2, r0
    feb8:	b.n	feaa <_calloc_r+0x3e>
    feba:	movs	r1, #0
    febc:	bl	106dc <memset>
    fec0:	mov	r0, r4
    fec2:	pop	{r4, pc}
    fec4:	add.w	r2, r0, #8
    fec8:	b.n	feaa <_calloc_r+0x3e>
    feca:	nop

0000fecc <__cxa_atexit>:
    fecc:	mov	r3, r2
    fece:	mov	r2, r1
    fed0:	mov	r1, r0
    fed2:	movs	r0, #2
    fed4:	b.w	12618 <__register_exitproc>

0000fed8 <fcvtf>:
    fed8:	push	{r4, r5, r6, r7, lr}
    feda:	sub	sp, #12
    fedc:	mov	r6, r2
    fede:	mov	r7, r3
    fee0:	mov	r5, r1
    fee2:	movs	r4, #0
    fee4:	bl	edfc <__aeabi_f2d>
    fee8:	str	r7, [sp, #0]
    feea:	mov	r3, r6
    feec:	mov	r2, r5
    feee:	str	r4, [sp, #4]
    fef0:	bl	13660 <fcvtbuf>
    fef4:	add	sp, #12
    fef6:	pop	{r4, r5, r6, r7, pc}

0000fef8 <__errno>:
    fef8:	ldr	r3, [pc, #4]	; (ff00 <__errno+0x8>)
    fefa:	ldr	r0, [r3, #0]
    fefc:	bx	lr
    fefe:	nop
    ff00:	.word	0x1fff9190

0000ff04 <__libc_init_array>:
    ff04:	push	{r4, r5, r6, lr}
    ff06:	ldr	r6, [pc, #60]	; (ff44 <__libc_init_array+0x40>)
    ff08:	ldr	r5, [pc, #60]	; (ff48 <__libc_init_array+0x44>)
    ff0a:	subs	r6, r6, r5
    ff0c:	asrs	r6, r6, #2
    ff0e:	it	ne
    ff10:	movne	r4, #0
    ff12:	beq.n	ff20 <__libc_init_array+0x1c>
    ff14:	adds	r4, #1
    ff16:	ldr.w	r3, [r5], #4
    ff1a:	blx	r3
    ff1c:	cmp	r6, r4
    ff1e:	bne.n	ff14 <__libc_init_array+0x10>
    ff20:	ldr	r6, [pc, #40]	; (ff4c <__libc_init_array+0x48>)
    ff22:	ldr	r5, [pc, #44]	; (ff50 <__libc_init_array+0x4c>)
    ff24:	subs	r6, r6, r5
    ff26:	bl	14b78 <_init>
    ff2a:	asrs	r6, r6, #2
    ff2c:	it	ne
    ff2e:	movne	r4, #0
    ff30:	beq.n	ff40 <__libc_init_array+0x3c>
    ff32:	adds	r4, #1
    ff34:	ldr.w	r3, [r5], #4
    ff38:	blx	r3
    ff3a:	cmp	r6, r4
    ff3c:	bne.n	ff32 <__libc_init_array+0x2e>
    ff3e:	pop	{r4, r5, r6, pc}
    ff40:	pop	{r4, r5, r6, pc}
    ff42:	nop
    ff44:	.word	0x00014b84
    ff48:	.word	0x00014b84
    ff4c:	.word	0x00014bd4
    ff50:	.word	0x00014b84

0000ff54 <malloc>:
    ff54:	ldr	r3, [pc, #8]	; (ff60 <malloc+0xc>)
    ff56:	mov	r1, r0
    ff58:	ldr	r0, [r3, #0]
    ff5a:	b.w	ff74 <_malloc_r>
    ff5e:	nop
    ff60:	.word	0x1fff9190

0000ff64 <free>:
    ff64:	ldr	r3, [pc, #8]	; (ff70 <free+0xc>)
    ff66:	mov	r1, r0
    ff68:	ldr	r0, [r3, #0]
    ff6a:	b.w	13810 <_free_r>
    ff6e:	nop
    ff70:	.word	0x1fff9190

0000ff74 <_malloc_r>:
    ff74:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ff78:	add.w	r5, r1, #11
    ff7c:	cmp	r5, #22
    ff7e:	sub	sp, #12
    ff80:	mov	r6, r0
    ff82:	bls.w	100c4 <_malloc_r+0x150>
    ff86:	bics.w	r5, r5, #7
    ff8a:	bmi.w	1010c <_malloc_r+0x198>
    ff8e:	cmp	r1, r5
    ff90:	bhi.w	1010c <_malloc_r+0x198>
    ff94:	bl	10778 <__malloc_lock>
    ff98:	cmp.w	r5, #504	; 0x1f8
    ff9c:	bcc.w	104d8 <_malloc_r+0x564>
    ffa0:	lsrs	r3, r5, #9
    ffa2:	beq.w	1011a <_malloc_r+0x1a6>
    ffa6:	cmp	r3, #4
    ffa8:	bhi.w	102b2 <_malloc_r+0x33e>
    ffac:	lsrs	r0, r5, #6
    ffae:	add.w	lr, r0, #57	; 0x39
    ffb2:	mov.w	r3, lr, lsl #1
    ffb6:	adds	r0, #56	; 0x38
    ffb8:	ldr	r7, [pc, #784]	; (102cc <_malloc_r+0x358>)
    ffba:	add.w	r3, r7, r3, lsl #2
    ffbe:	sub.w	r1, r3, #8
    ffc2:	ldr	r4, [r3, #4]
    ffc4:	cmp	r1, r4
    ffc6:	bne.n	ffd8 <_malloc_r+0x64>
    ffc8:	b.n	10124 <_malloc_r+0x1b0>
    ffca:	cmp	r2, #0
    ffcc:	bge.w	10128 <_malloc_r+0x1b4>
    ffd0:	ldr	r4, [r4, #12]
    ffd2:	cmp	r1, r4
    ffd4:	beq.w	10124 <_malloc_r+0x1b0>
    ffd8:	ldr	r3, [r4, #4]
    ffda:	bic.w	r3, r3, #3
    ffde:	subs	r2, r3, r5
    ffe0:	cmp	r2, #15
    ffe2:	ble.n	ffca <_malloc_r+0x56>
    ffe4:	ldr	r1, [pc, #740]	; (102cc <_malloc_r+0x358>)
    ffe6:	ldr	r4, [r7, #16]
    ffe8:	add.w	lr, r1, #8
    ffec:	cmp	r4, lr
    ffee:	beq.w	10358 <_malloc_r+0x3e4>
    fff2:	ldr	r3, [r4, #4]
    fff4:	bic.w	r3, r3, #3
    fff8:	subs	r2, r3, r5
    fffa:	cmp	r2, #15
    fffc:	bgt.w	10332 <_malloc_r+0x3be>
   10000:	cmp	r2, #0
   10002:	str.w	lr, [r1, #20]
   10006:	str.w	lr, [r1, #16]
   1000a:	bge.w	1014a <_malloc_r+0x1d6>
   1000e:	cmp.w	r3, #512	; 0x200
   10012:	bcs.w	102e4 <_malloc_r+0x370>
   10016:	lsrs	r3, r3, #3
   10018:	add.w	ip, r3, #1
   1001c:	movs	r2, #1
   1001e:	asrs	r3, r3, #2
   10020:	lsl.w	r3, r2, r3
   10024:	ldr	r2, [r1, #4]
   10026:	ldr.w	r8, [r1, ip, lsl #3]
   1002a:	str.w	r8, [r4, #8]
   1002e:	add.w	r9, r1, ip, lsl #3
   10032:	orrs	r2, r3
   10034:	sub.w	r3, r9, #8
   10038:	str	r3, [r4, #12]
   1003a:	str	r2, [r1, #4]
   1003c:	str.w	r4, [r1, ip, lsl #3]
   10040:	str.w	r4, [r8, #12]
   10044:	asrs	r3, r0, #2
   10046:	movs	r4, #1
   10048:	lsls	r4, r3
   1004a:	cmp	r4, r2
   1004c:	bhi.w	10164 <_malloc_r+0x1f0>
   10050:	tst	r4, r2
   10052:	bne.n	10062 <_malloc_r+0xee>
   10054:	bic.w	r0, r0, #3
   10058:	lsls	r4, r4, #1
   1005a:	tst	r4, r2
   1005c:	add.w	r0, r0, #4
   10060:	beq.n	10058 <_malloc_r+0xe4>
   10062:	add.w	r9, r7, r0, lsl #3
   10066:	mov	ip, r9
   10068:	mov	r8, r0
   1006a:	ldr.w	r1, [ip, #12]
   1006e:	cmp	ip, r1
   10070:	bne.n	10082 <_malloc_r+0x10e>
   10072:	b.n	1035c <_malloc_r+0x3e8>
   10074:	cmp	r2, #0
   10076:	bge.w	1037c <_malloc_r+0x408>
   1007a:	ldr	r1, [r1, #12]
   1007c:	cmp	ip, r1
   1007e:	beq.w	1035c <_malloc_r+0x3e8>
   10082:	ldr	r3, [r1, #4]
   10084:	bic.w	r3, r3, #3
   10088:	subs	r2, r3, r5
   1008a:	cmp	r2, #15
   1008c:	ble.n	10074 <_malloc_r+0x100>
   1008e:	mov	r4, r1
   10090:	ldr.w	ip, [r1, #12]
   10094:	ldr.w	r8, [r4, #8]!
   10098:	adds	r3, r1, r5
   1009a:	orr.w	r5, r5, #1
   1009e:	str	r5, [r1, #4]
   100a0:	orr.w	r1, r2, #1
   100a4:	str.w	ip, [r8, #12]
   100a8:	mov	r0, r6
   100aa:	str.w	r8, [ip, #8]
   100ae:	str	r3, [r7, #20]
   100b0:	str	r3, [r7, #16]
   100b2:	str.w	lr, [r3, #12]
   100b6:	str.w	lr, [r3, #8]
   100ba:	str	r1, [r3, #4]
   100bc:	str	r2, [r3, r2]
   100be:	bl	1077c <__malloc_unlock>
   100c2:	b.n	10104 <_malloc_r+0x190>
   100c4:	cmp	r1, #16
   100c6:	bhi.n	1010c <_malloc_r+0x198>
   100c8:	bl	10778 <__malloc_lock>
   100cc:	movs	r5, #16
   100ce:	movs	r3, #6
   100d0:	movs	r0, #2
   100d2:	ldr	r7, [pc, #504]	; (102cc <_malloc_r+0x358>)
   100d4:	add.w	r3, r7, r3, lsl #2
   100d8:	sub.w	r2, r3, #8
   100dc:	ldr	r4, [r3, #4]
   100de:	cmp	r4, r2
   100e0:	beq.w	1036e <_malloc_r+0x3fa>
   100e4:	ldr	r3, [r4, #4]
   100e6:	ldr	r1, [r4, #12]
   100e8:	ldr	r5, [r4, #8]
   100ea:	bic.w	r3, r3, #3
   100ee:	add	r3, r4
   100f0:	mov	r0, r6
   100f2:	ldr	r2, [r3, #4]
   100f4:	str	r1, [r5, #12]
   100f6:	orr.w	r2, r2, #1
   100fa:	str	r5, [r1, #8]
   100fc:	str	r2, [r3, #4]
   100fe:	bl	1077c <__malloc_unlock>
   10102:	adds	r4, #8
   10104:	mov	r0, r4
   10106:	add	sp, #12
   10108:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1010c:	movs	r4, #0
   1010e:	movs	r3, #12
   10110:	mov	r0, r4
   10112:	str	r3, [r6, #0]
   10114:	add	sp, #12
   10116:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1011a:	movs	r3, #128	; 0x80
   1011c:	mov.w	lr, #64	; 0x40
   10120:	movs	r0, #63	; 0x3f
   10122:	b.n	ffb8 <_malloc_r+0x44>
   10124:	mov	r0, lr
   10126:	b.n	ffe4 <_malloc_r+0x70>
   10128:	add	r3, r4
   1012a:	ldr	r1, [r4, #12]
   1012c:	ldr	r2, [r3, #4]
   1012e:	ldr	r5, [r4, #8]
   10130:	orr.w	r2, r2, #1
   10134:	str	r1, [r5, #12]
   10136:	mov	r0, r6
   10138:	str	r5, [r1, #8]
   1013a:	str	r2, [r3, #4]
   1013c:	bl	1077c <__malloc_unlock>
   10140:	adds	r4, #8
   10142:	mov	r0, r4
   10144:	add	sp, #12
   10146:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1014a:	add	r3, r4
   1014c:	mov	r0, r6
   1014e:	ldr	r2, [r3, #4]
   10150:	orr.w	r2, r2, #1
   10154:	str	r2, [r3, #4]
   10156:	bl	1077c <__malloc_unlock>
   1015a:	adds	r4, #8
   1015c:	mov	r0, r4
   1015e:	add	sp, #12
   10160:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10164:	ldr	r4, [r7, #8]
   10166:	ldr	r3, [r4, #4]
   10168:	bic.w	r8, r3, #3
   1016c:	cmp	r8, r5
   1016e:	bcc.n	1017a <_malloc_r+0x206>
   10170:	rsb	r3, r5, r8
   10174:	cmp	r3, #15
   10176:	bgt.w	10292 <_malloc_r+0x31e>
   1017a:	ldr	r3, [pc, #340]	; (102d0 <_malloc_r+0x35c>)
   1017c:	ldr.w	r9, [pc, #352]	; 102e0 <_malloc_r+0x36c>
   10180:	ldr	r2, [r3, #0]
   10182:	ldr.w	r3, [r9]
   10186:	adds	r3, #1
   10188:	add	r2, r5
   1018a:	add.w	sl, r4, r8
   1018e:	beq.w	10452 <_malloc_r+0x4de>
   10192:	add.w	r2, r2, #4096	; 0x1000
   10196:	adds	r2, #15
   10198:	bic.w	r2, r2, #4080	; 0xff0
   1019c:	bic.w	r2, r2, #15
   101a0:	mov	r1, r2
   101a2:	mov	r0, r6
   101a4:	str	r2, [sp, #4]
   101a6:	bl	10b60 <_sbrk_r>
   101aa:	cmp.w	r0, #4294967295
   101ae:	mov	fp, r0
   101b0:	ldr	r2, [sp, #4]
   101b2:	beq.w	10466 <_malloc_r+0x4f2>
   101b6:	cmp	sl, r0
   101b8:	bhi.w	103b4 <_malloc_r+0x440>
   101bc:	ldr	r3, [pc, #276]	; (102d4 <_malloc_r+0x360>)
   101be:	ldr	r1, [r3, #0]
   101c0:	cmp	sl, fp
   101c2:	add	r1, r2
   101c4:	str	r1, [r3, #0]
   101c6:	beq.w	10470 <_malloc_r+0x4fc>
   101ca:	ldr.w	r0, [r9]
   101ce:	ldr.w	lr, [pc, #272]	; 102e0 <_malloc_r+0x36c>
   101d2:	adds	r0, #1
   101d4:	ittet	ne
   101d6:	rsbne	sl, sl, fp
   101da:	addne	r1, sl
   101dc:	streq.w	fp, [lr]
   101e0:	strne	r1, [r3, #0]
   101e2:	ands.w	r1, fp, #7
   101e6:	beq.w	10418 <_malloc_r+0x4a4>
   101ea:	rsb	r0, r1, #8
   101ee:	rsb	r1, r1, #4096	; 0x1000
   101f2:	add	fp, r0
   101f4:	adds	r1, #8
   101f6:	add	r2, fp
   101f8:	ubfx	r2, r2, #0, #12
   101fc:	rsb	r9, r2, r1
   10200:	mov	r1, r9
   10202:	mov	r0, r6
   10204:	str	r3, [sp, #4]
   10206:	bl	10b60 <_sbrk_r>
   1020a:	adds	r3, r0, #1
   1020c:	ldr	r3, [sp, #4]
   1020e:	beq.w	10490 <_malloc_r+0x51c>
   10212:	rsb	r2, fp, r0
   10216:	add	r2, r9
   10218:	orr.w	r2, r2, #1
   1021c:	ldr	r1, [r3, #0]
   1021e:	str.w	fp, [r7, #8]
   10222:	add	r1, r9
   10224:	cmp	r4, r7
   10226:	str.w	r2, [fp, #4]
   1022a:	str	r1, [r3, #0]
   1022c:	ldr.w	r9, [pc, #164]	; 102d4 <_malloc_r+0x360>
   10230:	beq.n	10260 <_malloc_r+0x2ec>
   10232:	cmp.w	r8, #15
   10236:	bls.w	10434 <_malloc_r+0x4c0>
   1023a:	ldr	r2, [r4, #4]
   1023c:	sub.w	r3, r8, #12
   10240:	bic.w	r3, r3, #7
   10244:	adds	r0, r4, r3
   10246:	and.w	r2, r2, #1
   1024a:	mov.w	lr, #5
   1024e:	orrs	r2, r3
   10250:	cmp	r3, #15
   10252:	str	r2, [r4, #4]
   10254:	str.w	lr, [r0, #4]
   10258:	str.w	lr, [r0, #8]
   1025c:	bhi.w	10498 <_malloc_r+0x524>
   10260:	ldr	r3, [pc, #116]	; (102d8 <_malloc_r+0x364>)
   10262:	ldr	r4, [r7, #8]
   10264:	ldr	r2, [r3, #0]
   10266:	cmp	r1, r2
   10268:	it	hi
   1026a:	strhi	r1, [r3, #0]
   1026c:	ldr	r3, [pc, #108]	; (102dc <_malloc_r+0x368>)
   1026e:	ldr	r2, [r3, #0]
   10270:	cmp	r1, r2
   10272:	ldr	r2, [r4, #4]
   10274:	it	hi
   10276:	strhi	r1, [r3, #0]
   10278:	bic.w	r2, r2, #3
   1027c:	cmp	r5, r2
   1027e:	sub.w	r3, r2, r5
   10282:	bhi.n	10288 <_malloc_r+0x314>
   10284:	cmp	r3, #15
   10286:	bgt.n	10292 <_malloc_r+0x31e>
   10288:	mov	r0, r6
   1028a:	bl	1077c <__malloc_unlock>
   1028e:	movs	r4, #0
   10290:	b.n	10104 <_malloc_r+0x190>
   10292:	adds	r2, r4, r5
   10294:	orr.w	r3, r3, #1
   10298:	orr.w	r5, r5, #1
   1029c:	str	r5, [r4, #4]
   1029e:	mov	r0, r6
   102a0:	str	r2, [r7, #8]
   102a2:	str	r3, [r2, #4]
   102a4:	bl	1077c <__malloc_unlock>
   102a8:	adds	r4, #8
   102aa:	mov	r0, r4
   102ac:	add	sp, #12
   102ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   102b2:	cmp	r3, #20
   102b4:	bls.n	1039a <_malloc_r+0x426>
   102b6:	cmp	r3, #84	; 0x54
   102b8:	bhi.w	10404 <_malloc_r+0x490>
   102bc:	lsrs	r0, r5, #12
   102be:	add.w	lr, r0, #111	; 0x6f
   102c2:	mov.w	r3, lr, lsl #1
   102c6:	adds	r0, #110	; 0x6e
   102c8:	b.n	ffb8 <_malloc_r+0x44>
   102ca:	nop
   102cc:	.word	0x1fff9300
   102d0:	.word	0x200031ec
   102d4:	.word	0x200031f0
   102d8:	.word	0x200031e8
   102dc:	.word	0x200031e4
   102e0:	.word	0x1fff970c
   102e4:	lsrs	r2, r3, #9
   102e6:	cmp	r2, #4
   102e8:	bls.n	103a8 <_malloc_r+0x434>
   102ea:	cmp	r2, #20
   102ec:	bhi.w	10456 <_malloc_r+0x4e2>
   102f0:	add.w	r1, r2, #92	; 0x5c
   102f4:	lsls	r1, r1, #1
   102f6:	adds	r2, #91	; 0x5b
   102f8:	add.w	ip, r7, r1, lsl #2
   102fc:	ldr.w	r1, [r7, r1, lsl #2]
   10300:	ldr.w	r8, [pc, #476]	; 104e0 <_malloc_r+0x56c>
   10304:	sub.w	ip, ip, #8
   10308:	cmp	ip, r1
   1030a:	beq.w	1041e <_malloc_r+0x4aa>
   1030e:	ldr	r2, [r1, #4]
   10310:	bic.w	r2, r2, #3
   10314:	cmp	r3, r2
   10316:	bcs.n	1031e <_malloc_r+0x3aa>
   10318:	ldr	r1, [r1, #8]
   1031a:	cmp	ip, r1
   1031c:	bne.n	1030e <_malloc_r+0x39a>
   1031e:	ldr.w	ip, [r1, #12]
   10322:	ldr	r2, [r7, #4]
   10324:	str.w	ip, [r4, #12]
   10328:	str	r1, [r4, #8]
   1032a:	str.w	r4, [ip, #8]
   1032e:	str	r4, [r1, #12]
   10330:	b.n	10044 <_malloc_r+0xd0>
   10332:	adds	r3, r4, r5
   10334:	orr.w	r7, r2, #1
   10338:	orr.w	r5, r5, #1
   1033c:	str	r5, [r4, #4]
   1033e:	mov	r0, r6
   10340:	str	r3, [r1, #20]
   10342:	str	r3, [r1, #16]
   10344:	str.w	lr, [r3, #12]
   10348:	str.w	lr, [r3, #8]
   1034c:	str	r7, [r3, #4]
   1034e:	str	r2, [r3, r2]
   10350:	adds	r4, #8
   10352:	bl	1077c <__malloc_unlock>
   10356:	b.n	10104 <_malloc_r+0x190>
   10358:	ldr	r2, [r1, #4]
   1035a:	b.n	10044 <_malloc_r+0xd0>
   1035c:	add.w	r8, r8, #1
   10360:	tst.w	r8, #3
   10364:	add.w	ip, ip, #8
   10368:	bne.w	1006a <_malloc_r+0xf6>
   1036c:	b.n	103d0 <_malloc_r+0x45c>
   1036e:	ldr	r4, [r3, #12]
   10370:	cmp	r3, r4
   10372:	it	eq
   10374:	addeq	r0, #2
   10376:	beq.w	ffe4 <_malloc_r+0x70>
   1037a:	b.n	100e4 <_malloc_r+0x170>
   1037c:	add	r3, r1
   1037e:	mov	r4, r1
   10380:	ldr	r2, [r3, #4]
   10382:	ldr	r1, [r1, #12]
   10384:	ldr.w	r5, [r4, #8]!
   10388:	orr.w	r2, r2, #1
   1038c:	str	r2, [r3, #4]
   1038e:	mov	r0, r6
   10390:	str	r1, [r5, #12]
   10392:	str	r5, [r1, #8]
   10394:	bl	1077c <__malloc_unlock>
   10398:	b.n	10104 <_malloc_r+0x190>
   1039a:	add.w	lr, r3, #92	; 0x5c
   1039e:	add.w	r0, r3, #91	; 0x5b
   103a2:	mov.w	r3, lr, lsl #1
   103a6:	b.n	ffb8 <_malloc_r+0x44>
   103a8:	lsrs	r2, r3, #6
   103aa:	add.w	r1, r2, #57	; 0x39
   103ae:	lsls	r1, r1, #1
   103b0:	adds	r2, #56	; 0x38
   103b2:	b.n	102f8 <_malloc_r+0x384>
   103b4:	cmp	r4, r7
   103b6:	ldr	r3, [pc, #296]	; (104e0 <_malloc_r+0x56c>)
   103b8:	beq.w	101bc <_malloc_r+0x248>
   103bc:	ldr	r4, [r3, #8]
   103be:	ldr	r2, [r4, #4]
   103c0:	bic.w	r2, r2, #3
   103c4:	b.n	1027c <_malloc_r+0x308>
   103c6:	ldr.w	r3, [r9], #-8
   103ca:	cmp	r9, r3
   103cc:	bne.w	104d4 <_malloc_r+0x560>
   103d0:	tst.w	r0, #3
   103d4:	add.w	r0, r0, #4294967295
   103d8:	bne.n	103c6 <_malloc_r+0x452>
   103da:	ldr	r3, [r7, #4]
   103dc:	bic.w	r3, r3, r4
   103e0:	str	r3, [r7, #4]
   103e2:	lsls	r4, r4, #1
   103e4:	cmp	r4, r3
   103e6:	bhi.w	10164 <_malloc_r+0x1f0>
   103ea:	cmp	r4, #0
   103ec:	beq.w	10164 <_malloc_r+0x1f0>
   103f0:	tst	r4, r3
   103f2:	mov	r0, r8
   103f4:	bne.w	10062 <_malloc_r+0xee>
   103f8:	lsls	r4, r4, #1
   103fa:	tst	r4, r3
   103fc:	add.w	r0, r0, #4
   10400:	beq.n	103f8 <_malloc_r+0x484>
   10402:	b.n	10062 <_malloc_r+0xee>
   10404:	cmp.w	r3, #340	; 0x154
   10408:	bhi.n	1043c <_malloc_r+0x4c8>
   1040a:	lsrs	r0, r5, #15
   1040c:	add.w	lr, r0, #120	; 0x78
   10410:	mov.w	r3, lr, lsl #1
   10414:	adds	r0, #119	; 0x77
   10416:	b.n	ffb8 <_malloc_r+0x44>
   10418:	mov.w	r1, #4096	; 0x1000
   1041c:	b.n	101f6 <_malloc_r+0x282>
   1041e:	movs	r1, #1
   10420:	ldr.w	r3, [r8, #4]
   10424:	asrs	r2, r2, #2
   10426:	lsl.w	r2, r1, r2
   1042a:	orrs	r2, r3
   1042c:	str.w	r2, [r8, #4]
   10430:	mov	r1, ip
   10432:	b.n	10324 <_malloc_r+0x3b0>
   10434:	movs	r3, #1
   10436:	str.w	r3, [fp, #4]
   1043a:	b.n	10288 <_malloc_r+0x314>
   1043c:	movw	r2, #1364	; 0x554
   10440:	cmp	r3, r2
   10442:	bhi.n	10486 <_malloc_r+0x512>
   10444:	lsrs	r0, r5, #18
   10446:	add.w	lr, r0, #125	; 0x7d
   1044a:	mov.w	r3, lr, lsl #1
   1044e:	adds	r0, #124	; 0x7c
   10450:	b.n	ffb8 <_malloc_r+0x44>
   10452:	adds	r2, #16
   10454:	b.n	101a0 <_malloc_r+0x22c>
   10456:	cmp	r2, #84	; 0x54
   10458:	bhi.n	104a8 <_malloc_r+0x534>
   1045a:	lsrs	r2, r3, #12
   1045c:	add.w	r1, r2, #111	; 0x6f
   10460:	lsls	r1, r1, #1
   10462:	adds	r2, #110	; 0x6e
   10464:	b.n	102f8 <_malloc_r+0x384>
   10466:	ldr	r4, [r7, #8]
   10468:	ldr	r2, [r4, #4]
   1046a:	bic.w	r2, r2, #3
   1046e:	b.n	1027c <_malloc_r+0x308>
   10470:	ubfx	r0, sl, #0, #12
   10474:	cmp	r0, #0
   10476:	bne.w	101ca <_malloc_r+0x256>
   1047a:	add	r2, r8
   1047c:	ldr	r3, [r7, #8]
   1047e:	orr.w	r2, r2, #1
   10482:	str	r2, [r3, #4]
   10484:	b.n	10260 <_malloc_r+0x2ec>
   10486:	movs	r3, #254	; 0xfe
   10488:	mov.w	lr, #127	; 0x7f
   1048c:	movs	r0, #126	; 0x7e
   1048e:	b.n	ffb8 <_malloc_r+0x44>
   10490:	movs	r2, #1
   10492:	mov.w	r9, #0
   10496:	b.n	1021c <_malloc_r+0x2a8>
   10498:	add.w	r1, r4, #8
   1049c:	mov	r0, r6
   1049e:	bl	13810 <_free_r>
   104a2:	ldr.w	r1, [r9]
   104a6:	b.n	10260 <_malloc_r+0x2ec>
   104a8:	cmp.w	r2, #340	; 0x154
   104ac:	bhi.n	104ba <_malloc_r+0x546>
   104ae:	lsrs	r2, r3, #15
   104b0:	add.w	r1, r2, #120	; 0x78
   104b4:	lsls	r1, r1, #1
   104b6:	adds	r2, #119	; 0x77
   104b8:	b.n	102f8 <_malloc_r+0x384>
   104ba:	movw	r1, #1364	; 0x554
   104be:	cmp	r2, r1
   104c0:	bhi.n	104ce <_malloc_r+0x55a>
   104c2:	lsrs	r2, r3, #18
   104c4:	add.w	r1, r2, #125	; 0x7d
   104c8:	lsls	r1, r1, #1
   104ca:	adds	r2, #124	; 0x7c
   104cc:	b.n	102f8 <_malloc_r+0x384>
   104ce:	movs	r1, #254	; 0xfe
   104d0:	movs	r2, #126	; 0x7e
   104d2:	b.n	102f8 <_malloc_r+0x384>
   104d4:	ldr	r3, [r7, #4]
   104d6:	b.n	103e2 <_malloc_r+0x46e>
   104d8:	lsrs	r0, r5, #3
   104da:	adds	r3, r0, #1
   104dc:	lsls	r3, r3, #1
   104de:	b.n	100d2 <_malloc_r+0x15e>
   104e0:	.word	0x1fff9300

000104e4 <__ascii_mbtowc>:
   104e4:	sub	sp, #8
   104e6:	cbz	r1, 104fc <__ascii_mbtowc+0x18>
   104e8:	cbz	r2, 10502 <__ascii_mbtowc+0x1e>
   104ea:	cbz	r3, 10508 <__ascii_mbtowc+0x24>
   104ec:	ldrb	r3, [r2, #0]
   104ee:	str	r3, [r1, #0]
   104f0:	ldrb	r2, [r2, #0]
   104f2:	adds	r0, r2, #0
   104f4:	it	ne
   104f6:	movne	r0, #1
   104f8:	add	sp, #8
   104fa:	bx	lr
   104fc:	add	r1, sp, #4
   104fe:	cmp	r2, #0
   10500:	bne.n	104ea <__ascii_mbtowc+0x6>
   10502:	mov	r0, r2
   10504:	add	sp, #8
   10506:	bx	lr
   10508:	mvn.w	r0, #1
   1050c:	b.n	104f8 <__ascii_mbtowc+0x14>
   1050e:	nop

00010510 <memchr>:
   10510:	and.w	r1, r1, #255	; 0xff
   10514:	cmp	r2, #16
   10516:	blt.n	10570 <memchr+0x60>
   10518:	tst.w	r0, #7
   1051c:	beq.n	10530 <memchr+0x20>
   1051e:	ldrb.w	r3, [r0], #1
   10522:	subs	r2, #1
   10524:	cmp	r3, r1
   10526:	beq.n	10584 <memchr+0x74>
   10528:	tst.w	r0, #7
   1052c:	cbz	r2, 10580 <memchr+0x70>
   1052e:	bne.n	1051e <memchr+0xe>
   10530:	push	{r4, r5, r6, r7}
   10532:	orr.w	r1, r1, r1, lsl #8
   10536:	orr.w	r1, r1, r1, lsl #16
   1053a:	bic.w	r4, r2, #7
   1053e:	mvns.w	r7, #0
   10542:	movs	r3, #0
   10544:	ldrd	r5, r6, [r0], #8
   10548:	subs	r4, #8
   1054a:	eor.w	r5, r5, r1
   1054e:	eor.w	r6, r6, r1
   10552:	uadd8	r5, r5, r7
   10556:	sel	r5, r3, r7
   1055a:	uadd8	r6, r6, r7
   1055e:	sel	r6, r5, r7
   10562:	cbnz	r6, 10588 <memchr+0x78>
   10564:	bne.n	10544 <memchr+0x34>
   10566:	pop	{r4, r5, r6, r7}
   10568:	and.w	r1, r1, #255	; 0xff
   1056c:	and.w	r2, r2, #7
   10570:	cbz	r2, 10580 <memchr+0x70>
   10572:	ldrb.w	r3, [r0], #1
   10576:	subs	r2, #1
   10578:	eor.w	r3, r3, r1
   1057c:	cbz	r3, 10584 <memchr+0x74>
   1057e:	bne.n	10572 <memchr+0x62>
   10580:	movs	r0, #0
   10582:	bx	lr
   10584:	subs	r0, #1
   10586:	bx	lr
   10588:	cmp	r5, #0
   1058a:	itte	eq
   1058c:	moveq	r5, r6
   1058e:	subeq	r0, #3
   10590:	subne	r0, #7
   10592:	tst.w	r5, #1
   10596:	bne.n	105a8 <memchr+0x98>
   10598:	adds	r0, #1
   1059a:	tst.w	r5, #256	; 0x100
   1059e:	ittt	eq
   105a0:	addeq	r0, #1
   105a2:	tsteq.w	r5, #98304	; 0x18000
   105a6:	addeq	r0, #1
   105a8:	pop	{r4, r5, r6, r7}
   105aa:	subs	r0, #1
   105ac:	bx	lr
   105ae:	nop

000105b0 <memcmp>:
   105b0:	cmp	r2, #3
   105b2:	push	{r4, r5, r6}
   105b4:	bls.n	10604 <memcmp+0x54>
   105b6:	orr.w	r3, r0, r1
   105ba:	lsls	r3, r3, #30
   105bc:	beq.n	105e2 <memcmp+0x32>
   105be:	ldrb	r4, [r0, #0]
   105c0:	ldrb	r5, [r1, #0]
   105c2:	cmp	r4, r5
   105c4:	bne.n	1060c <memcmp+0x5c>
   105c6:	add	r2, r0
   105c8:	adds	r3, r0, #1
   105ca:	b.n	105d8 <memcmp+0x28>
   105cc:	ldrb.w	r4, [r3], #1
   105d0:	ldrb.w	r5, [r1, #1]!
   105d4:	cmp	r4, r5
   105d6:	bne.n	1060c <memcmp+0x5c>
   105d8:	cmp	r3, r2
   105da:	bne.n	105cc <memcmp+0x1c>
   105dc:	movs	r0, #0
   105de:	pop	{r4, r5, r6}
   105e0:	bx	lr
   105e2:	mov	r4, r1
   105e4:	mov	r3, r0
   105e6:	ldr	r6, [r3, #0]
   105e8:	ldr	r5, [r4, #0]
   105ea:	cmp	r6, r5
   105ec:	mov	r0, r3
   105ee:	mov	r1, r4
   105f0:	add.w	r3, r3, #4
   105f4:	add.w	r4, r4, #4
   105f8:	bne.n	105be <memcmp+0xe>
   105fa:	subs	r2, #4
   105fc:	cmp	r2, #3
   105fe:	mov	r0, r3
   10600:	mov	r1, r4
   10602:	bhi.n	105e6 <memcmp+0x36>
   10604:	cmp	r2, #0
   10606:	bne.n	105be <memcmp+0xe>
   10608:	mov	r0, r2
   1060a:	b.n	105de <memcmp+0x2e>
   1060c:	subs	r0, r4, r5
   1060e:	pop	{r4, r5, r6}
   10610:	bx	lr
   10612:	nop

00010614 <memmove>:
   10614:	cmp	r0, r1
   10616:	push	{r4, r5, r6, r7, lr}
   10618:	bls.n	10636 <memmove+0x22>
   1061a:	adds	r3, r1, r2
   1061c:	cmp	r0, r3
   1061e:	bcs.n	10636 <memmove+0x22>
   10620:	adds	r1, r0, r2
   10622:	cmp	r2, #0
   10624:	beq.n	106ca <memmove+0xb6>
   10626:	subs	r2, r3, r2
   10628:	ldrb.w	r4, [r3, #-1]!
   1062c:	strb.w	r4, [r1, #-1]!
   10630:	cmp	r3, r2
   10632:	bne.n	10628 <memmove+0x14>
   10634:	pop	{r4, r5, r6, r7, pc}
   10636:	cmp	r2, #15
   10638:	bls.n	106cc <memmove+0xb8>
   1063a:	orr.w	r3, r1, r0
   1063e:	lsls	r3, r3, #30
   10640:	bne.n	106d0 <memmove+0xbc>
   10642:	add.w	r4, r0, #16
   10646:	add.w	r3, r1, #16
   1064a:	mov	r5, r2
   1064c:	ldr.w	r6, [r3, #-16]
   10650:	str.w	r6, [r4, #-16]
   10654:	ldr.w	r6, [r3, #-12]
   10658:	str.w	r6, [r4, #-12]
   1065c:	ldr.w	r6, [r3, #-8]
   10660:	str.w	r6, [r4, #-8]
   10664:	subs	r5, #16
   10666:	ldr.w	r6, [r3, #-4]
   1066a:	str.w	r6, [r4, #-4]
   1066e:	cmp	r5, #15
   10670:	add.w	r3, r3, #16
   10674:	add.w	r4, r4, #16
   10678:	bhi.n	1064c <memmove+0x38>
   1067a:	sub.w	r3, r2, #16
   1067e:	bic.w	r3, r3, #15
   10682:	and.w	lr, r2, #15
   10686:	adds	r3, #16
   10688:	cmp.w	lr, #3
   1068c:	add	r1, r3
   1068e:	add	r3, r0
   10690:	bls.n	106d6 <memmove+0xc2>
   10692:	subs	r6, r3, #4
   10694:	mov	r5, r1
   10696:	mov	r4, lr
   10698:	subs	r4, #4
   1069a:	ldr.w	r7, [r5], #4
   1069e:	str.w	r7, [r6, #4]!
   106a2:	cmp	r4, #3
   106a4:	bhi.n	10698 <memmove+0x84>
   106a6:	sub.w	r4, lr, #4
   106aa:	bic.w	r4, r4, #3
   106ae:	adds	r4, #4
   106b0:	add	r3, r4
   106b2:	add	r1, r4
   106b4:	and.w	r2, r2, #3
   106b8:	cbz	r2, 106d4 <memmove+0xc0>
   106ba:	subs	r3, #1
   106bc:	add	r2, r1
   106be:	ldrb.w	r4, [r1], #1
   106c2:	strb.w	r4, [r3, #1]!
   106c6:	cmp	r2, r1
   106c8:	bne.n	106be <memmove+0xaa>
   106ca:	pop	{r4, r5, r6, r7, pc}
   106cc:	mov	r3, r0
   106ce:	b.n	106b8 <memmove+0xa4>
   106d0:	mov	r3, r0
   106d2:	b.n	106ba <memmove+0xa6>
   106d4:	pop	{r4, r5, r6, r7, pc}
   106d6:	mov	r2, lr
   106d8:	b.n	106b8 <memmove+0xa4>
   106da:	nop

000106dc <memset>:
   106dc:	push	{r4, r5, r6}
   106de:	lsls	r4, r0, #30
   106e0:	beq.n	10770 <memset+0x94>
   106e2:	subs	r4, r2, #1
   106e4:	cmp	r2, #0
   106e6:	beq.n	1076c <memset+0x90>
   106e8:	uxtb	r5, r1
   106ea:	mov	r3, r0
   106ec:	b.n	106f4 <memset+0x18>
   106ee:	subs	r2, r4, #1
   106f0:	cbz	r4, 1076c <memset+0x90>
   106f2:	mov	r4, r2
   106f4:	strb.w	r5, [r3], #1
   106f8:	lsls	r2, r3, #30
   106fa:	bne.n	106ee <memset+0x12>
   106fc:	cmp	r4, #3
   106fe:	bls.n	1075e <memset+0x82>
   10700:	uxtb	r5, r1
   10702:	orr.w	r5, r5, r5, lsl #8
   10706:	cmp	r4, #15
   10708:	orr.w	r5, r5, r5, lsl #16
   1070c:	bls.n	10742 <memset+0x66>
   1070e:	add.w	r2, r3, #16
   10712:	mov	r6, r4
   10714:	subs	r6, #16
   10716:	cmp	r6, #15
   10718:	str.w	r5, [r2, #-16]
   1071c:	str.w	r5, [r2, #-12]
   10720:	str.w	r5, [r2, #-8]
   10724:	str.w	r5, [r2, #-4]
   10728:	add.w	r2, r2, #16
   1072c:	bhi.n	10714 <memset+0x38>
   1072e:	sub.w	r2, r4, #16
   10732:	bic.w	r2, r2, #15
   10736:	and.w	r4, r4, #15
   1073a:	adds	r2, #16
   1073c:	cmp	r4, #3
   1073e:	add	r3, r2
   10740:	bls.n	1075e <memset+0x82>
   10742:	mov	r6, r3
   10744:	mov	r2, r4
   10746:	subs	r2, #4
   10748:	cmp	r2, #3
   1074a:	str.w	r5, [r6], #4
   1074e:	bhi.n	10746 <memset+0x6a>
   10750:	subs	r2, r4, #4
   10752:	bic.w	r2, r2, #3
   10756:	adds	r2, #4
   10758:	add	r3, r2
   1075a:	and.w	r4, r4, #3
   1075e:	cbz	r4, 1076c <memset+0x90>
   10760:	uxtb	r1, r1
   10762:	add	r4, r3
   10764:	strb.w	r1, [r3], #1
   10768:	cmp	r3, r4
   1076a:	bne.n	10764 <memset+0x88>
   1076c:	pop	{r4, r5, r6}
   1076e:	bx	lr
   10770:	mov	r4, r2
   10772:	mov	r3, r0
   10774:	b.n	106fc <memset+0x20>
   10776:	nop

00010778 <__malloc_lock>:
   10778:	bx	lr
   1077a:	nop

0001077c <__malloc_unlock>:
   1077c:	bx	lr
   1077e:	nop

00010780 <_realloc_r>:
   10780:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10784:	mov	r7, r2
   10786:	sub	sp, #12
   10788:	cmp	r1, #0
   1078a:	beq.w	10910 <_realloc_r+0x190>
   1078e:	mov	r6, r1
   10790:	mov	r9, r0
   10792:	add.w	r5, r7, #11
   10796:	bl	10778 <__malloc_lock>
   1079a:	ldr.w	lr, [r6, #-4]
   1079e:	cmp	r5, #22
   107a0:	bic.w	r4, lr, #3
   107a4:	sub.w	r8, r6, #8
   107a8:	bhi.n	1082c <_realloc_r+0xac>
   107aa:	movs	r2, #16
   107ac:	mov	r5, r2
   107ae:	cmp	r7, r5
   107b0:	bhi.n	10836 <_realloc_r+0xb6>
   107b2:	cmp	r4, r2
   107b4:	bge.n	108a2 <_realloc_r+0x122>
   107b6:	ldr	r3, [pc, #804]	; (10adc <_realloc_r+0x35c>)
   107b8:	ldr	r1, [r3, #8]
   107ba:	add.w	r0, r8, r4
   107be:	cmp	r0, r1
   107c0:	ldr	r1, [r0, #4]
   107c2:	beq.w	10978 <_realloc_r+0x1f8>
   107c6:	bic.w	r3, r1, #1
   107ca:	add	r3, r0
   107cc:	ldr	r3, [r3, #4]
   107ce:	lsls	r3, r3, #31
   107d0:	bpl.n	108ce <_realloc_r+0x14e>
   107d2:	tst.w	lr, #1
   107d6:	beq.n	10844 <_realloc_r+0xc4>
   107d8:	mov	r1, r7
   107da:	mov	r0, r9
   107dc:	bl	ff74 <_malloc_r>
   107e0:	mov	r7, r0
   107e2:	cbz	r0, 1081e <_realloc_r+0x9e>
   107e4:	ldr.w	r3, [r6, #-4]
   107e8:	bic.w	r3, r3, #1
   107ec:	add	r3, r8
   107ee:	sub.w	r2, r0, #8
   107f2:	cmp	r2, r3
   107f4:	beq.w	10a80 <_realloc_r+0x300>
   107f8:	subs	r2, r4, #4
   107fa:	cmp	r2, #36	; 0x24
   107fc:	bhi.w	10a62 <_realloc_r+0x2e2>
   10800:	cmp	r2, #19
   10802:	bhi.w	10a0e <_realloc_r+0x28e>
   10806:	mov	r3, r0
   10808:	mov	r2, r6
   1080a:	ldr	r1, [r2, #0]
   1080c:	str	r1, [r3, #0]
   1080e:	ldr	r1, [r2, #4]
   10810:	str	r1, [r3, #4]
   10812:	ldr	r2, [r2, #8]
   10814:	str	r2, [r3, #8]
   10816:	mov	r1, r6
   10818:	mov	r0, r9
   1081a:	bl	13810 <_free_r>
   1081e:	mov	r0, r9
   10820:	bl	1077c <__malloc_unlock>
   10824:	mov	r0, r7
   10826:	add	sp, #12
   10828:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1082c:	bic.w	r5, r5, #7
   10830:	cmp	r5, #0
   10832:	mov	r2, r5
   10834:	bge.n	107ae <_realloc_r+0x2e>
   10836:	movs	r3, #12
   10838:	movs	r0, #0
   1083a:	str.w	r3, [r9]
   1083e:	add	sp, #12
   10840:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10844:	ldr.w	r3, [r6, #-8]
   10848:	rsb	sl, r3, r8
   1084c:	ldr.w	r3, [sl, #4]
   10850:	bic.w	ip, r3, #3
   10854:	add.w	r3, r4, ip
   10858:	cmp	r3, r2
   1085a:	blt.n	107d8 <_realloc_r+0x58>
   1085c:	mov	r7, sl
   1085e:	ldr.w	r1, [sl, #12]
   10862:	ldr.w	r0, [r7, #8]!
   10866:	subs	r2, r4, #4
   10868:	cmp	r2, #36	; 0x24
   1086a:	str	r1, [r0, #12]
   1086c:	str	r0, [r1, #8]
   1086e:	bhi.w	10aa0 <_realloc_r+0x320>
   10872:	cmp	r2, #19
   10874:	bls.w	10a9c <_realloc_r+0x31c>
   10878:	ldr	r1, [r6, #0]
   1087a:	str.w	r1, [sl, #8]
   1087e:	ldr	r1, [r6, #4]
   10880:	str.w	r1, [sl, #12]
   10884:	cmp	r2, #27
   10886:	bhi.w	10ae0 <_realloc_r+0x360>
   1088a:	adds	r6, #8
   1088c:	add.w	r2, sl, #16
   10890:	ldr	r1, [r6, #0]
   10892:	str	r1, [r2, #0]
   10894:	ldr	r1, [r6, #4]
   10896:	str	r1, [r2, #4]
   10898:	ldr	r1, [r6, #8]
   1089a:	str	r1, [r2, #8]
   1089c:	mov	r6, r7
   1089e:	mov	r4, r3
   108a0:	mov	r8, sl
   108a2:	subs	r3, r4, r5
   108a4:	cmp	r3, #15
   108a6:	bhi.n	108e4 <_realloc_r+0x164>
   108a8:	ldr.w	r3, [r8, #4]
   108ac:	and.w	r3, r3, #1
   108b0:	orrs	r3, r4
   108b2:	add	r4, r8
   108b4:	str.w	r3, [r8, #4]
   108b8:	ldr	r3, [r4, #4]
   108ba:	orr.w	r3, r3, #1
   108be:	str	r3, [r4, #4]
   108c0:	mov	r0, r9
   108c2:	bl	1077c <__malloc_unlock>
   108c6:	mov	r0, r6
   108c8:	add	sp, #12
   108ca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   108ce:	bic.w	r1, r1, #3
   108d2:	add	r1, r4
   108d4:	cmp	r1, r2
   108d6:	blt.n	1091c <_realloc_r+0x19c>
   108d8:	ldr	r3, [r0, #12]
   108da:	ldr	r2, [r0, #8]
   108dc:	mov	r4, r1
   108de:	str	r3, [r2, #12]
   108e0:	str	r2, [r3, #8]
   108e2:	b.n	108a2 <_realloc_r+0x122>
   108e4:	ldr.w	r2, [r8, #4]
   108e8:	add.w	r1, r8, r5
   108ec:	and.w	r2, r2, #1
   108f0:	orrs	r5, r2
   108f2:	orr.w	r2, r3, #1
   108f6:	add	r3, r1
   108f8:	str.w	r5, [r8, #4]
   108fc:	str	r2, [r1, #4]
   108fe:	ldr	r2, [r3, #4]
   10900:	orr.w	r2, r2, #1
   10904:	adds	r1, #8
   10906:	str	r2, [r3, #4]
   10908:	mov	r0, r9
   1090a:	bl	13810 <_free_r>
   1090e:	b.n	108c0 <_realloc_r+0x140>
   10910:	mov	r1, r2
   10912:	add	sp, #12
   10914:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10918:	b.w	ff74 <_malloc_r>
   1091c:	tst.w	lr, #1
   10920:	bne.w	107d8 <_realloc_r+0x58>
   10924:	ldr.w	r3, [r6, #-8]
   10928:	rsb	sl, r3, r8
   1092c:	ldr.w	r3, [sl, #4]
   10930:	bic.w	ip, r3, #3
   10934:	add.w	lr, r1, ip
   10938:	cmp	lr, r2
   1093a:	blt.n	10854 <_realloc_r+0xd4>
   1093c:	ldr	r3, [r0, #12]
   1093e:	ldr	r2, [r0, #8]
   10940:	mov	r7, sl
   10942:	str	r3, [r2, #12]
   10944:	str	r2, [r3, #8]
   10946:	ldr.w	r1, [r7, #8]!
   1094a:	ldr.w	r3, [sl, #12]
   1094e:	str	r3, [r1, #12]
   10950:	subs	r2, r4, #4
   10952:	cmp	r2, #36	; 0x24
   10954:	str	r1, [r3, #8]
   10956:	bhi.w	10a8c <_realloc_r+0x30c>
   1095a:	cmp	r2, #19
   1095c:	bls.n	10a24 <_realloc_r+0x2a4>
   1095e:	ldr	r3, [r6, #0]
   10960:	str.w	r3, [sl, #8]
   10964:	ldr	r3, [r6, #4]
   10966:	str.w	r3, [sl, #12]
   1096a:	cmp	r2, #27
   1096c:	bhi.w	10ab0 <_realloc_r+0x330>
   10970:	adds	r6, #8
   10972:	add.w	r3, sl, #16
   10976:	b.n	10a26 <_realloc_r+0x2a6>
   10978:	bic.w	fp, r1, #3
   1097c:	add	fp, r4
   1097e:	add.w	r0, r5, #16
   10982:	cmp	fp, r0
   10984:	bge.n	10a3a <_realloc_r+0x2ba>
   10986:	tst.w	lr, #1
   1098a:	bne.w	107d8 <_realloc_r+0x58>
   1098e:	ldr.w	r1, [r6, #-8]
   10992:	rsb	sl, r1, r8
   10996:	ldr.w	r1, [sl, #4]
   1099a:	bic.w	ip, r1, #3
   1099e:	add	fp, ip
   109a0:	cmp	r0, fp
   109a2:	bgt.w	10854 <_realloc_r+0xd4>
   109a6:	mov	r7, sl
   109a8:	ldr.w	r1, [sl, #12]
   109ac:	ldr.w	r0, [r7, #8]!
   109b0:	subs	r2, r4, #4
   109b2:	cmp	r2, #36	; 0x24
   109b4:	str	r1, [r0, #12]
   109b6:	str	r0, [r1, #8]
   109b8:	bhi.w	10b24 <_realloc_r+0x3a4>
   109bc:	cmp	r2, #19
   109be:	bls.w	10b0c <_realloc_r+0x38c>
   109c2:	ldr	r1, [r6, #0]
   109c4:	str.w	r1, [sl, #8]
   109c8:	ldr	r1, [r6, #4]
   109ca:	str.w	r1, [sl, #12]
   109ce:	cmp	r2, #27
   109d0:	bhi.w	10b32 <_realloc_r+0x3b2>
   109d4:	adds	r6, #8
   109d6:	add.w	r2, sl, #16
   109da:	ldr	r1, [r6, #0]
   109dc:	str	r1, [r2, #0]
   109de:	ldr	r1, [r6, #4]
   109e0:	str	r1, [r2, #4]
   109e2:	ldr	r1, [r6, #8]
   109e4:	str	r1, [r2, #8]
   109e6:	add.w	r1, sl, r5
   109ea:	rsb	r2, r5, fp
   109ee:	orr.w	r2, r2, #1
   109f2:	str	r1, [r3, #8]
   109f4:	str	r2, [r1, #4]
   109f6:	ldr.w	r3, [sl, #4]
   109fa:	and.w	r3, r3, #1
   109fe:	orrs	r5, r3
   10a00:	mov	r0, r9
   10a02:	str.w	r5, [sl, #4]
   10a06:	bl	1077c <__malloc_unlock>
   10a0a:	mov	r0, r7
   10a0c:	b.n	108c8 <_realloc_r+0x148>
   10a0e:	ldr	r3, [r6, #0]
   10a10:	str	r3, [r0, #0]
   10a12:	ldr	r3, [r6, #4]
   10a14:	str	r3, [r0, #4]
   10a16:	cmp	r2, #27
   10a18:	bhi.n	10a6a <_realloc_r+0x2ea>
   10a1a:	add.w	r3, r0, #8
   10a1e:	add.w	r2, r6, #8
   10a22:	b.n	1080a <_realloc_r+0x8a>
   10a24:	mov	r3, r7
   10a26:	ldr	r2, [r6, #0]
   10a28:	str	r2, [r3, #0]
   10a2a:	ldr	r2, [r6, #4]
   10a2c:	str	r2, [r3, #4]
   10a2e:	ldr	r2, [r6, #8]
   10a30:	str	r2, [r3, #8]
   10a32:	mov	r6, r7
   10a34:	mov	r4, lr
   10a36:	mov	r8, sl
   10a38:	b.n	108a2 <_realloc_r+0x122>
   10a3a:	add.w	r1, r8, r5
   10a3e:	rsb	fp, r5, fp
   10a42:	orr.w	r2, fp, #1
   10a46:	str	r1, [r3, #8]
   10a48:	str	r2, [r1, #4]
   10a4a:	ldr.w	r3, [r6, #-4]
   10a4e:	and.w	r3, r3, #1
   10a52:	orrs	r5, r3
   10a54:	mov	r0, r9
   10a56:	str.w	r5, [r6, #-4]
   10a5a:	bl	1077c <__malloc_unlock>
   10a5e:	mov	r0, r6
   10a60:	b.n	108c8 <_realloc_r+0x148>
   10a62:	mov	r1, r6
   10a64:	bl	10614 <memmove>
   10a68:	b.n	10816 <_realloc_r+0x96>
   10a6a:	ldr	r3, [r6, #8]
   10a6c:	str	r3, [r0, #8]
   10a6e:	ldr	r3, [r6, #12]
   10a70:	str	r3, [r0, #12]
   10a72:	cmp	r2, #36	; 0x24
   10a74:	beq.n	10ac8 <_realloc_r+0x348>
   10a76:	add.w	r3, r0, #16
   10a7a:	add.w	r2, r6, #16
   10a7e:	b.n	1080a <_realloc_r+0x8a>
   10a80:	ldr.w	r3, [r0, #-4]
   10a84:	bic.w	r3, r3, #3
   10a88:	add	r4, r3
   10a8a:	b.n	108a2 <_realloc_r+0x122>
   10a8c:	mov	r1, r6
   10a8e:	mov	r0, r7
   10a90:	mov	r4, lr
   10a92:	mov	r8, sl
   10a94:	bl	10614 <memmove>
   10a98:	mov	r6, r7
   10a9a:	b.n	108a2 <_realloc_r+0x122>
   10a9c:	mov	r2, r7
   10a9e:	b.n	10890 <_realloc_r+0x110>
   10aa0:	mov	r1, r6
   10aa2:	mov	r0, r7
   10aa4:	mov	r4, r3
   10aa6:	mov	r8, sl
   10aa8:	bl	10614 <memmove>
   10aac:	mov	r6, r7
   10aae:	b.n	108a2 <_realloc_r+0x122>
   10ab0:	ldr	r3, [r6, #8]
   10ab2:	str.w	r3, [sl, #16]
   10ab6:	ldr	r3, [r6, #12]
   10ab8:	str.w	r3, [sl, #20]
   10abc:	cmp	r2, #36	; 0x24
   10abe:	beq.n	10af8 <_realloc_r+0x378>
   10ac0:	adds	r6, #16
   10ac2:	add.w	r3, sl, #24
   10ac6:	b.n	10a26 <_realloc_r+0x2a6>
   10ac8:	ldr	r3, [r6, #16]
   10aca:	str	r3, [r0, #16]
   10acc:	ldr	r3, [r6, #20]
   10ace:	str	r3, [r0, #20]
   10ad0:	add.w	r2, r6, #24
   10ad4:	add.w	r3, r0, #24
   10ad8:	b.n	1080a <_realloc_r+0x8a>
   10ada:	nop
   10adc:	.word	0x1fff9300
   10ae0:	ldr	r1, [r6, #8]
   10ae2:	str.w	r1, [sl, #16]
   10ae6:	ldr	r1, [r6, #12]
   10ae8:	str.w	r1, [sl, #20]
   10aec:	cmp	r2, #36	; 0x24
   10aee:	beq.n	10b10 <_realloc_r+0x390>
   10af0:	adds	r6, #16
   10af2:	add.w	r2, sl, #24
   10af6:	b.n	10890 <_realloc_r+0x110>
   10af8:	ldr	r3, [r6, #16]
   10afa:	str.w	r3, [sl, #24]
   10afe:	ldr	r3, [r6, #20]
   10b00:	str.w	r3, [sl, #28]
   10b04:	adds	r6, #24
   10b06:	add.w	r3, sl, #32
   10b0a:	b.n	10a26 <_realloc_r+0x2a6>
   10b0c:	mov	r2, r7
   10b0e:	b.n	109da <_realloc_r+0x25a>
   10b10:	ldr	r2, [r6, #16]
   10b12:	str.w	r2, [sl, #24]
   10b16:	ldr	r2, [r6, #20]
   10b18:	str.w	r2, [sl, #28]
   10b1c:	adds	r6, #24
   10b1e:	add.w	r2, sl, #32
   10b22:	b.n	10890 <_realloc_r+0x110>
   10b24:	mov	r1, r6
   10b26:	mov	r0, r7
   10b28:	str	r3, [sp, #4]
   10b2a:	bl	10614 <memmove>
   10b2e:	ldr	r3, [sp, #4]
   10b30:	b.n	109e6 <_realloc_r+0x266>
   10b32:	ldr	r1, [r6, #8]
   10b34:	str.w	r1, [sl, #16]
   10b38:	ldr	r1, [r6, #12]
   10b3a:	str.w	r1, [sl, #20]
   10b3e:	cmp	r2, #36	; 0x24
   10b40:	beq.n	10b4a <_realloc_r+0x3ca>
   10b42:	adds	r6, #16
   10b44:	add.w	r2, sl, #24
   10b48:	b.n	109da <_realloc_r+0x25a>
   10b4a:	ldr	r2, [r6, #16]
   10b4c:	str.w	r2, [sl, #24]
   10b50:	ldr	r2, [r6, #20]
   10b52:	str.w	r2, [sl, #28]
   10b56:	adds	r6, #24
   10b58:	add.w	r2, sl, #32
   10b5c:	b.n	109da <_realloc_r+0x25a>
   10b5e:	nop

00010b60 <_sbrk_r>:
   10b60:	push	{r3, r4, r5, lr}
   10b62:	ldr	r4, [pc, #28]	; (10b80 <_sbrk_r+0x20>)
   10b64:	movs	r3, #0
   10b66:	mov	r5, r0
   10b68:	mov	r0, r1
   10b6a:	str	r3, [r4, #0]
   10b6c:	bl	d0cc <_sbrk>
   10b70:	adds	r3, r0, #1
   10b72:	beq.n	10b76 <_sbrk_r+0x16>
   10b74:	pop	{r3, r4, r5, pc}
   10b76:	ldr	r3, [r4, #0]
   10b78:	cmp	r3, #0
   10b7a:	beq.n	10b74 <_sbrk_r+0x14>
   10b7c:	str	r3, [r5, #0]
   10b7e:	pop	{r3, r4, r5, pc}
   10b80:	.word	0x20003230

00010b84 <sprintf>:
   10b84:	push	{r1, r2, r3}
   10b86:	push	{r4, r5, r6, r7, lr}
   10b88:	sub	sp, #112	; 0x70
   10b8a:	add	r3, sp, #132	; 0x84
   10b8c:	ldr	r1, [pc, #60]	; (10bcc <sprintf+0x48>)
   10b8e:	ldr.w	r2, [r3], #4
   10b92:	str	r3, [sp, #4]
   10b94:	mov	r5, r0
   10b96:	mvn.w	r4, #2147483648	; 0x80000000
   10b9a:	ldr	r0, [r1, #0]
   10b9c:	str	r5, [sp, #8]
   10b9e:	mov.w	r7, #520	; 0x208
   10ba2:	movw	r6, #65535	; 0xffff
   10ba6:	add	r1, sp, #8
   10ba8:	str	r5, [sp, #24]
   10baa:	strh.w	r7, [sp, #20]
   10bae:	str	r4, [sp, #16]
   10bb0:	str	r4, [sp, #28]
   10bb2:	strh.w	r6, [sp, #22]
   10bb6:	bl	10ebc <_svfprintf_r>
   10bba:	ldr	r3, [sp, #8]
   10bbc:	movs	r2, #0
   10bbe:	strb	r2, [r3, #0]
   10bc0:	add	sp, #112	; 0x70
   10bc2:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   10bc6:	add	sp, #12
   10bc8:	bx	lr
   10bca:	nop
   10bcc:	.word	0x1fff9190

00010bd0 <strcpy>:
   10bd0:	eor.w	r2, r0, r1
   10bd4:	mov	ip, r0
   10bd6:	tst.w	r2, #3
   10bda:	bne.n	10c7c <strcpy+0xac>
   10bdc:	tst.w	r1, #3
   10be0:	bne.n	10c48 <strcpy+0x78>
   10be2:	str.w	r4, [sp, #-4]!
   10be6:	tst.w	r1, #4
   10bea:	ldr.w	r3, [r1], #4
   10bee:	beq.n	10c08 <strcpy+0x38>
   10bf0:	sub.w	r2, r3, #16843009	; 0x1010101
   10bf4:	bics	r2, r3
   10bf6:	tst.w	r2, #2155905152	; 0x80808080
   10bfa:	itt	eq
   10bfc:	streq.w	r3, [ip], #4
   10c00:	ldreq.w	r3, [r1], #4
   10c04:	bne.n	10c34 <strcpy+0x64>
   10c06:	nop
   10c08:	ldr.w	r4, [r1], #4
   10c0c:	sub.w	r2, r3, #16843009	; 0x1010101
   10c10:	bics	r2, r3
   10c12:	tst.w	r2, #2155905152	; 0x80808080
   10c16:	sub.w	r2, r4, #16843009	; 0x1010101
   10c1a:	bne.n	10c34 <strcpy+0x64>
   10c1c:	str.w	r3, [ip], #4
   10c20:	bics	r2, r4
   10c22:	tst.w	r2, #2155905152	; 0x80808080
   10c26:	itt	eq
   10c28:	ldreq.w	r3, [r1], #4
   10c2c:	streq.w	r4, [ip], #4
   10c30:	beq.n	10c08 <strcpy+0x38>
   10c32:	mov	r3, r4
   10c34:	strb.w	r3, [ip], #1
   10c38:	tst.w	r3, #255	; 0xff
   10c3c:	mov.w	r3, r3, ror #8
   10c40:	bne.n	10c34 <strcpy+0x64>
   10c42:	ldr.w	r4, [sp], #4
   10c46:	bx	lr
   10c48:	tst.w	r1, #1
   10c4c:	beq.n	10c5c <strcpy+0x8c>
   10c4e:	ldrb.w	r2, [r1], #1
   10c52:	strb.w	r2, [ip], #1
   10c56:	cmp	r2, #0
   10c58:	it	eq
   10c5a:	bxeq	lr
   10c5c:	tst.w	r1, #2
   10c60:	beq.n	10be2 <strcpy+0x12>
   10c62:	ldrh.w	r2, [r1], #2
   10c66:	tst.w	r2, #255	; 0xff
   10c6a:	itet	ne
   10c6c:	strhne.w	r2, [ip], #2
   10c70:	strbeq.w	r2, [ip]
   10c74:	tstne.w	r2, #65280	; 0xff00
   10c78:	bne.n	10be2 <strcpy+0x12>
   10c7a:	bx	lr
   10c7c:	ldrb.w	r2, [r1], #1
   10c80:	strb.w	r2, [ip], #1
   10c84:	cmp	r2, #0
   10c86:	bne.n	10c7c <strcpy+0xac>
   10c88:	bx	lr
   10c8a:	nop

00010c8c <strlcat>:
   10c8c:	push	{r4, r5, r6, lr}
   10c8e:	cbz	r2, 10cce <strlcat+0x42>
   10c90:	ldrb	r6, [r0, #0]
   10c92:	cbz	r6, 10cda <strlcat+0x4e>
   10c94:	adds	r3, r0, #1
   10c96:	adds	r6, r0, r2
   10c98:	b.n	10ca0 <strlcat+0x14>
   10c9a:	ldrb	r5, [r3, #0]
   10c9c:	adds	r3, #1
   10c9e:	cbz	r5, 10ca6 <strlcat+0x1a>
   10ca0:	cmp	r6, r3
   10ca2:	mov	r4, r3
   10ca4:	bne.n	10c9a <strlcat+0xe>
   10ca6:	subs	r6, r4, r0
   10ca8:	subs	r2, r2, r6
   10caa:	beq.n	10cd0 <strlcat+0x44>
   10cac:	ldrb	r3, [r1, #0]
   10cae:	mov	r5, r1
   10cb0:	cbz	r3, 10cc6 <strlcat+0x3a>
   10cb2:	cmp	r2, #1
   10cb4:	beq.n	10cbc <strlcat+0x30>
   10cb6:	strb	r3, [r4, #0]
   10cb8:	subs	r2, #1
   10cba:	adds	r4, #1
   10cbc:	ldrb.w	r3, [r5, #1]!
   10cc0:	cmp	r3, #0
   10cc2:	bne.n	10cb2 <strlcat+0x26>
   10cc4:	subs	r3, r5, r1
   10cc6:	movs	r2, #0
   10cc8:	strb	r2, [r4, #0]
   10cca:	adds	r0, r6, r3
   10ccc:	pop	{r4, r5, r6, pc}
   10cce:	mov	r6, r2
   10cd0:	mov	r0, r1
   10cd2:	bl	10d40 <strlen>
   10cd6:	add	r0, r6
   10cd8:	pop	{r4, r5, r6, pc}
   10cda:	mov	r4, r0
   10cdc:	b.n	10cac <strlcat+0x20>
   10cde:	nop

00010ce0 <strlcpy>:
   10ce0:	push	{r4}
   10ce2:	mov	r3, r1
   10ce4:	cbz	r2, 10cfa <strlcpy+0x1a>
   10ce6:	b.n	10cf2 <strlcpy+0x12>
   10ce8:	ldrb.w	r4, [r3], #1
   10cec:	strb.w	r4, [r0], #1
   10cf0:	cbz	r4, 10d02 <strlcpy+0x22>
   10cf2:	subs	r2, #1
   10cf4:	bne.n	10ce8 <strlcpy+0x8>
   10cf6:	movs	r2, #0
   10cf8:	strb	r2, [r0, #0]
   10cfa:	ldrb.w	r2, [r3], #1
   10cfe:	cmp	r2, #0
   10d00:	bne.n	10cfa <strlcpy+0x1a>
   10d02:	subs	r0, r3, r1
   10d04:	subs	r0, #1
   10d06:	pop	{r4}
   10d08:	bx	lr
   10d0a:	nop
   10d0c:			; <UNDEFINED> instruction: 0xffffffff
   10d10:			; <UNDEFINED> instruction: 0xffffffff
   10d14:			; <UNDEFINED> instruction: 0xffffffff
   10d18:			; <UNDEFINED> instruction: 0xffffffff
   10d1c:			; <UNDEFINED> instruction: 0xffffffff
   10d20:			; <UNDEFINED> instruction: 0xffffffff
   10d24:			; <UNDEFINED> instruction: 0xffffffff
   10d28:			; <UNDEFINED> instruction: 0xffffffff
   10d2c:			; <UNDEFINED> instruction: 0xffffffff
   10d30:			; <UNDEFINED> instruction: 0xffffffff
   10d34:			; <UNDEFINED> instruction: 0xffffffff
   10d38:			; <UNDEFINED> instruction: 0xffffffff
   10d3c:			; <UNDEFINED> instruction: 0xffffffff

00010d40 <strlen>:
   10d40:	pld	[r0]
   10d44:	strd	r4, r5, [sp, #-8]!
   10d48:	bic.w	r1, r0, #7
   10d4c:	mvn.w	ip, #0
   10d50:	ands.w	r4, r0, #7
   10d54:	pld	[r1, #32]
   10d58:	bne.w	10dee <strlen+0xae>
   10d5c:	mov.w	r4, #0
   10d60:	mvn.w	r0, #7
   10d64:	ldrd	r2, r3, [r1]
   10d68:	pld	[r1, #64]	; 0x40
   10d6c:	add.w	r0, r0, #8
   10d70:	uadd8	r2, r2, ip
   10d74:	sel	r2, r4, ip
   10d78:	uadd8	r3, r3, ip
   10d7c:	sel	r3, r2, ip
   10d80:	cbnz	r3, 10dd6 <strlen+0x96>
   10d82:	ldrd	r2, r3, [r1, #8]
   10d86:	uadd8	r2, r2, ip
   10d8a:	add.w	r0, r0, #8
   10d8e:	sel	r2, r4, ip
   10d92:	uadd8	r3, r3, ip
   10d96:	sel	r3, r2, ip
   10d9a:	cbnz	r3, 10dd6 <strlen+0x96>
   10d9c:	ldrd	r2, r3, [r1, #16]
   10da0:	uadd8	r2, r2, ip
   10da4:	add.w	r0, r0, #8
   10da8:	sel	r2, r4, ip
   10dac:	uadd8	r3, r3, ip
   10db0:	sel	r3, r2, ip
   10db4:	cbnz	r3, 10dd6 <strlen+0x96>
   10db6:	ldrd	r2, r3, [r1, #24]
   10dba:	add.w	r1, r1, #32
   10dbe:	uadd8	r2, r2, ip
   10dc2:	add.w	r0, r0, #8
   10dc6:	sel	r2, r4, ip
   10dca:	uadd8	r3, r3, ip
   10dce:	sel	r3, r2, ip
   10dd2:	cmp	r3, #0
   10dd4:	beq.n	10d64 <strlen+0x24>
   10dd6:	cmp	r2, #0
   10dd8:	itt	eq
   10dda:	addeq	r0, #4
   10ddc:	moveq	r2, r3
   10dde:	rev	r2, r2
   10de0:	clz	r2, r2
   10de4:	ldrd	r4, r5, [sp], #8
   10de8:	add.w	r0, r0, r2, lsr #3
   10dec:	bx	lr
   10dee:	ldrd	r2, r3, [r1]
   10df2:	and.w	r5, r4, #3
   10df6:	rsb	r0, r4, #0
   10dfa:	mov.w	r5, r5, lsl #3
   10dfe:	tst.w	r4, #4
   10e02:	pld	[r1, #64]	; 0x40
   10e06:	lsl.w	r5, ip, r5
   10e0a:	orn	r2, r2, r5
   10e0e:	itt	ne
   10e10:	ornne	r3, r3, r5
   10e14:	movne	r2, ip
   10e16:	mov.w	r4, #0
   10e1a:	b.n	10d70 <strlen+0x30>

00010e1c <strncmp>:
   10e1c:	cmp	r2, #0
   10e1e:	beq.n	10ea4 <strncmp+0x88>
   10e20:	orr.w	r3, r0, r1
   10e24:	ands.w	r3, r3, #3
   10e28:	push	{r4, r5, r6, r7}
   10e2a:	bne.n	10e78 <strncmp+0x5c>
   10e2c:	cmp	r2, #3
   10e2e:	bls.n	10e78 <strncmp+0x5c>
   10e30:	ldr	r4, [r0, #0]
   10e32:	ldr	r5, [r1, #0]
   10e34:	cmp	r4, r5
   10e36:	bne.n	10e78 <strncmp+0x5c>
   10e38:	subs	r2, #4
   10e3a:	beq.n	10ea8 <strncmp+0x8c>
   10e3c:	sub.w	r5, r4, #16843009	; 0x1010101
   10e40:	bic.w	r4, r5, r4
   10e44:	tst.w	r4, #2155905152	; 0x80808080
   10e48:	bne.n	10eae <strncmp+0x92>
   10e4a:	adds	r7, r0, #4
   10e4c:	adds	r5, r1, #4
   10e4e:	b.n	10e6c <strncmp+0x50>
   10e50:	ldr.w	r3, [r7], #4
   10e54:	ldr	r6, [r1, #0]
   10e56:	sub.w	r4, r3, #16843009	; 0x1010101
   10e5a:	cmp	r3, r6
   10e5c:	bic.w	r4, r4, r3
   10e60:	bne.n	10e78 <strncmp+0x5c>
   10e62:	subs	r2, #4
   10e64:	beq.n	10ea8 <strncmp+0x8c>
   10e66:	tst.w	r4, #2155905152	; 0x80808080
   10e6a:	bne.n	10eb4 <strncmp+0x98>
   10e6c:	cmp	r2, #3
   10e6e:	mov	r1, r5
   10e70:	mov	r0, r7
   10e72:	add.w	r5, r5, #4
   10e76:	bhi.n	10e50 <strncmp+0x34>
   10e78:	ldrb	r3, [r0, #0]
   10e7a:	ldrb	r4, [r1, #0]
   10e7c:	cmp	r4, r3
   10e7e:	add.w	r2, r2, #4294967295
   10e82:	bne.n	10e9e <strncmp+0x82>
   10e84:	cbz	r2, 10ea8 <strncmp+0x8c>
   10e86:	cbnz	r4, 10e8e <strncmp+0x72>
   10e88:	b.n	10eb8 <strncmp+0x9c>
   10e8a:	cbz	r2, 10ea8 <strncmp+0x8c>
   10e8c:	cbz	r3, 10eae <strncmp+0x92>
   10e8e:	ldrb.w	r3, [r0, #1]!
   10e92:	ldrb.w	r4, [r1, #1]!
   10e96:	cmp	r3, r4
   10e98:	add.w	r2, r2, #4294967295
   10e9c:	beq.n	10e8a <strncmp+0x6e>
   10e9e:	subs	r0, r3, r4
   10ea0:	pop	{r4, r5, r6, r7}
   10ea2:	bx	lr
   10ea4:	mov	r0, r2
   10ea6:	bx	lr
   10ea8:	mov	r0, r2
   10eaa:	pop	{r4, r5, r6, r7}
   10eac:	bx	lr
   10eae:	mov	r0, r3
   10eb0:	pop	{r4, r5, r6, r7}
   10eb2:	bx	lr
   10eb4:	movs	r0, #0
   10eb6:	b.n	10ea0 <strncmp+0x84>
   10eb8:	mov	r0, r4
   10eba:	b.n	10ea0 <strncmp+0x84>

00010ebc <_svfprintf_r>:
   10ebc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10ec0:	sub	sp, #260	; 0x104
   10ec2:	mov	r4, r1
   10ec4:	str	r1, [sp, #36]	; 0x24
   10ec6:	mov	r5, r2
   10ec8:	str	r3, [sp, #56]	; 0x38
   10eca:	str	r0, [sp, #40]	; 0x28
   10ecc:	bl	139e0 <_localeconv_r>
   10ed0:	ldr	r3, [r0, #0]
   10ed2:	str	r3, [sp, #92]	; 0x5c
   10ed4:	mov	r0, r3
   10ed6:	bl	10d40 <strlen>
   10eda:	ldrh	r3, [r4, #12]
   10edc:	str	r0, [sp, #88]	; 0x58
   10ede:	lsls	r6, r3, #24
   10ee0:	bpl.n	10eea <_svfprintf_r+0x2e>
   10ee2:	ldr	r3, [r4, #16]
   10ee4:	cmp	r3, #0
   10ee6:	beq.w	1211e <_svfprintf_r+0x1262>
   10eea:	movs	r3, #0
   10eec:	mov	r2, r3
   10eee:	str	r3, [sp, #72]	; 0x48
   10ef0:	str	r3, [sp, #148]	; 0x94
   10ef2:	str	r3, [sp, #144]	; 0x90
   10ef4:	str	r3, [sp, #100]	; 0x64
   10ef6:	str	r3, [sp, #44]	; 0x2c
   10ef8:	ldr.w	sl, [pc, #1124]	; 11360 <_svfprintf_r+0x4a4>
   10efc:	str	r2, [sp, #80]	; 0x50
   10efe:	add	r3, sp, #192	; 0xc0
   10f00:	str	r3, [sp, #140]	; 0x8c
   10f02:	mov	r9, r3
   10f04:	str	r2, [sp, #84]	; 0x54
   10f06:	mov	r8, r5
   10f08:	ldrb.w	r3, [r8]
   10f0c:	mov	r4, r8
   10f0e:	cbz	r3, 10f4c <_svfprintf_r+0x90>
   10f10:	cmp	r3, #37	; 0x25
   10f12:	bne.n	10f1a <_svfprintf_r+0x5e>
   10f14:	b.n	10f4c <_svfprintf_r+0x90>
   10f16:	cmp	r3, #37	; 0x25
   10f18:	beq.n	10f22 <_svfprintf_r+0x66>
   10f1a:	ldrb.w	r3, [r4, #1]!
   10f1e:	cmp	r3, #0
   10f20:	bne.n	10f16 <_svfprintf_r+0x5a>
   10f22:	rsb	r5, r8, r4
   10f26:	cbz	r5, 10f4c <_svfprintf_r+0x90>
   10f28:	ldr	r3, [sp, #144]	; 0x90
   10f2a:	ldr	r2, [sp, #148]	; 0x94
   10f2c:	str.w	r8, [r9]
   10f30:	adds	r3, #1
   10f32:	add	r2, r5
   10f34:	cmp	r3, #7
   10f36:	str.w	r5, [r9, #4]
   10f3a:	str	r2, [sp, #148]	; 0x94
   10f3c:	str	r3, [sp, #144]	; 0x90
   10f3e:	bgt.w	1108e <_svfprintf_r+0x1d2>
   10f42:	add.w	r9, r9, #8
   10f46:	ldr	r3, [sp, #44]	; 0x2c
   10f48:	add	r3, r5
   10f4a:	str	r3, [sp, #44]	; 0x2c
   10f4c:	ldrb	r3, [r4, #0]
   10f4e:	cmp	r3, #0
   10f50:	beq.w	110a0 <_svfprintf_r+0x1e4>
   10f54:	movs	r3, #0
   10f56:	mov	r2, r3
   10f58:	strb.w	r3, [sp, #111]	; 0x6f
   10f5c:	mov	r1, r3
   10f5e:	str	r3, [sp, #48]	; 0x30
   10f60:	str	r3, [sp, #28]
   10f62:	mov.w	fp, #4294967295
   10f66:	ldrb	r3, [r4, #1]
   10f68:	add.w	r8, r4, #1
   10f6c:	mov	r5, fp
   10f6e:	add.w	r8, r8, #1
   10f72:	sub.w	r0, r3, #32
   10f76:	cmp	r0, #88	; 0x58
   10f78:	bhi.w	117c6 <_svfprintf_r+0x90a>
   10f7c:	tbh	[pc, r0, lsl #1]
   10f80:	.word	0x04230388
   10f84:	.word	0x03900423
   10f88:	.word	0x04230423
   10f8c:	.word	0x04230423
   10f90:	.word	0x04230423
   10f94:	.word	0x03a50397
   10f98:	.word	0x005d0423
   10f9c:	.word	0x042300e2
   10fa0:	.word	0x010500fe
   10fa4:	.word	0x01050105
   10fa8:	.word	0x01050105
   10fac:	.word	0x01050105
   10fb0:	.word	0x01050105
   10fb4:	.word	0x04230423
   10fb8:	.word	0x04230423
   10fbc:	.word	0x04230423
   10fc0:	.word	0x04230423
   10fc4:	.word	0x04230423
   10fc8:	.word	0x02810115
   10fcc:	.word	0x02810423
   10fd0:	.word	0x04230423
   10fd4:	.word	0x04230423
   10fd8:	.word	0x042302c6
   10fdc:	.word	0x02cd0423
   10fe0:	.word	0x04230423
   10fe4:	.word	0x04230423
   10fe8:	.word	0x02f70423
   10fec:	.word	0x04230423
   10ff0:	.word	0x04230325
   10ff4:	.word	0x04230423
   10ff8:	.word	0x04230423
   10ffc:	.word	0x04230423
   11000:	.word	0x04230423
   11004:	.word	0x03660423
   11008:	.word	0x02810379
   1100c:	.word	0x02810281
   11010:	.word	0x03790381
   11014:	.word	0x04230423
   11018:	.word	0x042303d1
   1101c:	.word	0x00a303db
   11020:	.word	0x03ee0064
   11024:	.word	0x03f50423
   11028:	.word	0x03aa0423
   1102c:	.word	0x04230423
   11030:	.short	0x03bc
   11032:	ldr	r0, [sp, #48]	; 0x30
   11034:	str	r3, [sp, #56]	; 0x38
   11036:	negs	r0, r0
   11038:	str	r0, [sp, #48]	; 0x30
   1103a:	ldr	r3, [sp, #28]
   1103c:	orr.w	r3, r3, #4
   11040:	str	r3, [sp, #28]
   11042:	ldrb.w	r3, [r8]
   11046:	b.n	10f6e <_svfprintf_r+0xb2>
   11048:	ldr	r0, [sp, #56]	; 0x38
   1104a:	mov	fp, r5
   1104c:	movs	r1, #0
   1104e:	ldr	r4, [r0, #0]
   11050:	strb.w	r1, [sp, #111]	; 0x6f
   11054:	adds	r7, r0, #4
   11056:	ldr	r0, [sp, #28]
   11058:	movs	r3, #48	; 0x30
   1105a:	movs	r2, #120	; 0x78
   1105c:	cmp	fp, r1
   1105e:	strb.w	r3, [sp, #112]	; 0x70
   11062:	mov.w	r5, #0
   11066:	strb.w	r2, [sp, #113]	; 0x71
   1106a:	orr.w	r3, r0, #2
   1106e:	blt.w	11800 <_svfprintf_r+0x944>
   11072:	bic.w	r3, r0, #128	; 0x80
   11076:	orr.w	r3, r3, #2
   1107a:	str	r3, [sp, #28]
   1107c:	orrs.w	r3, r4, r5
   11080:	str	r7, [sp, #56]	; 0x38
   11082:	beq.w	117ac <_svfprintf_r+0x8f0>
   11086:	mov	r7, r1
   11088:	str	r2, [sp, #68]	; 0x44
   1108a:	ldr	r0, [pc, #716]	; (11358 <_svfprintf_r+0x49c>)
   1108c:	b.n	1162c <_svfprintf_r+0x770>
   1108e:	add	r2, sp, #140	; 0x8c
   11090:	ldr	r1, [sp, #36]	; 0x24
   11092:	ldr	r0, [sp, #40]	; 0x28
   11094:	bl	14018 <__ssprint_r>
   11098:	cbnz	r0, 110ae <_svfprintf_r+0x1f2>
   1109a:	add.w	r9, sp, #192	; 0xc0
   1109e:	b.n	10f46 <_svfprintf_r+0x8a>
   110a0:	ldr	r3, [sp, #148]	; 0x94
   110a2:	cbz	r3, 110ae <_svfprintf_r+0x1f2>
   110a4:	ldr	r0, [sp, #40]	; 0x28
   110a6:	ldr	r1, [sp, #36]	; 0x24
   110a8:	add	r2, sp, #140	; 0x8c
   110aa:	bl	14018 <__ssprint_r>
   110ae:	ldr	r3, [sp, #36]	; 0x24
   110b0:	ldrh	r3, [r3, #12]
   110b2:	tst.w	r3, #64	; 0x40
   110b6:	ldr	r3, [sp, #44]	; 0x2c
   110b8:	it	ne
   110ba:	movne.w	r3, #4294967295
   110be:	mov	r0, r3
   110c0:	add	sp, #260	; 0x104
   110c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   110c6:	str	r3, [sp, #68]	; 0x44
   110c8:	mov	fp, r5
   110ca:	cmp	r2, #0
   110cc:	bne.w	12536 <_svfprintf_r+0x167a>
   110d0:	ldr	r2, [sp, #28]
   110d2:	ands.w	r3, r2, #32
   110d6:	beq.w	11536 <_svfprintf_r+0x67a>
   110da:	ldr	r7, [sp, #56]	; 0x38
   110dc:	adds	r7, #7
   110de:	bic.w	r3, r7, #7
   110e2:	movs	r7, #0
   110e4:	add.w	r1, r3, #8
   110e8:	cmp	fp, r7
   110ea:	str	r1, [sp, #56]	; 0x38
   110ec:	ldrd	r4, r5, [r3]
   110f0:	strb.w	r7, [sp, #111]	; 0x6f
   110f4:	blt.w	11fea <_svfprintf_r+0x112e>
   110f8:	bic.w	r3, r2, #128	; 0x80
   110fc:	str	r3, [sp, #28]
   110fe:	orrs.w	r3, r4, r5
   11102:	beq.w	117f0 <_svfprintf_r+0x934>
   11106:	add	r6, sp, #192	; 0xc0
   11108:	lsrs	r2, r4, #3
   1110a:	orr.w	r2, r2, r5, lsl #29
   1110e:	lsrs	r1, r5, #3
   11110:	and.w	r3, r4, #7
   11114:	mov	r5, r1
   11116:	mov	r4, r2
   11118:	adds	r3, #48	; 0x30
   1111a:	orrs.w	r2, r4, r5
   1111e:	strb.w	r3, [r6, #-1]!
   11122:	bne.n	11108 <_svfprintf_r+0x24c>
   11124:	ldr	r2, [sp, #28]
   11126:	lsls	r1, r2, #31
   11128:	bpl.w	11234 <_svfprintf_r+0x378>
   1112c:	cmp	r3, #48	; 0x30
   1112e:	beq.w	11234 <_svfprintf_r+0x378>
   11132:	movs	r2, #48	; 0x30
   11134:	subs	r3, r6, #1
   11136:	strb.w	r2, [r6, #-1]
   1113a:	add	r2, sp, #192	; 0xc0
   1113c:	subs	r2, r2, r3
   1113e:	str	r2, [sp, #52]	; 0x34
   11140:	mov	r6, r3
   11142:	b.n	1123a <_svfprintf_r+0x37e>
   11144:	ldrb.w	r3, [r8]
   11148:	cmp	r3, #42	; 0x2a
   1114a:	add.w	r4, r8, #1
   1114e:	beq.w	124c4 <_svfprintf_r+0x1608>
   11152:	sub.w	r0, r3, #48	; 0x30
   11156:	cmp	r0, #9
   11158:	it	ls
   1115a:	movls	r5, #0
   1115c:	bhi.w	12438 <_svfprintf_r+0x157c>
   11160:	ldrb.w	r3, [r4], #1
   11164:	add.w	r5, r5, r5, lsl #2
   11168:	add.w	r5, r0, r5, lsl #1
   1116c:	sub.w	r0, r3, #48	; 0x30
   11170:	cmp	r0, #9
   11172:	bls.n	11160 <_svfprintf_r+0x2a4>
   11174:	orr.w	r5, r5, r5, asr #31
   11178:	mov	r8, r4
   1117a:	b.n	10f72 <_svfprintf_r+0xb6>
   1117c:	ldr	r3, [sp, #28]
   1117e:	orr.w	r3, r3, #128	; 0x80
   11182:	str	r3, [sp, #28]
   11184:	ldrb.w	r3, [r8]
   11188:	b.n	10f6e <_svfprintf_r+0xb2>
   1118a:	sub.w	r0, r3, #48	; 0x30
   1118e:	movs	r3, #0
   11190:	mov	r4, r3
   11192:	ldrb.w	r3, [r8], #1
   11196:	add.w	r4, r4, r4, lsl #2
   1119a:	add.w	r4, r0, r4, lsl #1
   1119e:	sub.w	r0, r3, #48	; 0x30
   111a2:	cmp	r0, #9
   111a4:	bls.n	11192 <_svfprintf_r+0x2d6>
   111a6:	str	r4, [sp, #48]	; 0x30
   111a8:	b.n	10f72 <_svfprintf_r+0xb6>
   111aa:	str	r3, [sp, #68]	; 0x44
   111ac:	mov	fp, r5
   111ae:	cmp	r2, #0
   111b0:	bne.w	1250a <_svfprintf_r+0x164e>
   111b4:	ldr	r3, [sp, #28]
   111b6:	orr.w	r3, r3, #16
   111ba:	str	r3, [sp, #28]
   111bc:	ldr	r3, [sp, #28]
   111be:	lsls	r0, r3, #26
   111c0:	bpl.w	11c24 <_svfprintf_r+0xd68>
   111c4:	ldr	r7, [sp, #56]	; 0x38
   111c6:	adds	r7, #7
   111c8:	bic.w	r7, r7, #7
   111cc:	ldrd	r2, r3, [r7]
   111d0:	add.w	r1, r7, #8
   111d4:	str	r1, [sp, #56]	; 0x38
   111d6:	mov	r4, r2
   111d8:	mov	r5, r3
   111da:	cmp	r2, #0
   111dc:	sbcs.w	r3, r3, #0
   111e0:	blt.w	11c9a <_svfprintf_r+0xdde>
   111e4:	cmp.w	fp, #0
   111e8:	ldrb.w	r7, [sp, #111]	; 0x6f
   111ec:	blt.w	11c60 <_svfprintf_r+0xda4>
   111f0:	ldr	r3, [sp, #28]
   111f2:	bic.w	r3, r3, #128	; 0x80
   111f6:	str	r3, [sp, #28]
   111f8:	orrs.w	r3, r4, r5
   111fc:	beq.w	115b6 <_svfprintf_r+0x6fa>
   11200:	cmp	r5, #0
   11202:	it	eq
   11204:	cmpeq	r4, #10
   11206:	bcc.w	115c0 <_svfprintf_r+0x704>
   1120a:	add	r6, sp, #192	; 0xc0
   1120c:	mov	r0, r4
   1120e:	mov	r1, r5
   11210:	movs	r2, #10
   11212:	movs	r3, #0
   11214:	bl	fb54 <__aeabi_uldivmod>
   11218:	adds	r2, #48	; 0x30
   1121a:	strb.w	r2, [r6, #-1]!
   1121e:	mov	r0, r4
   11220:	mov	r1, r5
   11222:	movs	r3, #0
   11224:	movs	r2, #10
   11226:	bl	fb54 <__aeabi_uldivmod>
   1122a:	mov	r4, r0
   1122c:	mov	r5, r1
   1122e:	orrs.w	r3, r4, r5
   11232:	bne.n	1120c <_svfprintf_r+0x350>
   11234:	add	r3, sp, #192	; 0xc0
   11236:	subs	r3, r3, r6
   11238:	str	r3, [sp, #52]	; 0x34
   1123a:	ldr	r3, [sp, #52]	; 0x34
   1123c:	cmp	r3, fp
   1123e:	it	lt
   11240:	movlt	r3, fp
   11242:	str	r3, [sp, #32]
   11244:	movs	r3, #0
   11246:	str	r3, [sp, #76]	; 0x4c
   11248:	cbz	r7, 11250 <_svfprintf_r+0x394>
   1124a:	ldr	r3, [sp, #32]
   1124c:	adds	r3, #1
   1124e:	str	r3, [sp, #32]
   11250:	ldr	r3, [sp, #28]
   11252:	ands.w	r3, r3, #2
   11256:	str	r3, [sp, #60]	; 0x3c
   11258:	beq.n	11260 <_svfprintf_r+0x3a4>
   1125a:	ldr	r3, [sp, #32]
   1125c:	adds	r3, #2
   1125e:	str	r3, [sp, #32]
   11260:	ldr	r3, [sp, #28]
   11262:	ands.w	r3, r3, #132	; 0x84
   11266:	str	r3, [sp, #64]	; 0x40
   11268:	bne.w	1181a <_svfprintf_r+0x95e>
   1126c:	ldr	r3, [sp, #48]	; 0x30
   1126e:	ldr	r2, [sp, #32]
   11270:	subs	r5, r3, r2
   11272:	cmp	r5, #0
   11274:	ble.w	1181a <_svfprintf_r+0x95e>
   11278:	cmp	r5, #16
   1127a:	ldr	r1, [sp, #148]	; 0x94
   1127c:	ldr	r2, [sp, #144]	; 0x90
   1127e:	ldr	r7, [pc, #220]	; (1135c <_svfprintf_r+0x4a0>)
   11280:	ble.n	112d2 <_svfprintf_r+0x416>
   11282:	str	r6, [sp, #96]	; 0x60
   11284:	mov	r0, r9
   11286:	movs	r4, #16
   11288:	mov	r9, r7
   1128a:	ldr	r6, [sp, #36]	; 0x24
   1128c:	mov	r7, r5
   1128e:	ldr	r5, [sp, #40]	; 0x28
   11290:	b.n	1129c <_svfprintf_r+0x3e0>
   11292:	subs	r7, #16
   11294:	cmp	r7, #16
   11296:	add.w	r0, r0, #8
   1129a:	ble.n	112ca <_svfprintf_r+0x40e>
   1129c:	adds	r2, #1
   1129e:	ldr	r3, [pc, #188]	; (1135c <_svfprintf_r+0x4a0>)
   112a0:	str	r2, [sp, #144]	; 0x90
   112a2:	adds	r1, #16
   112a4:	cmp	r2, #7
   112a6:	str	r1, [sp, #148]	; 0x94
   112a8:	stmia.w	r0, {r3, r4}
   112ac:	ble.n	11292 <_svfprintf_r+0x3d6>
   112ae:	add	r2, sp, #140	; 0x8c
   112b0:	mov	r1, r6
   112b2:	mov	r0, r5
   112b4:	bl	14018 <__ssprint_r>
   112b8:	cmp	r0, #0
   112ba:	bne.w	110ae <_svfprintf_r+0x1f2>
   112be:	subs	r7, #16
   112c0:	cmp	r7, #16
   112c2:	ldr	r1, [sp, #148]	; 0x94
   112c4:	ldr	r2, [sp, #144]	; 0x90
   112c6:	add	r0, sp, #192	; 0xc0
   112c8:	bgt.n	1129c <_svfprintf_r+0x3e0>
   112ca:	ldr	r6, [sp, #96]	; 0x60
   112cc:	mov	r5, r7
   112ce:	mov	r7, r9
   112d0:	mov	r9, r0
   112d2:	adds	r2, #1
   112d4:	adds	r4, r5, r1
   112d6:	cmp	r2, #7
   112d8:	str	r4, [sp, #148]	; 0x94
   112da:	str	r2, [sp, #144]	; 0x90
   112dc:	str.w	r7, [r9]
   112e0:	str.w	r5, [r9, #4]
   112e4:	bgt.w	11b38 <_svfprintf_r+0xc7c>
   112e8:	ldrb.w	r7, [sp, #111]	; 0x6f
   112ec:	add.w	r9, r9, #8
   112f0:	cbz	r7, 11310 <_svfprintf_r+0x454>
   112f2:	ldr	r3, [sp, #144]	; 0x90
   112f4:	adds	r3, #1
   112f6:	adds	r4, #1
   112f8:	add.w	r1, sp, #111	; 0x6f
   112fc:	movs	r2, #1
   112fe:	cmp	r3, #7
   11300:	str	r4, [sp, #148]	; 0x94
   11302:	str	r3, [sp, #144]	; 0x90
   11304:	stmia.w	r9, {r1, r2}
   11308:	bgt.w	11a4c <_svfprintf_r+0xb90>
   1130c:	add.w	r9, r9, #8
   11310:	ldr	r3, [sp, #60]	; 0x3c
   11312:	cbz	r3, 11330 <_svfprintf_r+0x474>
   11314:	ldr	r3, [sp, #144]	; 0x90
   11316:	adds	r3, #1
   11318:	adds	r4, #2
   1131a:	add	r1, sp, #112	; 0x70
   1131c:	movs	r2, #2
   1131e:	cmp	r3, #7
   11320:	str	r4, [sp, #148]	; 0x94
   11322:	str	r3, [sp, #144]	; 0x90
   11324:	stmia.w	r9, {r1, r2}
   11328:	bgt.w	11a64 <_svfprintf_r+0xba8>
   1132c:	add.w	r9, r9, #8
   11330:	ldr	r3, [sp, #64]	; 0x40
   11332:	cmp	r3, #128	; 0x80
   11334:	beq.w	118e2 <_svfprintf_r+0xa26>
   11338:	ldr	r3, [sp, #52]	; 0x34
   1133a:	rsb	r7, r3, fp
   1133e:	cmp	r7, #0
   11340:	ble.n	113b6 <_svfprintf_r+0x4fa>
   11342:	ldr	r2, [pc, #28]	; (11360 <_svfprintf_r+0x4a4>)
   11344:	ldr	r3, [sp, #144]	; 0x90
   11346:	str	r2, [sp, #60]	; 0x3c
   11348:	cmp	r7, #16
   1134a:	ble.n	1139e <_svfprintf_r+0x4e2>
   1134c:	mov	r2, r4
   1134e:	mov.w	fp, #16
   11352:	ldr	r5, [sp, #40]	; 0x28
   11354:	ldr	r4, [sp, #36]	; 0x24
   11356:	b.n	1136e <_svfprintf_r+0x4b2>
   11358:	.word	0x00014934
   1135c:	.word	0x00014950
   11360:	.word	0x00014900
   11364:	subs	r7, #16
   11366:	cmp	r7, #16
   11368:	add.w	r9, r9, #8
   1136c:	ble.n	1139c <_svfprintf_r+0x4e0>
   1136e:	adds	r3, #1
   11370:	adds	r2, #16
   11372:	cmp	r3, #7
   11374:	str	r2, [sp, #148]	; 0x94
   11376:	str	r3, [sp, #144]	; 0x90
   11378:	stmia.w	r9, {sl, fp}
   1137c:	ble.n	11364 <_svfprintf_r+0x4a8>
   1137e:	add	r2, sp, #140	; 0x8c
   11380:	mov	r1, r4
   11382:	mov	r0, r5
   11384:	bl	14018 <__ssprint_r>
   11388:	cmp	r0, #0
   1138a:	bne.w	110ae <_svfprintf_r+0x1f2>
   1138e:	subs	r7, #16
   11390:	cmp	r7, #16
   11392:	ldr	r2, [sp, #148]	; 0x94
   11394:	ldr	r3, [sp, #144]	; 0x90
   11396:	add.w	r9, sp, #192	; 0xc0
   1139a:	bgt.n	1136e <_svfprintf_r+0x4b2>
   1139c:	mov	r4, r2
   1139e:	adds	r3, #1
   113a0:	ldr	r2, [sp, #60]	; 0x3c
   113a2:	str	r3, [sp, #144]	; 0x90
   113a4:	add	r4, r7
   113a6:	cmp	r3, #7
   113a8:	str	r4, [sp, #148]	; 0x94
   113aa:	stmia.w	r9, {r2, r7}
   113ae:	bgt.w	11a34 <_svfprintf_r+0xb78>
   113b2:	add.w	r9, r9, #8
   113b6:	ldr	r3, [sp, #28]
   113b8:	lsls	r2, r3, #23
   113ba:	bmi.w	1181e <_svfprintf_r+0x962>
   113be:	ldr	r3, [sp, #144]	; 0x90
   113c0:	ldr	r1, [sp, #52]	; 0x34
   113c2:	str.w	r6, [r9]
   113c6:	adds	r3, #1
   113c8:	add	r4, r1
   113ca:	cmp	r3, #7
   113cc:	str	r4, [sp, #148]	; 0x94
   113ce:	str.w	r1, [r9, #4]
   113d2:	str	r3, [sp, #144]	; 0x90
   113d4:	bgt.w	11a08 <_svfprintf_r+0xb4c>
   113d8:	add.w	r9, r9, #8
   113dc:	ldr	r3, [sp, #28]
   113de:	lsls	r1, r3, #29
   113e0:	bpl.n	11462 <_svfprintf_r+0x5a6>
   113e2:	ldr	r3, [sp, #48]	; 0x30
   113e4:	ldr	r2, [sp, #32]
   113e6:	subs	r5, r3, r2
   113e8:	cmp	r5, #0
   113ea:	ble.n	11462 <_svfprintf_r+0x5a6>
   113ec:	cmp	r5, #16
   113ee:	ldr	r3, [sp, #144]	; 0x90
   113f0:	ldr	r7, [pc, #752]	; (116e4 <_svfprintf_r+0x828>)
   113f2:	ble.n	1143c <_svfprintf_r+0x580>
   113f4:	mov	r2, r4
   113f6:	movs	r6, #16
   113f8:	ldr.w	fp, [sp, #40]	; 0x28
   113fc:	ldr	r4, [sp, #36]	; 0x24
   113fe:	b.n	1140a <_svfprintf_r+0x54e>
   11400:	subs	r5, #16
   11402:	cmp	r5, #16
   11404:	add.w	r9, r9, #8
   11408:	ble.n	1143a <_svfprintf_r+0x57e>
   1140a:	adds	r3, #1
   1140c:	ldr	r1, [pc, #724]	; (116e4 <_svfprintf_r+0x828>)
   1140e:	str	r3, [sp, #144]	; 0x90
   11410:	adds	r2, #16
   11412:	cmp	r3, #7
   11414:	str	r2, [sp, #148]	; 0x94
   11416:	stmia.w	r9, {r1, r6}
   1141a:	ble.n	11400 <_svfprintf_r+0x544>
   1141c:	add	r2, sp, #140	; 0x8c
   1141e:	mov	r1, r4
   11420:	mov	r0, fp
   11422:	bl	14018 <__ssprint_r>
   11426:	cmp	r0, #0
   11428:	bne.w	110ae <_svfprintf_r+0x1f2>
   1142c:	subs	r5, #16
   1142e:	cmp	r5, #16
   11430:	ldr	r2, [sp, #148]	; 0x94
   11432:	ldr	r3, [sp, #144]	; 0x90
   11434:	add.w	r9, sp, #192	; 0xc0
   11438:	bgt.n	1140a <_svfprintf_r+0x54e>
   1143a:	mov	r4, r2
   1143c:	adds	r3, #1
   1143e:	add	r4, r5
   11440:	cmp	r3, #7
   11442:	str	r4, [sp, #148]	; 0x94
   11444:	str	r3, [sp, #144]	; 0x90
   11446:	str.w	r7, [r9]
   1144a:	str.w	r5, [r9, #4]
   1144e:	ble.n	11462 <_svfprintf_r+0x5a6>
   11450:	add	r2, sp, #140	; 0x8c
   11452:	ldr	r1, [sp, #36]	; 0x24
   11454:	ldr	r0, [sp, #40]	; 0x28
   11456:	bl	14018 <__ssprint_r>
   1145a:	cmp	r0, #0
   1145c:	bne.w	110ae <_svfprintf_r+0x1f2>
   11460:	ldr	r4, [sp, #148]	; 0x94
   11462:	ldr	r3, [sp, #44]	; 0x2c
   11464:	ldr	r2, [sp, #48]	; 0x30
   11466:	ldr	r1, [sp, #32]
   11468:	cmp	r2, r1
   1146a:	ite	ge
   1146c:	addge	r3, r3, r2
   1146e:	addlt	r3, r3, r1
   11470:	str	r3, [sp, #44]	; 0x2c
   11472:	cmp	r4, #0
   11474:	bne.w	11a20 <_svfprintf_r+0xb64>
   11478:	movs	r3, #0
   1147a:	str	r3, [sp, #144]	; 0x90
   1147c:	add.w	r9, sp, #192	; 0xc0
   11480:	b.n	10f08 <_svfprintf_r+0x4c>
   11482:	str	r3, [sp, #68]	; 0x44
   11484:	mov	fp, r5
   11486:	cmp	r2, #0
   11488:	bne.w	1252e <_svfprintf_r+0x1672>
   1148c:	ldr	r7, [sp, #56]	; 0x38
   1148e:	adds	r7, #7
   11490:	bic.w	r3, r7, #7
   11494:	add.w	r2, r3, #8
   11498:	str	r2, [sp, #56]	; 0x38
   1149a:	ldr	r2, [r3, #0]
   1149c:	str	r2, [sp, #80]	; 0x50
   1149e:	ldr	r3, [r3, #4]
   114a0:	str	r3, [sp, #84]	; 0x54
   114a2:	ldr	r3, [sp, #84]	; 0x54
   114a4:	ldr	r5, [sp, #80]	; 0x50
   114a6:	bic.w	r4, r3, #2147483648	; 0x80000000
   114aa:	mov	r0, r5
   114ac:	mov	r1, r4
   114ae:	mov.w	r2, #4294967295
   114b2:	ldr	r3, [pc, #564]	; (116e8 <_svfprintf_r+0x82c>)
   114b4:	bl	f3d8 <__aeabi_dcmpun>
   114b8:	cmp	r0, #0
   114ba:	bne.w	11e42 <_svfprintf_r+0xf86>
   114be:	mov	r0, r5
   114c0:	mov	r1, r4
   114c2:	mov.w	r2, #4294967295
   114c6:	ldr	r3, [pc, #544]	; (116e8 <_svfprintf_r+0x82c>)
   114c8:	bl	f39c <__aeabi_dcmple>
   114cc:	cmp	r0, #0
   114ce:	bne.w	11e42 <_svfprintf_r+0xf86>
   114d2:	ldr	r0, [sp, #80]	; 0x50
   114d4:	ldr	r1, [sp, #84]	; 0x54
   114d6:	movs	r2, #0
   114d8:	movs	r3, #0
   114da:	bl	f388 <__aeabi_dcmplt>
   114de:	cmp	r0, #0
   114e0:	bne.w	12382 <_svfprintf_r+0x14c6>
   114e4:	ldrb.w	r7, [sp, #111]	; 0x6f
   114e8:	ldr	r6, [pc, #512]	; (116ec <_svfprintf_r+0x830>)
   114ea:	ldr	r3, [pc, #516]	; (116f0 <_svfprintf_r+0x834>)
   114ec:	ldr	r1, [sp, #28]
   114ee:	bic.w	r1, r1, #128	; 0x80
   114f2:	str	r1, [sp, #28]
   114f4:	ldr	r1, [sp, #68]	; 0x44
   114f6:	movs	r2, #3
   114f8:	mov.w	fp, #0
   114fc:	str	r2, [sp, #32]
   114fe:	cmp	r1, #71	; 0x47
   11500:	it	le
   11502:	movle	r6, r3
   11504:	str	r2, [sp, #52]	; 0x34
   11506:	str.w	fp, [sp, #76]	; 0x4c
   1150a:	b.n	11248 <_svfprintf_r+0x38c>
   1150c:	ldr	r3, [sp, #28]
   1150e:	orr.w	r3, r3, #8
   11512:	str	r3, [sp, #28]
   11514:	ldrb.w	r3, [r8]
   11518:	b.n	10f6e <_svfprintf_r+0xb2>
   1151a:	str	r3, [sp, #68]	; 0x44
   1151c:	mov	fp, r5
   1151e:	cmp	r2, #0
   11520:	bne.w	12546 <_svfprintf_r+0x168a>
   11524:	ldr	r3, [sp, #28]
   11526:	orr.w	r3, r3, #16
   1152a:	str	r3, [sp, #28]
   1152c:	ldr	r2, [sp, #28]
   1152e:	ands.w	r3, r2, #32
   11532:	bne.w	110da <_svfprintf_r+0x21e>
   11536:	ldr	r1, [sp, #28]
   11538:	ands.w	r2, r1, #16
   1153c:	beq.w	11f98 <_svfprintf_r+0x10dc>
   11540:	ldr	r0, [sp, #56]	; 0x38
   11542:	strb.w	r3, [sp, #111]	; 0x6f
   11546:	cmp.w	fp, #0
   1154a:	ldr	r4, [r0, #0]
   1154c:	add.w	r7, r0, #4
   11550:	mov.w	r5, #0
   11554:	blt.w	11fe8 <_svfprintf_r+0x112c>
   11558:	mov	r2, r1
   1155a:	bic.w	r2, r2, #128	; 0x80
   1155e:	str	r2, [sp, #28]
   11560:	orrs.w	r2, r4, r5
   11564:	str	r7, [sp, #56]	; 0x38
   11566:	beq.w	117f0 <_svfprintf_r+0x934>
   1156a:	mov	r7, r3
   1156c:	b.n	11106 <_svfprintf_r+0x24a>
   1156e:	str	r3, [sp, #68]	; 0x44
   11570:	mov	fp, r5
   11572:	cmp	r2, #0
   11574:	bne.w	1253e <_svfprintf_r+0x1682>
   11578:	ldr	r3, [sp, #28]
   1157a:	orr.w	r3, r3, #16
   1157e:	str	r3, [sp, #28]
   11580:	ldr	r2, [sp, #28]
   11582:	ands.w	r3, r2, #32
   11586:	beq.w	11bee <_svfprintf_r+0xd32>
   1158a:	ldr	r7, [sp, #56]	; 0x38
   1158c:	adds	r7, #7
   1158e:	bic.w	r3, r7, #7
   11592:	movs	r7, #0
   11594:	add.w	r1, r3, #8
   11598:	cmp	fp, r7
   1159a:	str	r1, [sp, #56]	; 0x38
   1159c:	ldrd	r4, r5, [r3]
   115a0:	strb.w	r7, [sp, #111]	; 0x6f
   115a4:	blt.w	11c60 <_svfprintf_r+0xda4>
   115a8:	bic.w	r3, r2, #128	; 0x80
   115ac:	str	r3, [sp, #28]
   115ae:	orrs.w	r3, r4, r5
   115b2:	bne.w	11200 <_svfprintf_r+0x344>
   115b6:	cmp.w	fp, #0
   115ba:	beq.w	117ba <_svfprintf_r+0x8fe>
   115be:	movs	r4, #0
   115c0:	add	r6, sp, #256	; 0x100
   115c2:	adds	r4, #48	; 0x30
   115c4:	strb.w	r4, [r6, #-65]!
   115c8:	b.n	11234 <_svfprintf_r+0x378>
   115ca:	str	r3, [sp, #68]	; 0x44
   115cc:	mov	fp, r5
   115ce:	cmp	r2, #0
   115d0:	bne.w	12502 <_svfprintf_r+0x1646>
   115d4:	ldr	r3, [sp, #28]
   115d6:	ldr	r0, [pc, #284]	; (116f4 <_svfprintf_r+0x838>)
   115d8:	lsls	r5, r3, #26
   115da:	bpl.w	1170c <_svfprintf_r+0x850>
   115de:	ldr	r7, [sp, #56]	; 0x38
   115e0:	adds	r7, #7
   115e2:	bic.w	r3, r7, #7
   115e6:	ldrd	r4, r5, [r3]
   115ea:	add.w	r2, r3, #8
   115ee:	str	r2, [sp, #56]	; 0x38
   115f0:	ldr	r2, [sp, #28]
   115f2:	ands.w	r7, r2, #1
   115f6:	beq.w	11a7c <_svfprintf_r+0xbc0>
   115fa:	orrs.w	r3, r4, r5
   115fe:	beq.w	1200c <_svfprintf_r+0x1150>
   11602:	ldrb.w	r2, [sp, #68]	; 0x44
   11606:	strb.w	r2, [sp, #113]	; 0x71
   1160a:	movs	r7, #0
   1160c:	ldr	r2, [sp, #28]
   1160e:	strb.w	r7, [sp, #111]	; 0x6f
   11612:	movs	r3, #48	; 0x30
   11614:	cmp	fp, r7
   11616:	strb.w	r3, [sp, #112]	; 0x70
   1161a:	orr.w	r3, r2, #2
   1161e:	blt.w	1238c <_svfprintf_r+0x14d0>
   11622:	bic.w	r3, r2, #128	; 0x80
   11626:	orr.w	r3, r3, #2
   1162a:	str	r3, [sp, #28]
   1162c:	add	r6, sp, #192	; 0xc0
   1162e:	lsrs	r3, r4, #4
   11630:	and.w	r1, r4, #15
   11634:	orr.w	r3, r3, r5, lsl #28
   11638:	lsrs	r2, r5, #4
   1163a:	mov	r4, r3
   1163c:	mov	r5, r2
   1163e:	ldrb	r3, [r0, r1]
   11640:	strb.w	r3, [r6, #-1]!
   11644:	orrs.w	r3, r4, r5
   11648:	bne.n	1162e <_svfprintf_r+0x772>
   1164a:	b.n	11234 <_svfprintf_r+0x378>
   1164c:	ldr	r1, [sp, #56]	; 0x38
   1164e:	str	r3, [sp, #68]	; 0x44
   11650:	ldr	r2, [r1, #0]
   11652:	strb.w	r2, [sp, #152]	; 0x98
   11656:	movs	r3, #0
   11658:	mov	r2, r1
   1165a:	mov	r7, r3
   1165c:	strb.w	r3, [sp, #111]	; 0x6f
   11660:	adds	r2, #4
   11662:	movs	r3, #1
   11664:	str	r3, [sp, #32]
   11666:	mov	fp, r7
   11668:	str	r7, [sp, #76]	; 0x4c
   1166a:	str	r2, [sp, #56]	; 0x38
   1166c:	str	r3, [sp, #52]	; 0x34
   1166e:	add	r6, sp, #152	; 0x98
   11670:	b.n	11250 <_svfprintf_r+0x394>
   11672:	str	r3, [sp, #68]	; 0x44
   11674:	mov	fp, r5
   11676:	cmp	r2, #0
   11678:	beq.w	111bc <_svfprintf_r+0x300>
   1167c:	strb.w	r1, [sp, #111]	; 0x6f
   11680:	b.n	111bc <_svfprintf_r+0x300>
   11682:	ldr	r3, [sp, #28]
   11684:	orr.w	r3, r3, #64	; 0x40
   11688:	str	r3, [sp, #28]
   1168a:	ldrb.w	r3, [r8]
   1168e:	b.n	10f6e <_svfprintf_r+0xb2>
   11690:	ldrb.w	r3, [r8]
   11694:	cmp	r1, #0
   11696:	bne.w	10f6e <_svfprintf_r+0xb2>
   1169a:	movs	r2, #1
   1169c:	movs	r1, #32
   1169e:	b.n	10f6e <_svfprintf_r+0xb2>
   116a0:	ldr	r3, [sp, #28]
   116a2:	orr.w	r3, r3, #1
   116a6:	str	r3, [sp, #28]
   116a8:	ldrb.w	r3, [r8]
   116ac:	b.n	10f6e <_svfprintf_r+0xb2>
   116ae:	ldr	r4, [sp, #56]	; 0x38
   116b0:	ldr	r3, [r4, #0]
   116b2:	str	r3, [sp, #48]	; 0x30
   116b4:	mov	r0, r3
   116b6:	cmp	r0, #0
   116b8:	mov	r3, r4
   116ba:	add.w	r3, r3, #4
   116be:	blt.w	11032 <_svfprintf_r+0x176>
   116c2:	str	r3, [sp, #56]	; 0x38
   116c4:	ldrb.w	r3, [r8]
   116c8:	b.n	10f6e <_svfprintf_r+0xb2>
   116ca:	ldrb.w	r3, [r8]
   116ce:	movs	r2, #1
   116d0:	movs	r1, #43	; 0x2b
   116d2:	b.n	10f6e <_svfprintf_r+0xb2>
   116d4:	str	r3, [sp, #68]	; 0x44
   116d6:	mov	fp, r5
   116d8:	cmp	r2, #0
   116da:	beq.w	11580 <_svfprintf_r+0x6c4>
   116de:	strb.w	r1, [sp, #111]	; 0x6f
   116e2:	b.n	11580 <_svfprintf_r+0x6c4>
   116e4:	.word	0x00014950
   116e8:	.word	0x7fefffff
   116ec:	.word	0x00014914
   116f0:	.word	0x00014910
   116f4:	.word	0x00014920
   116f8:	str	r3, [sp, #68]	; 0x44
   116fa:	mov	fp, r5
   116fc:	cmp	r2, #0
   116fe:	bne.w	12556 <_svfprintf_r+0x169a>
   11702:	ldr	r3, [sp, #28]
   11704:	ldr	r0, [pc, #612]	; (1196c <_svfprintf_r+0xab0>)
   11706:	lsls	r5, r3, #26
   11708:	bmi.w	115de <_svfprintf_r+0x722>
   1170c:	ldr	r3, [sp, #28]
   1170e:	lsls	r4, r3, #27
   11710:	bpl.w	11f7e <_svfprintf_r+0x10c2>
   11714:	ldr	r2, [sp, #56]	; 0x38
   11716:	mov	r3, r2
   11718:	adds	r3, #4
   1171a:	ldr	r4, [r2, #0]
   1171c:	str	r3, [sp, #56]	; 0x38
   1171e:	movs	r5, #0
   11720:	b.n	115f0 <_svfprintf_r+0x734>
   11722:	ldrb.w	r3, [r8]
   11726:	cmp	r3, #108	; 0x6c
   11728:	beq.w	120f0 <_svfprintf_r+0x1234>
   1172c:	ldr	r0, [sp, #28]
   1172e:	orr.w	r0, r0, #16
   11732:	str	r0, [sp, #28]
   11734:	b.n	10f6e <_svfprintf_r+0xb2>
   11736:	cmp	r2, #0
   11738:	bne.w	1254e <_svfprintf_r+0x1692>
   1173c:	ldr	r3, [sp, #28]
   1173e:	lsls	r3, r3, #26
   11740:	bpl.w	11f50 <_svfprintf_r+0x1094>
   11744:	ldr	r2, [sp, #56]	; 0x38
   11746:	ldr	r1, [sp, #44]	; 0x2c
   11748:	ldr	r3, [r2, #0]
   1174a:	asrs	r5, r1, #31
   1174c:	mov	r0, r1
   1174e:	adds	r2, #4
   11750:	mov	r1, r5
   11752:	str	r2, [sp, #56]	; 0x38
   11754:	strd	r0, r1, [r3]
   11758:	b.w	10f08 <_svfprintf_r+0x4c>
   1175c:	ldr	r3, [sp, #28]
   1175e:	orr.w	r3, r3, #32
   11762:	str	r3, [sp, #28]
   11764:	ldrb.w	r3, [r8]
   11768:	b.n	10f6e <_svfprintf_r+0xb2>
   1176a:	ldr	r2, [sp, #56]	; 0x38
   1176c:	str	r3, [sp, #68]	; 0x44
   1176e:	ldr	r6, [r2, #0]
   11770:	movs	r4, #0
   11772:	strb.w	r4, [sp, #111]	; 0x6f
   11776:	adds	r7, r2, #4
   11778:	cmp	r6, #0
   1177a:	beq.w	12318 <_svfprintf_r+0x145c>
   1177e:	cmp	r5, #0
   11780:	blt.w	121b4 <_svfprintf_r+0x12f8>
   11784:	mov	r2, r5
   11786:	mov	r1, r4
   11788:	mov	r0, r6
   1178a:	bl	10510 <memchr>
   1178e:	cmp	r0, #0
   11790:	beq.w	123e8 <_svfprintf_r+0x152c>
   11794:	subs	r3, r0, r6
   11796:	str	r3, [sp, #52]	; 0x34
   11798:	mov	fp, r4
   1179a:	bic.w	r3, r3, r3, asr #31
   1179e:	str	r7, [sp, #56]	; 0x38
   117a0:	str	r3, [sp, #32]
   117a2:	str.w	fp, [sp, #76]	; 0x4c
   117a6:	ldrb.w	r7, [sp, #111]	; 0x6f
   117aa:	b.n	11248 <_svfprintf_r+0x38c>
   117ac:	ldr	r0, [pc, #444]	; (1196c <_svfprintf_r+0xab0>)
   117ae:	str	r2, [sp, #68]	; 0x44
   117b0:	cmp.w	fp, #0
   117b4:	bne.w	11a9e <_svfprintf_r+0xbe2>
   117b8:	mov	r7, fp
   117ba:	mov.w	fp, #0
   117be:	str.w	fp, [sp, #52]	; 0x34
   117c2:	add	r6, sp, #192	; 0xc0
   117c4:	b.n	1123a <_svfprintf_r+0x37e>
   117c6:	str	r3, [sp, #68]	; 0x44
   117c8:	cmp	r2, #0
   117ca:	bne.w	12526 <_svfprintf_r+0x166a>
   117ce:	ldr	r2, [sp, #68]	; 0x44
   117d0:	cmp	r2, #0
   117d2:	beq.w	110a0 <_svfprintf_r+0x1e4>
   117d6:	movs	r3, #0
   117d8:	movs	r1, #1
   117da:	mov	r7, r3
   117dc:	str	r1, [sp, #32]
   117de:	strb.w	r2, [sp, #152]	; 0x98
   117e2:	strb.w	r3, [sp, #111]	; 0x6f
   117e6:	mov	fp, r3
   117e8:	str	r3, [sp, #76]	; 0x4c
   117ea:	str	r1, [sp, #52]	; 0x34
   117ec:	add	r6, sp, #152	; 0x98
   117ee:	b.n	11250 <_svfprintf_r+0x394>
   117f0:	cmp.w	fp, #0
   117f4:	beq.w	123fe <_svfprintf_r+0x1542>
   117f8:	movs	r7, #0
   117fa:	movs	r4, #0
   117fc:	movs	r5, #0
   117fe:	b.n	11106 <_svfprintf_r+0x24a>
   11800:	ldr	r0, [pc, #360]	; (1196c <_svfprintf_r+0xab0>)
   11802:	str	r3, [sp, #28]
   11804:	str	r2, [sp, #68]	; 0x44
   11806:	orrs.w	r3, r4, r5
   1180a:	str	r7, [sp, #56]	; 0x38
   1180c:	mov.w	r7, #0
   11810:	bne.w	1162c <_svfprintf_r+0x770>
   11814:	movs	r4, #0
   11816:	movs	r5, #0
   11818:	b.n	1162c <_svfprintf_r+0x770>
   1181a:	ldr	r4, [sp, #148]	; 0x94
   1181c:	b.n	112f0 <_svfprintf_r+0x434>
   1181e:	ldr	r3, [sp, #68]	; 0x44
   11820:	cmp	r3, #101	; 0x65
   11822:	ble.w	11978 <_svfprintf_r+0xabc>
   11826:	ldr	r0, [sp, #80]	; 0x50
   11828:	ldr	r1, [sp, #84]	; 0x54
   1182a:	movs	r2, #0
   1182c:	movs	r3, #0
   1182e:	bl	f374 <__aeabi_dcmpeq>
   11832:	cmp	r0, #0
   11834:	beq.w	11aa2 <_svfprintf_r+0xbe6>
   11838:	ldr	r3, [sp, #144]	; 0x90
   1183a:	ldr	r2, [pc, #308]	; (11970 <_svfprintf_r+0xab4>)
   1183c:	str.w	r2, [r9]
   11840:	adds	r3, #1
   11842:	adds	r4, #1
   11844:	movs	r2, #1
   11846:	cmp	r3, #7
   11848:	str	r4, [sp, #148]	; 0x94
   1184a:	str	r3, [sp, #144]	; 0x90
   1184c:	str.w	r2, [r9, #4]
   11850:	bgt.w	12024 <_svfprintf_r+0x1168>
   11854:	add.w	r9, r9, #8
   11858:	ldr	r3, [sp, #116]	; 0x74
   1185a:	ldr	r2, [sp, #72]	; 0x48
   1185c:	cmp	r3, r2
   1185e:	blt.n	11868 <_svfprintf_r+0x9ac>
   11860:	ldr	r3, [sp, #28]
   11862:	lsls	r3, r3, #31
   11864:	bpl.w	113dc <_svfprintf_r+0x520>
   11868:	ldr	r3, [sp, #144]	; 0x90
   1186a:	ldr	r1, [sp, #88]	; 0x58
   1186c:	ldr	r2, [sp, #92]	; 0x5c
   1186e:	str.w	r2, [r9]
   11872:	adds	r3, #1
   11874:	add	r4, r1
   11876:	cmp	r3, #7
   11878:	str	r4, [sp, #148]	; 0x94
   1187a:	str.w	r1, [r9, #4]
   1187e:	str	r3, [sp, #144]	; 0x90
   11880:	bgt.w	12104 <_svfprintf_r+0x1248>
   11884:	add.w	r9, r9, #8
   11888:	ldr	r3, [sp, #72]	; 0x48
   1188a:	subs	r5, r3, #1
   1188c:	cmp	r5, #0
   1188e:	ble.w	113dc <_svfprintf_r+0x520>
   11892:	ldr	r2, [pc, #224]	; (11974 <_svfprintf_r+0xab8>)
   11894:	ldr	r3, [sp, #144]	; 0x90
   11896:	str	r2, [sp, #60]	; 0x3c
   11898:	cmp	r5, #16
   1189a:	ble.w	11c6a <_svfprintf_r+0xdae>
   1189e:	movs	r6, #16
   118a0:	ldr	r7, [sp, #40]	; 0x28
   118a2:	ldr.w	fp, [sp, #36]	; 0x24
   118a6:	b.n	118b4 <_svfprintf_r+0x9f8>
   118a8:	add.w	r9, r9, #8
   118ac:	subs	r5, #16
   118ae:	cmp	r5, #16
   118b0:	ble.w	11c6a <_svfprintf_r+0xdae>
   118b4:	adds	r3, #1
   118b6:	adds	r4, #16
   118b8:	cmp	r3, #7
   118ba:	str	r4, [sp, #148]	; 0x94
   118bc:	str	r3, [sp, #144]	; 0x90
   118be:	str.w	sl, [r9]
   118c2:	str.w	r6, [r9, #4]
   118c6:	ble.n	118a8 <_svfprintf_r+0x9ec>
   118c8:	add	r2, sp, #140	; 0x8c
   118ca:	mov	r1, fp
   118cc:	mov	r0, r7
   118ce:	bl	14018 <__ssprint_r>
   118d2:	cmp	r0, #0
   118d4:	bne.w	110ae <_svfprintf_r+0x1f2>
   118d8:	ldr	r4, [sp, #148]	; 0x94
   118da:	ldr	r3, [sp, #144]	; 0x90
   118dc:	add.w	r9, sp, #192	; 0xc0
   118e0:	b.n	118ac <_svfprintf_r+0x9f0>
   118e2:	ldr	r3, [sp, #48]	; 0x30
   118e4:	ldr	r2, [sp, #32]
   118e6:	subs	r7, r3, r2
   118e8:	cmp	r7, #0
   118ea:	ble.w	11338 <_svfprintf_r+0x47c>
   118ee:	ldr	r2, [pc, #132]	; (11974 <_svfprintf_r+0xab8>)
   118f0:	ldr	r3, [sp, #144]	; 0x90
   118f2:	str	r2, [sp, #60]	; 0x3c
   118f4:	cmp	r7, #16
   118f6:	ble.n	11950 <_svfprintf_r+0xa94>
   118f8:	mov	r2, r9
   118fa:	mov	r1, r4
   118fc:	mov	r9, r7
   118fe:	movs	r5, #16
   11900:	mov	r7, r6
   11902:	ldr	r4, [sp, #40]	; 0x28
   11904:	ldr	r6, [sp, #36]	; 0x24
   11906:	b.n	11916 <_svfprintf_r+0xa5a>
   11908:	sub.w	r9, r9, #16
   1190c:	cmp.w	r9, #16
   11910:	add.w	r2, r2, #8
   11914:	ble.n	11948 <_svfprintf_r+0xa8c>
   11916:	adds	r3, #1
   11918:	adds	r1, #16
   1191a:	cmp	r3, #7
   1191c:	str	r1, [sp, #148]	; 0x94
   1191e:	str	r3, [sp, #144]	; 0x90
   11920:	str.w	sl, [r2]
   11924:	str	r5, [r2, #4]
   11926:	ble.n	11908 <_svfprintf_r+0xa4c>
   11928:	add	r2, sp, #140	; 0x8c
   1192a:	mov	r1, r6
   1192c:	mov	r0, r4
   1192e:	bl	14018 <__ssprint_r>
   11932:	cmp	r0, #0
   11934:	bne.w	110ae <_svfprintf_r+0x1f2>
   11938:	sub.w	r9, r9, #16
   1193c:	cmp.w	r9, #16
   11940:	ldr	r1, [sp, #148]	; 0x94
   11942:	ldr	r3, [sp, #144]	; 0x90
   11944:	add	r2, sp, #192	; 0xc0
   11946:	bgt.n	11916 <_svfprintf_r+0xa5a>
   11948:	mov	r6, r7
   1194a:	mov	r4, r1
   1194c:	mov	r7, r9
   1194e:	mov	r9, r2
   11950:	adds	r3, #1
   11952:	ldr	r2, [sp, #60]	; 0x3c
   11954:	str	r3, [sp, #144]	; 0x90
   11956:	add	r4, r7
   11958:	cmp	r3, #7
   1195a:	str	r4, [sp, #148]	; 0x94
   1195c:	stmia.w	r9, {r2, r7}
   11960:	bgt.w	11dee <_svfprintf_r+0xf32>
   11964:	add.w	r9, r9, #8
   11968:	b.n	11338 <_svfprintf_r+0x47c>
   1196a:	nop
   1196c:	.word	0x00014934
   11970:	.word	0x00014798
   11974:	.word	0x00014900
   11978:	ldr	r3, [sp, #72]	; 0x48
   1197a:	ldr	r5, [sp, #144]	; 0x90
   1197c:	cmp	r3, #1
   1197e:	ble.w	11d92 <_svfprintf_r+0xed6>
   11982:	adds	r5, #1
   11984:	adds	r4, #1
   11986:	movs	r3, #1
   11988:	cmp	r5, #7
   1198a:	str	r4, [sp, #148]	; 0x94
   1198c:	str	r5, [sp, #144]	; 0x90
   1198e:	str.w	r6, [r9]
   11992:	str.w	r3, [r9, #4]
   11996:	bgt.w	11db4 <_svfprintf_r+0xef8>
   1199a:	add.w	r9, r9, #8
   1199e:	ldr	r2, [sp, #88]	; 0x58
   119a0:	ldr	r3, [sp, #92]	; 0x5c
   119a2:	str.w	r3, [r9]
   119a6:	adds	r5, #1
   119a8:	add	r4, r2
   119aa:	cmp	r5, #7
   119ac:	str	r4, [sp, #148]	; 0x94
   119ae:	str	r5, [sp, #144]	; 0x90
   119b0:	str.w	r2, [r9, #4]
   119b4:	bgt.w	11dd4 <_svfprintf_r+0xf18>
   119b8:	add.w	r9, r9, #8
   119bc:	movs	r3, #0
   119be:	ldr	r0, [sp, #80]	; 0x50
   119c0:	ldr	r1, [sp, #84]	; 0x54
   119c2:	movs	r2, #0
   119c4:	bl	f374 <__aeabi_dcmpeq>
   119c8:	ldr	r3, [sp, #72]	; 0x48
   119ca:	cmp	r0, #0
   119cc:	bne.w	11b56 <_svfprintf_r+0xc9a>
   119d0:	subs	r3, #1
   119d2:	adds	r5, #1
   119d4:	adds	r6, #1
   119d6:	add	r4, r3
   119d8:	cmp	r5, #7
   119da:	str	r5, [sp, #144]	; 0x90
   119dc:	str	r4, [sp, #148]	; 0x94
   119de:	str.w	r6, [r9]
   119e2:	str.w	r3, [r9, #4]
   119e6:	bgt.w	11bd4 <_svfprintf_r+0xd18>
   119ea:	add.w	r9, r9, #8
   119ee:	ldr	r2, [sp, #100]	; 0x64
   119f0:	str.w	r2, [r9, #4]
   119f4:	adds	r5, #1
   119f6:	add	r4, r2
   119f8:	add	r3, sp, #124	; 0x7c
   119fa:	cmp	r5, #7
   119fc:	str	r4, [sp, #148]	; 0x94
   119fe:	str	r5, [sp, #144]	; 0x90
   11a00:	str.w	r3, [r9]
   11a04:	ble.w	113d8 <_svfprintf_r+0x51c>
   11a08:	add	r2, sp, #140	; 0x8c
   11a0a:	ldr	r1, [sp, #36]	; 0x24
   11a0c:	ldr	r0, [sp, #40]	; 0x28
   11a0e:	bl	14018 <__ssprint_r>
   11a12:	cmp	r0, #0
   11a14:	bne.w	110ae <_svfprintf_r+0x1f2>
   11a18:	ldr	r4, [sp, #148]	; 0x94
   11a1a:	add.w	r9, sp, #192	; 0xc0
   11a1e:	b.n	113dc <_svfprintf_r+0x520>
   11a20:	add	r2, sp, #140	; 0x8c
   11a22:	ldr	r1, [sp, #36]	; 0x24
   11a24:	ldr	r0, [sp, #40]	; 0x28
   11a26:	bl	14018 <__ssprint_r>
   11a2a:	cmp	r0, #0
   11a2c:	beq.w	11478 <_svfprintf_r+0x5bc>
   11a30:	b.w	110ae <_svfprintf_r+0x1f2>
   11a34:	add	r2, sp, #140	; 0x8c
   11a36:	ldr	r1, [sp, #36]	; 0x24
   11a38:	ldr	r0, [sp, #40]	; 0x28
   11a3a:	bl	14018 <__ssprint_r>
   11a3e:	cmp	r0, #0
   11a40:	bne.w	110ae <_svfprintf_r+0x1f2>
   11a44:	ldr	r4, [sp, #148]	; 0x94
   11a46:	add.w	r9, sp, #192	; 0xc0
   11a4a:	b.n	113b6 <_svfprintf_r+0x4fa>
   11a4c:	add	r2, sp, #140	; 0x8c
   11a4e:	ldr	r1, [sp, #36]	; 0x24
   11a50:	ldr	r0, [sp, #40]	; 0x28
   11a52:	bl	14018 <__ssprint_r>
   11a56:	cmp	r0, #0
   11a58:	bne.w	110ae <_svfprintf_r+0x1f2>
   11a5c:	ldr	r4, [sp, #148]	; 0x94
   11a5e:	add.w	r9, sp, #192	; 0xc0
   11a62:	b.n	11310 <_svfprintf_r+0x454>
   11a64:	add	r2, sp, #140	; 0x8c
   11a66:	ldr	r1, [sp, #36]	; 0x24
   11a68:	ldr	r0, [sp, #40]	; 0x28
   11a6a:	bl	14018 <__ssprint_r>
   11a6e:	cmp	r0, #0
   11a70:	bne.w	110ae <_svfprintf_r+0x1f2>
   11a74:	ldr	r4, [sp, #148]	; 0x94
   11a76:	add.w	r9, sp, #192	; 0xc0
   11a7a:	b.n	11330 <_svfprintf_r+0x474>
   11a7c:	cmp.w	fp, #0
   11a80:	strb.w	r7, [sp, #111]	; 0x6f
   11a84:	blt.w	1203c <_svfprintf_r+0x1180>
   11a88:	bic.w	r3, r2, #128	; 0x80
   11a8c:	str	r3, [sp, #28]
   11a8e:	orrs.w	r3, r4, r5
   11a92:	bne.w	1162c <_svfprintf_r+0x770>
   11a96:	cmp.w	fp, #0
   11a9a:	beq.w	117b8 <_svfprintf_r+0x8fc>
   11a9e:	movs	r7, #0
   11aa0:	b.n	11814 <_svfprintf_r+0x958>
   11aa2:	ldr	r5, [sp, #116]	; 0x74
   11aa4:	cmp	r5, #0
   11aa6:	ble.w	12042 <_svfprintf_r+0x1186>
   11aaa:	ldr	r3, [sp, #76]	; 0x4c
   11aac:	ldr	r2, [sp, #72]	; 0x48
   11aae:	cmp	r3, r2
   11ab0:	it	ge
   11ab2:	movge	r3, r2
   11ab4:	cmp	r3, #0
   11ab6:	mov	r5, r3
   11ab8:	ble.n	11ad6 <_svfprintf_r+0xc1a>
   11aba:	ldr	r3, [sp, #144]	; 0x90
   11abc:	str.w	r6, [r9]
   11ac0:	adds	r3, #1
   11ac2:	add	r4, r5
   11ac4:	cmp	r3, #7
   11ac6:	str	r4, [sp, #148]	; 0x94
   11ac8:	str.w	r5, [r9, #4]
   11acc:	str	r3, [sp, #144]	; 0x90
   11ace:	bgt.w	12218 <_svfprintf_r+0x135c>
   11ad2:	add.w	r9, r9, #8
   11ad6:	ldr	r3, [sp, #76]	; 0x4c
   11ad8:	cmp	r5, #0
   11ada:	it	ge
   11adc:	subge	r3, r3, r5
   11ade:	cmp	r3, #0
   11ae0:	mov	r5, r3
   11ae2:	ble.w	11cd2 <_svfprintf_r+0xe16>
   11ae6:	ldr	r2, [pc, #744]	; (11dd0 <_svfprintf_r+0xf14>)
   11ae8:	ldr	r3, [sp, #144]	; 0x90
   11aea:	str	r2, [sp, #60]	; 0x3c
   11aec:	cmp	r5, #16
   11aee:	ble.w	11ff2 <_svfprintf_r+0x1136>
   11af2:	mov	r2, r4
   11af4:	movs	r7, #16
   11af6:	ldr.w	fp, [sp, #40]	; 0x28
   11afa:	ldr	r4, [sp, #36]	; 0x24
   11afc:	b.n	11b0a <_svfprintf_r+0xc4e>
   11afe:	add.w	r9, r9, #8
   11b02:	subs	r5, #16
   11b04:	cmp	r5, #16
   11b06:	ble.w	11ff0 <_svfprintf_r+0x1134>
   11b0a:	adds	r3, #1
   11b0c:	adds	r2, #16
   11b0e:	cmp	r3, #7
   11b10:	str	r2, [sp, #148]	; 0x94
   11b12:	str	r3, [sp, #144]	; 0x90
   11b14:	str.w	sl, [r9]
   11b18:	str.w	r7, [r9, #4]
   11b1c:	ble.n	11afe <_svfprintf_r+0xc42>
   11b1e:	add	r2, sp, #140	; 0x8c
   11b20:	mov	r1, r4
   11b22:	mov	r0, fp
   11b24:	bl	14018 <__ssprint_r>
   11b28:	cmp	r0, #0
   11b2a:	bne.w	110ae <_svfprintf_r+0x1f2>
   11b2e:	ldr	r2, [sp, #148]	; 0x94
   11b30:	ldr	r3, [sp, #144]	; 0x90
   11b32:	add.w	r9, sp, #192	; 0xc0
   11b36:	b.n	11b02 <_svfprintf_r+0xc46>
   11b38:	add	r2, sp, #140	; 0x8c
   11b3a:	ldr	r1, [sp, #36]	; 0x24
   11b3c:	ldr	r0, [sp, #40]	; 0x28
   11b3e:	bl	14018 <__ssprint_r>
   11b42:	cmp	r0, #0
   11b44:	bne.w	110ae <_svfprintf_r+0x1f2>
   11b48:	ldrb.w	r7, [sp, #111]	; 0x6f
   11b4c:	ldr	r4, [sp, #148]	; 0x94
   11b4e:	add.w	r9, sp, #192	; 0xc0
   11b52:	b.w	112f0 <_svfprintf_r+0x434>
   11b56:	subs	r6, r3, #1
   11b58:	cmp	r6, #0
   11b5a:	ble.w	119ee <_svfprintf_r+0xb32>
   11b5e:	ldr	r3, [pc, #624]	; (11dd0 <_svfprintf_r+0xf14>)
   11b60:	str	r3, [sp, #60]	; 0x3c
   11b62:	cmp	r6, #16
   11b64:	ble.n	11bc0 <_svfprintf_r+0xd04>
   11b66:	str.w	r8, [sp, #52]	; 0x34
   11b6a:	movs	r7, #16
   11b6c:	mov	r8, r6
   11b6e:	ldr.w	fp, [sp, #40]	; 0x28
   11b72:	ldr	r6, [sp, #36]	; 0x24
   11b74:	b.n	11b84 <_svfprintf_r+0xcc8>
   11b76:	sub.w	r8, r8, #16
   11b7a:	cmp.w	r8, #16
   11b7e:	add.w	r9, r9, #8
   11b82:	ble.n	11bba <_svfprintf_r+0xcfe>
   11b84:	adds	r5, #1
   11b86:	adds	r4, #16
   11b88:	cmp	r5, #7
   11b8a:	str	r4, [sp, #148]	; 0x94
   11b8c:	str	r5, [sp, #144]	; 0x90
   11b8e:	str.w	sl, [r9]
   11b92:	str.w	r7, [r9, #4]
   11b96:	ble.n	11b76 <_svfprintf_r+0xcba>
   11b98:	add	r2, sp, #140	; 0x8c
   11b9a:	mov	r1, r6
   11b9c:	mov	r0, fp
   11b9e:	bl	14018 <__ssprint_r>
   11ba2:	cmp	r0, #0
   11ba4:	bne.w	110ae <_svfprintf_r+0x1f2>
   11ba8:	sub.w	r8, r8, #16
   11bac:	cmp.w	r8, #16
   11bb0:	ldr	r4, [sp, #148]	; 0x94
   11bb2:	ldr	r5, [sp, #144]	; 0x90
   11bb4:	add.w	r9, sp, #192	; 0xc0
   11bb8:	bgt.n	11b84 <_svfprintf_r+0xcc8>
   11bba:	mov	r6, r8
   11bbc:	ldr.w	r8, [sp, #52]	; 0x34
   11bc0:	ldr	r3, [sp, #60]	; 0x3c
   11bc2:	adds	r5, #1
   11bc4:	add	r4, r6
   11bc6:	cmp	r5, #7
   11bc8:	str	r4, [sp, #148]	; 0x94
   11bca:	str	r5, [sp, #144]	; 0x90
   11bcc:	stmia.w	r9, {r3, r6}
   11bd0:	ble.w	119ea <_svfprintf_r+0xb2e>
   11bd4:	add	r2, sp, #140	; 0x8c
   11bd6:	ldr	r1, [sp, #36]	; 0x24
   11bd8:	ldr	r0, [sp, #40]	; 0x28
   11bda:	bl	14018 <__ssprint_r>
   11bde:	cmp	r0, #0
   11be0:	bne.w	110ae <_svfprintf_r+0x1f2>
   11be4:	ldr	r4, [sp, #148]	; 0x94
   11be6:	ldr	r5, [sp, #144]	; 0x90
   11be8:	add.w	r9, sp, #192	; 0xc0
   11bec:	b.n	119ee <_svfprintf_r+0xb32>
   11bee:	ldr	r1, [sp, #28]
   11bf0:	ands.w	r2, r1, #16
   11bf4:	beq.w	11e08 <_svfprintf_r+0xf4c>
   11bf8:	ldr	r0, [sp, #56]	; 0x38
   11bfa:	strb.w	r3, [sp, #111]	; 0x6f
   11bfe:	cmp.w	fp, #0
   11c02:	ldr	r4, [r0, #0]
   11c04:	add.w	r7, r0, #4
   11c08:	mov.w	r5, #0
   11c0c:	blt.n	11c5c <_svfprintf_r+0xda0>
   11c0e:	mov	r2, r1
   11c10:	bic.w	r2, r2, #128	; 0x80
   11c14:	str	r2, [sp, #28]
   11c16:	orrs.w	r2, r4, r5
   11c1a:	str	r7, [sp, #56]	; 0x38
   11c1c:	mov	r7, r3
   11c1e:	bne.w	11200 <_svfprintf_r+0x344>
   11c22:	b.n	115b6 <_svfprintf_r+0x6fa>
   11c24:	ldr	r3, [sp, #28]
   11c26:	lsls	r1, r3, #27
   11c28:	bmi.n	11c80 <_svfprintf_r+0xdc4>
   11c2a:	ldr	r3, [sp, #28]
   11c2c:	lsls	r2, r3, #25
   11c2e:	bpl.n	11c80 <_svfprintf_r+0xdc4>
   11c30:	ldr	r1, [sp, #56]	; 0x38
   11c32:	ldrsh.w	r4, [r1]
   11c36:	adds	r1, #4
   11c38:	asrs	r5, r4, #31
   11c3a:	mov	r2, r4
   11c3c:	mov	r3, r5
   11c3e:	str	r1, [sp, #56]	; 0x38
   11c40:	b.w	111da <_svfprintf_r+0x31e>
   11c44:	ldr	r1, [sp, #56]	; 0x38
   11c46:	strb.w	r3, [sp, #111]	; 0x6f
   11c4a:	cmp.w	fp, #0
   11c4e:	ldr	r4, [r1, #0]
   11c50:	add.w	r7, r1, #4
   11c54:	mov.w	r5, #0
   11c58:	bge.w	120e6 <_svfprintf_r+0x122a>
   11c5c:	str	r7, [sp, #56]	; 0x38
   11c5e:	mov	r7, r3
   11c60:	orrs.w	r3, r4, r5
   11c64:	bne.w	11200 <_svfprintf_r+0x344>
   11c68:	b.n	115c0 <_svfprintf_r+0x704>
   11c6a:	adds	r3, #1
   11c6c:	ldr	r2, [sp, #60]	; 0x3c
   11c6e:	str	r3, [sp, #144]	; 0x90
   11c70:	add	r4, r5
   11c72:	cmp	r3, #7
   11c74:	str	r4, [sp, #148]	; 0x94
   11c76:	stmia.w	r9, {r2, r5}
   11c7a:	ble.w	113d8 <_svfprintf_r+0x51c>
   11c7e:	b.n	11a08 <_svfprintf_r+0xb4c>
   11c80:	ldr	r2, [sp, #56]	; 0x38
   11c82:	ldr	r4, [r2, #0]
   11c84:	mov	r3, r2
   11c86:	adds	r3, #4
   11c88:	asrs	r5, r4, #31
   11c8a:	mov	r2, r4
   11c8c:	str	r3, [sp, #56]	; 0x38
   11c8e:	cmp	r2, #0
   11c90:	mov	r3, r5
   11c92:	sbcs.w	r3, r3, #0
   11c96:	bge.w	111e4 <_svfprintf_r+0x328>
   11c9a:	negs	r4, r4
   11c9c:	mov.w	r7, #45	; 0x2d
   11ca0:	sbc.w	r5, r5, r5, lsl #1
   11ca4:	cmp.w	fp, #0
   11ca8:	strb.w	r7, [sp, #111]	; 0x6f
   11cac:	blt.w	11200 <_svfprintf_r+0x344>
   11cb0:	ldr	r3, [sp, #28]
   11cb2:	bic.w	r3, r3, #128	; 0x80
   11cb6:	str	r3, [sp, #28]
   11cb8:	b.w	11200 <_svfprintf_r+0x344>
   11cbc:	add	r2, sp, #140	; 0x8c
   11cbe:	ldr	r1, [sp, #36]	; 0x24
   11cc0:	ldr	r0, [sp, #40]	; 0x28
   11cc2:	bl	14018 <__ssprint_r>
   11cc6:	cmp	r0, #0
   11cc8:	bne.w	110ae <_svfprintf_r+0x1f2>
   11ccc:	ldr	r4, [sp, #148]	; 0x94
   11cce:	add.w	r9, sp, #192	; 0xc0
   11cd2:	ldr	r2, [sp, #76]	; 0x4c
   11cd4:	ldr	r3, [sp, #116]	; 0x74
   11cd6:	add	r2, r6
   11cd8:	mov	r7, r2
   11cda:	ldr	r2, [sp, #72]	; 0x48
   11cdc:	cmp	r3, r2
   11cde:	blt.n	11d70 <_svfprintf_r+0xeb4>
   11ce0:	ldr	r2, [sp, #28]
   11ce2:	lsls	r5, r2, #31
   11ce4:	bmi.n	11d70 <_svfprintf_r+0xeb4>
   11ce6:	ldr	r1, [sp, #72]	; 0x48
   11ce8:	add	r6, r1
   11cea:	subs	r5, r6, r7
   11cec:	subs	r3, r1, r3
   11cee:	cmp	r5, r3
   11cf0:	it	ge
   11cf2:	movge	r5, r3
   11cf4:	cmp	r5, #0
   11cf6:	mov	r6, r5
   11cf8:	ble.n	11d16 <_svfprintf_r+0xe5a>
   11cfa:	ldr	r2, [sp, #144]	; 0x90
   11cfc:	str.w	r7, [r9]
   11d00:	adds	r2, #1
   11d02:	add	r4, r5
   11d04:	cmp	r2, #7
   11d06:	str	r4, [sp, #148]	; 0x94
   11d08:	str.w	r5, [r9, #4]
   11d0c:	str	r2, [sp, #144]	; 0x90
   11d0e:	bgt.w	12336 <_svfprintf_r+0x147a>
   11d12:	add.w	r9, r9, #8
   11d16:	cmp	r6, #0
   11d18:	ite	ge
   11d1a:	subge	r5, r3, r6
   11d1c:	movlt	r5, r3
   11d1e:	cmp	r5, #0
   11d20:	ble.w	113dc <_svfprintf_r+0x520>
   11d24:	ldr	r2, [pc, #168]	; (11dd0 <_svfprintf_r+0xf14>)
   11d26:	ldr	r3, [sp, #144]	; 0x90
   11d28:	str	r2, [sp, #60]	; 0x3c
   11d2a:	cmp	r5, #16
   11d2c:	ble.n	11c6a <_svfprintf_r+0xdae>
   11d2e:	movs	r6, #16
   11d30:	ldr	r7, [sp, #40]	; 0x28
   11d32:	ldr.w	fp, [sp, #36]	; 0x24
   11d36:	b.n	11d42 <_svfprintf_r+0xe86>
   11d38:	add.w	r9, r9, #8
   11d3c:	subs	r5, #16
   11d3e:	cmp	r5, #16
   11d40:	ble.n	11c6a <_svfprintf_r+0xdae>
   11d42:	adds	r3, #1
   11d44:	adds	r4, #16
   11d46:	cmp	r3, #7
   11d48:	str	r4, [sp, #148]	; 0x94
   11d4a:	str	r3, [sp, #144]	; 0x90
   11d4c:	str.w	sl, [r9]
   11d50:	str.w	r6, [r9, #4]
   11d54:	ble.n	11d38 <_svfprintf_r+0xe7c>
   11d56:	add	r2, sp, #140	; 0x8c
   11d58:	mov	r1, fp
   11d5a:	mov	r0, r7
   11d5c:	bl	14018 <__ssprint_r>
   11d60:	cmp	r0, #0
   11d62:	bne.w	110ae <_svfprintf_r+0x1f2>
   11d66:	ldr	r4, [sp, #148]	; 0x94
   11d68:	ldr	r3, [sp, #144]	; 0x90
   11d6a:	add.w	r9, sp, #192	; 0xc0
   11d6e:	b.n	11d3c <_svfprintf_r+0xe80>
   11d70:	ldr	r2, [sp, #144]	; 0x90
   11d72:	ldr	r0, [sp, #88]	; 0x58
   11d74:	ldr	r1, [sp, #92]	; 0x5c
   11d76:	str.w	r1, [r9]
   11d7a:	adds	r2, #1
   11d7c:	add	r4, r0
   11d7e:	cmp	r2, #7
   11d80:	str	r4, [sp, #148]	; 0x94
   11d82:	str.w	r0, [r9, #4]
   11d86:	str	r2, [sp, #144]	; 0x90
   11d88:	bgt.w	122d6 <_svfprintf_r+0x141a>
   11d8c:	add.w	r9, r9, #8
   11d90:	b.n	11ce6 <_svfprintf_r+0xe2a>
   11d92:	ldr	r3, [sp, #28]
   11d94:	lsls	r0, r3, #31
   11d96:	bmi.w	11982 <_svfprintf_r+0xac6>
   11d9a:	adds	r5, #1
   11d9c:	adds	r4, #1
   11d9e:	movs	r3, #1
   11da0:	cmp	r5, #7
   11da2:	str	r4, [sp, #148]	; 0x94
   11da4:	str	r5, [sp, #144]	; 0x90
   11da6:	str.w	r6, [r9]
   11daa:	str.w	r3, [r9, #4]
   11dae:	ble.w	119ea <_svfprintf_r+0xb2e>
   11db2:	b.n	11bd4 <_svfprintf_r+0xd18>
   11db4:	add	r2, sp, #140	; 0x8c
   11db6:	ldr	r1, [sp, #36]	; 0x24
   11db8:	ldr	r0, [sp, #40]	; 0x28
   11dba:	bl	14018 <__ssprint_r>
   11dbe:	cmp	r0, #0
   11dc0:	bne.w	110ae <_svfprintf_r+0x1f2>
   11dc4:	ldr	r4, [sp, #148]	; 0x94
   11dc6:	ldr	r5, [sp, #144]	; 0x90
   11dc8:	add.w	r9, sp, #192	; 0xc0
   11dcc:	b.n	1199e <_svfprintf_r+0xae2>
   11dce:	nop
   11dd0:	.word	0x00014900
   11dd4:	add	r2, sp, #140	; 0x8c
   11dd6:	ldr	r1, [sp, #36]	; 0x24
   11dd8:	ldr	r0, [sp, #40]	; 0x28
   11dda:	bl	14018 <__ssprint_r>
   11dde:	cmp	r0, #0
   11de0:	bne.w	110ae <_svfprintf_r+0x1f2>
   11de4:	ldr	r4, [sp, #148]	; 0x94
   11de6:	ldr	r5, [sp, #144]	; 0x90
   11de8:	add.w	r9, sp, #192	; 0xc0
   11dec:	b.n	119bc <_svfprintf_r+0xb00>
   11dee:	add	r2, sp, #140	; 0x8c
   11df0:	ldr	r1, [sp, #36]	; 0x24
   11df2:	ldr	r0, [sp, #40]	; 0x28
   11df4:	bl	14018 <__ssprint_r>
   11df8:	cmp	r0, #0
   11dfa:	bne.w	110ae <_svfprintf_r+0x1f2>
   11dfe:	ldr	r4, [sp, #148]	; 0x94
   11e00:	add.w	r9, sp, #192	; 0xc0
   11e04:	b.w	11338 <_svfprintf_r+0x47c>
   11e08:	ldr	r1, [sp, #28]
   11e0a:	ands.w	r3, r1, #64	; 0x40
   11e0e:	beq.w	11c44 <_svfprintf_r+0xd88>
   11e12:	ldr	r0, [sp, #56]	; 0x38
   11e14:	strb.w	r2, [sp, #111]	; 0x6f
   11e18:	mov	r3, r0
   11e1a:	cmp.w	fp, #0
   11e1e:	add.w	r3, r3, #4
   11e22:	ldrh	r4, [r0, #0]
   11e24:	mov.w	r5, #0
   11e28:	blt.w	1219e <_svfprintf_r+0x12e2>
   11e2c:	bic.w	r1, r1, #128	; 0x80
   11e30:	str	r1, [sp, #28]
   11e32:	orrs.w	r1, r4, r5
   11e36:	str	r3, [sp, #56]	; 0x38
   11e38:	mov	r7, r2
   11e3a:	bne.w	11200 <_svfprintf_r+0x344>
   11e3e:	b.w	115b6 <_svfprintf_r+0x6fa>
   11e42:	ldr	r4, [sp, #80]	; 0x50
   11e44:	mov	r2, r4
   11e46:	mov	r0, r4
   11e48:	ldr	r4, [sp, #84]	; 0x54
   11e4a:	mov	r3, r4
   11e4c:	mov	r1, r4
   11e4e:	bl	f3d8 <__aeabi_dcmpun>
   11e52:	cmp	r0, #0
   11e54:	bne.w	12482 <_svfprintf_r+0x15c6>
   11e58:	ldr	r3, [sp, #68]	; 0x44
   11e5a:	cmp.w	fp, #4294967295
   11e5e:	bic.w	r3, r3, #32
   11e62:	str	r3, [sp, #52]	; 0x34
   11e64:	beq.w	12354 <_svfprintf_r+0x1498>
   11e68:	cmp	r3, #71	; 0x47
   11e6a:	beq.w	12192 <_svfprintf_r+0x12d6>
   11e6e:	ldr	r3, [sp, #28]
   11e70:	orr.w	r3, r3, #256	; 0x100
   11e74:	str	r3, [sp, #64]	; 0x40
   11e76:	ldr	r3, [sp, #84]	; 0x54
   11e78:	subs	r7, r3, #0
   11e7a:	ldr	r3, [sp, #80]	; 0x50
   11e7c:	str	r3, [sp, #32]
   11e7e:	ittet	lt
   11e80:	movlt	r3, r7
   11e82:	addlt.w	r7, r3, #2147483648	; 0x80000000
   11e86:	movge	r3, #0
   11e88:	movlt	r3, #45	; 0x2d
   11e8a:	str	r3, [sp, #60]	; 0x3c
   11e8c:	ldr	r3, [sp, #68]	; 0x44
   11e8e:	cmp	r3, #102	; 0x66
   11e90:	beq.w	1235a <_svfprintf_r+0x149e>
   11e94:	cmp	r3, #70	; 0x46
   11e96:	beq.w	12156 <_svfprintf_r+0x129a>
   11e9a:	ldr	r3, [sp, #52]	; 0x34
   11e9c:	ldr	r2, [sp, #32]
   11e9e:	cmp	r3, #69	; 0x45
   11ea0:	add	r0, sp, #132	; 0x84
   11ea2:	add	r1, sp, #120	; 0x78
   11ea4:	ite	eq
   11ea6:	addeq.w	r5, fp, #1
   11eaa:	movne	r5, fp
   11eac:	str	r0, [sp, #16]
   11eae:	str	r1, [sp, #12]
   11eb0:	add	r0, sp, #116	; 0x74
   11eb2:	movs	r1, #2
   11eb4:	mov	r3, r7
   11eb6:	str	r0, [sp, #8]
   11eb8:	str	r5, [sp, #4]
   11eba:	str	r1, [sp, #0]
   11ebc:	ldr	r0, [sp, #40]	; 0x28
   11ebe:	bl	12808 <_dtoa_r>
   11ec2:	ldr	r3, [sp, #68]	; 0x44
   11ec4:	cmp	r3, #103	; 0x67
   11ec6:	mov	r6, r0
   11ec8:	bne.w	123c6 <_svfprintf_r+0x150a>
   11ecc:	ldr	r3, [sp, #28]
   11ece:	lsls	r2, r3, #31
   11ed0:	bpl.w	12452 <_svfprintf_r+0x1596>
   11ed4:	adds	r4, r6, r5
   11ed6:	ldr	r0, [sp, #32]
   11ed8:	mov	r1, r7
   11eda:	movs	r2, #0
   11edc:	movs	r3, #0
   11ede:	bl	f374 <__aeabi_dcmpeq>
   11ee2:	cmp	r0, #0
   11ee4:	bne.w	12230 <_svfprintf_r+0x1374>
   11ee8:	ldr	r3, [sp, #132]	; 0x84
   11eea:	cmp	r4, r3
   11eec:	bls.n	11efc <_svfprintf_r+0x1040>
   11eee:	movs	r1, #48	; 0x30
   11ef0:	adds	r2, r3, #1
   11ef2:	str	r2, [sp, #132]	; 0x84
   11ef4:	strb	r1, [r3, #0]
   11ef6:	ldr	r3, [sp, #132]	; 0x84
   11ef8:	cmp	r4, r3
   11efa:	bhi.n	11ef0 <_svfprintf_r+0x1034>
   11efc:	subs	r3, r3, r6
   11efe:	str	r3, [sp, #72]	; 0x48
   11f00:	ldr	r3, [sp, #52]	; 0x34
   11f02:	cmp	r3, #71	; 0x47
   11f04:	beq.w	1220a <_svfprintf_r+0x134e>
   11f08:	ldr	r3, [sp, #68]	; 0x44
   11f0a:	cmp	r3, #101	; 0x65
   11f0c:	ble.w	123e4 <_svfprintf_r+0x1528>
   11f10:	ldr	r3, [sp, #68]	; 0x44
   11f12:	cmp	r3, #102	; 0x66
   11f14:	ldr	r3, [sp, #116]	; 0x74
   11f16:	str	r3, [sp, #76]	; 0x4c
   11f18:	beq.w	123aa <_svfprintf_r+0x14ee>
   11f1c:	ldr	r2, [sp, #76]	; 0x4c
   11f1e:	ldr	r1, [sp, #72]	; 0x48
   11f20:	cmp	r2, r1
   11f22:	blt.w	12392 <_svfprintf_r+0x14d6>
   11f26:	ldr	r3, [sp, #28]
   11f28:	lsls	r1, r3, #31
   11f2a:	bmi.w	12440 <_svfprintf_r+0x1584>
   11f2e:	bic.w	r3, r2, r2, asr #31
   11f32:	str	r2, [sp, #52]	; 0x34
   11f34:	movs	r2, #103	; 0x67
   11f36:	str	r2, [sp, #68]	; 0x44
   11f38:	ldr	r2, [sp, #60]	; 0x3c
   11f3a:	cmp	r2, #0
   11f3c:	bne.w	121f6 <_svfprintf_r+0x133a>
   11f40:	str	r3, [sp, #32]
   11f42:	ldr	r3, [sp, #64]	; 0x40
   11f44:	str	r3, [sp, #28]
   11f46:	mov	fp, r2
   11f48:	ldrb.w	r7, [sp, #111]	; 0x6f
   11f4c:	b.w	11248 <_svfprintf_r+0x38c>
   11f50:	ldr	r3, [sp, #28]
   11f52:	lsls	r7, r3, #27
   11f54:	bmi.n	11f6e <_svfprintf_r+0x10b2>
   11f56:	ldr	r3, [sp, #28]
   11f58:	lsls	r6, r3, #25
   11f5a:	bpl.n	11f6e <_svfprintf_r+0x10b2>
   11f5c:	ldr	r2, [sp, #56]	; 0x38
   11f5e:	ldr	r3, [r2, #0]
   11f60:	adds	r2, #4
   11f62:	str	r2, [sp, #56]	; 0x38
   11f64:	ldrh.w	r2, [sp, #44]	; 0x2c
   11f68:	strh	r2, [r3, #0]
   11f6a:	b.w	10f08 <_svfprintf_r+0x4c>
   11f6e:	ldr	r2, [sp, #56]	; 0x38
   11f70:	ldr	r3, [r2, #0]
   11f72:	adds	r2, #4
   11f74:	str	r2, [sp, #56]	; 0x38
   11f76:	ldr	r2, [sp, #44]	; 0x2c
   11f78:	str	r2, [r3, #0]
   11f7a:	b.w	10f08 <_svfprintf_r+0x4c>
   11f7e:	ldr	r3, [sp, #28]
   11f80:	ldr	r2, [sp, #56]	; 0x38
   11f82:	tst.w	r3, #64	; 0x40
   11f86:	mov	r3, r2
   11f88:	beq.w	121a8 <_svfprintf_r+0x12ec>
   11f8c:	adds	r3, #4
   11f8e:	ldrh	r4, [r2, #0]
   11f90:	str	r3, [sp, #56]	; 0x38
   11f92:	movs	r5, #0
   11f94:	b.w	115f0 <_svfprintf_r+0x734>
   11f98:	ldr	r1, [sp, #28]
   11f9a:	ands.w	r3, r1, #64	; 0x40
   11f9e:	beq.n	11fd0 <_svfprintf_r+0x1114>
   11fa0:	ldr	r0, [sp, #56]	; 0x38
   11fa2:	strb.w	r2, [sp, #111]	; 0x6f
   11fa6:	mov	r3, r0
   11fa8:	cmp.w	fp, #0
   11fac:	add.w	r3, r3, #4
   11fb0:	ldrh	r4, [r0, #0]
   11fb2:	mov.w	r5, #0
   11fb6:	blt.w	121a4 <_svfprintf_r+0x12e8>
   11fba:	bic.w	r1, r1, #128	; 0x80
   11fbe:	str	r1, [sp, #28]
   11fc0:	orrs.w	r1, r4, r5
   11fc4:	str	r3, [sp, #56]	; 0x38
   11fc6:	beq.w	117f0 <_svfprintf_r+0x934>
   11fca:	mov	r7, r2
   11fcc:	b.w	11106 <_svfprintf_r+0x24a>
   11fd0:	ldr	r1, [sp, #56]	; 0x38
   11fd2:	strb.w	r3, [sp, #111]	; 0x6f
   11fd6:	cmp.w	fp, #0
   11fda:	ldr	r4, [r1, #0]
   11fdc:	add.w	r7, r1, #4
   11fe0:	mov.w	r5, #0
   11fe4:	bge.w	120ea <_svfprintf_r+0x122e>
   11fe8:	str	r7, [sp, #56]	; 0x38
   11fea:	movs	r7, #0
   11fec:	b.w	11106 <_svfprintf_r+0x24a>
   11ff0:	mov	r4, r2
   11ff2:	adds	r3, #1
   11ff4:	ldr	r2, [sp, #60]	; 0x3c
   11ff6:	str	r3, [sp, #144]	; 0x90
   11ff8:	add	r4, r5
   11ffa:	cmp	r3, #7
   11ffc:	str	r4, [sp, #148]	; 0x94
   11ffe:	stmia.w	r9, {r2, r5}
   12002:	bgt.w	11cbc <_svfprintf_r+0xe00>
   12006:	add.w	r9, r9, #8
   1200a:	b.n	11cd2 <_svfprintf_r+0xe16>
   1200c:	movs	r7, #0
   1200e:	cmp	fp, r7
   12010:	strb.w	r7, [sp, #111]	; 0x6f
   12014:	blt.w	11814 <_svfprintf_r+0x958>
   12018:	ldr	r3, [sp, #28]
   1201a:	bic.w	r3, r3, #128	; 0x80
   1201e:	str	r3, [sp, #28]
   12020:	b.w	117b0 <_svfprintf_r+0x8f4>
   12024:	add	r2, sp, #140	; 0x8c
   12026:	ldr	r1, [sp, #36]	; 0x24
   12028:	ldr	r0, [sp, #40]	; 0x28
   1202a:	bl	14018 <__ssprint_r>
   1202e:	cmp	r0, #0
   12030:	bne.w	110ae <_svfprintf_r+0x1f2>
   12034:	ldr	r4, [sp, #148]	; 0x94
   12036:	add.w	r9, sp, #192	; 0xc0
   1203a:	b.n	11858 <_svfprintf_r+0x99c>
   1203c:	ldr	r7, [sp, #56]	; 0x38
   1203e:	b.w	11806 <_svfprintf_r+0x94a>
   12042:	ldr	r3, [sp, #144]	; 0x90
   12044:	ldr	r2, [pc, #708]	; (1230c <_svfprintf_r+0x1450>)
   12046:	str.w	r2, [r9]
   1204a:	adds	r3, #1
   1204c:	adds	r4, #1
   1204e:	movs	r2, #1
   12050:	cmp	r3, #7
   12052:	str	r4, [sp, #148]	; 0x94
   12054:	str	r3, [sp, #144]	; 0x90
   12056:	str.w	r2, [r9, #4]
   1205a:	bgt.n	1213c <_svfprintf_r+0x1280>
   1205c:	add.w	r9, r9, #8
   12060:	cbnz	r5, 1206e <_svfprintf_r+0x11b2>
   12062:	ldr	r3, [sp, #72]	; 0x48
   12064:	cbnz	r3, 1206e <_svfprintf_r+0x11b2>
   12066:	ldr	r3, [sp, #28]
   12068:	lsls	r7, r3, #31
   1206a:	bpl.w	113dc <_svfprintf_r+0x520>
   1206e:	ldr	r3, [sp, #144]	; 0x90
   12070:	ldr	r1, [sp, #88]	; 0x58
   12072:	ldr	r2, [sp, #92]	; 0x5c
   12074:	str.w	r2, [r9]
   12078:	adds	r3, #1
   1207a:	add	r4, r1
   1207c:	cmp	r3, #7
   1207e:	str	r4, [sp, #148]	; 0x94
   12080:	str.w	r1, [r9, #4]
   12084:	str	r3, [sp, #144]	; 0x90
   12086:	bgt.w	1241c <_svfprintf_r+0x1560>
   1208a:	add.w	r9, r9, #8
   1208e:	negs	r5, r5
   12090:	cmp	r5, #0
   12092:	ble.w	121dc <_svfprintf_r+0x1320>
   12096:	ldr	r2, [pc, #632]	; (12310 <_svfprintf_r+0x1454>)
   12098:	str	r2, [sp, #60]	; 0x3c
   1209a:	cmp	r5, #16
   1209c:	ble.w	122f2 <_svfprintf_r+0x1436>
   120a0:	mov	r2, r4
   120a2:	movs	r7, #16
   120a4:	ldr.w	fp, [sp, #40]	; 0x28
   120a8:	ldr	r4, [sp, #36]	; 0x24
   120aa:	b.n	120b8 <_svfprintf_r+0x11fc>
   120ac:	add.w	r9, r9, #8
   120b0:	subs	r5, #16
   120b2:	cmp	r5, #16
   120b4:	ble.w	122f0 <_svfprintf_r+0x1434>
   120b8:	adds	r3, #1
   120ba:	adds	r2, #16
   120bc:	cmp	r3, #7
   120be:	str	r2, [sp, #148]	; 0x94
   120c0:	str	r3, [sp, #144]	; 0x90
   120c2:	str.w	sl, [r9]
   120c6:	str.w	r7, [r9, #4]
   120ca:	ble.n	120ac <_svfprintf_r+0x11f0>
   120cc:	add	r2, sp, #140	; 0x8c
   120ce:	mov	r1, r4
   120d0:	mov	r0, fp
   120d2:	bl	14018 <__ssprint_r>
   120d6:	cmp	r0, #0
   120d8:	bne.w	110ae <_svfprintf_r+0x1f2>
   120dc:	ldr	r2, [sp, #148]	; 0x94
   120de:	ldr	r3, [sp, #144]	; 0x90
   120e0:	add.w	r9, sp, #192	; 0xc0
   120e4:	b.n	120b0 <_svfprintf_r+0x11f4>
   120e6:	ldr	r2, [sp, #28]
   120e8:	b.n	11c10 <_svfprintf_r+0xd54>
   120ea:	ldr	r2, [sp, #28]
   120ec:	b.w	1155a <_svfprintf_r+0x69e>
   120f0:	ldr	r3, [sp, #28]
   120f2:	orr.w	r3, r3, #32
   120f6:	str	r3, [sp, #28]
   120f8:	add.w	r8, r8, #1
   120fc:	ldrb.w	r3, [r8]
   12100:	b.w	10f6e <_svfprintf_r+0xb2>
   12104:	add	r2, sp, #140	; 0x8c
   12106:	ldr	r1, [sp, #36]	; 0x24
   12108:	ldr	r0, [sp, #40]	; 0x28
   1210a:	bl	14018 <__ssprint_r>
   1210e:	cmp	r0, #0
   12110:	bne.w	110ae <_svfprintf_r+0x1f2>
   12114:	ldr	r4, [sp, #148]	; 0x94
   12116:	add.w	r9, sp, #192	; 0xc0
   1211a:	b.w	11888 <_svfprintf_r+0x9cc>
   1211e:	movs	r1, #64	; 0x40
   12120:	ldr	r0, [sp, #40]	; 0x28
   12122:	bl	ff74 <_malloc_r>
   12126:	ldr	r2, [sp, #36]	; 0x24
   12128:	str	r0, [r2, #0]
   1212a:	str	r0, [r2, #16]
   1212c:	cmp	r0, #0
   1212e:	beq.w	12518 <_svfprintf_r+0x165c>
   12132:	ldr	r2, [sp, #36]	; 0x24
   12134:	movs	r3, #64	; 0x40
   12136:	str	r3, [r2, #20]
   12138:	b.w	10eea <_svfprintf_r+0x2e>
   1213c:	add	r2, sp, #140	; 0x8c
   1213e:	ldr	r1, [sp, #36]	; 0x24
   12140:	ldr	r0, [sp, #40]	; 0x28
   12142:	bl	14018 <__ssprint_r>
   12146:	cmp	r0, #0
   12148:	bne.w	110ae <_svfprintf_r+0x1f2>
   1214c:	ldr	r5, [sp, #116]	; 0x74
   1214e:	ldr	r4, [sp, #148]	; 0x94
   12150:	add.w	r9, sp, #192	; 0xc0
   12154:	b.n	12060 <_svfprintf_r+0x11a4>
   12156:	add	r0, sp, #132	; 0x84
   12158:	add	r1, sp, #120	; 0x78
   1215a:	str	r0, [sp, #16]
   1215c:	str	r1, [sp, #12]
   1215e:	add	r0, sp, #116	; 0x74
   12160:	movs	r1, #3
   12162:	str	r0, [sp, #8]
   12164:	ldr	r2, [sp, #32]
   12166:	str.w	fp, [sp, #4]
   1216a:	mov	r3, r7
   1216c:	str	r1, [sp, #0]
   1216e:	ldr	r0, [sp, #40]	; 0x28
   12170:	bl	12808 <_dtoa_r>
   12174:	mov	r5, fp
   12176:	mov	r6, r0
   12178:	ldr	r3, [sp, #68]	; 0x44
   1217a:	cmp	r3, #70	; 0x46
   1217c:	add.w	r4, r6, r5
   12180:	bne.w	11ed6 <_svfprintf_r+0x101a>
   12184:	ldrb	r3, [r6, #0]
   12186:	cmp	r3, #48	; 0x30
   12188:	beq.w	12466 <_svfprintf_r+0x15aa>
   1218c:	ldr	r5, [sp, #116]	; 0x74
   1218e:	add	r4, r5
   12190:	b.n	11ed6 <_svfprintf_r+0x101a>
   12192:	cmp.w	fp, #0
   12196:	it	eq
   12198:	moveq.w	fp, #1
   1219c:	b.n	11e6e <_svfprintf_r+0xfb2>
   1219e:	str	r3, [sp, #56]	; 0x38
   121a0:	mov	r7, r2
   121a2:	b.n	11c60 <_svfprintf_r+0xda4>
   121a4:	str	r3, [sp, #56]	; 0x38
   121a6:	b.n	11fea <_svfprintf_r+0x112e>
   121a8:	adds	r3, #4
   121aa:	ldr	r4, [r2, #0]
   121ac:	str	r3, [sp, #56]	; 0x38
   121ae:	movs	r5, #0
   121b0:	b.w	115f0 <_svfprintf_r+0x734>
   121b4:	mov	r0, r6
   121b6:	bl	10d40 <strlen>
   121ba:	mov	fp, r4
   121bc:	mov	r3, r0
   121be:	str	r0, [sp, #52]	; 0x34
   121c0:	b.w	1179a <_svfprintf_r+0x8de>
   121c4:	add	r2, sp, #140	; 0x8c
   121c6:	ldr	r1, [sp, #36]	; 0x24
   121c8:	ldr	r0, [sp, #40]	; 0x28
   121ca:	bl	14018 <__ssprint_r>
   121ce:	cmp	r0, #0
   121d0:	bne.w	110ae <_svfprintf_r+0x1f2>
   121d4:	ldr	r4, [sp, #148]	; 0x94
   121d6:	ldr	r3, [sp, #144]	; 0x90
   121d8:	add.w	r9, sp, #192	; 0xc0
   121dc:	ldr	r1, [sp, #72]	; 0x48
   121de:	str.w	r6, [r9]
   121e2:	adds	r3, #1
   121e4:	add	r4, r1
   121e6:	cmp	r3, #7
   121e8:	str	r4, [sp, #148]	; 0x94
   121ea:	str	r3, [sp, #144]	; 0x90
   121ec:	str.w	r1, [r9, #4]
   121f0:	ble.w	113d8 <_svfprintf_r+0x51c>
   121f4:	b.n	11a08 <_svfprintf_r+0xb4c>
   121f6:	movs	r7, #45	; 0x2d
   121f8:	str	r3, [sp, #32]
   121fa:	ldr	r3, [sp, #64]	; 0x40
   121fc:	str	r3, [sp, #28]
   121fe:	strb.w	r7, [sp, #111]	; 0x6f
   12202:	mov.w	fp, #0
   12206:	b.w	1124a <_svfprintf_r+0x38e>
   1220a:	ldr	r3, [sp, #116]	; 0x74
   1220c:	adds	r5, r3, #3
   1220e:	blt.n	12234 <_svfprintf_r+0x1378>
   12210:	cmp	fp, r3
   12212:	blt.n	12234 <_svfprintf_r+0x1378>
   12214:	str	r3, [sp, #76]	; 0x4c
   12216:	b.n	11f1c <_svfprintf_r+0x1060>
   12218:	add	r2, sp, #140	; 0x8c
   1221a:	ldr	r1, [sp, #36]	; 0x24
   1221c:	ldr	r0, [sp, #40]	; 0x28
   1221e:	bl	14018 <__ssprint_r>
   12222:	cmp	r0, #0
   12224:	bne.w	110ae <_svfprintf_r+0x1f2>
   12228:	ldr	r4, [sp, #148]	; 0x94
   1222a:	add.w	r9, sp, #192	; 0xc0
   1222e:	b.n	11ad6 <_svfprintf_r+0xc1a>
   12230:	mov	r3, r4
   12232:	b.n	11efc <_svfprintf_r+0x1040>
   12234:	ldr	r2, [sp, #68]	; 0x44
   12236:	subs	r2, #2
   12238:	str	r2, [sp, #68]	; 0x44
   1223a:	subs	r3, #1
   1223c:	cmp	r3, #0
   1223e:	ldrb.w	r2, [sp, #68]	; 0x44
   12242:	str	r3, [sp, #116]	; 0x74
   12244:	it	lt
   12246:	neglt	r3, r3
   12248:	strb.w	r2, [sp, #124]	; 0x7c
   1224c:	ite	lt
   1224e:	movlt	r2, #45	; 0x2d
   12250:	movge	r2, #43	; 0x2b
   12252:	cmp	r3, #9
   12254:	strb.w	r2, [sp, #125]	; 0x7d
   12258:	ble.w	12456 <_svfprintf_r+0x159a>
   1225c:	add.w	r0, sp, #139	; 0x8b
   12260:	mov	r4, r0
   12262:	ldr	r2, [pc, #176]	; (12314 <_svfprintf_r+0x1458>)
   12264:	smull	r2, r1, r2, r3
   12268:	asrs	r2, r3, #31
   1226a:	rsb	r2, r2, r1, asr #2
   1226e:	add.w	r1, r2, r2, lsl #2
   12272:	sub.w	r3, r3, r1, lsl #1
   12276:	add.w	r1, r3, #48	; 0x30
   1227a:	cmp	r2, #9
   1227c:	mov	r3, r2
   1227e:	strb.w	r1, [r4, #-1]!
   12282:	bgt.n	12262 <_svfprintf_r+0x13a6>
   12284:	mov	r1, r4
   12286:	adds	r3, #48	; 0x30
   12288:	uxtb	r2, r3
   1228a:	strb.w	r2, [r1, #-1]!
   1228e:	cmp	r0, r1
   12290:	bls.w	12512 <_svfprintf_r+0x1656>
   12294:	add.w	r1, sp, #126	; 0x7e
   12298:	mov	r3, r4
   1229a:	b.n	122a0 <_svfprintf_r+0x13e4>
   1229c:	ldrb.w	r2, [r3], #1
   122a0:	strb.w	r2, [r1], #1
   122a4:	cmp	r0, r3
   122a6:	bne.n	1229c <_svfprintf_r+0x13e0>
   122a8:	adds	r3, r0, #1
   122aa:	subs	r3, r3, r4
   122ac:	add.w	r2, sp, #126	; 0x7e
   122b0:	add	r3, r2
   122b2:	add	r2, sp, #124	; 0x7c
   122b4:	subs	r3, r3, r2
   122b6:	ldr	r2, [sp, #72]	; 0x48
   122b8:	str	r3, [sp, #100]	; 0x64
   122ba:	cmp	r2, #1
   122bc:	add	r3, r2
   122be:	str	r3, [sp, #52]	; 0x34
   122c0:	ble.w	124b0 <_svfprintf_r+0x15f4>
   122c4:	ldr	r3, [sp, #52]	; 0x34
   122c6:	ldr	r2, [sp, #88]	; 0x58
   122c8:	add	r3, r2
   122ca:	movs	r2, #0
   122cc:	str	r3, [sp, #52]	; 0x34
   122ce:	str	r2, [sp, #76]	; 0x4c
   122d0:	bic.w	r3, r3, r3, asr #31
   122d4:	b.n	11f38 <_svfprintf_r+0x107c>
   122d6:	add	r2, sp, #140	; 0x8c
   122d8:	ldr	r1, [sp, #36]	; 0x24
   122da:	ldr	r0, [sp, #40]	; 0x28
   122dc:	bl	14018 <__ssprint_r>
   122e0:	cmp	r0, #0
   122e2:	bne.w	110ae <_svfprintf_r+0x1f2>
   122e6:	ldr	r3, [sp, #116]	; 0x74
   122e8:	ldr	r4, [sp, #148]	; 0x94
   122ea:	add.w	r9, sp, #192	; 0xc0
   122ee:	b.n	11ce6 <_svfprintf_r+0xe2a>
   122f0:	mov	r4, r2
   122f2:	adds	r3, #1
   122f4:	ldr	r2, [sp, #60]	; 0x3c
   122f6:	str	r3, [sp, #144]	; 0x90
   122f8:	add	r4, r5
   122fa:	cmp	r3, #7
   122fc:	str	r4, [sp, #148]	; 0x94
   122fe:	stmia.w	r9, {r2, r5}
   12302:	bgt.w	121c4 <_svfprintf_r+0x1308>
   12306:	add.w	r9, r9, #8
   1230a:	b.n	121dc <_svfprintf_r+0x1320>
   1230c:	.word	0x00014798
   12310:	.word	0x00014900
   12314:	.word	0x66666667
   12318:	cmp	r5, #6
   1231a:	mov	r3, r5
   1231c:	it	cs
   1231e:	movcs	r3, #6
   12320:	str	r3, [sp, #52]	; 0x34
   12322:	bic.w	r3, r3, r3, asr #31
   12326:	mov	fp, r6
   12328:	str	r7, [sp, #56]	; 0x38
   1232a:	str	r6, [sp, #76]	; 0x4c
   1232c:	mov	r7, r6
   1232e:	str	r3, [sp, #32]
   12330:	ldr	r6, [pc, #556]	; (12560 <_svfprintf_r+0x16a4>)
   12332:	b.w	11248 <_svfprintf_r+0x38c>
   12336:	add	r2, sp, #140	; 0x8c
   12338:	ldr	r1, [sp, #36]	; 0x24
   1233a:	ldr	r0, [sp, #40]	; 0x28
   1233c:	bl	14018 <__ssprint_r>
   12340:	cmp	r0, #0
   12342:	bne.w	110ae <_svfprintf_r+0x1f2>
   12346:	ldr	r3, [sp, #116]	; 0x74
   12348:	ldr	r2, [sp, #72]	; 0x48
   1234a:	ldr	r4, [sp, #148]	; 0x94
   1234c:	subs	r3, r2, r3
   1234e:	add.w	r9, sp, #192	; 0xc0
   12352:	b.n	11d16 <_svfprintf_r+0xe5a>
   12354:	mov.w	fp, #6
   12358:	b.n	11e6e <_svfprintf_r+0xfb2>
   1235a:	add	r0, sp, #132	; 0x84
   1235c:	add	r1, sp, #120	; 0x78
   1235e:	str	r0, [sp, #16]
   12360:	str	r1, [sp, #12]
   12362:	add	r0, sp, #116	; 0x74
   12364:	movs	r1, #3
   12366:	str	r0, [sp, #8]
   12368:	ldr	r2, [sp, #32]
   1236a:	str.w	fp, [sp, #4]
   1236e:	mov	r3, r7
   12370:	str	r1, [sp, #0]
   12372:	ldr	r0, [sp, #40]	; 0x28
   12374:	bl	12808 <_dtoa_r>
   12378:	mov	r5, fp
   1237a:	mov	r6, r0
   1237c:	add.w	r4, r0, fp
   12380:	b.n	12184 <_svfprintf_r+0x12c8>
   12382:	movs	r7, #45	; 0x2d
   12384:	strb.w	r7, [sp, #111]	; 0x6f
   12388:	b.w	114e8 <_svfprintf_r+0x62c>
   1238c:	str	r3, [sp, #28]
   1238e:	b.w	1162c <_svfprintf_r+0x770>
   12392:	ldr	r2, [sp, #88]	; 0x58
   12394:	ldr	r3, [sp, #72]	; 0x48
   12396:	add	r3, r2
   12398:	ldr	r2, [sp, #76]	; 0x4c
   1239a:	str	r3, [sp, #52]	; 0x34
   1239c:	cmp	r2, #0
   1239e:	ble.n	124a0 <_svfprintf_r+0x15e4>
   123a0:	movs	r2, #103	; 0x67
   123a2:	bic.w	r3, r3, r3, asr #31
   123a6:	str	r2, [sp, #68]	; 0x44
   123a8:	b.n	11f38 <_svfprintf_r+0x107c>
   123aa:	cmp	r3, #0
   123ac:	ble.w	124e0 <_svfprintf_r+0x1624>
   123b0:	cmp.w	fp, #0
   123b4:	bne.n	1248e <_svfprintf_r+0x15d2>
   123b6:	ldr	r2, [sp, #28]
   123b8:	lsls	r4, r2, #31
   123ba:	bmi.n	1248e <_svfprintf_r+0x15d2>
   123bc:	mov	r2, r3
   123be:	str	r2, [sp, #52]	; 0x34
   123c0:	bic.w	r3, r3, r3, asr #31
   123c4:	b.n	11f38 <_svfprintf_r+0x107c>
   123c6:	ldr	r3, [sp, #68]	; 0x44
   123c8:	cmp	r3, #71	; 0x47
   123ca:	bne.w	11ed4 <_svfprintf_r+0x1018>
   123ce:	ldr	r3, [sp, #28]
   123d0:	lsls	r3, r3, #31
   123d2:	bmi.w	12178 <_svfprintf_r+0x12bc>
   123d6:	ldr	r3, [sp, #132]	; 0x84
   123d8:	subs	r3, r3, r6
   123da:	str	r3, [sp, #72]	; 0x48
   123dc:	ldr	r3, [sp, #52]	; 0x34
   123de:	cmp	r3, #71	; 0x47
   123e0:	beq.w	1220a <_svfprintf_r+0x134e>
   123e4:	ldr	r3, [sp, #116]	; 0x74
   123e6:	b.n	1223a <_svfprintf_r+0x137e>
   123e8:	bic.w	r3, r5, r5, asr #31
   123ec:	str	r7, [sp, #56]	; 0x38
   123ee:	str	r3, [sp, #32]
   123f0:	str	r5, [sp, #52]	; 0x34
   123f2:	mov	fp, r0
   123f4:	str	r0, [sp, #76]	; 0x4c
   123f6:	ldrb.w	r7, [sp, #111]	; 0x6f
   123fa:	b.w	11248 <_svfprintf_r+0x38c>
   123fe:	ldr	r3, [sp, #28]
   12400:	lsls	r3, r3, #31
   12402:	mov	r7, fp
   12404:	bpl.n	12412 <_svfprintf_r+0x1556>
   12406:	add	r6, sp, #256	; 0x100
   12408:	movs	r3, #48	; 0x30
   1240a:	strb.w	r3, [r6, #-65]!
   1240e:	b.w	11234 <_svfprintf_r+0x378>
   12412:	str.w	fp, [sp, #52]	; 0x34
   12416:	add	r6, sp, #192	; 0xc0
   12418:	b.w	1123a <_svfprintf_r+0x37e>
   1241c:	add	r2, sp, #140	; 0x8c
   1241e:	ldr	r1, [sp, #36]	; 0x24
   12420:	ldr	r0, [sp, #40]	; 0x28
   12422:	bl	14018 <__ssprint_r>
   12426:	cmp	r0, #0
   12428:	bne.w	110ae <_svfprintf_r+0x1f2>
   1242c:	ldr	r5, [sp, #116]	; 0x74
   1242e:	ldr	r4, [sp, #148]	; 0x94
   12430:	ldr	r3, [sp, #144]	; 0x90
   12432:	add.w	r9, sp, #192	; 0xc0
   12436:	b.n	1208e <_svfprintf_r+0x11d2>
   12438:	mov	r8, r4
   1243a:	movs	r5, #0
   1243c:	b.w	10f72 <_svfprintf_r+0xb6>
   12440:	ldr	r2, [sp, #88]	; 0x58
   12442:	ldr	r3, [sp, #76]	; 0x4c
   12444:	add	r3, r2
   12446:	movs	r2, #103	; 0x67
   12448:	str	r3, [sp, #52]	; 0x34
   1244a:	str	r2, [sp, #68]	; 0x44
   1244c:	bic.w	r3, r3, r3, asr #31
   12450:	b.n	11f38 <_svfprintf_r+0x107c>
   12452:	ldr	r3, [sp, #132]	; 0x84
   12454:	b.n	11efc <_svfprintf_r+0x1040>
   12456:	adds	r3, #48	; 0x30
   12458:	movs	r2, #48	; 0x30
   1245a:	strb.w	r3, [sp, #127]	; 0x7f
   1245e:	strb.w	r2, [sp, #126]	; 0x7e
   12462:	add	r3, sp, #128	; 0x80
   12464:	b.n	122b2 <_svfprintf_r+0x13f6>
   12466:	ldr	r0, [sp, #32]
   12468:	mov	r1, r7
   1246a:	movs	r2, #0
   1246c:	movs	r3, #0
   1246e:	bl	f374 <__aeabi_dcmpeq>
   12472:	cmp	r0, #0
   12474:	bne.w	1218c <_svfprintf_r+0x12d0>
   12478:	rsb	r5, r5, #1
   1247c:	str	r5, [sp, #116]	; 0x74
   1247e:	add	r4, r5
   12480:	b.n	11ed6 <_svfprintf_r+0x101a>
   12482:	ldr	r6, [pc, #224]	; (12564 <_svfprintf_r+0x16a8>)
   12484:	ldr	r3, [pc, #224]	; (12568 <_svfprintf_r+0x16ac>)
   12486:	ldrb.w	r7, [sp, #111]	; 0x6f
   1248a:	b.w	114ec <_svfprintf_r+0x630>
   1248e:	ldr	r3, [sp, #76]	; 0x4c
   12490:	ldr	r2, [sp, #88]	; 0x58
   12492:	adds	r5, r3, r2
   12494:	add.w	r3, r5, fp
   12498:	str	r3, [sp, #52]	; 0x34
   1249a:	bic.w	r3, r3, r3, asr #31
   1249e:	b.n	11f38 <_svfprintf_r+0x107c>
   124a0:	ldr	r3, [sp, #76]	; 0x4c
   124a2:	ldr	r2, [sp, #52]	; 0x34
   124a4:	rsb	r3, r3, #1
   124a8:	add	r2, r3
   124aa:	mov	r3, r2
   124ac:	str	r2, [sp, #52]	; 0x34
   124ae:	b.n	123a0 <_svfprintf_r+0x14e4>
   124b0:	ldr	r3, [sp, #28]
   124b2:	ands.w	r3, r3, #1
   124b6:	bne.w	122c4 <_svfprintf_r+0x1408>
   124ba:	str	r3, [sp, #76]	; 0x4c
   124bc:	ldr	r3, [sp, #52]	; 0x34
   124be:	bic.w	r3, r3, r3, asr #31
   124c2:	b.n	11f38 <_svfprintf_r+0x107c>
   124c4:	ldr	r0, [sp, #56]	; 0x38
   124c6:	ldrb.w	r3, [r8, #1]
   124ca:	ldr	r5, [r0, #0]
   124cc:	adds	r0, #4
   124ce:	cmp	r5, #0
   124d0:	str	r0, [sp, #56]	; 0x38
   124d2:	mov	r8, r4
   124d4:	bge.w	10f6e <_svfprintf_r+0xb2>
   124d8:	mov.w	r5, #4294967295
   124dc:	b.w	10f6e <_svfprintf_r+0xb2>
   124e0:	cmp.w	fp, #0
   124e4:	bne.n	124ec <_svfprintf_r+0x1630>
   124e6:	ldr	r3, [sp, #28]
   124e8:	lsls	r0, r3, #31
   124ea:	bpl.n	124fc <_svfprintf_r+0x1640>
   124ec:	ldr	r3, [sp, #88]	; 0x58
   124ee:	adds	r5, r3, #1
   124f0:	add.w	r3, r5, fp
   124f4:	str	r3, [sp, #52]	; 0x34
   124f6:	bic.w	r3, r3, r3, asr #31
   124fa:	b.n	11f38 <_svfprintf_r+0x107c>
   124fc:	movs	r3, #1
   124fe:	str	r3, [sp, #52]	; 0x34
   12500:	b.n	11f38 <_svfprintf_r+0x107c>
   12502:	strb.w	r1, [sp, #111]	; 0x6f
   12506:	b.w	115d4 <_svfprintf_r+0x718>
   1250a:	strb.w	r1, [sp, #111]	; 0x6f
   1250e:	b.w	111b4 <_svfprintf_r+0x2f8>
   12512:	add.w	r3, sp, #126	; 0x7e
   12516:	b.n	122b2 <_svfprintf_r+0x13f6>
   12518:	ldr	r2, [sp, #40]	; 0x28
   1251a:	movs	r3, #12
   1251c:	str	r3, [r2, #0]
   1251e:	mov.w	r0, #4294967295
   12522:	b.w	110c0 <_svfprintf_r+0x204>
   12526:	strb.w	r1, [sp, #111]	; 0x6f
   1252a:	b.w	117ce <_svfprintf_r+0x912>
   1252e:	strb.w	r1, [sp, #111]	; 0x6f
   12532:	b.w	1148c <_svfprintf_r+0x5d0>
   12536:	strb.w	r1, [sp, #111]	; 0x6f
   1253a:	b.w	110d0 <_svfprintf_r+0x214>
   1253e:	strb.w	r1, [sp, #111]	; 0x6f
   12542:	b.w	11578 <_svfprintf_r+0x6bc>
   12546:	strb.w	r1, [sp, #111]	; 0x6f
   1254a:	b.w	11524 <_svfprintf_r+0x668>
   1254e:	strb.w	r1, [sp, #111]	; 0x6f
   12552:	b.w	1173c <_svfprintf_r+0x880>
   12556:	strb.w	r1, [sp, #111]	; 0x6f
   1255a:	b.w	11702 <_svfprintf_r+0x846>
   1255e:	nop
   12560:	.word	0x00014948
   12564:	.word	0x0001491c
   12568:	.word	0x00014918

0001256c <_vdprintf_r>:
   1256c:	push	{r4, r5, r6, r7, lr}
   1256e:	sub.w	sp, sp, #532	; 0x214
   12572:	add	r5, sp, #16
   12574:	str	r3, [sp, #0]
   12576:	mov	r7, r1
   12578:	mov	r3, r2
   1257a:	mov.w	r4, #512	; 0x200
   1257e:	add	r2, sp, #12
   12580:	mov	r1, r5
   12582:	str	r4, [sp, #12]
   12584:	mov	r6, r0
   12586:	bl	14118 <_vasnprintf_r>
   1258a:	cbz	r0, 125b0 <_vdprintf_r+0x44>
   1258c:	mov	r4, r0
   1258e:	mov	r2, r0
   12590:	mov	r1, r7
   12592:	ldr	r3, [sp, #12]
   12594:	mov	r0, r6
   12596:	bl	125ec <_write_r>
   1259a:	cmp	r4, r5
   1259c:	str	r0, [sp, #12]
   1259e:	beq.n	125aa <_vdprintf_r+0x3e>
   125a0:	mov	r0, r6
   125a2:	mov	r1, r4
   125a4:	bl	13810 <_free_r>
   125a8:	ldr	r0, [sp, #12]
   125aa:	add.w	sp, sp, #532	; 0x214
   125ae:	pop	{r4, r5, r6, r7, pc}
   125b0:	mov.w	r0, #4294967295
   125b4:	b.n	125aa <_vdprintf_r+0x3e>
   125b6:	nop

000125b8 <vdprintf>:
   125b8:	push	{r4}
   125ba:	ldr	r4, [pc, #16]	; (125cc <vdprintf+0x14>)
   125bc:	mov	r3, r2
   125be:	mov	r2, r1
   125c0:	mov	r1, r0
   125c2:	ldr	r0, [r4, #0]
   125c4:	pop	{r4}
   125c6:	b.w	1256c <_vdprintf_r>
   125ca:	nop
   125cc:	.word	0x1fff9190

000125d0 <__ascii_wctomb>:
   125d0:	cbz	r1, 125dc <__ascii_wctomb+0xc>
   125d2:	cmp	r2, #255	; 0xff
   125d4:	bhi.n	125e0 <__ascii_wctomb+0x10>
   125d6:	strb	r2, [r1, #0]
   125d8:	movs	r0, #1
   125da:	bx	lr
   125dc:	mov	r0, r1
   125de:	bx	lr
   125e0:	movs	r3, #138	; 0x8a
   125e2:	str	r3, [r0, #0]
   125e4:	mov.w	r0, #4294967295
   125e8:	bx	lr
   125ea:	nop

000125ec <_write_r>:
   125ec:	push	{r4, r5, r6, lr}
   125ee:	mov	r5, r1
   125f0:	ldr	r4, [pc, #32]	; (12614 <_write_r+0x28>)
   125f2:	mov	r1, r2
   125f4:	mov	r6, r0
   125f6:	mov	r2, r3
   125f8:	mov	r0, r5
   125fa:	movs	r3, #0
   125fc:	str	r3, [r4, #0]
   125fe:	bl	e7dc <_write>
   12602:	adds	r3, r0, #1
   12604:	beq.n	12608 <_write_r+0x1c>
   12606:	pop	{r4, r5, r6, pc}
   12608:	ldr	r3, [r4, #0]
   1260a:	cmp	r3, #0
   1260c:	beq.n	12606 <_write_r+0x1a>
   1260e:	str	r3, [r6, #0]
   12610:	pop	{r4, r5, r6, pc}
   12612:	nop
   12614:	.word	0x20003230

00012618 <__register_exitproc>:
   12618:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1261c:	ldr	r4, [pc, #148]	; (126b4 <__register_exitproc+0x9c>)
   1261e:	ldr	r5, [r4, #0]
   12620:	ldr.w	r4, [r5, #328]	; 0x148
   12624:	mov	r6, r0
   12626:	mov	r8, r1
   12628:	mov	sl, r2
   1262a:	mov	r9, r3
   1262c:	cbz	r4, 126a0 <__register_exitproc+0x88>
   1262e:	ldr	r0, [r4, #4]
   12630:	cmp	r0, #31
   12632:	bgt.n	12664 <__register_exitproc+0x4c>
   12634:	adds	r3, r0, #1
   12636:	cbz	r6, 12656 <__register_exitproc+0x3e>
   12638:	add.w	r5, r4, r0, lsl #2
   1263c:	movs	r2, #1
   1263e:	str.w	sl, [r5, #136]	; 0x88
   12642:	ldr.w	r1, [r4, #392]	; 0x188
   12646:	lsls	r2, r0
   12648:	orrs	r1, r2
   1264a:	cmp	r6, #2
   1264c:	str.w	r1, [r4, #392]	; 0x188
   12650:	str.w	r9, [r5, #264]	; 0x108
   12654:	beq.n	12694 <__register_exitproc+0x7c>
   12656:	adds	r0, #2
   12658:	str	r3, [r4, #4]
   1265a:	str.w	r8, [r4, r0, lsl #2]
   1265e:	movs	r0, #0
   12660:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12664:	ldr	r3, [pc, #80]	; (126b8 <__register_exitproc+0xa0>)
   12666:	cbz	r3, 126aa <__register_exitproc+0x92>
   12668:	mov.w	r0, #400	; 0x190
   1266c:	bl	ff54 <malloc>
   12670:	mov	r4, r0
   12672:	cbz	r0, 126aa <__register_exitproc+0x92>
   12674:	ldr.w	r3, [r5, #328]	; 0x148
   12678:	movs	r7, #0
   1267a:	stmia.w	r0, {r3, r7}
   1267e:	str.w	r4, [r5, #328]	; 0x148
   12682:	mov	r0, r7
   12684:	movs	r3, #1
   12686:	str.w	r7, [r4, #392]	; 0x188
   1268a:	str.w	r7, [r4, #396]	; 0x18c
   1268e:	cmp	r6, #0
   12690:	beq.n	12656 <__register_exitproc+0x3e>
   12692:	b.n	12638 <__register_exitproc+0x20>
   12694:	ldr.w	r1, [r4, #396]	; 0x18c
   12698:	orrs	r2, r1
   1269a:	str.w	r2, [r4, #396]	; 0x18c
   1269e:	b.n	12656 <__register_exitproc+0x3e>
   126a0:	add.w	r4, r5, #332	; 0x14c
   126a4:	str.w	r4, [r5, #328]	; 0x148
   126a8:	b.n	1262e <__register_exitproc+0x16>
   126aa:	mov.w	r0, #4294967295
   126ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   126b2:	nop
   126b4:	.word	0x000148ec
   126b8:	.word	0x0000ff55

000126bc <register_fini>:
   126bc:	ldr	r3, [pc, #8]	; (126c8 <register_fini+0xc>)
   126be:	cbz	r3, 126c6 <register_fini+0xa>
   126c0:	ldr	r0, [pc, #8]	; (126cc <register_fini+0x10>)
   126c2:	b.w	126d0 <atexit>
   126c6:	bx	lr
   126c8:	.word	0x00000000
   126cc:	.word	0x0001374d

000126d0 <atexit>:
   126d0:	movs	r3, #0
   126d2:	mov	r1, r0
   126d4:	mov	r2, r3
   126d6:	mov	r0, r3
   126d8:	b.w	12618 <__register_exitproc>

000126dc <quorem>:
   126dc:	ldr	r2, [r0, #16]
   126de:	ldr	r3, [r1, #16]
   126e0:	cmp	r3, r2
   126e2:	bgt.w	12800 <quorem+0x124>
   126e6:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   126ea:	add.w	r8, r3, #4294967295
   126ee:	add.w	r7, r1, #20
   126f2:	add.w	fp, r0, #20
   126f6:	ldr.w	r2, [r7, r8, lsl #2]
   126fa:	ldr.w	r3, [fp, r8, lsl #2]
   126fe:	mov.w	r4, r8, lsl #2
   12702:	sub	sp, #12
   12704:	adds	r2, #1
   12706:	udiv	r9, r3, r2
   1270a:	add.w	r3, fp, r4
   1270e:	str	r4, [sp, #0]
   12710:	add.w	sl, r7, r4
   12714:	str	r3, [sp, #4]
   12716:	cmp.w	r9, #0
   1271a:	beq.n	12790 <quorem+0xb4>
   1271c:	movs	r5, #0
   1271e:	mov	ip, r7
   12720:	mov	lr, fp
   12722:	mov	r3, r5
   12724:	ldr.w	r6, [ip], #4
   12728:	ldr.w	r2, [lr]
   1272c:	uxth	r4, r6
   1272e:	mla	r5, r9, r4, r5
   12732:	lsrs	r6, r6, #16
   12734:	lsrs	r4, r5, #16
   12736:	mla	r4, r9, r6, r4
   1273a:	uxth	r5, r5
   1273c:	subs	r3, r3, r5
   1273e:	uxth	r6, r4
   12740:	uxtah	r3, r3, r2
   12744:	rsb	r6, r6, r2, lsr #16
   12748:	add.w	r6, r6, r3, asr #16
   1274c:	uxth	r3, r3
   1274e:	orr.w	r3, r3, r6, lsl #16
   12752:	cmp	sl, ip
   12754:	str.w	r3, [lr], #4
   12758:	mov.w	r5, r4, lsr #16
   1275c:	mov.w	r3, r6, asr #16
   12760:	bcs.n	12724 <quorem+0x48>
   12762:	ldr	r3, [sp, #0]
   12764:	ldr.w	r3, [fp, r3]
   12768:	cbnz	r3, 12790 <quorem+0xb4>
   1276a:	ldr	r4, [sp, #4]
   1276c:	subs	r3, r4, #4
   1276e:	cmp	fp, r3
   12770:	bcs.n	1278c <quorem+0xb0>
   12772:	ldr.w	r3, [r4, #-4]
   12776:	cbnz	r3, 1278c <quorem+0xb0>
   12778:	sub.w	r3, r4, #8
   1277c:	b.n	12784 <quorem+0xa8>
   1277e:	ldr	r2, [r3, #0]
   12780:	subs	r3, #4
   12782:	cbnz	r2, 1278c <quorem+0xb0>
   12784:	cmp	fp, r3
   12786:	add.w	r8, r8, #4294967295
   1278a:	bcc.n	1277e <quorem+0xa2>
   1278c:	str.w	r8, [r0, #16]
   12790:	mov	r4, r0
   12792:	bl	13e0c <__mcmp>
   12796:	cmp	r0, #0
   12798:	blt.n	127f8 <quorem+0x11c>
   1279a:	add.w	r9, r9, #1
   1279e:	mov	r5, fp
   127a0:	movs	r3, #0
   127a2:	ldr.w	r1, [r7], #4
   127a6:	ldr	r0, [r5, #0]
   127a8:	uxth	r2, r1
   127aa:	subs	r2, r3, r2
   127ac:	lsrs	r1, r1, #16
   127ae:	uxtah	r2, r2, r0
   127b2:	rsb	r3, r1, r0, lsr #16
   127b6:	add.w	r3, r3, r2, asr #16
   127ba:	uxth	r1, r2
   127bc:	orr.w	r1, r1, r3, lsl #16
   127c0:	cmp	sl, r7
   127c2:	str.w	r1, [r5], #4
   127c6:	mov.w	r3, r3, asr #16
   127ca:	bcs.n	127a2 <quorem+0xc6>
   127cc:	ldr.w	r2, [fp, r8, lsl #2]
   127d0:	add.w	r3, fp, r8, lsl #2
   127d4:	cbnz	r2, 127f8 <quorem+0x11c>
   127d6:	subs	r2, r3, #4
   127d8:	cmp	fp, r2
   127da:	bcs.n	127f4 <quorem+0x118>
   127dc:	ldr.w	r2, [r3, #-4]
   127e0:	cbnz	r2, 127f4 <quorem+0x118>
   127e2:	subs	r3, #8
   127e4:	b.n	127ec <quorem+0x110>
   127e6:	ldr	r2, [r3, #0]
   127e8:	subs	r3, #4
   127ea:	cbnz	r2, 127f4 <quorem+0x118>
   127ec:	cmp	fp, r3
   127ee:	add.w	r8, r8, #4294967295
   127f2:	bcc.n	127e6 <quorem+0x10a>
   127f4:	str.w	r8, [r4, #16]
   127f8:	mov	r0, r9
   127fa:	add	sp, #12
   127fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12800:	movs	r0, #0
   12802:	bx	lr
   12804:			; <UNDEFINED> instruction: 0xffffffff

00012808 <_dtoa_r>:
   12808:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1280c:	ldr	r1, [r0, #64]	; 0x40
   1280e:	sub	sp, #92	; 0x5c
   12810:	mov	r9, r0
   12812:	ldr	r4, [sp, #140]	; 0x8c
   12814:	mov	sl, r2
   12816:	mov	fp, r3
   12818:	cbz	r1, 1282e <_dtoa_r+0x26>
   1281a:	ldr	r2, [r0, #68]	; 0x44
   1281c:	str	r2, [r1, #4]
   1281e:	movs	r3, #1
   12820:	lsls	r3, r2
   12822:	str	r3, [r1, #8]
   12824:	bl	13a48 <_Bfree>
   12828:	movs	r3, #0
   1282a:	str.w	r3, [r9, #64]	; 0x40
   1282e:	cmp.w	fp, #0
   12832:	mov	r8, fp
   12834:	blt.n	1289e <_dtoa_r+0x96>
   12836:	movs	r3, #0
   12838:	str	r3, [r4, #0]
   1283a:	ldr	r3, [pc, #660]	; (12ad0 <_dtoa_r+0x2c8>)
   1283c:	mov	r2, r3
   1283e:	and.w	r3, r8, r3
   12842:	cmp	r3, r2
   12844:	beq.n	12870 <_dtoa_r+0x68>
   12846:	mov	r0, sl
   12848:	mov	r1, fp
   1284a:	movs	r2, #0
   1284c:	movs	r3, #0
   1284e:	bl	f374 <__aeabi_dcmpeq>
   12852:	mov	r5, r0
   12854:	cbz	r0, 128aa <_dtoa_r+0xa2>
   12856:	ldr	r2, [sp, #136]	; 0x88
   12858:	movs	r3, #1
   1285a:	str	r3, [r2, #0]
   1285c:	ldr	r3, [sp, #144]	; 0x90
   1285e:	cmp	r3, #0
   12860:	beq.w	129ee <_dtoa_r+0x1e6>
   12864:	ldr	r0, [pc, #620]	; (12ad4 <_dtoa_r+0x2cc>)
   12866:	str	r0, [r3, #0]
   12868:	subs	r0, #1
   1286a:	add	sp, #92	; 0x5c
   1286c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12870:	ldr	r2, [sp, #136]	; 0x88
   12872:	movw	r3, #9999	; 0x270f
   12876:	str	r3, [r2, #0]
   12878:	cmp.w	sl, #0
   1287c:	beq.w	129c4 <_dtoa_r+0x1bc>
   12880:	ldr	r0, [pc, #596]	; (12ad8 <_dtoa_r+0x2d0>)
   12882:	ldr	r3, [sp, #144]	; 0x90
   12884:	cmp	r3, #0
   12886:	beq.n	1286a <_dtoa_r+0x62>
   12888:	ldrb	r3, [r0, #3]
   1288a:	cmp	r3, #0
   1288c:	beq.w	129f2 <_dtoa_r+0x1ea>
   12890:	add.w	r3, r0, #8
   12894:	ldr	r2, [sp, #144]	; 0x90
   12896:	str	r3, [r2, #0]
   12898:	add	sp, #92	; 0x5c
   1289a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1289e:	movs	r3, #1
   128a0:	bic.w	r8, fp, #2147483648	; 0x80000000
   128a4:	str	r3, [r4, #0]
   128a6:	mov	fp, r8
   128a8:	b.n	1283a <_dtoa_r+0x32>
   128aa:	add	r2, sp, #80	; 0x50
   128ac:	add	r3, sp, #84	; 0x54
   128ae:	str	r2, [sp, #4]
   128b0:	str	r3, [sp, #0]
   128b2:	mov	r2, sl
   128b4:	mov	r3, fp
   128b6:	mov	r0, r9
   128b8:	bl	13f60 <__d2b>
   128bc:	movs.w	r4, r8, lsr #20
   128c0:	str	r0, [sp, #32]
   128c2:	bne.w	129d6 <_dtoa_r+0x1ce>
   128c6:	ldr	r5, [sp, #80]	; 0x50
   128c8:	ldr	r4, [sp, #84]	; 0x54
   128ca:	add	r4, r5
   128cc:	addw	r3, r4, #1074	; 0x432
   128d0:	cmp	r3, #32
   128d2:	ble.w	12df8 <_dtoa_r+0x5f0>
   128d6:	rsb	r3, r3, #64	; 0x40
   128da:	addw	r0, r4, #1042	; 0x412
   128de:	lsl.w	r8, r8, r3
   128e2:	lsr.w	r0, sl, r0
   128e6:	orr.w	r0, r0, r8
   128ea:	bl	edb8 <__aeabi_ui2d>
   128ee:	movs	r3, #1
   128f0:	subs	r4, #1
   128f2:	sub.w	r1, r1, #32505856	; 0x1f00000
   128f6:	str	r3, [sp, #64]	; 0x40
   128f8:	movs	r2, #0
   128fa:	ldr	r3, [pc, #480]	; (12adc <_dtoa_r+0x2d4>)
   128fc:	bl	eb3c <__aeabi_dsub>
   12900:	add	r3, pc, #436	; (adr r3, 12ab8 <_dtoa_r+0x2b0>)
   12902:	ldrd	r2, r3, [r3]
   12906:	bl	eea4 <__aeabi_dmul>
   1290a:	add	r3, pc, #436	; (adr r3, 12ac0 <_dtoa_r+0x2b8>)
   1290c:	ldrd	r2, r3, [r3]
   12910:	bl	eb40 <__adddf3>
   12914:	mov	r6, r0
   12916:	mov	r0, r4
   12918:	mov	r7, r1
   1291a:	bl	edd8 <__aeabi_i2d>
   1291e:	add	r3, pc, #424	; (adr r3, 12ac8 <_dtoa_r+0x2c0>)
   12920:	ldrd	r2, r3, [r3]
   12924:	bl	eea4 <__aeabi_dmul>
   12928:	mov	r2, r0
   1292a:	mov	r3, r1
   1292c:	mov	r0, r6
   1292e:	mov	r1, r7
   12930:	bl	eb40 <__adddf3>
   12934:	mov	r6, r0
   12936:	mov	r7, r1
   12938:	bl	f404 <__aeabi_d2iz>
   1293c:	movs	r2, #0
   1293e:	str	r0, [sp, #16]
   12940:	movs	r3, #0
   12942:	mov	r0, r6
   12944:	mov	r1, r7
   12946:	bl	f388 <__aeabi_dcmplt>
   1294a:	cmp	r0, #0
   1294c:	bne.w	12db0 <_dtoa_r+0x5a8>
   12950:	ldr	r6, [sp, #16]
   12952:	cmp	r6, #22
   12954:	bhi.w	12daa <_dtoa_r+0x5a2>
   12958:	ldr	r3, [pc, #388]	; (12ae0 <_dtoa_r+0x2d8>)
   1295a:	add.w	r3, r3, r6, lsl #3
   1295e:	ldrd	r0, r1, [r3]
   12962:	mov	r2, sl
   12964:	mov	r3, fp
   12966:	bl	f3c4 <__aeabi_dcmpgt>
   1296a:	cmp	r0, #0
   1296c:	beq.w	12e02 <_dtoa_r+0x5fa>
   12970:	subs	r3, r6, #1
   12972:	str	r3, [sp, #16]
   12974:	movs	r3, #0
   12976:	str	r3, [sp, #48]	; 0x30
   12978:	subs	r4, r5, r4
   1297a:	subs	r3, r4, #1
   1297c:	str	r3, [sp, #8]
   1297e:	bmi.w	12de6 <_dtoa_r+0x5de>
   12982:	movs	r3, #0
   12984:	str	r3, [sp, #20]
   12986:	ldr	r3, [sp, #16]
   12988:	cmp	r3, #0
   1298a:	blt.w	12dd4 <_dtoa_r+0x5cc>
   1298e:	ldr	r2, [sp, #8]
   12990:	str	r3, [sp, #44]	; 0x2c
   12992:	mov	r1, r2
   12994:	add	r1, r3
   12996:	movs	r3, #0
   12998:	str	r1, [sp, #8]
   1299a:	str	r3, [sp, #40]	; 0x28
   1299c:	ldr	r3, [sp, #128]	; 0x80
   1299e:	cmp	r3, #9
   129a0:	bhi.n	129f6 <_dtoa_r+0x1ee>
   129a2:	cmp	r3, #5
   129a4:	ble.w	13658 <_dtoa_r+0xe50>
   129a8:	subs	r3, #4
   129aa:	str	r3, [sp, #128]	; 0x80
   129ac:	movs	r5, #0
   129ae:	ldr	r3, [sp, #128]	; 0x80
   129b0:	subs	r3, #2
   129b2:	cmp	r3, #3
   129b4:	bhi.w	13622 <_dtoa_r+0xe1a>
   129b8:	tbh	[pc, r3, lsl #1]
   129bc:	.word	0x0228032c
   129c0:	.word	0x04590337
   129c4:	ldr	r3, [pc, #272]	; (12ad8 <_dtoa_r+0x2d0>)
   129c6:	ldr	r2, [pc, #284]	; (12ae4 <_dtoa_r+0x2dc>)
   129c8:	ubfx	r0, r8, #0, #20
   129cc:	cmp	r0, #0
   129ce:	ite	ne
   129d0:	movne	r0, r3
   129d2:	moveq	r0, r2
   129d4:	b.n	12882 <_dtoa_r+0x7a>
   129d6:	ubfx	r3, fp, #0, #20
   129da:	orr.w	r1, r3, #1069547520	; 0x3fc00000
   129de:	str	r5, [sp, #64]	; 0x40
   129e0:	mov	r0, sl
   129e2:	subw	r4, r4, #1023	; 0x3ff
   129e6:	orr.w	r1, r1, #3145728	; 0x300000
   129ea:	ldr	r5, [sp, #80]	; 0x50
   129ec:	b.n	128f8 <_dtoa_r+0xf0>
   129ee:	ldr	r0, [pc, #248]	; (12ae8 <_dtoa_r+0x2e0>)
   129f0:	b.n	1286a <_dtoa_r+0x62>
   129f2:	adds	r3, r0, #3
   129f4:	b.n	12894 <_dtoa_r+0x8c>
   129f6:	movs	r1, #0
   129f8:	str.w	r1, [r9, #68]	; 0x44
   129fc:	mov	r0, r9
   129fe:	str	r1, [sp, #128]	; 0x80
   12a00:	bl	139fc <_Balloc>
   12a04:	mov.w	r3, #4294967295
   12a08:	str	r3, [sp, #24]
   12a0a:	ldr	r2, [sp, #128]	; 0x80
   12a0c:	str	r3, [sp, #52]	; 0x34
   12a0e:	movs	r3, #1
   12a10:	str	r0, [sp, #28]
   12a12:	str	r2, [sp, #132]	; 0x84
   12a14:	str.w	r0, [r9, #64]	; 0x40
   12a18:	str	r3, [sp, #36]	; 0x24
   12a1a:	ldr	r3, [sp, #84]	; 0x54
   12a1c:	cmp	r3, #0
   12a1e:	blt.w	12bc4 <_dtoa_r+0x3bc>
   12a22:	ldr	r2, [sp, #16]
   12a24:	cmp	r2, #14
   12a26:	bgt.w	12bc4 <_dtoa_r+0x3bc>
   12a2a:	ldr	r3, [pc, #180]	; (12ae0 <_dtoa_r+0x2d8>)
   12a2c:	add.w	r3, r3, r2, lsl #3
   12a30:	ldrd	r3, r4, [r3]
   12a34:	strd	r3, r4, [sp, #8]
   12a38:	ldr	r3, [sp, #132]	; 0x84
   12a3a:	cmp	r3, #0
   12a3c:	blt.w	13040 <_dtoa_r+0x838>
   12a40:	mov	r6, sl
   12a42:	mov	r7, fp
   12a44:	mov	r0, sl
   12a46:	mov	r1, fp
   12a48:	ldrd	sl, fp, [sp, #8]
   12a4c:	mov	r2, sl
   12a4e:	mov	r3, fp
   12a50:	bl	f0f8 <__aeabi_ddiv>
   12a54:	bl	f404 <__aeabi_d2iz>
   12a58:	mov	r4, r0
   12a5a:	bl	edd8 <__aeabi_i2d>
   12a5e:	mov	r2, sl
   12a60:	mov	r3, fp
   12a62:	bl	eea4 <__aeabi_dmul>
   12a66:	mov	r3, r1
   12a68:	mov	r2, r0
   12a6a:	mov	r1, r7
   12a6c:	mov	r0, r6
   12a6e:	bl	eb3c <__aeabi_dsub>
   12a72:	ldr	r5, [sp, #28]
   12a74:	add.w	r3, r4, #48	; 0x30
   12a78:	strb	r3, [r5, #0]
   12a7a:	ldr	r3, [sp, #24]
   12a7c:	cmp	r3, #1
   12a7e:	mov	r6, r0
   12a80:	mov	r7, r1
   12a82:	add.w	r5, r5, #1
   12a86:	beq.n	12b4e <_dtoa_r+0x346>
   12a88:	movs	r2, #0
   12a8a:	ldr	r3, [pc, #96]	; (12aec <_dtoa_r+0x2e4>)
   12a8c:	bl	eea4 <__aeabi_dmul>
   12a90:	movs	r2, #0
   12a92:	movs	r3, #0
   12a94:	mov	r6, r0
   12a96:	mov	r7, r1
   12a98:	bl	f374 <__aeabi_dcmpeq>
   12a9c:	cmp	r0, #0
   12a9e:	bne.n	12b9e <_dtoa_r+0x396>
   12aa0:	str.w	r9, [sp, #20]
   12aa4:	ldr.w	sl, [sp, #24]
   12aa8:	ldr.w	fp, [sp, #28]
   12aac:	ldrd	r8, r9, [sp, #8]
   12ab0:	b.n	12b06 <_dtoa_r+0x2fe>
   12ab2:	nop
   12ab4:	nop.w
   12ab8:	.word	0x636f4361
   12abc:	.word	0x3fd287a7
   12ac0:	.word	0x8b60c8b3
   12ac4:	.word	0x3fc68a28
   12ac8:	.word	0x509f79fb
   12acc:	.word	0x3fd34413
   12ad0:	.word	0x7ff00000
   12ad4:	.word	0x00014799
   12ad8:	.word	0x00014a70
   12adc:	.word	0x3ff80000
   12ae0:	.word	0x00014a78
   12ae4:	.word	0x00014a64
   12ae8:	.word	0x00014798
   12aec:	.word	0x40240000
   12af0:	bl	eea4 <__aeabi_dmul>
   12af4:	movs	r2, #0
   12af6:	movs	r3, #0
   12af8:	mov	r6, r0
   12afa:	mov	r7, r1
   12afc:	bl	f374 <__aeabi_dcmpeq>
   12b00:	cmp	r0, #0
   12b02:	bne.w	13274 <_dtoa_r+0xa6c>
   12b06:	mov	r2, r8
   12b08:	mov	r3, r9
   12b0a:	mov	r0, r6
   12b0c:	mov	r1, r7
   12b0e:	bl	f0f8 <__aeabi_ddiv>
   12b12:	bl	f404 <__aeabi_d2iz>
   12b16:	mov	r4, r0
   12b18:	bl	edd8 <__aeabi_i2d>
   12b1c:	mov	r2, r8
   12b1e:	mov	r3, r9
   12b20:	bl	eea4 <__aeabi_dmul>
   12b24:	mov	r2, r0
   12b26:	mov	r3, r1
   12b28:	mov	r0, r6
   12b2a:	mov	r1, r7
   12b2c:	bl	eb3c <__aeabi_dsub>
   12b30:	add.w	lr, r4, #48	; 0x30
   12b34:	strb.w	lr, [r5], #1
   12b38:	rsb	lr, fp, r5
   12b3c:	cmp	lr, sl
   12b3e:	mov	r6, r0
   12b40:	mov	r7, r1
   12b42:	mov.w	r2, #0
   12b46:	ldr	r3, [pc, #704]	; (12e08 <_dtoa_r+0x600>)
   12b48:	bne.n	12af0 <_dtoa_r+0x2e8>
   12b4a:	ldr.w	r9, [sp, #20]
   12b4e:	mov	r2, r6
   12b50:	mov	r3, r7
   12b52:	mov	r0, r6
   12b54:	mov	r1, r7
   12b56:	bl	eb40 <__adddf3>
   12b5a:	mov	r6, r0
   12b5c:	mov	r7, r1
   12b5e:	mov	r2, r0
   12b60:	mov	r3, r1
   12b62:	ldrd	r0, r1, [sp, #8]
   12b66:	bl	f388 <__aeabi_dcmplt>
   12b6a:	cbnz	r0, 12b7e <_dtoa_r+0x376>
   12b6c:	mov	r2, r6
   12b6e:	mov	r3, r7
   12b70:	ldrd	r0, r1, [sp, #8]
   12b74:	bl	f374 <__aeabi_dcmpeq>
   12b78:	cbz	r0, 12b9e <_dtoa_r+0x396>
   12b7a:	lsls	r3, r4, #31
   12b7c:	bpl.n	12b9e <_dtoa_r+0x396>
   12b7e:	ldrb.w	r4, [r5, #-1]
   12b82:	ldr	r2, [sp, #28]
   12b84:	subs	r3, r5, #1
   12b86:	b.n	12b92 <_dtoa_r+0x38a>
   12b88:	cmp	r2, r3
   12b8a:	beq.w	133e6 <_dtoa_r+0xbde>
   12b8e:	ldrb.w	r4, [r3, #-1]!
   12b92:	cmp	r4, #57	; 0x39
   12b94:	add.w	r5, r3, #1
   12b98:	beq.n	12b88 <_dtoa_r+0x380>
   12b9a:	adds	r4, #1
   12b9c:	strb	r4, [r3, #0]
   12b9e:	ldr	r1, [sp, #32]
   12ba0:	mov	r0, r9
   12ba2:	bl	13a48 <_Bfree>
   12ba6:	movs	r2, #0
   12ba8:	ldr	r3, [sp, #16]
   12baa:	strb	r2, [r5, #0]
   12bac:	ldr	r2, [sp, #136]	; 0x88
   12bae:	adds	r3, #1
   12bb0:	str	r3, [r2, #0]
   12bb2:	ldr	r3, [sp, #144]	; 0x90
   12bb4:	cmp	r3, #0
   12bb6:	beq.w	13308 <_dtoa_r+0xb00>
   12bba:	ldr	r0, [sp, #28]
   12bbc:	str	r5, [r3, #0]
   12bbe:	add	sp, #92	; 0x5c
   12bc0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12bc4:	ldr	r2, [sp, #36]	; 0x24
   12bc6:	cmp	r2, #0
   12bc8:	beq.w	12df0 <_dtoa_r+0x5e8>
   12bcc:	ldr	r2, [sp, #128]	; 0x80
   12bce:	cmp	r2, #1
   12bd0:	ble.w	13084 <_dtoa_r+0x87c>
   12bd4:	ldr	r3, [sp, #24]
   12bd6:	ldr	r2, [sp, #40]	; 0x28
   12bd8:	subs	r7, r3, #1
   12bda:	cmp	r2, r7
   12bdc:	blt.w	1330e <_dtoa_r+0xb06>
   12be0:	subs	r7, r2, r7
   12be2:	ldr	r3, [sp, #24]
   12be4:	cmp	r3, #0
   12be6:	blt.w	134fe <_dtoa_r+0xcf6>
   12bea:	ldr	r5, [sp, #20]
   12bec:	ldr	r3, [sp, #24]
   12bee:	ldr	r2, [sp, #20]
   12bf0:	add	r2, r3
   12bf2:	str	r2, [sp, #20]
   12bf4:	ldr	r2, [sp, #8]
   12bf6:	movs	r1, #1
   12bf8:	add	r2, r3
   12bfa:	mov	r0, r9
   12bfc:	str	r2, [sp, #8]
   12bfe:	bl	13b78 <__i2b>
   12c02:	mov	r6, r0
   12c04:	cbz	r5, 12c20 <_dtoa_r+0x418>
   12c06:	ldr	r1, [sp, #8]
   12c08:	cmp	r1, #0
   12c0a:	mov	r3, r1
   12c0c:	ble.n	12c20 <_dtoa_r+0x418>
   12c0e:	cmp	r1, r5
   12c10:	ldr	r2, [sp, #20]
   12c12:	it	ge
   12c14:	movge	r3, r5
   12c16:	subs	r2, r2, r3
   12c18:	subs	r5, r5, r3
   12c1a:	subs	r3, r1, r3
   12c1c:	str	r2, [sp, #20]
   12c1e:	str	r3, [sp, #8]
   12c20:	ldr	r3, [sp, #40]	; 0x28
   12c22:	cmp	r3, #0
   12c24:	ble.w	13220 <_dtoa_r+0xa18>
   12c28:	ldr	r2, [sp, #36]	; 0x24
   12c2a:	cmp	r2, #0
   12c2c:	beq.w	13032 <_dtoa_r+0x82a>
   12c30:	cmp	r7, #0
   12c32:	beq.w	13032 <_dtoa_r+0x82a>
   12c36:	mov	r1, r6
   12c38:	mov	r2, r7
   12c3a:	mov	r0, r9
   12c3c:	bl	13cbc <__pow5mult>
   12c40:	ldr.w	r8, [sp, #32]
   12c44:	mov	r1, r0
   12c46:	mov	r2, r8
   12c48:	mov	r6, r0
   12c4a:	mov	r0, r9
   12c4c:	bl	13b8c <__multiply>
   12c50:	mov	r1, r8
   12c52:	mov	r4, r0
   12c54:	mov	r0, r9
   12c56:	bl	13a48 <_Bfree>
   12c5a:	ldr	r3, [sp, #40]	; 0x28
   12c5c:	subs	r3, r3, r7
   12c5e:	str	r3, [sp, #40]	; 0x28
   12c60:	bne.w	13030 <_dtoa_r+0x828>
   12c64:	movs	r1, #1
   12c66:	mov	r0, r9
   12c68:	bl	13b78 <__i2b>
   12c6c:	ldr	r3, [sp, #44]	; 0x2c
   12c6e:	mov	r8, r0
   12c70:	cmp	r3, #0
   12c72:	beq.w	130a8 <_dtoa_r+0x8a0>
   12c76:	mov	r1, r0
   12c78:	mov	r2, r3
   12c7a:	mov	r0, r9
   12c7c:	bl	13cbc <__pow5mult>
   12c80:	ldr	r3, [sp, #128]	; 0x80
   12c82:	cmp	r3, #1
   12c84:	mov	r8, r0
   12c86:	ble.w	1327a <_dtoa_r+0xa72>
   12c8a:	movs	r7, #0
   12c8c:	ldr.w	r3, [r8, #16]
   12c90:	add.w	r3, r8, r3, lsl #2
   12c94:	ldr	r0, [r3, #16]
   12c96:	bl	13adc <__hi0bits>
   12c9a:	rsb	r0, r0, #32
   12c9e:	ldr	r2, [sp, #8]
   12ca0:	add	r0, r2
   12ca2:	ands.w	r0, r0, #31
   12ca6:	beq.w	13096 <_dtoa_r+0x88e>
   12caa:	rsb	r3, r0, #32
   12cae:	cmp	r3, #4
   12cb0:	ble.w	13648 <_dtoa_r+0xe40>
   12cb4:	ldr	r3, [sp, #20]
   12cb6:	rsb	r0, r0, #28
   12cba:	add	r3, r0
   12cbc:	str	r3, [sp, #20]
   12cbe:	mov	r3, r2
   12cc0:	add	r3, r0
   12cc2:	add	r5, r0
   12cc4:	str	r3, [sp, #8]
   12cc6:	ldr	r3, [sp, #20]
   12cc8:	cmp	r3, #0
   12cca:	ble.n	12cd8 <_dtoa_r+0x4d0>
   12ccc:	mov	r1, r4
   12cce:	mov	r2, r3
   12cd0:	mov	r0, r9
   12cd2:	bl	13d5c <__lshift>
   12cd6:	mov	r4, r0
   12cd8:	ldr	r3, [sp, #8]
   12cda:	cmp	r3, #0
   12cdc:	ble.n	12cea <_dtoa_r+0x4e2>
   12cde:	mov	r1, r8
   12ce0:	mov	r2, r3
   12ce2:	mov	r0, r9
   12ce4:	bl	13d5c <__lshift>
   12ce8:	mov	r8, r0
   12cea:	ldr	r3, [sp, #48]	; 0x30
   12cec:	cmp	r3, #0
   12cee:	bne.w	131ea <_dtoa_r+0x9e2>
   12cf2:	ldr	r3, [sp, #24]
   12cf4:	cmp	r3, #0
   12cf6:	ble.w	13224 <_dtoa_r+0xa1c>
   12cfa:	ldr	r3, [sp, #36]	; 0x24
   12cfc:	cmp	r3, #0
   12cfe:	bne.w	130ec <_dtoa_r+0x8e4>
   12d02:	ldr.w	fp, [sp, #28]
   12d06:	ldr	r7, [sp, #24]
   12d08:	mov	r5, fp
   12d0a:	b.n	12d12 <_dtoa_r+0x50a>
   12d0c:	bl	13a5c <__multadd>
   12d10:	mov	r4, r0
   12d12:	mov	r1, r8
   12d14:	mov	r0, r4
   12d16:	bl	126dc <quorem>
   12d1a:	add.w	sl, r0, #48	; 0x30
   12d1e:	strb.w	sl, [r5], #1
   12d22:	rsb	r3, fp, r5
   12d26:	cmp	r3, r7
   12d28:	mov.w	r2, #10
   12d2c:	mov.w	r3, #0
   12d30:	mov	r1, r4
   12d32:	mov	r0, r9
   12d34:	blt.n	12d0c <_dtoa_r+0x504>
   12d36:	ldr	r3, [sp, #28]
   12d38:	ldr	r2, [sp, #24]
   12d3a:	cmp	r2, #1
   12d3c:	ite	ge
   12d3e:	addge	r3, r3, r2
   12d40:	addlt	r3, #1
   12d42:	mov	r5, r3
   12d44:	mov.w	fp, #0
   12d48:	mov	r1, r4
   12d4a:	movs	r2, #1
   12d4c:	mov	r0, r9
   12d4e:	bl	13d5c <__lshift>
   12d52:	mov	r1, r8
   12d54:	str	r0, [sp, #32]
   12d56:	bl	13e0c <__mcmp>
   12d5a:	cmp	r0, #0
   12d5c:	ble.w	1337a <_dtoa_r+0xb72>
   12d60:	ldrb.w	r2, [r5, #-1]
   12d64:	ldr	r1, [sp, #28]
   12d66:	subs	r3, r5, #1
   12d68:	b.n	12d74 <_dtoa_r+0x56c>
   12d6a:	cmp	r3, r1
   12d6c:	beq.w	13260 <_dtoa_r+0xa58>
   12d70:	ldrb.w	r2, [r3, #-1]!
   12d74:	cmp	r2, #57	; 0x39
   12d76:	add.w	r5, r3, #1
   12d7a:	beq.n	12d6a <_dtoa_r+0x562>
   12d7c:	adds	r2, #1
   12d7e:	strb	r2, [r3, #0]
   12d80:	mov	r1, r8
   12d82:	mov	r0, r9
   12d84:	bl	13a48 <_Bfree>
   12d88:	cmp	r6, #0
   12d8a:	beq.w	12b9e <_dtoa_r+0x396>
   12d8e:	cmp.w	fp, #0
   12d92:	beq.n	12da0 <_dtoa_r+0x598>
   12d94:	cmp	fp, r6
   12d96:	beq.n	12da0 <_dtoa_r+0x598>
   12d98:	mov	r1, fp
   12d9a:	mov	r0, r9
   12d9c:	bl	13a48 <_Bfree>
   12da0:	mov	r1, r6
   12da2:	mov	r0, r9
   12da4:	bl	13a48 <_Bfree>
   12da8:	b.n	12b9e <_dtoa_r+0x396>
   12daa:	movs	r3, #1
   12dac:	str	r3, [sp, #48]	; 0x30
   12dae:	b.n	12978 <_dtoa_r+0x170>
   12db0:	ldr.w	r8, [sp, #16]
   12db4:	mov	r0, r8
   12db6:	bl	edd8 <__aeabi_i2d>
   12dba:	mov	r2, r0
   12dbc:	mov	r3, r1
   12dbe:	mov	r0, r6
   12dc0:	mov	r1, r7
   12dc2:	bl	f374 <__aeabi_dcmpeq>
   12dc6:	cmp	r0, #0
   12dc8:	bne.w	12950 <_dtoa_r+0x148>
   12dcc:	add.w	r3, r8, #4294967295
   12dd0:	str	r3, [sp, #16]
   12dd2:	b.n	12950 <_dtoa_r+0x148>
   12dd4:	ldr	r2, [sp, #20]
   12dd6:	ldr	r3, [sp, #16]
   12dd8:	subs	r2, r2, r3
   12dda:	negs	r3, r3
   12ddc:	str	r3, [sp, #40]	; 0x28
   12dde:	movs	r3, #0
   12de0:	str	r2, [sp, #20]
   12de2:	str	r3, [sp, #44]	; 0x2c
   12de4:	b.n	1299c <_dtoa_r+0x194>
   12de6:	negs	r3, r3
   12de8:	str	r3, [sp, #20]
   12dea:	movs	r3, #0
   12dec:	str	r3, [sp, #8]
   12dee:	b.n	12986 <_dtoa_r+0x17e>
   12df0:	ldr	r7, [sp, #40]	; 0x28
   12df2:	ldr	r5, [sp, #20]
   12df4:	ldr	r6, [sp, #36]	; 0x24
   12df6:	b.n	12c04 <_dtoa_r+0x3fc>
   12df8:	rsb	r8, r3, #32
   12dfc:	lsl.w	r0, sl, r8
   12e00:	b.n	128ea <_dtoa_r+0xe2>
   12e02:	str	r0, [sp, #48]	; 0x30
   12e04:	b.n	12978 <_dtoa_r+0x170>
   12e06:	nop
   12e08:	.word	0x40240000
   12e0c:	movs	r3, #0
   12e0e:	str	r3, [sp, #36]	; 0x24
   12e10:	ldr	r3, [sp, #16]
   12e12:	ldr	r2, [sp, #132]	; 0x84
   12e14:	add	r3, r2
   12e16:	str	r3, [sp, #52]	; 0x34
   12e18:	adds	r3, #1
   12e1a:	cmp	r3, #0
   12e1c:	str	r3, [sp, #24]
   12e1e:	ble.w	13328 <_dtoa_r+0xb20>
   12e22:	ldr	r4, [sp, #24]
   12e24:	mov	r6, r4
   12e26:	movs	r1, #0
   12e28:	cmp	r6, #23
   12e2a:	str.w	r1, [r9, #68]	; 0x44
   12e2e:	bls.n	12e48 <_dtoa_r+0x640>
   12e30:	movs	r2, #1
   12e32:	movs	r3, #4
   12e34:	lsls	r3, r3, #1
   12e36:	add.w	r0, r3, #20
   12e3a:	cmp	r0, r6
   12e3c:	mov	r1, r2
   12e3e:	add.w	r2, r2, #1
   12e42:	bls.n	12e34 <_dtoa_r+0x62c>
   12e44:	str.w	r1, [r9, #68]	; 0x44
   12e48:	mov	r0, r9
   12e4a:	bl	139fc <_Balloc>
   12e4e:	cmp	r4, #14
   12e50:	str	r0, [sp, #28]
   12e52:	str.w	r0, [r9, #64]	; 0x40
   12e56:	bhi.w	12a1a <_dtoa_r+0x212>
   12e5a:	cmp	r5, #0
   12e5c:	beq.w	12a1a <_dtoa_r+0x212>
   12e60:	ldr	r1, [sp, #16]
   12e62:	mov	r7, sl
   12e64:	mov	r8, fp
   12e66:	cmp	r1, #0
   12e68:	strd	r7, r8, [sp, #56]	; 0x38
   12e6c:	ble.w	13394 <_dtoa_r+0xb8c>
   12e70:	ldr	r3, [pc, #580]	; (130b8 <_dtoa_r+0x8b0>)
   12e72:	and.w	r2, r1, #15
   12e76:	asrs	r6, r1, #4
   12e78:	add.w	r3, r3, r2, lsl #3
   12e7c:	lsls	r0, r6, #27
   12e7e:	ldrd	r4, r5, [r3]
   12e82:	bpl.w	1331e <_dtoa_r+0xb16>
   12e86:	ldr	r3, [pc, #564]	; (130bc <_dtoa_r+0x8b4>)
   12e88:	mov	r0, sl
   12e8a:	mov	r1, fp
   12e8c:	ldrd	r2, r3, [r3, #32]
   12e90:	bl	f0f8 <__aeabi_ddiv>
   12e94:	and.w	r6, r6, #15
   12e98:	mov	sl, r0
   12e9a:	mov	fp, r1
   12e9c:	mov.w	r8, #3
   12ea0:	cbz	r6, 12ec4 <_dtoa_r+0x6bc>
   12ea2:	ldr	r7, [pc, #536]	; (130bc <_dtoa_r+0x8b4>)
   12ea4:	lsls	r1, r6, #31
   12ea6:	bpl.n	12ebc <_dtoa_r+0x6b4>
   12ea8:	mov	r0, r4
   12eaa:	mov	r1, r5
   12eac:	ldrd	r2, r3, [r7]
   12eb0:	bl	eea4 <__aeabi_dmul>
   12eb4:	add.w	r8, r8, #1
   12eb8:	mov	r4, r0
   12eba:	mov	r5, r1
   12ebc:	asrs	r6, r6, #1
   12ebe:	add.w	r7, r7, #8
   12ec2:	bne.n	12ea4 <_dtoa_r+0x69c>
   12ec4:	mov	r2, r4
   12ec6:	mov	r3, r5
   12ec8:	mov	r0, sl
   12eca:	mov	r1, fp
   12ecc:	bl	f0f8 <__aeabi_ddiv>
   12ed0:	mov	r6, r0
   12ed2:	mov	r7, r1
   12ed4:	ldr	r3, [sp, #48]	; 0x30
   12ed6:	cbz	r3, 12eea <_dtoa_r+0x6e2>
   12ed8:	movs	r2, #0
   12eda:	ldr	r3, [pc, #484]	; (130c0 <_dtoa_r+0x8b8>)
   12edc:	mov	r0, r6
   12ede:	mov	r1, r7
   12ee0:	bl	f388 <__aeabi_dcmplt>
   12ee4:	cmp	r0, #0
   12ee6:	bne.w	1352a <_dtoa_r+0xd22>
   12eea:	mov	r0, r8
   12eec:	bl	edd8 <__aeabi_i2d>
   12ef0:	mov	r2, r6
   12ef2:	mov	r3, r7
   12ef4:	bl	eea4 <__aeabi_dmul>
   12ef8:	ldr	r3, [pc, #456]	; (130c4 <_dtoa_r+0x8bc>)
   12efa:	movs	r2, #0
   12efc:	bl	eb40 <__adddf3>
   12f00:	ldr	r3, [sp, #24]
   12f02:	mov	r4, r0
   12f04:	sub.w	r5, r1, #54525952	; 0x3400000
   12f08:	cmp	r3, #0
   12f0a:	beq.w	132cc <_dtoa_r+0xac4>
   12f0e:	ldr	r3, [sp, #16]
   12f10:	ldr.w	r8, [sp, #24]
   12f14:	str	r3, [sp, #68]	; 0x44
   12f16:	ldr	r3, [sp, #36]	; 0x24
   12f18:	cmp	r3, #0
   12f1a:	beq.w	1344c <_dtoa_r+0xc44>
   12f1e:	ldr	r3, [pc, #408]	; (130b8 <_dtoa_r+0x8b0>)
   12f20:	ldr	r1, [pc, #420]	; (130c8 <_dtoa_r+0x8c0>)
   12f22:	add.w	r3, r3, r8, lsl #3
   12f26:	ldrd	r2, r3, [r3, #-8]
   12f2a:	movs	r0, #0
   12f2c:	bl	f0f8 <__aeabi_ddiv>
   12f30:	mov	r2, r4
   12f32:	mov	r3, r5
   12f34:	bl	eb3c <__aeabi_dsub>
   12f38:	mov	sl, r0
   12f3a:	mov	fp, r1
   12f3c:	mov	r0, r6
   12f3e:	mov	r1, r7
   12f40:	bl	f404 <__aeabi_d2iz>
   12f44:	mov	r4, r0
   12f46:	bl	edd8 <__aeabi_i2d>
   12f4a:	mov	r2, r0
   12f4c:	mov	r3, r1
   12f4e:	mov	r0, r6
   12f50:	mov	r1, r7
   12f52:	bl	eb3c <__aeabi_dsub>
   12f56:	adds	r4, #48	; 0x30
   12f58:	ldr	r5, [sp, #28]
   12f5a:	uxtb	r4, r4
   12f5c:	mov	r6, r0
   12f5e:	mov	r7, r1
   12f60:	strb	r4, [r5, #0]
   12f62:	mov	r2, r0
   12f64:	mov	r3, r1
   12f66:	mov	r0, sl
   12f68:	mov	r1, fp
   12f6a:	adds	r5, #1
   12f6c:	bl	f3c4 <__aeabi_dcmpgt>
   12f70:	cmp	r0, #0
   12f72:	bne.n	1300e <_dtoa_r+0x806>
   12f74:	mov	r2, r6
   12f76:	mov	r3, r7
   12f78:	movs	r0, #0
   12f7a:	ldr	r1, [pc, #324]	; (130c0 <_dtoa_r+0x8b8>)
   12f7c:	bl	eb3c <__aeabi_dsub>
   12f80:	mov	r2, r0
   12f82:	mov	r3, r1
   12f84:	mov	r0, sl
   12f86:	mov	r1, fp
   12f88:	bl	f3c4 <__aeabi_dcmpgt>
   12f8c:	cmp	r0, #0
   12f8e:	bne.w	135ac <_dtoa_r+0xda4>
   12f92:	cmp.w	r8, #1
   12f96:	ble.w	13300 <_dtoa_r+0xaf8>
   12f9a:	ldr	r3, [sp, #28]
   12f9c:	add	r8, r3
   12f9e:	b.n	12fbc <_dtoa_r+0x7b4>
   12fa0:	movs	r0, #0
   12fa2:	ldr	r1, [pc, #284]	; (130c0 <_dtoa_r+0x8b8>)
   12fa4:	bl	eb3c <__aeabi_dsub>
   12fa8:	mov	r2, sl
   12faa:	mov	r3, fp
   12fac:	bl	f388 <__aeabi_dcmplt>
   12fb0:	cmp	r0, #0
   12fb2:	bne.w	135ac <_dtoa_r+0xda4>
   12fb6:	cmp	r5, r8
   12fb8:	beq.w	13300 <_dtoa_r+0xaf8>
   12fbc:	mov	r0, sl
   12fbe:	mov	r1, fp
   12fc0:	movs	r2, #0
   12fc2:	ldr	r3, [pc, #264]	; (130cc <_dtoa_r+0x8c4>)
   12fc4:	bl	eea4 <__aeabi_dmul>
   12fc8:	movs	r2, #0
   12fca:	ldr	r3, [pc, #256]	; (130cc <_dtoa_r+0x8c4>)
   12fcc:	mov	sl, r0
   12fce:	mov	fp, r1
   12fd0:	mov	r0, r6
   12fd2:	mov	r1, r7
   12fd4:	bl	eea4 <__aeabi_dmul>
   12fd8:	mov	r7, r1
   12fda:	mov	r6, r0
   12fdc:	bl	f404 <__aeabi_d2iz>
   12fe0:	mov	r4, r0
   12fe2:	bl	edd8 <__aeabi_i2d>
   12fe6:	mov	r2, r0
   12fe8:	mov	r3, r1
   12fea:	mov	r0, r6
   12fec:	mov	r1, r7
   12fee:	bl	eb3c <__aeabi_dsub>
   12ff2:	adds	r4, #48	; 0x30
   12ff4:	uxtb	r4, r4
   12ff6:	mov	r2, sl
   12ff8:	mov	r3, fp
   12ffa:	strb.w	r4, [r5], #1
   12ffe:	mov	r6, r0
   13000:	mov	r7, r1
   13002:	bl	f388 <__aeabi_dcmplt>
   13006:	mov	r2, r6
   13008:	mov	r3, r7
   1300a:	cmp	r0, #0
   1300c:	beq.n	12fa0 <_dtoa_r+0x798>
   1300e:	ldr	r3, [sp, #68]	; 0x44
   13010:	str	r3, [sp, #16]
   13012:	b.n	12b9e <_dtoa_r+0x396>
   13014:	movs	r3, #0
   13016:	str	r3, [sp, #36]	; 0x24
   13018:	ldr	r3, [sp, #132]	; 0x84
   1301a:	cmp	r3, #0
   1301c:	ble.w	13332 <_dtoa_r+0xb2a>
   13020:	mov	r6, r3
   13022:	mov	r4, r3
   13024:	str	r3, [sp, #52]	; 0x34
   13026:	str	r3, [sp, #24]
   13028:	b.n	12e26 <_dtoa_r+0x61e>
   1302a:	movs	r3, #1
   1302c:	str	r3, [sp, #36]	; 0x24
   1302e:	b.n	13018 <_dtoa_r+0x810>
   13030:	str	r4, [sp, #32]
   13032:	ldr	r2, [sp, #40]	; 0x28
   13034:	ldr	r1, [sp, #32]
   13036:	mov	r0, r9
   13038:	bl	13cbc <__pow5mult>
   1303c:	mov	r4, r0
   1303e:	b.n	12c64 <_dtoa_r+0x45c>
   13040:	ldr	r3, [sp, #24]
   13042:	cmp	r3, #0
   13044:	bgt.w	12a40 <_dtoa_r+0x238>
   13048:	bne.w	13600 <_dtoa_r+0xdf8>
   1304c:	movs	r2, #0
   1304e:	ldr	r3, [pc, #128]	; (130d0 <_dtoa_r+0x8c8>)
   13050:	ldrd	r0, r1, [sp, #8]
   13054:	bl	eea4 <__aeabi_dmul>
   13058:	mov	r2, sl
   1305a:	mov	r3, fp
   1305c:	bl	f3b0 <__aeabi_dcmpge>
   13060:	ldr.w	r8, [sp, #24]
   13064:	mov	r6, r8
   13066:	cmp	r0, #0
   13068:	beq.w	13250 <_dtoa_r+0xa48>
   1306c:	ldr	r3, [sp, #132]	; 0x84
   1306e:	ldr	r5, [sp, #28]
   13070:	mvns	r3, r3
   13072:	str	r3, [sp, #16]
   13074:	mov	r1, r8
   13076:	mov	r0, r9
   13078:	bl	13a48 <_Bfree>
   1307c:	cmp	r6, #0
   1307e:	beq.w	12b9e <_dtoa_r+0x396>
   13082:	b.n	12da0 <_dtoa_r+0x598>
   13084:	ldr	r2, [sp, #64]	; 0x40
   13086:	cmp	r2, #0
   13088:	beq.w	1350e <_dtoa_r+0xd06>
   1308c:	addw	r3, r3, #1075	; 0x433
   13090:	ldr	r7, [sp, #40]	; 0x28
   13092:	ldr	r5, [sp, #20]
   13094:	b.n	12bee <_dtoa_r+0x3e6>
   13096:	movs	r0, #28
   13098:	ldr	r3, [sp, #20]
   1309a:	add	r3, r0
   1309c:	str	r3, [sp, #20]
   1309e:	ldr	r3, [sp, #8]
   130a0:	add	r3, r0
   130a2:	add	r5, r0
   130a4:	str	r3, [sp, #8]
   130a6:	b.n	12cc6 <_dtoa_r+0x4be>
   130a8:	ldr	r3, [sp, #128]	; 0x80
   130aa:	cmp	r3, #1
   130ac:	ble.w	135b4 <_dtoa_r+0xdac>
   130b0:	ldr	r7, [sp, #44]	; 0x2c
   130b2:	movs	r0, #1
   130b4:	b.n	12c9e <_dtoa_r+0x496>
   130b6:	nop
   130b8:	.word	0x00014a78
   130bc:	.word	0x00014b50
   130c0:	.word	0x3ff00000
   130c4:	.word	0x401c0000
   130c8:	.word	0x3fe00000
   130cc:	.word	0x40240000
   130d0:	.word	0x40140000
   130d4:	mov	r1, r6
   130d6:	movs	r3, #0
   130d8:	movs	r2, #10
   130da:	mov	r0, r9
   130dc:	bl	13a5c <__multadd>
   130e0:	ldr	r3, [sp, #52]	; 0x34
   130e2:	cmp	r3, #0
   130e4:	mov	r6, r0
   130e6:	ble.w	13618 <_dtoa_r+0xe10>
   130ea:	str	r3, [sp, #24]
   130ec:	cmp	r5, #0
   130ee:	ble.n	130fc <_dtoa_r+0x8f4>
   130f0:	mov	r1, r6
   130f2:	mov	r2, r5
   130f4:	mov	r0, r9
   130f6:	bl	13d5c <__lshift>
   130fa:	mov	r6, r0
   130fc:	cmp	r7, #0
   130fe:	bne.w	133fa <_dtoa_r+0xbf2>
   13102:	str	r6, [sp, #20]
   13104:	ldr	r3, [sp, #24]
   13106:	ldr	r2, [sp, #28]
   13108:	ldr.w	fp, [sp, #20]
   1310c:	subs	r3, #1
   1310e:	adds	r3, r2, r3
   13110:	str	r3, [sp, #32]
   13112:	and.w	r3, sl, #1
   13116:	str	r3, [sp, #36]	; 0x24
   13118:	mov	r7, r2
   1311a:	mov	sl, r8
   1311c:	mov	r1, sl
   1311e:	mov	r0, r4
   13120:	bl	126dc <quorem>
   13124:	mov	r1, r6
   13126:	mov	r5, r0
   13128:	mov	r0, r4
   1312a:	bl	13e0c <__mcmp>
   1312e:	mov	r2, fp
   13130:	str	r0, [sp, #8]
   13132:	mov	r1, sl
   13134:	mov	r0, r9
   13136:	bl	13e4c <__mdiff>
   1313a:	ldr	r2, [r0, #12]
   1313c:	mov	r8, r0
   1313e:	add.w	r3, r5, #48	; 0x30
   13142:	cmp	r2, #0
   13144:	bne.n	131da <_dtoa_r+0x9d2>
   13146:	mov	r1, r0
   13148:	mov	r0, r4
   1314a:	str	r3, [sp, #24]
   1314c:	bl	13e0c <__mcmp>
   13150:	mov	r1, r8
   13152:	str	r0, [sp, #20]
   13154:	mov	r0, r9
   13156:	bl	13a48 <_Bfree>
   1315a:	ldr	r2, [sp, #20]
   1315c:	ldr	r3, [sp, #24]
   1315e:	cbnz	r2, 1316c <_dtoa_r+0x964>
   13160:	ldr	r1, [sp, #128]	; 0x80
   13162:	cbnz	r1, 1316c <_dtoa_r+0x964>
   13164:	ldr	r1, [sp, #36]	; 0x24
   13166:	cmp	r1, #0
   13168:	beq.w	135d8 <_dtoa_r+0xdd0>
   1316c:	ldr	r1, [sp, #8]
   1316e:	cmp	r1, #0
   13170:	blt.w	1333c <_dtoa_r+0xb34>
   13174:	bne.n	13182 <_dtoa_r+0x97a>
   13176:	ldr	r1, [sp, #128]	; 0x80
   13178:	cbnz	r1, 13182 <_dtoa_r+0x97a>
   1317a:	ldr	r1, [sp, #36]	; 0x24
   1317c:	cmp	r1, #0
   1317e:	beq.w	1333c <_dtoa_r+0xb34>
   13182:	cmp	r2, #0
   13184:	bgt.w	13422 <_dtoa_r+0xc1a>
   13188:	ldr	r2, [sp, #32]
   1318a:	strb	r3, [r7, #0]
   1318c:	add.w	r8, r7, #1
   13190:	cmp	r7, r2
   13192:	mov	r5, r8
   13194:	beq.w	13440 <_dtoa_r+0xc38>
   13198:	mov	r1, r4
   1319a:	movs	r3, #0
   1319c:	movs	r2, #10
   1319e:	mov	r0, r9
   131a0:	bl	13a5c <__multadd>
   131a4:	cmp	r6, fp
   131a6:	mov	r4, r0
   131a8:	mov	r1, r6
   131aa:	mov.w	r3, #0
   131ae:	mov.w	r2, #10
   131b2:	mov	r0, r9
   131b4:	beq.n	131ce <_dtoa_r+0x9c6>
   131b6:	bl	13a5c <__multadd>
   131ba:	mov	r1, fp
   131bc:	mov	r6, r0
   131be:	movs	r3, #0
   131c0:	movs	r2, #10
   131c2:	mov	r0, r9
   131c4:	bl	13a5c <__multadd>
   131c8:	mov	r7, r8
   131ca:	mov	fp, r0
   131cc:	b.n	1311c <_dtoa_r+0x914>
   131ce:	bl	13a5c <__multadd>
   131d2:	mov	r7, r8
   131d4:	mov	r6, r0
   131d6:	mov	fp, r0
   131d8:	b.n	1311c <_dtoa_r+0x914>
   131da:	mov	r1, r0
   131dc:	mov	r0, r9
   131de:	str	r3, [sp, #20]
   131e0:	bl	13a48 <_Bfree>
   131e4:	movs	r2, #1
   131e6:	ldr	r3, [sp, #20]
   131e8:	b.n	1316c <_dtoa_r+0x964>
   131ea:	mov	r1, r8
   131ec:	mov	r0, r4
   131ee:	bl	13e0c <__mcmp>
   131f2:	cmp	r0, #0
   131f4:	bge.w	12cf2 <_dtoa_r+0x4ea>
   131f8:	mov	r1, r4
   131fa:	ldr	r4, [sp, #16]
   131fc:	movs	r3, #0
   131fe:	subs	r4, #1
   13200:	movs	r2, #10
   13202:	mov	r0, r9
   13204:	str	r4, [sp, #16]
   13206:	bl	13a5c <__multadd>
   1320a:	ldr	r3, [sp, #36]	; 0x24
   1320c:	mov	r4, r0
   1320e:	cmp	r3, #0
   13210:	bne.w	130d4 <_dtoa_r+0x8cc>
   13214:	ldr	r3, [sp, #52]	; 0x34
   13216:	cmp	r3, #0
   13218:	ble.w	13608 <_dtoa_r+0xe00>
   1321c:	str	r3, [sp, #24]
   1321e:	b.n	12d02 <_dtoa_r+0x4fa>
   13220:	ldr	r4, [sp, #32]
   13222:	b.n	12c64 <_dtoa_r+0x45c>
   13224:	ldr	r3, [sp, #128]	; 0x80
   13226:	cmp	r3, #2
   13228:	ble.w	12cfa <_dtoa_r+0x4f2>
   1322c:	ldr	r3, [sp, #24]
   1322e:	cmp	r3, #0
   13230:	bne.w	13526 <_dtoa_r+0xd1e>
   13234:	mov	r1, r8
   13236:	movs	r2, #5
   13238:	mov	r0, r9
   1323a:	bl	13a5c <__multadd>
   1323e:	mov	r1, r0
   13240:	mov	r8, r0
   13242:	mov	r0, r4
   13244:	bl	13e0c <__mcmp>
   13248:	cmp	r0, #0
   1324a:	str	r4, [sp, #32]
   1324c:	ble.w	1306c <_dtoa_r+0x864>
   13250:	ldr	r2, [sp, #16]
   13252:	ldr	r1, [sp, #28]
   13254:	movs	r3, #49	; 0x31
   13256:	adds	r2, #1
   13258:	str	r2, [sp, #16]
   1325a:	strb	r3, [r1, #0]
   1325c:	adds	r5, r1, #1
   1325e:	b.n	13074 <_dtoa_r+0x86c>
   13260:	ldr	r2, [sp, #16]
   13262:	adds	r2, #1
   13264:	str	r2, [sp, #16]
   13266:	ldr	r2, [sp, #28]
   13268:	movs	r3, #49	; 0x31
   1326a:	strb	r3, [r2, #0]
   1326c:	b.n	12d80 <_dtoa_r+0x578>
   1326e:	movs	r3, #1
   13270:	str	r3, [sp, #36]	; 0x24
   13272:	b.n	12e10 <_dtoa_r+0x608>
   13274:	ldr.w	r9, [sp, #20]
   13278:	b.n	12b9e <_dtoa_r+0x396>
   1327a:	cmp.w	sl, #0
   1327e:	bne.w	12c8a <_dtoa_r+0x482>
   13282:	ubfx	r3, fp, #0, #20
   13286:	cmp	r3, #0
   13288:	bne.w	1350a <_dtoa_r+0xd02>
   1328c:	bic.w	r7, fp, #2147483648	; 0x80000000
   13290:	lsrs	r7, r7, #20
   13292:	lsls	r7, r7, #20
   13294:	cbz	r7, 132a4 <_dtoa_r+0xa9c>
   13296:	ldr	r3, [sp, #20]
   13298:	adds	r3, #1
   1329a:	str	r3, [sp, #20]
   1329c:	ldr	r3, [sp, #8]
   1329e:	adds	r3, #1
   132a0:	str	r3, [sp, #8]
   132a2:	movs	r7, #1
   132a4:	ldr	r3, [sp, #44]	; 0x2c
   132a6:	movs	r0, #1
   132a8:	cmp	r3, #0
   132aa:	beq.w	12c9e <_dtoa_r+0x496>
   132ae:	b.n	12c8c <_dtoa_r+0x484>
   132b0:	mov	r0, r8
   132b2:	bl	edd8 <__aeabi_i2d>
   132b6:	mov	r2, r6
   132b8:	mov	r3, r7
   132ba:	bl	eea4 <__aeabi_dmul>
   132be:	movs	r2, #0
   132c0:	ldr	r3, [pc, #764]	; (135c0 <_dtoa_r+0xdb8>)
   132c2:	bl	eb40 <__adddf3>
   132c6:	mov	r4, r0
   132c8:	sub.w	r5, r1, #54525952	; 0x3400000
   132cc:	mov	r0, r6
   132ce:	mov	r1, r7
   132d0:	movs	r2, #0
   132d2:	ldr	r3, [pc, #752]	; (135c4 <_dtoa_r+0xdbc>)
   132d4:	bl	eb3c <__aeabi_dsub>
   132d8:	mov	r2, r4
   132da:	mov	r3, r5
   132dc:	mov	r6, r0
   132de:	mov	r7, r1
   132e0:	bl	f3c4 <__aeabi_dcmpgt>
   132e4:	mov	r8, r0
   132e6:	cmp	r0, #0
   132e8:	bne.w	134f6 <_dtoa_r+0xcee>
   132ec:	mov	r2, r4
   132ee:	add.w	r3, r5, #2147483648	; 0x80000000
   132f2:	mov	r0, r6
   132f4:	mov	r1, r7
   132f6:	bl	f388 <__aeabi_dcmplt>
   132fa:	cbz	r0, 13300 <_dtoa_r+0xaf8>
   132fc:	mov	r6, r8
   132fe:	b.n	1306c <_dtoa_r+0x864>
   13300:	ldrd	sl, fp, [sp, #56]	; 0x38
   13304:	b.w	12a1a <_dtoa_r+0x212>
   13308:	ldr	r0, [sp, #28]
   1330a:	b.w	1286a <_dtoa_r+0x62>
   1330e:	ldr	r3, [sp, #40]	; 0x28
   13310:	ldr	r2, [sp, #44]	; 0x2c
   13312:	str	r7, [sp, #40]	; 0x28
   13314:	subs	r3, r7, r3
   13316:	add	r2, r3
   13318:	str	r2, [sp, #44]	; 0x2c
   1331a:	movs	r7, #0
   1331c:	b.n	12be2 <_dtoa_r+0x3da>
   1331e:	ldrd	sl, fp, [sp, #56]	; 0x38
   13322:	mov.w	r8, #2
   13326:	b.n	12ea0 <_dtoa_r+0x698>
   13328:	mov	r4, r3
   1332a:	movs	r1, #0
   1332c:	str.w	r1, [r9, #68]	; 0x44
   13330:	b.n	12e48 <_dtoa_r+0x640>
   13332:	movs	r4, #1
   13334:	str	r4, [sp, #132]	; 0x84
   13336:	str	r4, [sp, #52]	; 0x34
   13338:	str	r4, [sp, #24]
   1333a:	b.n	1332a <_dtoa_r+0xb22>
   1333c:	cmp	r2, #0
   1333e:	mov	r8, sl
   13340:	str.w	fp, [sp, #20]
   13344:	mov	sl, r3
   13346:	ble.n	1336c <_dtoa_r+0xb64>
   13348:	mov	r1, r4
   1334a:	movs	r2, #1
   1334c:	mov	r0, r9
   1334e:	bl	13d5c <__lshift>
   13352:	mov	r1, r8
   13354:	mov	r4, r0
   13356:	bl	13e0c <__mcmp>
   1335a:	cmp	r0, #0
   1335c:	ble.w	135f2 <_dtoa_r+0xdea>
   13360:	cmp.w	sl, #57	; 0x39
   13364:	beq.w	13574 <_dtoa_r+0xd6c>
   13368:	add.w	sl, r5, #49	; 0x31
   1336c:	mov	fp, r6
   1336e:	strb.w	sl, [r7]
   13372:	adds	r5, r7, #1
   13374:	ldr	r6, [sp, #20]
   13376:	str	r4, [sp, #32]
   13378:	b.n	12d80 <_dtoa_r+0x578>
   1337a:	bne.n	13386 <_dtoa_r+0xb7e>
   1337c:	tst.w	sl, #1
   13380:	beq.n	13386 <_dtoa_r+0xb7e>
   13382:	b.n	12d60 <_dtoa_r+0x558>
   13384:	mov	r5, r2
   13386:	ldrb.w	r3, [r5, #-1]
   1338a:	cmp	r3, #48	; 0x30
   1338c:	add.w	r2, r5, #4294967295
   13390:	beq.n	13384 <_dtoa_r+0xb7c>
   13392:	b.n	12d80 <_dtoa_r+0x578>
   13394:	ldr	r3, [sp, #16]
   13396:	negs	r4, r3
   13398:	cmp	r4, #0
   1339a:	beq.w	1351c <_dtoa_r+0xd14>
   1339e:	ldr	r3, [pc, #552]	; (135c8 <_dtoa_r+0xdc0>)
   133a0:	and.w	r2, r4, #15
   133a4:	add.w	r3, r3, r2, lsl #3
   133a8:	ldrd	r2, r3, [r3]
   133ac:	ldrd	r0, r1, [sp, #56]	; 0x38
   133b0:	bl	eea4 <__aeabi_dmul>
   133b4:	asrs	r4, r4, #4
   133b6:	mov	r6, r0
   133b8:	mov	r7, r1
   133ba:	beq.w	13612 <_dtoa_r+0xe0a>
   133be:	ldr	r5, [pc, #524]	; (135cc <_dtoa_r+0xdc4>)
   133c0:	mov.w	r8, #2
   133c4:	lsls	r2, r4, #31
   133c6:	bpl.n	133dc <_dtoa_r+0xbd4>
   133c8:	mov	r0, r6
   133ca:	mov	r1, r7
   133cc:	ldrd	r2, r3, [r5]
   133d0:	bl	eea4 <__aeabi_dmul>
   133d4:	add.w	r8, r8, #1
   133d8:	mov	r6, r0
   133da:	mov	r7, r1
   133dc:	asrs	r4, r4, #1
   133de:	add.w	r5, r5, #8
   133e2:	bne.n	133c4 <_dtoa_r+0xbbc>
   133e4:	b.n	12ed4 <_dtoa_r+0x6cc>
   133e6:	ldr	r1, [sp, #28]
   133e8:	movs	r2, #48	; 0x30
   133ea:	strb	r2, [r1, #0]
   133ec:	ldr	r2, [sp, #16]
   133ee:	ldrb.w	r4, [r5, #-1]
   133f2:	adds	r2, #1
   133f4:	str	r2, [sp, #16]
   133f6:	b.w	12b9a <_dtoa_r+0x392>
   133fa:	ldr	r1, [r6, #4]
   133fc:	mov	r0, r9
   133fe:	bl	139fc <_Balloc>
   13402:	ldr	r3, [r6, #16]
   13404:	adds	r2, r3, #2
   13406:	mov	r5, r0
   13408:	lsls	r2, r2, #2
   1340a:	add.w	r1, r6, #12
   1340e:	adds	r0, #12
   13410:	bl	cb10 <memcpy>
   13414:	mov	r1, r5
   13416:	movs	r2, #1
   13418:	mov	r0, r9
   1341a:	bl	13d5c <__lshift>
   1341e:	str	r0, [sp, #20]
   13420:	b.n	13104 <_dtoa_r+0x8fc>
   13422:	cmp	r3, #57	; 0x39
   13424:	str.w	fp, [sp, #20]
   13428:	mov	r8, sl
   1342a:	beq.w	13574 <_dtoa_r+0xd6c>
   1342e:	add.w	sl, r3, #1
   13432:	mov	fp, r6
   13434:	strb.w	sl, [r7]
   13438:	adds	r5, r7, #1
   1343a:	ldr	r6, [sp, #20]
   1343c:	str	r4, [sp, #32]
   1343e:	b.n	12d80 <_dtoa_r+0x578>
   13440:	mov	r2, fp
   13442:	mov	r8, sl
   13444:	mov	fp, r6
   13446:	mov	sl, r3
   13448:	mov	r6, r2
   1344a:	b.n	12d48 <_dtoa_r+0x540>
   1344c:	ldr	r1, [pc, #376]	; (135c8 <_dtoa_r+0xdc0>)
   1344e:	add.w	sl, r8, #4294967295
   13452:	add.w	r1, r1, sl, lsl #3
   13456:	mov	r2, r4
   13458:	mov	r3, r5
   1345a:	ldrd	r0, r1, [r1]
   1345e:	bl	eea4 <__aeabi_dmul>
   13462:	strd	r0, r1, [sp, #72]	; 0x48
   13466:	mov	r1, r7
   13468:	mov	r0, r6
   1346a:	bl	f404 <__aeabi_d2iz>
   1346e:	mov	r4, r0
   13470:	bl	edd8 <__aeabi_i2d>
   13474:	mov	r2, r0
   13476:	mov	r3, r1
   13478:	mov	r0, r6
   1347a:	mov	r1, r7
   1347c:	bl	eb3c <__aeabi_dsub>
   13480:	ldr	r2, [sp, #28]
   13482:	adds	r4, #48	; 0x30
   13484:	cmp.w	r8, #1
   13488:	mov	r6, r0
   1348a:	mov	r7, r1
   1348c:	strb	r4, [r2, #0]
   1348e:	add.w	r5, r2, #1
   13492:	beq.n	134d2 <_dtoa_r+0xcca>
   13494:	ldr	r3, [sp, #28]
   13496:	add.w	fp, r3, r8
   1349a:	mov	r8, r5
   1349c:	movs	r2, #0
   1349e:	ldr	r3, [pc, #304]	; (135d0 <_dtoa_r+0xdc8>)
   134a0:	mov	r0, r6
   134a2:	mov	r1, r7
   134a4:	bl	eea4 <__aeabi_dmul>
   134a8:	mov	r7, r1
   134aa:	mov	r6, r0
   134ac:	bl	f404 <__aeabi_d2iz>
   134b0:	mov	r4, r0
   134b2:	bl	edd8 <__aeabi_i2d>
   134b6:	adds	r4, #48	; 0x30
   134b8:	mov	r2, r0
   134ba:	mov	r3, r1
   134bc:	mov	r0, r6
   134be:	mov	r1, r7
   134c0:	bl	eb3c <__aeabi_dsub>
   134c4:	strb.w	r4, [r8], #1
   134c8:	cmp	fp, r8
   134ca:	mov	r6, r0
   134cc:	mov	r7, r1
   134ce:	bne.n	1349c <_dtoa_r+0xc94>
   134d0:	add	r5, sl
   134d2:	movs	r2, #0
   134d4:	ldr	r3, [pc, #252]	; (135d4 <_dtoa_r+0xdcc>)
   134d6:	ldrd	r0, r1, [sp, #72]	; 0x48
   134da:	bl	eb40 <__adddf3>
   134de:	mov	r2, r6
   134e0:	mov	r3, r7
   134e2:	bl	f388 <__aeabi_dcmplt>
   134e6:	cmp	r0, #0
   134e8:	beq.n	13584 <_dtoa_r+0xd7c>
   134ea:	ldr	r3, [sp, #68]	; 0x44
   134ec:	str	r3, [sp, #16]
   134ee:	ldrb.w	r4, [r5, #-1]
   134f2:	b.w	12b82 <_dtoa_r+0x37a>
   134f6:	mov.w	r8, #0
   134fa:	mov	r6, r8
   134fc:	b.n	13250 <_dtoa_r+0xa48>
   134fe:	ldr	r3, [sp, #20]
   13500:	ldr	r2, [sp, #24]
   13502:	subs	r5, r3, r2
   13504:	movs	r3, #0
   13506:	b.w	12bee <_dtoa_r+0x3e6>
   1350a:	movs	r7, #0
   1350c:	b.n	132a4 <_dtoa_r+0xa9c>
   1350e:	ldr	r3, [sp, #80]	; 0x50
   13510:	ldr	r7, [sp, #40]	; 0x28
   13512:	ldr	r5, [sp, #20]
   13514:	rsb	r3, r3, #54	; 0x36
   13518:	b.w	12bee <_dtoa_r+0x3e6>
   1351c:	ldrd	r6, r7, [sp, #56]	; 0x38
   13520:	mov.w	r8, #2
   13524:	b.n	12ed4 <_dtoa_r+0x6cc>
   13526:	str	r4, [sp, #32]
   13528:	b.n	1306c <_dtoa_r+0x864>
   1352a:	ldr	r3, [sp, #24]
   1352c:	cmp	r3, #0
   1352e:	beq.w	132b0 <_dtoa_r+0xaa8>
   13532:	ldr	r3, [sp, #52]	; 0x34
   13534:	cmp	r3, #0
   13536:	ble.w	13300 <_dtoa_r+0xaf8>
   1353a:	movs	r2, #0
   1353c:	ldr	r3, [pc, #144]	; (135d0 <_dtoa_r+0xdc8>)
   1353e:	mov	r0, r6
   13540:	mov	r1, r7
   13542:	bl	eea4 <__aeabi_dmul>
   13546:	mov	r6, r0
   13548:	mov	r7, r1
   1354a:	add.w	r0, r8, #1
   1354e:	bl	edd8 <__aeabi_i2d>
   13552:	mov	r2, r6
   13554:	mov	r3, r7
   13556:	bl	eea4 <__aeabi_dmul>
   1355a:	movs	r2, #0
   1355c:	ldr	r3, [pc, #96]	; (135c0 <_dtoa_r+0xdb8>)
   1355e:	bl	eb40 <__adddf3>
   13562:	ldr	r2, [sp, #16]
   13564:	ldr.w	r8, [sp, #52]	; 0x34
   13568:	subs	r2, #1
   1356a:	mov	r4, r0
   1356c:	sub.w	r5, r1, #54525952	; 0x3400000
   13570:	str	r2, [sp, #68]	; 0x44
   13572:	b.n	12f16 <_dtoa_r+0x70e>
   13574:	movs	r2, #57	; 0x39
   13576:	mov	fp, r6
   13578:	str	r4, [sp, #32]
   1357a:	ldr	r6, [sp, #20]
   1357c:	strb	r2, [r7, #0]
   1357e:	adds	r5, r7, #1
   13580:	b.w	12d64 <_dtoa_r+0x55c>
   13584:	ldrd	r2, r3, [sp, #72]	; 0x48
   13588:	movs	r0, #0
   1358a:	ldr	r1, [pc, #72]	; (135d4 <_dtoa_r+0xdcc>)
   1358c:	bl	eb3c <__aeabi_dsub>
   13590:	mov	r2, r6
   13592:	mov	r3, r7
   13594:	bl	f3c4 <__aeabi_dcmpgt>
   13598:	cbnz	r0, 1359e <_dtoa_r+0xd96>
   1359a:	b.n	13300 <_dtoa_r+0xaf8>
   1359c:	mov	r5, r2
   1359e:	ldrb.w	r3, [r5, #-1]
   135a2:	cmp	r3, #48	; 0x30
   135a4:	add.w	r2, r5, #4294967295
   135a8:	beq.n	1359c <_dtoa_r+0xd94>
   135aa:	b.n	1300e <_dtoa_r+0x806>
   135ac:	ldr	r3, [sp, #68]	; 0x44
   135ae:	str	r3, [sp, #16]
   135b0:	b.w	12b82 <_dtoa_r+0x37a>
   135b4:	cmp.w	sl, #0
   135b8:	bne.w	130b0 <_dtoa_r+0x8a8>
   135bc:	b.n	13282 <_dtoa_r+0xa7a>
   135be:	nop
   135c0:	.word	0x401c0000
   135c4:	.word	0x40140000
   135c8:	.word	0x00014a78
   135cc:	.word	0x00014b50
   135d0:	.word	0x40240000
   135d4:	.word	0x3fe00000
   135d8:	cmp	r3, #57	; 0x39
   135da:	str.w	fp, [sp, #20]
   135de:	mov	r8, sl
   135e0:	ldr.w	fp, [sp, #8]
   135e4:	mov	sl, r3
   135e6:	beq.n	13574 <_dtoa_r+0xd6c>
   135e8:	cmp.w	fp, #0
   135ec:	bgt.w	13368 <_dtoa_r+0xb60>
   135f0:	b.n	1336c <_dtoa_r+0xb64>
   135f2:	bne.w	1336c <_dtoa_r+0xb64>
   135f6:	tst.w	sl, #1
   135fa:	beq.w	1336c <_dtoa_r+0xb64>
   135fe:	b.n	13360 <_dtoa_r+0xb58>
   13600:	mov.w	r8, #0
   13604:	mov	r6, r8
   13606:	b.n	1306c <_dtoa_r+0x864>
   13608:	ldr	r3, [sp, #128]	; 0x80
   1360a:	cmp	r3, #2
   1360c:	bgt.n	13652 <_dtoa_r+0xe4a>
   1360e:	ldr	r3, [sp, #52]	; 0x34
   13610:	b.n	1321c <_dtoa_r+0xa14>
   13612:	mov.w	r8, #2
   13616:	b.n	12ed4 <_dtoa_r+0x6cc>
   13618:	ldr	r3, [sp, #128]	; 0x80
   1361a:	cmp	r3, #2
   1361c:	bgt.n	13652 <_dtoa_r+0xe4a>
   1361e:	ldr	r3, [sp, #52]	; 0x34
   13620:	b.n	130ea <_dtoa_r+0x8e2>
   13622:	movs	r4, #0
   13624:	str.w	r4, [r9, #68]	; 0x44
   13628:	mov	r1, r4
   1362a:	mov	r0, r9
   1362c:	bl	139fc <_Balloc>
   13630:	mov.w	r3, #4294967295
   13634:	str	r3, [sp, #24]
   13636:	str	r3, [sp, #52]	; 0x34
   13638:	movs	r3, #1
   1363a:	str	r0, [sp, #28]
   1363c:	str	r4, [sp, #132]	; 0x84
   1363e:	str.w	r0, [r9, #64]	; 0x40
   13642:	str	r3, [sp, #36]	; 0x24
   13644:	b.w	12a1a <_dtoa_r+0x212>
   13648:	beq.w	12cc6 <_dtoa_r+0x4be>
   1364c:	rsb	r0, r0, #60	; 0x3c
   13650:	b.n	13098 <_dtoa_r+0x890>
   13652:	ldr	r3, [sp, #52]	; 0x34
   13654:	str	r3, [sp, #24]
   13656:	b.n	1322c <_dtoa_r+0xa24>
   13658:	movs	r5, #1
   1365a:	b.w	129ae <_dtoa_r+0x1a6>
   1365e:	nop

00013660 <fcvtbuf>:
   13660:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13664:	sub	sp, #32
   13666:	ldr	r4, [pc, #216]	; (13740 <fcvtbuf+0xe0>)
   13668:	ldr	r5, [sp, #68]	; 0x44
   1366a:	ldr.w	r9, [r4]
   1366e:	mov	r6, r0
   13670:	mov	r7, r1
   13672:	mov	r4, r2
   13674:	mov	r8, r3
   13676:	cmp	r5, #0
   13678:	beq.n	13702 <fcvtbuf+0xa2>
   1367a:	movs	r2, #0
   1367c:	ldr	r3, [pc, #196]	; (13744 <fcvtbuf+0xe4>)
   1367e:	mov	r0, r6
   13680:	mov	r1, r7
   13682:	bl	f388 <__aeabi_dcmplt>
   13686:	cbnz	r0, 136ea <fcvtbuf+0x8a>
   13688:	add.w	lr, sp, #28
   1368c:	movs	r1, #3
   1368e:	ldr	r3, [sp, #64]	; 0x40
   13690:	str	r3, [sp, #12]
   13692:	str	r1, [sp, #0]
   13694:	mov	r3, r7
   13696:	str.w	r8, [sp, #8]
   1369a:	str	r4, [sp, #4]
   1369c:	mov	r2, r6
   1369e:	mov	r0, r9
   136a0:	str.w	lr, [sp, #16]
   136a4:	bl	12808 <_dtoa_r>
   136a8:	ldr	r3, [sp, #28]
   136aa:	ldr.w	r1, [r8]
   136ae:	cmp	r0, r3
   136b0:	rsb	r1, r1, #0
   136b4:	bcs.n	13714 <fcvtbuf+0xb4>
   136b6:	subs	r1, r1, r5
   136b8:	mov	r3, r5
   136ba:	ldrb.w	r2, [r0], #1
   136be:	strb.w	r2, [r3], #1
   136c2:	ldr	r2, [sp, #28]
   136c4:	cmp	r2, r0
   136c6:	add.w	r6, r3, r1
   136ca:	bhi.n	136ba <fcvtbuf+0x5a>
   136cc:	cmp	r4, r6
   136ce:	ble.n	1371a <fcvtbuf+0xba>
   136d0:	subs	r2, r4, r6
   136d2:	add	r2, r3
   136d4:	movs	r1, #48	; 0x30
   136d6:	strb.w	r1, [r3], #1
   136da:	cmp	r2, r3
   136dc:	bne.n	136d6 <fcvtbuf+0x76>
   136de:	movs	r3, #0
   136e0:	strb	r3, [r2, #0]
   136e2:	mov	r0, r5
   136e4:	add	sp, #32
   136e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   136ea:	movs	r2, #0
   136ec:	ldr	r3, [pc, #88]	; (13748 <fcvtbuf+0xe8>)
   136ee:	mov	r0, r6
   136f0:	mov	r1, r7
   136f2:	bl	f3c4 <__aeabi_dcmpgt>
   136f6:	cmp	r0, #0
   136f8:	beq.n	13688 <fcvtbuf+0x28>
   136fa:	add.w	lr, sp, #28
   136fe:	movs	r1, #2
   13700:	b.n	1368e <fcvtbuf+0x2e>
   13702:	ldr.w	r2, [r9, #80]	; 0x50
   13706:	add.w	r3, r4, #35	; 0x23
   1370a:	cmp	r2, r3
   1370c:	ble.n	1371e <fcvtbuf+0xbe>
   1370e:	ldr.w	r5, [r9, #84]	; 0x54
   13712:	b.n	1367a <fcvtbuf+0x1a>
   13714:	mov	r6, r1
   13716:	mov	r3, r5
   13718:	b.n	136cc <fcvtbuf+0x6c>
   1371a:	mov	r2, r3
   1371c:	b.n	136de <fcvtbuf+0x7e>
   1371e:	add.w	sl, r4, #36	; 0x24
   13722:	mov	r2, sl
   13724:	ldr.w	r1, [r9, #84]	; 0x54
   13728:	mov	r0, r9
   1372a:	bl	10780 <_realloc_r>
   1372e:	mov	r5, r0
   13730:	cmp	r0, #0
   13732:	beq.n	136e2 <fcvtbuf+0x82>
   13734:	str.w	sl, [r9, #80]	; 0x50
   13738:	str.w	r0, [r9, #84]	; 0x54
   1373c:	b.n	1367a <fcvtbuf+0x1a>
   1373e:	nop
   13740:	.word	0x1fff9190
   13744:	.word	0x3ff00000
   13748:	.word	0xbff00000

0001374c <__libc_fini_array>:
   1374c:	push	{r3, r4, r5, lr}
   1374e:	ldr	r5, [pc, #28]	; (1376c <__libc_fini_array+0x20>)
   13750:	ldr	r4, [pc, #28]	; (13770 <__libc_fini_array+0x24>)
   13752:	subs	r4, r5, r4
   13754:	asrs	r4, r4, #2
   13756:	beq.n	13764 <__libc_fini_array+0x18>
   13758:	subs	r4, #1
   1375a:	ldr.w	r3, [r5, #-4]!
   1375e:	blx	r3
   13760:	cmp	r4, #0
   13762:	bne.n	13758 <__libc_fini_array+0xc>
   13764:	ldmia.w	sp!, {r3, r4, r5, lr}
   13768:	b.w	14bd4 <__init_array_end>
	...

00013774 <_malloc_trim_r>:
   13774:	push	{r3, r4, r5, r6, r7, lr}
   13776:	ldr	r7, [pc, #140]	; (13804 <_malloc_trim_r+0x90>)
   13778:	mov	r4, r1
   1377a:	mov	r6, r0
   1377c:	bl	10778 <__malloc_lock>
   13780:	ldr	r3, [r7, #8]
   13782:	ldr	r5, [r3, #4]
   13784:	bic.w	r5, r5, #3
   13788:	subs	r1, r5, r4
   1378a:	addw	r1, r1, #4079	; 0xfef
   1378e:	bic.w	r1, r1, #4080	; 0xff0
   13792:	bic.w	r1, r1, #15
   13796:	sub.w	r4, r1, #4096	; 0x1000
   1379a:	cmp.w	r4, #4096	; 0x1000
   1379e:	blt.n	137b0 <_malloc_trim_r+0x3c>
   137a0:	movs	r1, #0
   137a2:	mov	r0, r6
   137a4:	bl	10b60 <_sbrk_r>
   137a8:	ldr	r3, [r7, #8]
   137aa:	add	r3, r5
   137ac:	cmp	r0, r3
   137ae:	beq.n	137ba <_malloc_trim_r+0x46>
   137b0:	mov	r0, r6
   137b2:	bl	1077c <__malloc_unlock>
   137b6:	movs	r0, #0
   137b8:	pop	{r3, r4, r5, r6, r7, pc}
   137ba:	negs	r1, r4
   137bc:	mov	r0, r6
   137be:	bl	10b60 <_sbrk_r>
   137c2:	adds	r0, #1
   137c4:	beq.n	137e2 <_malloc_trim_r+0x6e>
   137c6:	ldr	r3, [pc, #64]	; (13808 <_malloc_trim_r+0x94>)
   137c8:	ldr	r2, [r7, #8]
   137ca:	ldr	r1, [r3, #0]
   137cc:	subs	r5, r5, r4
   137ce:	orr.w	r5, r5, #1
   137d2:	mov	r0, r6
   137d4:	subs	r1, r1, r4
   137d6:	str	r5, [r2, #4]
   137d8:	str	r1, [r3, #0]
   137da:	bl	1077c <__malloc_unlock>
   137de:	movs	r0, #1
   137e0:	pop	{r3, r4, r5, r6, r7, pc}
   137e2:	movs	r1, #0
   137e4:	mov	r0, r6
   137e6:	bl	10b60 <_sbrk_r>
   137ea:	ldr	r2, [r7, #8]
   137ec:	subs	r3, r0, r2
   137ee:	cmp	r3, #15
   137f0:	ble.n	137b0 <_malloc_trim_r+0x3c>
   137f2:	ldr	r4, [pc, #24]	; (1380c <_malloc_trim_r+0x98>)
   137f4:	ldr	r1, [pc, #16]	; (13808 <_malloc_trim_r+0x94>)
   137f6:	ldr	r4, [r4, #0]
   137f8:	orr.w	r3, r3, #1
   137fc:	subs	r0, r0, r4
   137fe:	str	r3, [r2, #4]
   13800:	str	r0, [r1, #0]
   13802:	b.n	137b0 <_malloc_trim_r+0x3c>
   13804:	.word	0x1fff9300
   13808:	.word	0x200031f0
   1380c:	.word	0x1fff970c

00013810 <_free_r>:
   13810:	cmp	r1, #0
   13812:	beq.n	138a0 <_free_r+0x90>
   13814:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13818:	mov	r5, r1
   1381a:	mov	r8, r0
   1381c:	bl	10778 <__malloc_lock>
   13820:	ldr.w	r7, [r5, #-4]
   13824:	ldr	r1, [pc, #424]	; (139d0 <_free_r+0x1c0>)
   13826:	bic.w	r3, r7, #1
   1382a:	sub.w	r4, r5, #8
   1382e:	adds	r2, r4, r3
   13830:	ldr	r6, [r1, #8]
   13832:	ldr	r0, [r2, #4]
   13834:	cmp	r2, r6
   13836:	bic.w	r0, r0, #3
   1383a:	beq.n	13902 <_free_r+0xf2>
   1383c:	lsls	r6, r7, #31
   1383e:	str	r0, [r2, #4]
   13840:	bmi.n	1385a <_free_r+0x4a>
   13842:	ldr.w	r7, [r5, #-8]
   13846:	subs	r4, r4, r7
   13848:	add.w	lr, r1, #8
   1384c:	ldr	r5, [r4, #8]
   1384e:	cmp	r5, lr
   13850:	add	r3, r7
   13852:	beq.n	13934 <_free_r+0x124>
   13854:	ldr	r7, [r4, #12]
   13856:	str	r7, [r5, #12]
   13858:	str	r5, [r7, #8]
   1385a:	adds	r5, r2, r0
   1385c:	ldr	r5, [r5, #4]
   1385e:	lsls	r5, r5, #31
   13860:	bpl.n	138e8 <_free_r+0xd8>
   13862:	orr.w	r2, r3, #1
   13866:	str	r2, [r4, #4]
   13868:	str	r3, [r4, r3]
   1386a:	cmp.w	r3, #512	; 0x200
   1386e:	bcs.n	138a2 <_free_r+0x92>
   13870:	lsrs	r3, r3, #3
   13872:	adds	r2, r3, #1
   13874:	ldr	r5, [r1, #4]
   13876:	ldr.w	r7, [r1, r2, lsl #3]
   1387a:	str	r7, [r4, #8]
   1387c:	movs	r0, #1
   1387e:	asrs	r3, r3, #2
   13880:	lsl.w	r3, r0, r3
   13884:	add.w	r0, r1, r2, lsl #3
   13888:	orrs	r5, r3
   1388a:	subs	r0, #8
   1388c:	str	r0, [r4, #12]
   1388e:	str	r5, [r1, #4]
   13890:	str.w	r4, [r1, r2, lsl #3]
   13894:	str	r4, [r7, #12]
   13896:	mov	r0, r8
   13898:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1389c:	b.w	1077c <__malloc_unlock>
   138a0:	bx	lr
   138a2:	lsrs	r2, r3, #9
   138a4:	cmp	r2, #4
   138a6:	bhi.n	13950 <_free_r+0x140>
   138a8:	lsrs	r2, r3, #6
   138aa:	add.w	r7, r2, #57	; 0x39
   138ae:	lsls	r7, r7, #1
   138b0:	add.w	r5, r2, #56	; 0x38
   138b4:	add.w	r0, r1, r7, lsl #2
   138b8:	ldr.w	r2, [r1, r7, lsl #2]
   138bc:	ldr	r1, [pc, #272]	; (139d0 <_free_r+0x1c0>)
   138be:	subs	r0, #8
   138c0:	cmp	r0, r2
   138c2:	beq.n	13960 <_free_r+0x150>
   138c4:	ldr	r1, [r2, #4]
   138c6:	bic.w	r1, r1, #3
   138ca:	cmp	r3, r1
   138cc:	bcs.n	138d4 <_free_r+0xc4>
   138ce:	ldr	r2, [r2, #8]
   138d0:	cmp	r0, r2
   138d2:	bne.n	138c4 <_free_r+0xb4>
   138d4:	ldr	r0, [r2, #12]
   138d6:	str	r0, [r4, #12]
   138d8:	str	r2, [r4, #8]
   138da:	str	r4, [r0, #8]
   138dc:	str	r4, [r2, #12]
   138de:	mov	r0, r8
   138e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   138e4:	b.w	1077c <__malloc_unlock>
   138e8:	ldr	r5, [r2, #8]
   138ea:	ldr	r7, [pc, #232]	; (139d4 <_free_r+0x1c4>)
   138ec:	cmp	r5, r7
   138ee:	add	r3, r0
   138f0:	beq.n	13972 <_free_r+0x162>
   138f2:	ldr	r0, [r2, #12]
   138f4:	str	r0, [r5, #12]
   138f6:	orr.w	r2, r3, #1
   138fa:	str	r5, [r0, #8]
   138fc:	str	r2, [r4, #4]
   138fe:	str	r3, [r4, r3]
   13900:	b.n	1386a <_free_r+0x5a>
   13902:	lsls	r7, r7, #31
   13904:	add	r3, r0
   13906:	bmi.n	13918 <_free_r+0x108>
   13908:	ldr.w	r2, [r5, #-8]
   1390c:	subs	r4, r4, r2
   1390e:	add	r3, r2
   13910:	ldr	r0, [r4, #8]
   13912:	ldr	r2, [r4, #12]
   13914:	str	r2, [r0, #12]
   13916:	str	r0, [r2, #8]
   13918:	ldr	r2, [pc, #188]	; (139d8 <_free_r+0x1c8>)
   1391a:	ldr	r2, [r2, #0]
   1391c:	orr.w	r0, r3, #1
   13920:	cmp	r3, r2
   13922:	str	r0, [r4, #4]
   13924:	str	r4, [r1, #8]
   13926:	bcc.n	13896 <_free_r+0x86>
   13928:	ldr	r3, [pc, #176]	; (139dc <_free_r+0x1cc>)
   1392a:	mov	r0, r8
   1392c:	ldr	r1, [r3, #0]
   1392e:	bl	13774 <_malloc_trim_r>
   13932:	b.n	13896 <_free_r+0x86>
   13934:	adds	r1, r2, r0
   13936:	ldr	r1, [r1, #4]
   13938:	lsls	r1, r1, #31
   1393a:	bmi.n	139c6 <_free_r+0x1b6>
   1393c:	ldr	r1, [r2, #8]
   1393e:	ldr	r2, [r2, #12]
   13940:	str	r2, [r1, #12]
   13942:	add	r3, r0
   13944:	orr.w	r0, r3, #1
   13948:	str	r1, [r2, #8]
   1394a:	str	r0, [r4, #4]
   1394c:	str	r3, [r4, r3]
   1394e:	b.n	13896 <_free_r+0x86>
   13950:	cmp	r2, #20
   13952:	bhi.n	13984 <_free_r+0x174>
   13954:	add.w	r7, r2, #92	; 0x5c
   13958:	lsls	r7, r7, #1
   1395a:	add.w	r5, r2, #91	; 0x5b
   1395e:	b.n	138b4 <_free_r+0xa4>
   13960:	asrs	r2, r5, #2
   13962:	ldr	r3, [r1, #4]
   13964:	movs	r5, #1
   13966:	lsl.w	r2, r5, r2
   1396a:	orrs	r3, r2
   1396c:	str	r3, [r1, #4]
   1396e:	mov	r2, r0
   13970:	b.n	138d6 <_free_r+0xc6>
   13972:	orr.w	r2, r3, #1
   13976:	str	r4, [r1, #20]
   13978:	str	r4, [r1, #16]
   1397a:	str	r5, [r4, #12]
   1397c:	str	r5, [r4, #8]
   1397e:	str	r2, [r4, #4]
   13980:	str	r3, [r4, r3]
   13982:	b.n	13896 <_free_r+0x86>
   13984:	cmp	r2, #84	; 0x54
   13986:	bhi.n	13996 <_free_r+0x186>
   13988:	lsrs	r2, r3, #12
   1398a:	add.w	r7, r2, #111	; 0x6f
   1398e:	lsls	r7, r7, #1
   13990:	add.w	r5, r2, #110	; 0x6e
   13994:	b.n	138b4 <_free_r+0xa4>
   13996:	cmp.w	r2, #340	; 0x154
   1399a:	bhi.n	139aa <_free_r+0x19a>
   1399c:	lsrs	r2, r3, #15
   1399e:	add.w	r7, r2, #120	; 0x78
   139a2:	lsls	r7, r7, #1
   139a4:	add.w	r5, r2, #119	; 0x77
   139a8:	b.n	138b4 <_free_r+0xa4>
   139aa:	movw	r0, #1364	; 0x554
   139ae:	cmp	r2, r0
   139b0:	bhi.n	139c0 <_free_r+0x1b0>
   139b2:	lsrs	r2, r3, #18
   139b4:	add.w	r7, r2, #125	; 0x7d
   139b8:	lsls	r7, r7, #1
   139ba:	add.w	r5, r2, #124	; 0x7c
   139be:	b.n	138b4 <_free_r+0xa4>
   139c0:	movs	r7, #254	; 0xfe
   139c2:	movs	r5, #126	; 0x7e
   139c4:	b.n	138b4 <_free_r+0xa4>
   139c6:	orr.w	r2, r3, #1
   139ca:	str	r2, [r4, #4]
   139cc:	str	r3, [r4, r3]
   139ce:	b.n	13896 <_free_r+0x86>
   139d0:	.word	0x1fff9300
   139d4:	.word	0x1fff9308
   139d8:	.word	0x1fff9708
   139dc:	.word	0x200031ec

000139e0 <_localeconv_r>:
   139e0:	ldr	r2, [pc, #16]	; (139f4 <_localeconv_r+0x14>)
   139e2:	ldr	r3, [pc, #20]	; (139f8 <_localeconv_r+0x18>)
   139e4:	ldr	r2, [r2, #0]
   139e6:	ldr	r0, [r2, #52]	; 0x34
   139e8:	cmp	r0, #0
   139ea:	it	eq
   139ec:	moveq	r0, r3
   139ee:	adds	r0, #240	; 0xf0
   139f0:	bx	lr
   139f2:	nop
   139f4:	.word	0x1fff9190
   139f8:	.word	0x1fff9194

000139fc <_Balloc>:
   139fc:	ldr	r3, [r0, #76]	; 0x4c
   139fe:	push	{r4, r5, r6, lr}
   13a00:	mov	r5, r0
   13a02:	mov	r4, r1
   13a04:	cbz	r3, 13a1a <_Balloc+0x1e>
   13a06:	ldr.w	r0, [r3, r4, lsl #2]
   13a0a:	cbz	r0, 13a2e <_Balloc+0x32>
   13a0c:	ldr	r2, [r0, #0]
   13a0e:	str.w	r2, [r3, r4, lsl #2]
   13a12:	movs	r3, #0
   13a14:	str	r3, [r0, #16]
   13a16:	str	r3, [r0, #12]
   13a18:	pop	{r4, r5, r6, pc}
   13a1a:	movs	r2, #33	; 0x21
   13a1c:	movs	r1, #4
   13a1e:	bl	fe6c <_calloc_r>
   13a22:	str	r0, [r5, #76]	; 0x4c
   13a24:	mov	r3, r0
   13a26:	cmp	r0, #0
   13a28:	bne.n	13a06 <_Balloc+0xa>
   13a2a:	movs	r0, #0
   13a2c:	pop	{r4, r5, r6, pc}
   13a2e:	movs	r1, #1
   13a30:	lsl.w	r6, r1, r4
   13a34:	adds	r2, r6, #5
   13a36:	mov	r0, r5
   13a38:	lsls	r2, r2, #2
   13a3a:	bl	fe6c <_calloc_r>
   13a3e:	cmp	r0, #0
   13a40:	beq.n	13a2a <_Balloc+0x2e>
   13a42:	str	r4, [r0, #4]
   13a44:	str	r6, [r0, #8]
   13a46:	b.n	13a12 <_Balloc+0x16>

00013a48 <_Bfree>:
   13a48:	cbz	r1, 13a58 <_Bfree+0x10>
   13a4a:	ldr	r3, [r0, #76]	; 0x4c
   13a4c:	ldr	r2, [r1, #4]
   13a4e:	ldr.w	r0, [r3, r2, lsl #2]
   13a52:	str	r0, [r1, #0]
   13a54:	str.w	r1, [r3, r2, lsl #2]
   13a58:	bx	lr
   13a5a:	nop

00013a5c <__multadd>:
   13a5c:	push	{r4, r5, r6, r7, lr}
   13a5e:	ldr	r4, [r1, #16]
   13a60:	sub	sp, #12
   13a62:	mov	r5, r1
   13a64:	mov	r6, r0
   13a66:	add.w	lr, r1, #20
   13a6a:	movs	r7, #0
   13a6c:	ldr.w	r0, [lr]
   13a70:	uxth	r1, r0
   13a72:	mla	r1, r2, r1, r3
   13a76:	lsrs	r3, r1, #16
   13a78:	lsrs	r0, r0, #16
   13a7a:	mla	r3, r2, r0, r3
   13a7e:	uxth	r1, r1
   13a80:	adds	r7, #1
   13a82:	add.w	r1, r1, r3, lsl #16
   13a86:	cmp	r4, r7
   13a88:	str.w	r1, [lr], #4
   13a8c:	mov.w	r3, r3, lsr #16
   13a90:	bgt.n	13a6c <__multadd+0x10>
   13a92:	cbz	r3, 13aa4 <__multadd+0x48>
   13a94:	ldr	r2, [r5, #8]
   13a96:	cmp	r4, r2
   13a98:	bge.n	13aaa <__multadd+0x4e>
   13a9a:	add.w	r2, r5, r4, lsl #2
   13a9e:	adds	r4, #1
   13aa0:	str	r3, [r2, #20]
   13aa2:	str	r4, [r5, #16]
   13aa4:	mov	r0, r5
   13aa6:	add	sp, #12
   13aa8:	pop	{r4, r5, r6, r7, pc}
   13aaa:	ldr	r1, [r5, #4]
   13aac:	str	r3, [sp, #4]
   13aae:	adds	r1, #1
   13ab0:	mov	r0, r6
   13ab2:	bl	139fc <_Balloc>
   13ab6:	ldr	r2, [r5, #16]
   13ab8:	adds	r2, #2
   13aba:	add.w	r1, r5, #12
   13abe:	mov	r7, r0
   13ac0:	lsls	r2, r2, #2
   13ac2:	adds	r0, #12
   13ac4:	bl	cb10 <memcpy>
   13ac8:	ldr	r2, [r6, #76]	; 0x4c
   13aca:	ldr	r1, [r5, #4]
   13acc:	ldr	r3, [sp, #4]
   13ace:	ldr.w	r0, [r2, r1, lsl #2]
   13ad2:	str	r0, [r5, #0]
   13ad4:	str.w	r5, [r2, r1, lsl #2]
   13ad8:	mov	r5, r7
   13ada:	b.n	13a9a <__multadd+0x3e>

00013adc <__hi0bits>:
   13adc:	lsrs	r3, r0, #16
   13ade:	lsls	r3, r3, #16
   13ae0:	cbnz	r3, 13b10 <__hi0bits+0x34>
   13ae2:	lsls	r0, r0, #16
   13ae4:	movs	r3, #16
   13ae6:	tst.w	r0, #4278190080	; 0xff000000
   13aea:	itt	eq
   13aec:	lsleq	r0, r0, #8
   13aee:	addeq	r3, #8
   13af0:	tst.w	r0, #4026531840	; 0xf0000000
   13af4:	itt	eq
   13af6:	lsleq	r0, r0, #4
   13af8:	addeq	r3, #4
   13afa:	tst.w	r0, #3221225472	; 0xc0000000
   13afe:	itt	eq
   13b00:	lsleq	r0, r0, #2
   13b02:	addeq	r3, #2
   13b04:	cmp	r0, #0
   13b06:	blt.n	13b18 <__hi0bits+0x3c>
   13b08:	lsls	r2, r0, #1
   13b0a:	bmi.n	13b14 <__hi0bits+0x38>
   13b0c:	movs	r0, #32
   13b0e:	bx	lr
   13b10:	movs	r3, #0
   13b12:	b.n	13ae6 <__hi0bits+0xa>
   13b14:	adds	r0, r3, #1
   13b16:	bx	lr
   13b18:	mov	r0, r3
   13b1a:	bx	lr

00013b1c <__lo0bits>:
   13b1c:	ldr	r3, [r0, #0]
   13b1e:	ands.w	r2, r3, #7
   13b22:	beq.n	13b34 <__lo0bits+0x18>
   13b24:	lsls	r1, r3, #31
   13b26:	bmi.n	13b6a <__lo0bits+0x4e>
   13b28:	lsls	r2, r3, #30
   13b2a:	bmi.n	13b6e <__lo0bits+0x52>
   13b2c:	lsrs	r3, r3, #2
   13b2e:	str	r3, [r0, #0]
   13b30:	movs	r0, #2
   13b32:	bx	lr
   13b34:	uxth	r1, r3
   13b36:	cbnz	r1, 13b3c <__lo0bits+0x20>
   13b38:	lsrs	r3, r3, #16
   13b3a:	movs	r2, #16
   13b3c:	tst.w	r3, #255	; 0xff
   13b40:	itt	eq
   13b42:	lsreq	r3, r3, #8
   13b44:	addeq	r2, #8
   13b46:	lsls	r1, r3, #28
   13b48:	itt	eq
   13b4a:	lsreq	r3, r3, #4
   13b4c:	addeq	r2, #4
   13b4e:	lsls	r1, r3, #30
   13b50:	itt	eq
   13b52:	lsreq	r3, r3, #2
   13b54:	addeq	r2, #2
   13b56:	lsls	r1, r3, #31
   13b58:	bmi.n	13b64 <__lo0bits+0x48>
   13b5a:	lsrs	r3, r3, #1
   13b5c:	bne.n	13b62 <__lo0bits+0x46>
   13b5e:	movs	r0, #32
   13b60:	bx	lr
   13b62:	adds	r2, #1
   13b64:	str	r3, [r0, #0]
   13b66:	mov	r0, r2
   13b68:	bx	lr
   13b6a:	movs	r0, #0
   13b6c:	bx	lr
   13b6e:	lsrs	r3, r3, #1
   13b70:	str	r3, [r0, #0]
   13b72:	movs	r0, #1
   13b74:	bx	lr
   13b76:	nop

00013b78 <__i2b>:
   13b78:	push	{r4, lr}
   13b7a:	mov	r4, r1
   13b7c:	movs	r1, #1
   13b7e:	bl	139fc <_Balloc>
   13b82:	movs	r2, #1
   13b84:	str	r4, [r0, #20]
   13b86:	str	r2, [r0, #16]
   13b88:	pop	{r4, pc}
   13b8a:	nop

00013b8c <__multiply>:
   13b8c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13b90:	ldr	r5, [r1, #16]
   13b92:	ldr	r7, [r2, #16]
   13b94:	cmp	r5, r7
   13b96:	sub	sp, #12
   13b98:	mov	r4, r1
   13b9a:	mov	r6, r2
   13b9c:	bge.n	13ba8 <__multiply+0x1c>
   13b9e:	mov	r2, r5
   13ba0:	mov	r4, r6
   13ba2:	mov	r5, r7
   13ba4:	mov	r6, r1
   13ba6:	mov	r7, r2
   13ba8:	ldr	r3, [r4, #8]
   13baa:	ldr	r1, [r4, #4]
   13bac:	add.w	r8, r5, r7
   13bb0:	cmp	r8, r3
   13bb2:	it	gt
   13bb4:	addgt	r1, #1
   13bb6:	bl	139fc <_Balloc>
   13bba:	add.w	ip, r0, #20
   13bbe:	add.w	r9, ip, r8, lsl #2
   13bc2:	cmp	ip, r9
   13bc4:	str	r0, [sp, #0]
   13bc6:	bcs.n	13bd4 <__multiply+0x48>
   13bc8:	mov	r3, ip
   13bca:	movs	r1, #0
   13bcc:	str.w	r1, [r3], #4
   13bd0:	cmp	r9, r3
   13bd2:	bhi.n	13bcc <__multiply+0x40>
   13bd4:	add.w	r2, r6, #20
   13bd8:	add.w	sl, r2, r7, lsl #2
   13bdc:	add.w	r3, r4, #20
   13be0:	cmp	r2, sl
   13be2:	add.w	lr, r3, r5, lsl #2
   13be6:	bcs.n	13c92 <__multiply+0x106>
   13be8:	str.w	r9, [sp, #4]
   13bec:	mov	r9, r3
   13bee:	ldr.w	r3, [r2], #4
   13bf2:	uxth.w	fp, r3
   13bf6:	cmp.w	fp, #0
   13bfa:	beq.n	13c3e <__multiply+0xb2>
   13bfc:	movs	r0, #0
   13bfe:	mov	r7, r9
   13c00:	mov	r6, ip
   13c02:	mov	r5, r0
   13c04:	b.n	13c08 <__multiply+0x7c>
   13c06:	mov	r6, r3
   13c08:	ldr.w	r4, [r7], #4
   13c0c:	ldr	r0, [r6, #0]
   13c0e:	uxth	r1, r4
   13c10:	uxth	r3, r0
   13c12:	mla	r1, fp, r1, r3
   13c16:	lsrs	r4, r4, #16
   13c18:	lsrs	r0, r0, #16
   13c1a:	adds	r3, r1, r5
   13c1c:	mla	r0, fp, r4, r0
   13c20:	add.w	r0, r0, r3, lsr #16
   13c24:	uxth	r1, r3
   13c26:	mov	r3, r6
   13c28:	orr.w	r1, r1, r0, lsl #16
   13c2c:	cmp	lr, r7
   13c2e:	mov.w	r5, r0, lsr #16
   13c32:	str.w	r1, [r3], #4
   13c36:	bhi.n	13c06 <__multiply+0x7a>
   13c38:	str	r5, [r6, #4]
   13c3a:	ldr.w	r3, [r2, #-4]
   13c3e:	movs.w	fp, r3, lsr #16
   13c42:	beq.n	13c86 <__multiply+0xfa>
   13c44:	ldr.w	r3, [ip]
   13c48:	mov	r7, ip
   13c4a:	mov	r0, r3
   13c4c:	mov	r5, r9
   13c4e:	movs	r1, #0
   13c50:	b.n	13c54 <__multiply+0xc8>
   13c52:	mov	r7, r6
   13c54:	ldrh	r4, [r5, #0]
   13c56:	lsrs	r0, r0, #16
   13c58:	mla	r0, fp, r4, r0
   13c5c:	add	r1, r0
   13c5e:	uxth	r4, r3
   13c60:	mov	r6, r7
   13c62:	orr.w	r3, r4, r1, lsl #16
   13c66:	str.w	r3, [r6], #4
   13c6a:	ldr	r0, [r7, #4]
   13c6c:	ldr.w	r4, [r5], #4
   13c70:	uxth	r3, r0
   13c72:	lsrs	r4, r4, #16
   13c74:	mla	r4, fp, r4, r3
   13c78:	add.w	r3, r4, r1, lsr #16
   13c7c:	cmp	lr, r5
   13c7e:	mov.w	r1, r3, lsr #16
   13c82:	bhi.n	13c52 <__multiply+0xc6>
   13c84:	str	r3, [r7, #4]
   13c86:	cmp	sl, r2
   13c88:	add.w	ip, ip, #4
   13c8c:	bhi.n	13bee <__multiply+0x62>
   13c8e:	ldr.w	r9, [sp, #4]
   13c92:	cmp.w	r8, #0
   13c96:	ble.n	13cb0 <__multiply+0x124>
   13c98:	ldr.w	r3, [r9, #-4]
   13c9c:	sub.w	r9, r9, #4
   13ca0:	cbz	r3, 13caa <__multiply+0x11e>
   13ca2:	b.n	13cb0 <__multiply+0x124>
   13ca4:	ldr.w	r3, [r9, #-4]!
   13ca8:	cbnz	r3, 13cb0 <__multiply+0x124>
   13caa:	subs.w	r8, r8, #1
   13cae:	bne.n	13ca4 <__multiply+0x118>
   13cb0:	ldr	r0, [sp, #0]
   13cb2:	str.w	r8, [r0, #16]
   13cb6:	add	sp, #12
   13cb8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00013cbc <__pow5mult>:
   13cbc:	ands.w	r3, r2, #3
   13cc0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13cc4:	mov	r4, r2
   13cc6:	mov	r7, r0
   13cc8:	bne.n	13d28 <__pow5mult+0x6c>
   13cca:	mov	r6, r1
   13ccc:	asrs	r4, r4, #2
   13cce:	beq.n	13d0a <__pow5mult+0x4e>
   13cd0:	ldr	r5, [r7, #72]	; 0x48
   13cd2:	cbz	r5, 13d3a <__pow5mult+0x7e>
   13cd4:	lsls	r3, r4, #31
   13cd6:	mov.w	r8, #0
   13cda:	bmi.n	13cea <__pow5mult+0x2e>
   13cdc:	asrs	r4, r4, #1
   13cde:	beq.n	13d0a <__pow5mult+0x4e>
   13ce0:	ldr	r0, [r5, #0]
   13ce2:	cbz	r0, 13d10 <__pow5mult+0x54>
   13ce4:	mov	r5, r0
   13ce6:	lsls	r3, r4, #31
   13ce8:	bpl.n	13cdc <__pow5mult+0x20>
   13cea:	mov	r2, r5
   13cec:	mov	r1, r6
   13cee:	mov	r0, r7
   13cf0:	bl	13b8c <__multiply>
   13cf4:	cbz	r6, 13d24 <__pow5mult+0x68>
   13cf6:	ldr	r2, [r6, #4]
   13cf8:	ldr	r3, [r7, #76]	; 0x4c
   13cfa:	asrs	r4, r4, #1
   13cfc:	ldr.w	r1, [r3, r2, lsl #2]
   13d00:	str	r1, [r6, #0]
   13d02:	str.w	r6, [r3, r2, lsl #2]
   13d06:	mov	r6, r0
   13d08:	bne.n	13ce0 <__pow5mult+0x24>
   13d0a:	mov	r0, r6
   13d0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13d10:	mov	r2, r5
   13d12:	mov	r1, r5
   13d14:	mov	r0, r7
   13d16:	bl	13b8c <__multiply>
   13d1a:	str	r0, [r5, #0]
   13d1c:	str.w	r8, [r0]
   13d20:	mov	r5, r0
   13d22:	b.n	13ce6 <__pow5mult+0x2a>
   13d24:	mov	r6, r0
   13d26:	b.n	13cdc <__pow5mult+0x20>
   13d28:	subs	r2, r3, #1
   13d2a:	ldr	r5, [pc, #44]	; (13d58 <__pow5mult+0x9c>)
   13d2c:	movs	r3, #0
   13d2e:	ldr.w	r2, [r5, r2, lsl #2]
   13d32:	bl	13a5c <__multadd>
   13d36:	mov	r6, r0
   13d38:	b.n	13ccc <__pow5mult+0x10>
   13d3a:	movs	r1, #1
   13d3c:	mov	r0, r7
   13d3e:	bl	139fc <_Balloc>
   13d42:	movw	r1, #625	; 0x271
   13d46:	movs	r2, #1
   13d48:	movs	r3, #0
   13d4a:	str	r1, [r0, #20]
   13d4c:	str	r2, [r0, #16]
   13d4e:	mov	r5, r0
   13d50:	str	r0, [r7, #72]	; 0x48
   13d52:	str	r3, [r0, #0]
   13d54:	b.n	13cd4 <__pow5mult+0x18>
   13d56:	nop
   13d58:	.word	0x00014b40

00013d5c <__lshift>:
   13d5c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13d60:	mov	r9, r2
   13d62:	ldr	r2, [r1, #16]
   13d64:	ldr	r3, [r1, #8]
   13d66:	mov.w	r4, r9, asr #5
   13d6a:	add.w	r8, r4, r2
   13d6e:	add.w	r5, r8, #1
   13d72:	cmp	r5, r3
   13d74:	mov	r6, r1
   13d76:	mov	sl, r0
   13d78:	ldr	r1, [r1, #4]
   13d7a:	ble.n	13d86 <__lshift+0x2a>
   13d7c:	lsls	r3, r3, #1
   13d7e:	cmp	r5, r3
   13d80:	add.w	r1, r1, #1
   13d84:	bgt.n	13d7c <__lshift+0x20>
   13d86:	mov	r0, sl
   13d88:	bl	139fc <_Balloc>
   13d8c:	cmp	r4, #0
   13d8e:	add.w	r2, r0, #20
   13d92:	ble.n	13e06 <__lshift+0xaa>
   13d94:	add.w	r3, r2, r4, lsl #2
   13d98:	movs	r1, #0
   13d9a:	str.w	r1, [r2], #4
   13d9e:	cmp	r3, r2
   13da0:	bne.n	13d9a <__lshift+0x3e>
   13da2:	ldr	r4, [r6, #16]
   13da4:	add.w	r1, r6, #20
   13da8:	ands.w	r9, r9, #31
   13dac:	add.w	lr, r1, r4, lsl #2
   13db0:	beq.n	13df6 <__lshift+0x9a>
   13db2:	rsb	r2, r9, #32
   13db6:	movs	r4, #0
   13db8:	ldr	r7, [r1, #0]
   13dba:	lsl.w	ip, r7, r9
   13dbe:	orr.w	r4, ip, r4
   13dc2:	mov	ip, r3
   13dc4:	str.w	r4, [r3], #4
   13dc8:	ldr.w	r4, [r1], #4
   13dcc:	cmp	lr, r1
   13dce:	lsr.w	r4, r4, r2
   13dd2:	bhi.n	13db8 <__lshift+0x5c>
   13dd4:	str.w	r4, [ip, #4]
   13dd8:	cbz	r4, 13dde <__lshift+0x82>
   13dda:	add.w	r5, r8, #2
   13dde:	ldr.w	r3, [sl, #76]	; 0x4c
   13de2:	ldr	r2, [r6, #4]
   13de4:	subs	r5, #1
   13de6:	ldr.w	r1, [r3, r2, lsl #2]
   13dea:	str	r5, [r0, #16]
   13dec:	str	r1, [r6, #0]
   13dee:	str.w	r6, [r3, r2, lsl #2]
   13df2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13df6:	subs	r3, #4
   13df8:	ldr.w	r2, [r1], #4
   13dfc:	str.w	r2, [r3, #4]!
   13e00:	cmp	lr, r1
   13e02:	bhi.n	13df8 <__lshift+0x9c>
   13e04:	b.n	13dde <__lshift+0x82>
   13e06:	mov	r3, r2
   13e08:	b.n	13da2 <__lshift+0x46>
   13e0a:	nop

00013e0c <__mcmp>:
   13e0c:	ldr	r2, [r0, #16]
   13e0e:	ldr	r3, [r1, #16]
   13e10:	subs	r2, r2, r3
   13e12:	bne.n	13e3a <__mcmp+0x2e>
   13e14:	lsls	r3, r3, #2
   13e16:	adds	r0, #20
   13e18:	adds	r1, #20
   13e1a:	add	r1, r3
   13e1c:	push	{r4}
   13e1e:	add	r3, r0
   13e20:	b.n	13e26 <__mcmp+0x1a>
   13e22:	cmp	r0, r3
   13e24:	bcs.n	13e3e <__mcmp+0x32>
   13e26:	ldr.w	r4, [r3, #-4]!
   13e2a:	ldr.w	r2, [r1, #-4]!
   13e2e:	cmp	r4, r2
   13e30:	beq.n	13e22 <__mcmp+0x16>
   13e32:	bcc.n	13e44 <__mcmp+0x38>
   13e34:	movs	r0, #1
   13e36:	pop	{r4}
   13e38:	bx	lr
   13e3a:	mov	r0, r2
   13e3c:	bx	lr
   13e3e:	movs	r0, #0
   13e40:	pop	{r4}
   13e42:	bx	lr
   13e44:	mov.w	r0, #4294967295
   13e48:	b.n	13e36 <__mcmp+0x2a>
   13e4a:	nop

00013e4c <__mdiff>:
   13e4c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13e50:	ldr	r3, [r1, #16]
   13e52:	mov	r7, r1
   13e54:	ldr	r1, [r2, #16]
   13e56:	subs	r3, r3, r1
   13e58:	cmp	r3, #0
   13e5a:	mov	r8, r2
   13e5c:	bne.n	13e8e <__mdiff+0x42>
   13e5e:	lsls	r1, r1, #2
   13e60:	add.w	r2, r7, #20
   13e64:	add.w	r5, r8, #20
   13e68:	adds	r3, r2, r1
   13e6a:	add	r1, r5
   13e6c:	b.n	13e72 <__mdiff+0x26>
   13e6e:	cmp	r2, r3
   13e70:	bcs.n	13f30 <__mdiff+0xe4>
   13e72:	ldr.w	r6, [r3, #-4]!
   13e76:	ldr.w	r4, [r1, #-4]!
   13e7a:	cmp	r6, r4
   13e7c:	beq.n	13e6e <__mdiff+0x22>
   13e7e:	bcs.n	13f42 <__mdiff+0xf6>
   13e80:	mov	r3, r7
   13e82:	mov	r4, r2
   13e84:	mov	r7, r8
   13e86:	mov.w	r9, #1
   13e8a:	mov	r8, r3
   13e8c:	b.n	13e9c <__mdiff+0x50>
   13e8e:	blt.n	13f4c <__mdiff+0x100>
   13e90:	add.w	r5, r7, #20
   13e94:	add.w	r4, r2, #20
   13e98:	mov.w	r9, #0
   13e9c:	ldr	r1, [r7, #4]
   13e9e:	bl	139fc <_Balloc>
   13ea2:	ldr.w	r3, [r8, #16]
   13ea6:	ldr	r6, [r7, #16]
   13ea8:	str.w	r9, [r0, #12]
   13eac:	add.w	ip, r4, r3, lsl #2
   13eb0:	mov	lr, r4
   13eb2:	add.w	r7, r5, r6, lsl #2
   13eb6:	add.w	r4, r0, #20
   13eba:	movs	r3, #0
   13ebc:	ldr.w	r1, [lr], #4
   13ec0:	ldr.w	r8, [r5], #4
   13ec4:	uxth	r2, r1
   13ec6:	uxtah	r3, r3, r8
   13eca:	lsrs	r1, r1, #16
   13ecc:	subs	r2, r3, r2
   13ece:	rsb	r3, r1, r8, lsr #16
   13ed2:	add.w	r3, r3, r2, asr #16
   13ed6:	uxth	r2, r2
   13ed8:	orr.w	r2, r2, r3, lsl #16
   13edc:	cmp	ip, lr
   13ede:	str.w	r2, [r4], #4
   13ee2:	mov.w	r3, r3, asr #16
   13ee6:	bhi.n	13ebc <__mdiff+0x70>
   13ee8:	cmp	r7, r5
   13eea:	bls.n	13f1c <__mdiff+0xd0>
   13eec:	mov	ip, r4
   13eee:	mov	r1, r5
   13ef0:	ldr.w	lr, [r1], #4
   13ef4:	uxtah	r2, r3, lr
   13ef8:	asrs	r3, r2, #16
   13efa:	add.w	r3, r3, lr, lsr #16
   13efe:	uxth	r2, r2
   13f00:	orr.w	r2, r2, r3, lsl #16
   13f04:	cmp	r7, r1
   13f06:	str.w	r2, [ip], #4
   13f0a:	mov.w	r3, r3, asr #16
   13f0e:	bhi.n	13ef0 <__mdiff+0xa4>
   13f10:	mvns	r5, r5
   13f12:	add	r5, r7
   13f14:	bic.w	r5, r5, #3
   13f18:	adds	r5, #4
   13f1a:	add	r4, r5
   13f1c:	subs	r4, #4
   13f1e:	cbnz	r2, 13f2a <__mdiff+0xde>
   13f20:	ldr.w	r3, [r4, #-4]!
   13f24:	subs	r6, #1
   13f26:	cmp	r3, #0
   13f28:	beq.n	13f20 <__mdiff+0xd4>
   13f2a:	str	r6, [r0, #16]
   13f2c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13f30:	movs	r1, #0
   13f32:	bl	139fc <_Balloc>
   13f36:	movs	r2, #1
   13f38:	movs	r3, #0
   13f3a:	str	r2, [r0, #16]
   13f3c:	str	r3, [r0, #20]
   13f3e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13f42:	mov	r4, r5
   13f44:	mov.w	r9, #0
   13f48:	mov	r5, r2
   13f4a:	b.n	13e9c <__mdiff+0x50>
   13f4c:	mov	r3, r7
   13f4e:	add.w	r4, r7, #20
   13f52:	add.w	r5, r8, #20
   13f56:	mov	r7, r8
   13f58:	mov.w	r9, #1
   13f5c:	mov	r8, r3
   13f5e:	b.n	13e9c <__mdiff+0x50>

00013f60 <__d2b>:
   13f60:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13f64:	sub	sp, #8
   13f66:	movs	r1, #1
   13f68:	mov	r4, r3
   13f6a:	ubfx	r7, r3, #20, #11
   13f6e:	mov	r5, r2
   13f70:	ldr	r6, [sp, #32]
   13f72:	bl	139fc <_Balloc>
   13f76:	ubfx	r4, r4, #0, #20
   13f7a:	mov	r8, r0
   13f7c:	cbz	r7, 13f82 <__d2b+0x22>
   13f7e:	orr.w	r4, r4, #1048576	; 0x100000
   13f82:	str	r4, [sp, #4]
   13f84:	cbz	r5, 13fce <__d2b+0x6e>
   13f86:	add	r0, sp, #8
   13f88:	str.w	r5, [r0, #-8]!
   13f8c:	bl	13b1c <__lo0bits>
   13f90:	cmp	r0, #0
   13f92:	bne.n	13ffe <__d2b+0x9e>
   13f94:	ldmia.w	sp, {r2, r3}
   13f98:	str.w	r2, [r8, #20]
   13f9c:	cmp	r3, #0
   13f9e:	ite	eq
   13fa0:	moveq	r1, #1
   13fa2:	movne	r1, #2
   13fa4:	str.w	r3, [r8, #24]
   13fa8:	str.w	r1, [r8, #16]
   13fac:	cbnz	r7, 13fe6 <__d2b+0x86>
   13fae:	add.w	r3, r8, r1, lsl #2
   13fb2:	subw	r0, r0, #1074	; 0x432
   13fb6:	str	r0, [r6, #0]
   13fb8:	ldr	r0, [r3, #16]
   13fba:	bl	13adc <__hi0bits>
   13fbe:	ldr	r3, [sp, #36]	; 0x24
   13fc0:	rsb	r0, r0, r1, lsl #5
   13fc4:	str	r0, [r3, #0]
   13fc6:	mov	r0, r8
   13fc8:	add	sp, #8
   13fca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13fce:	add	r0, sp, #4
   13fd0:	bl	13b1c <__lo0bits>
   13fd4:	ldr	r3, [sp, #4]
   13fd6:	str.w	r3, [r8, #20]
   13fda:	movs	r1, #1
   13fdc:	adds	r0, #32
   13fde:	str.w	r1, [r8, #16]
   13fe2:	cmp	r7, #0
   13fe4:	beq.n	13fae <__d2b+0x4e>
   13fe6:	ldr	r3, [sp, #36]	; 0x24
   13fe8:	subw	r7, r7, #1075	; 0x433
   13fec:	add	r7, r0
   13fee:	rsb	r0, r0, #53	; 0x35
   13ff2:	str	r7, [r6, #0]
   13ff4:	str	r0, [r3, #0]
   13ff6:	mov	r0, r8
   13ff8:	add	sp, #8
   13ffa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13ffe:	ldmia.w	sp, {r2, r3}
   14002:	rsb	r1, r0, #32
   14006:	lsl.w	r1, r3, r1
   1400a:	orrs	r2, r1
   1400c:	lsrs	r3, r0
   1400e:	str	r3, [sp, #4]
   14010:	str.w	r2, [r8, #20]
   14014:	b.n	13f9c <__d2b+0x3c>
   14016:	nop

00014018 <__ssprint_r>:
   14018:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1401c:	ldr	r3, [r2, #8]
   1401e:	sub	sp, #12
   14020:	mov	r8, r2
   14022:	cmp	r3, #0
   14024:	beq.n	1410c <__ssprint_r+0xf4>
   14026:	mov	fp, r0
   14028:	mov.w	r9, #0
   1402c:	ldr	r6, [r2, #0]
   1402e:	ldr	r0, [r1, #0]
   14030:	ldr	r3, [r1, #8]
   14032:	mov	r5, r1
   14034:	mov	r4, r9
   14036:	cmp	r4, #0
   14038:	beq.n	140c6 <__ssprint_r+0xae>
   1403a:	cmp	r4, r3
   1403c:	mov	r7, r3
   1403e:	mov	sl, r3
   14040:	bcc.n	140d0 <__ssprint_r+0xb8>
   14042:	ldrh	r3, [r5, #12]
   14044:	tst.w	r3, #1152	; 0x480
   14048:	beq.n	140a6 <__ssprint_r+0x8e>
   1404a:	ldr	r7, [r5, #20]
   1404c:	ldr	r1, [r5, #16]
   1404e:	add.w	r7, r7, r7, lsl #1
   14052:	rsb	sl, r1, r0
   14056:	add.w	r7, r7, r7, lsr #31
   1405a:	adds	r0, r4, #1
   1405c:	asrs	r7, r7, #1
   1405e:	add	r0, sl
   14060:	cmp	r0, r7
   14062:	mov	r2, r7
   14064:	itt	hi
   14066:	movhi	r7, r0
   14068:	movhi	r2, r7
   1406a:	lsls	r3, r3, #21
   1406c:	bpl.n	140d6 <__ssprint_r+0xbe>
   1406e:	mov	r1, r2
   14070:	mov	r0, fp
   14072:	bl	ff74 <_malloc_r>
   14076:	cmp	r0, #0
   14078:	beq.n	140ea <__ssprint_r+0xd2>
   1407a:	mov	r2, sl
   1407c:	ldr	r1, [r5, #16]
   1407e:	str	r0, [sp, #4]
   14080:	bl	cb10 <memcpy>
   14084:	ldrh	r2, [r5, #12]
   14086:	ldr	r3, [sp, #4]
   14088:	bic.w	r2, r2, #1152	; 0x480
   1408c:	orr.w	r2, r2, #128	; 0x80
   14090:	strh	r2, [r5, #12]
   14092:	rsb	r2, sl, r7
   14096:	add.w	r0, r3, sl
   1409a:	str	r7, [r5, #20]
   1409c:	str	r3, [r5, #16]
   1409e:	str	r0, [r5, #0]
   140a0:	str	r2, [r5, #8]
   140a2:	mov	r7, r4
   140a4:	mov	sl, r4
   140a6:	mov	r2, sl
   140a8:	mov	r1, r9
   140aa:	bl	10614 <memmove>
   140ae:	ldr.w	r2, [r8, #8]
   140b2:	ldr	r3, [r5, #8]
   140b4:	ldr	r0, [r5, #0]
   140b6:	subs	r3, r3, r7
   140b8:	add	r0, sl
   140ba:	subs	r4, r2, r4
   140bc:	str	r3, [r5, #8]
   140be:	str	r0, [r5, #0]
   140c0:	str.w	r4, [r8, #8]
   140c4:	cbz	r4, 1410c <__ssprint_r+0xf4>
   140c6:	ldr.w	r9, [r6]
   140ca:	ldr	r4, [r6, #4]
   140cc:	adds	r6, #8
   140ce:	b.n	14036 <__ssprint_r+0x1e>
   140d0:	mov	r7, r4
   140d2:	mov	sl, r4
   140d4:	b.n	140a6 <__ssprint_r+0x8e>
   140d6:	mov	r0, fp
   140d8:	bl	10780 <_realloc_r>
   140dc:	mov	r3, r0
   140de:	cmp	r0, #0
   140e0:	bne.n	14092 <__ssprint_r+0x7a>
   140e2:	ldr	r1, [r5, #16]
   140e4:	mov	r0, fp
   140e6:	bl	13810 <_free_r>
   140ea:	movs	r3, #12
   140ec:	str.w	r3, [fp]
   140f0:	ldrh	r3, [r5, #12]
   140f2:	movs	r2, #0
   140f4:	orr.w	r3, r3, #64	; 0x40
   140f8:	mov.w	r0, #4294967295
   140fc:	strh	r3, [r5, #12]
   140fe:	str.w	r2, [r8, #8]
   14102:	str.w	r2, [r8, #4]
   14106:	add	sp, #12
   14108:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1410c:	movs	r0, #0
   1410e:	str.w	r0, [r8, #4]
   14112:	add	sp, #12
   14114:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00014118 <_vasnprintf_r>:
   14118:	push	{r4, r5, r6, lr}
   1411a:	mov	r5, r2
   1411c:	sub	sp, #104	; 0x68
   1411e:	ldr	r4, [r2, #0]
   14120:	cbz	r1, 14126 <_vasnprintf_r+0xe>
   14122:	cmp	r4, #0
   14124:	bne.n	1415c <_vasnprintf_r+0x44>
   14126:	movs	r4, #0
   14128:	mov.w	r2, #648	; 0x288
   1412c:	strh.w	r2, [sp, #12]
   14130:	str	r4, [sp, #0]
   14132:	str	r4, [sp, #16]
   14134:	mov	r2, r3
   14136:	movw	r6, #65535	; 0xffff
   1413a:	ldr	r3, [sp, #120]	; 0x78
   1413c:	str	r4, [sp, #8]
   1413e:	mov	r1, sp
   14140:	str	r4, [sp, #20]
   14142:	strh.w	r6, [sp, #14]
   14146:	bl	10ebc <_svfprintf_r>
   1414a:	cmp	r0, #0
   1414c:	blt.n	14172 <_vasnprintf_r+0x5a>
   1414e:	ldr	r3, [sp, #0]
   14150:	str	r0, [r5, #0]
   14152:	movs	r2, #0
   14154:	strb	r2, [r3, #0]
   14156:	ldr	r0, [sp, #16]
   14158:	add	sp, #104	; 0x68
   1415a:	pop	{r4, r5, r6, pc}
   1415c:	mov.w	r2, #1544	; 0x608
   14160:	str	r1, [sp, #0]
   14162:	str	r1, [sp, #16]
   14164:	strh.w	r2, [sp, #12]
   14168:	bge.n	14134 <_vasnprintf_r+0x1c>
   1416a:	movs	r3, #139	; 0x8b
   1416c:	str	r3, [r0, #0]
   1416e:	movs	r0, #0
   14170:	b.n	14158 <_vasnprintf_r+0x40>
   14172:	movs	r0, #0
   14174:	b.n	14158 <_vasnprintf_r+0x40>
   14176:	nop

00014178 <vtable for Stream>:
	...
   14180:	........m...q...
   14190:	............

0001419c <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   141a4:	E.......m...1...
   141b4:	............

000141c0 <vtable for FsFile>:
	...
   141c8:	E.......m...1...
   141d8:	............

000141e4 <vtable for File>:
	...
   141ec:	........m.......
   141fc:	....q...........
   1420c:	%.......u.......
   1421c:	................
   1422c:	............!...
   1423c:	-...e...

00014244 <vtable for SDFile>:
	...
   1424c:	........m.......
   1425c:	....q...=.......
   1426c:	........%.......
   1427c:	................
   1428c:	........Q.......
   1429c:	%...}...

000142a4 <vtable for SDClass>:
	...
   142ac:	....1...........
   142bc:	....5.......U...

000142cc <SGTL_ADDR>:
   142cc:	....*...  File  
   142dc:	  this=%x, f=%x.
   142ec:	....   SDFile th
   142fc:	is=%x, refcount=
   1430c:	%u..%s: %6d %4d;
   1431c:	 %4d %4d; %4d...
   1432c:	SD Storage %d %d
   1433c:	 %s failed or mi
   1434c:	ssing...SD Stora
   1435c:	ge %d %d %s ....
   1436c:	.Start...Stop...
   1437c:	Reset...Now: %04
   1438c:	d-%02d-%02d_%02d
   1439c:	:%02d:%02d......
   143ac:	WMXZ..../%d/%02d
   143bc:	_%02d_%02d.raw..
   143cc:	%d %d %d %d %d %
   143dc:	d %d....loop....
   143ec:	MTP logger..Setu
   143fc:	p done.. Enter '
   1440c:	s' to start, 'q'
   1441c:	 to stop acquisi
   1442c:	tion and 'r' to 
   1443c:	restart MTP.sd1.

0001444c <vtable for MTPStorage_SD>:
	...
   14454:	1...I...M...]...
   14464:	i...U...Y....;..
   14474:	.(...)..M)...1..
   14484:	.0..u...e)...C..
   14494:	q.......e+...Y..
   144a4:	yL..yM../mtpinde
   144b4:	x.dat...cannot o
   144c4:	pen Index file..
   144d4:	/...%s/%s...%d: 
   144e4:	%d %d %d %d %d %
   144f4:	s...%d: %d %d %d
   14504:	 %d %d..

0001450c <supported_op>:
   1450c:	................
   1451c:	................
   1452c:	........

00014534 <propertyList>:
   14534:	............A.D.
   14544:	Teensy..microsof
   14554:	t.com: 1.0;.PJRC
   14564:	.... / MTP 1.0..
   14574:	%x %d %d %d: ...
   14584:	 %x.Event: .

00014590 <supported_events>:
   14590:	.@.@.@.@

00014598 <SPISettings::ctar_div_table>:
   14598:	................
   145a8:	...... .(.8.@.`.
   145b8:	................

000145c8 <SPISettings::ctar_clock_table>:
   145c8:	................
   145d8:	................
   145e8:	. ....... ...0..
   145f8:	. ... ...@...@..
   14608:	.P...P...`...`..
   14618:	.p...`...p..

00014624 <SPIClass::spi0_hardware>:
   14624:	<..@............
   14634:	....Iy..........
   14644:	........@.......
   14654:	....@...........
   14664:	................
   14674:	................
   14684:	................
   14694:	........

0001469c <monthDays>:
   1469c:	............

000146a8 <vtable for AudioControlSGTL5000>:
	...
   146b0:	....i.......m...
   146c0:	....

000146c4 <TwoWire::i2c0_hardware>:
   146c4:	4..@@...........
   146d4:	................

000146e4 <TwoWire::i2c1_hardware>:
   146e4:	4..@............
   146f4:	................

00014704 <vtable for TwoWire>:
	...
   1470c:	U.......m.......
   1471c:	............EXFA
   1472c:	T...

00014730 <usb_endpoint_config_table>:
   14730:	........

00014738 <usb_descriptor_list>:
   14738:	....|...........
   14748:	....i...........
   14758:	........L.......
   14768:	................
   14778:	............P...
	...
   14798:	0...1...

000147a0 <digital_pin_to_info_PGM>:
   147a0:	@..C@..@D..CD..@
   147b0:	...C...@0..C0..@
   147c0:	4..C4..@...C...@
   147d0:	...C...@...C...@
   147e0:	...C...@...C...@
   147f0:	...C...@...C...@
   14800:	...C...@...C...@
   14810:	...C...@...C...@
   14820:	...C...@...C...@
   14830:	...C...@...C...@
   14840:	...C...@...C...@
   14850:	...C...@...C...@
   14860:	...C...@L..CL..@
   14870:	. .C...@$..C$..@
   14880:	 ..C ..@(..C(..@
   14890:	,..C,..@. .C...@
   148a0:	H..CH..@...C...@

000148b0 <vtable for usb_serial_class>:
	...
   148b8:	........}...y...
   148c8:	u...q...m...i...
   148d8:	....fmodf...

000148e4 <Zero>:
   148e4:	........

000148ec <_global_impure_ptr>:
   148ec:	h...C...POSIX...
   148fc:	....

00014900 <zeroes.7256>:
   14900:	0000000000000000
   14910:	INF.inf.NAN.nan.
   14920:	0123456789ABCDEF
   14930:	....0123456789ab
   14940:	cdef....(null)..

00014950 <blanks.7255>:
   14950:	                

00014960 <_ctype_>:
   14960:	.         ((((( 
   14970:	                
   14980:	 ...............
   14990:	................
   149a0:	..AAAAAA........
   149b0:	................
   149c0:	..BBBBBB........
   149d0:	................
   149e0:	 ...............
	...
   14a60:	....Infinity....
   14a70:	NaN.....

00014a78 <__mprec_tens>:
   14a78:	.......?......$@
   14a88:	......Y@.....@.@
   14a98:	.......@.....j.@
   14aa8:	.......A......cA
   14ab8:	.......A....e..A
   14ac8:	... _..B....vH7B
   14ad8:	......mB..@..0.B
   14ae8:	.......B..4&.k.C
   14af8:	...7y.AC....W4vC
   14b08:	..Ngm..C.=.`.X.C
   14b18:	@..x...DP.....KD
   14b28:	..M....D.J...-.D
   14b38:	...yCx.D

00014b40 <p05.6085>:
   14b40:	........}.......

00014b50 <__mprec_bigtens>:
   14b50:	...7y.AC.n.....F
   14b60:	..?..O8M2.0.Hw.Z
   14b70:	<.s..O.u

00014b78 <_init>:
   14b78:	push	{r3, r4, r5, r6, r7, lr}
   14b7a:	nop
   14b7c:	pop	{r3, r4, r5, r6, r7}
   14b7e:	pop	{r3}
   14b80:	mov	lr, r3
   14b82:	bx	lr

00014b84 <__init_array_start>:
   14b84:	.word	0x000126bd

00014b88 <__frame_dummy_init_array_entry>:
   14b88:	5...a...........
   14b98:	!...9...Q.......
   14ba8:	............)...
   14bb8:	A...Y...q.......
   14bc8:	............

Disassembly of section .fini:

00014bd4 <_fini>:
   14bd4:	push	{r3, r4, r5, r6, r7, lr}
   14bd6:	nop

Disassembly of section .data:

1fff8960 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff8960:	push	{r3, r4, r5, lr}
1fff8962:	ldr	r3, [pc, #32]	; (1fff8984 <port_E_isr+0x24>)
1fff8964:	ldr	r4, [r3, #0]
1fff8966:	str	r4, [r3, #0]
1fff8968:	cbz	r4, 1fff8980 <port_E_isr+0x20>
1fff896a:	ldr	r5, [pc, #28]	; (1fff8988 <port_E_isr+0x28>)
1fff896c:	rbit	r3, r4
1fff8970:	clz	r3, r3
1fff8974:	ldr.w	r3, [r5, r3, lsl #2]
1fff8978:	blx	r3
1fff897a:	subs	r3, r4, #1
1fff897c:	ands	r4, r3
1fff897e:	bne.n	1fff896c <port_E_isr+0xc>
1fff8980:	pop	{r3, r4, r5, pc}
1fff8982:	nop
1fff8984:	.word	0x4004d0a0
1fff8988:	.word	0x1fff8d40

1fff898c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff898c:	push	{r3, r4, r5, lr}
1fff898e:	ldr	r3, [pc, #32]	; (1fff89b0 <port_D_isr+0x24>)
1fff8990:	ldr	r4, [r3, #0]
1fff8992:	str	r4, [r3, #0]
1fff8994:	cbz	r4, 1fff89ac <port_D_isr+0x20>
1fff8996:	ldr	r5, [pc, #28]	; (1fff89b4 <port_D_isr+0x28>)
1fff8998:	rbit	r3, r4
1fff899c:	clz	r3, r3
1fff89a0:	ldr.w	r3, [r5, r3, lsl #2]
1fff89a4:	blx	r3
1fff89a6:	subs	r3, r4, #1
1fff89a8:	ands	r4, r3
1fff89aa:	bne.n	1fff8998 <port_D_isr+0xc>
1fff89ac:	pop	{r3, r4, r5, pc}
1fff89ae:	nop
1fff89b0:	.word	0x4004c0a0
1fff89b4:	.word	0x1fff8d20

1fff89b8 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff89b8:	push	{r3, r4, r5, lr}
1fff89ba:	ldr	r3, [pc, #32]	; (1fff89dc <port_C_isr+0x24>)
1fff89bc:	ldr	r4, [r3, #0]
1fff89be:	str	r4, [r3, #0]
1fff89c0:	cbz	r4, 1fff89d8 <port_C_isr+0x20>
1fff89c2:	ldr	r5, [pc, #28]	; (1fff89e0 <port_C_isr+0x28>)
1fff89c4:	rbit	r3, r4
1fff89c8:	clz	r3, r3
1fff89cc:	ldr.w	r3, [r5, r3, lsl #2]
1fff89d0:	blx	r3
1fff89d2:	subs	r3, r4, #1
1fff89d4:	ands	r4, r3
1fff89d6:	bne.n	1fff89c4 <port_C_isr+0xc>
1fff89d8:	pop	{r3, r4, r5, pc}
1fff89da:	nop
1fff89dc:	.word	0x4004b0a0
1fff89e0:	.word	0x1fff8cf0

1fff89e4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff89e4:	push	{r3, r4, r5, lr}
1fff89e6:	ldr	r3, [pc, #32]	; (1fff8a08 <port_B_isr+0x24>)
1fff89e8:	ldr	r4, [r3, #0]
1fff89ea:	str	r4, [r3, #0]
1fff89ec:	cbz	r4, 1fff8a04 <port_B_isr+0x20>
1fff89ee:	ldr	r5, [pc, #28]	; (1fff8a0c <port_B_isr+0x28>)
1fff89f0:	rbit	r3, r4
1fff89f4:	clz	r3, r3
1fff89f8:	ldr.w	r3, [r5, r3, lsl #2]
1fff89fc:	blx	r3
1fff89fe:	subs	r3, r4, #1
1fff8a00:	ands	r4, r3
1fff8a02:	bne.n	1fff89f0 <port_B_isr+0xc>
1fff8a04:	pop	{r3, r4, r5, pc}
1fff8a06:	nop
1fff8a08:	.word	0x4004a0a0
1fff8a0c:	.word	0x1fff8ca0

1fff8a10 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff8a10:	push	{r3, r4, r5, lr}
1fff8a12:	ldr	r3, [pc, #32]	; (1fff8a34 <port_A_isr+0x24>)
1fff8a14:	ldr	r4, [r3, #0]
1fff8a16:	str	r4, [r3, #0]
1fff8a18:	cbz	r4, 1fff8a30 <port_A_isr+0x20>
1fff8a1a:	ldr	r5, [pc, #28]	; (1fff8a38 <port_A_isr+0x28>)
1fff8a1c:	rbit	r3, r4
1fff8a20:	clz	r3, r3
1fff8a24:	ldr.w	r3, [r5, r3, lsl #2]
1fff8a28:	blx	r3
1fff8a2a:	subs	r3, r4, #1
1fff8a2c:	ands	r4, r3
1fff8a2e:	bne.n	1fff8a1c <port_A_isr+0xc>
1fff8a30:	pop	{r3, r4, r5, pc}
1fff8a32:	nop
1fff8a34:	.word	0x400490a0
1fff8a38:	.word	0x1fff8c68

1fff8a3c <__dso_handle>:
1fff8a3c:	....

1fff8a40 <t_on>:
1fff8a40:	<...

1fff8a44 <sd_str>:
1fff8a44:	HD..

1fff8a48 <mfile>:
1fff8a48:	.A..............
1fff8a58:	....

1fff8a5c <propertyListNum>:
1fff8a5c:	....

1fff8a60 <SPI>:
1fff8a60:	...@$F..........
	...

1fff8a98 <syncInterval>:
1fff8a98:	,...

1fff8a9c <Wire>:
1fff8a9c:	.G..............
1fff8aac:	.`.@.F..........
	...

1fff8b08 <Wire1>:
1fff8b08:	.G..............
1fff8b18:	.p.@.F..........
	...

1fff8b74 <analog_config_bits>:
1fff8b74:	.

1fff8b75 <analog_num_average>:
1fff8b75:	...

1fff8b78 <__brkval>:
1fff8b78:	42. 

1fff8b7c <device_descriptor>:
1fff8b7c:	.......@..v.u...
1fff8b8c:	....

1fff8b90 <usb_string_manufacturer_name_default>:
1fff8b90:	..T.e.e.n.s.y.d.
1fff8ba0:	u.i.n.o.

1fff8ba8 <config_descriptor>:
1fff8ba8:	..i.....2.......
1fff8bb8:	...........$....
1fff8bc8:	$....$...$......
1fff8bd8:	...@............
1fff8be8:	.@......@.......
1fff8bf8:	........@......@
1fff8c08:	...... .....

1fff8c14 <usb_string_mtp>:
1fff8c14:	..M.T.P.

1fff8c1c <usb_string_product_name_default>:
1fff8c1c:	..T.e.e.n.s.y. .
1fff8c2c:	M.T.P. .D.i.s.k.
1fff8c3c:	/.S.e.r.i.a.l...

1fff8c4c <string0>:
1fff8c4c:	....

1fff8c50 <usb_string_serial_number_default>:
1fff8c50:	................
	...

1fff8c68 <isr_table_portA>:
1fff8c68:	=...=...=...=...
1fff8c78:	=...=...=...=...
1fff8c88:	=...=...=...=...
1fff8c98:	=...=...

1fff8ca0 <isr_table_portB>:
1fff8ca0:	=...=...=...=...
1fff8cb0:	=...=...=...=...
1fff8cc0:	=...=...=...=...
1fff8cd0:	=...=...=...=...
1fff8ce0:	=...=...=...=...

1fff8cf0 <isr_table_portC>:
1fff8cf0:	=...=...=...=...
1fff8d00:	=...=...=...=...
1fff8d10:	=...=...=...=...

1fff8d20 <isr_table_portD>:
1fff8d20:	=...=...=...=...
1fff8d30:	=...=...=...=...

1fff8d40 <isr_table_portE>:
1fff8d40:	=...=...

1fff8d48 <usb_buffer_available>:
1fff8d48:	....

1fff8d4c <yield_active_check_flags>:
1fff8d4c:	....

1fff8d50 <Serial>:
1fff8d50:	.H..............

1fff8d60 <_serialEvent_default>:
1fff8d60:	.

1fff8d61 <__fdlib_version>:
1fff8d61:	.......

1fff8d68 <impure_data>:
1fff8d68:	....T.......$...
	...
1fff8e10:	.........3..4.m.
1fff8e20:	................
	...

1fff9190 <_impure_ptr>:
1fff9190:	h...

1fff9194 <__global_locale>:
1fff9194:	C...............
	...
1fff91b4:	C...............
	...
1fff91d4:	C...............
	...
1fff91f4:	C...............
	...
1fff9214:	C...............
	...
1fff9234:	C...............
	...
1fff9254:	C...............
	...
1fff9274:	.%..........`I..
1fff9284:	.H...C...C...C..
1fff9294:	.C...C...C...C..
1fff92a4:	.C...C..........
1fff92b4:	..........ASCII.
	...
1fff92dc:	..ASCII.........
	...

1fff9300 <__malloc_av_>:
	...
1fff9308:	................
1fff9318:	................
1fff9328:	 ... ...(...(...
1fff9338:	0...0...8...8...
1fff9348:	@...@...H...H...
1fff9358:	P...P...X...X...
1fff9368:	`...`...h...h...
1fff9378:	p...p...x...x...
1fff9388:	................
1fff9398:	................
1fff93a8:	................
1fff93b8:	................
1fff93c8:	................
1fff93d8:	................
1fff93e8:	................
1fff93f8:	................
1fff9408:	................
1fff9418:	................
1fff9428:	 ... ...(...(...
1fff9438:	0...0...8...8...
1fff9448:	@...@...H...H...
1fff9458:	P...P...X...X...
1fff9468:	`...`...h...h...
1fff9478:	p...p...x...x...
1fff9488:	................
1fff9498:	................
1fff94a8:	................
1fff94b8:	................
1fff94c8:	................
1fff94d8:	................
1fff94e8:	................
1fff94f8:	................
1fff9508:	................
1fff9518:	................
1fff9528:	 ... ...(...(...
1fff9538:	0...0...8...8...
1fff9548:	@...@...H...H...
1fff9558:	P...P...X...X...
1fff9568:	`...`...h...h...
1fff9578:	p...p...x...x...
1fff9588:	................
1fff9598:	................
1fff95a8:	................
1fff95b8:	................
1fff95c8:	................
1fff95d8:	................
1fff95e8:	................
1fff95f8:	................
1fff9608:	................
1fff9618:	................
1fff9628:	 ... ...(...(...
1fff9638:	0...0...8...8...
1fff9648:	@...@...H...H...
1fff9658:	P...P...X...X...
1fff9668:	`...`...h...h...
1fff9678:	p...p...x...x...
1fff9688:	................
1fff9698:	................
1fff96a8:	................
1fff96b8:	................
1fff96c8:	................
1fff96d8:	................
1fff96e8:	................
1fff96f8:	................

1fff9708 <__malloc_trim_threshold>:
1fff9708:	....

1fff970c <__malloc_sbrk_base>:
1fff970c:	....
